<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XJY&#39;s Blog</title>
  
  <subtitle>你要静候再静候 就算失收始终要守</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://habitdiary.cn/"/>
  <updated>2017-10-24T16:12:27.615Z</updated>
  <id>http://habitdiary.cn/</id>
  
  <author>
    <name>谢均宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java学习总结之集合</title>
    <link href="http://habitdiary.cn/2017/10/23/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>http://habitdiary.cn/2017/10/23/Java学习总结之集合/</id>
    <published>2017-10-23T13:40:35.000Z</published>
    <updated>2017-10-24T16:12:27.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><p>Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Java只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、Bitset和Enumeration接口，其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，但要想建立一个全面的集合类库还需要大量的时间和高超的技能。<br>后来，经过艰难的抉择，设计人员设计出了一组功能完善的数据结构，下面我们来进入集合框架的学习。  </p><h4 id="集合接口与具体实现分离"><a href="#集合接口与具体实现分离" class="headerlink" title="集合接口与具体实现分离"></a>集合接口与具体实现分离</h4><p>Java集合类库将接口与实现分离。比如队列接口，其指出可以在队列的尾部添加元素，在队头删除元素，并可以查找队列中元素的个数等。队列接口的最简形式可能类似下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这个接口并没有说明队列的具体实现，实际上，队列的实现主要有两种方式：<strong>一是使用循环数组，二是使用链表。</strong>如果需要一个循环数组队列，可以使用<strong>ArrayDeque类</strong>;如果需要一个链表队列，就直接使用<strong>LinkedList类</strong>。这两个类都实现了Queue接口。<br>当我们使用队列时，一旦创建了集合就不用关心究竟使用了哪种实现，因此，只有在构建集合时，使用具体的类才有意义。<br>用两种具体类实现Queue接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div></pre></td></tr></table></figure></p><p><strong>注意：一般情况下循环数组比链表更高效，但它是一个有界集合，即容量有限，超过一定范围会进行扩容，降低效率。所以如果处理的数据量较小，优先使用循环数组，但如果程序要收集的对象数量没有上限，最好使用链表实现。</strong><br>在研究API时会发现一组名字以Abstract开头的类，例如，AbstractQueue。这些类是为类库设计者设计的，如果想要实现自己的队列类，会发现扩展AbstractQueue类比实现Queue接口中的所有方法轻松得多。  </p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>在Java类库中，集合类的基本接口是Collection接口，其常用API如下：    </p><ul><li>boolean add(E e)<br>将一个元素添加到集合中。如果由于这个调用改变了集合，返回true。   </li><li>boolean addAll(Collection&lt;? extends E&gt; other)<br>将other集合中的所有元素都添加到这个集合。如果由于这个调用改变了集合，返回true。  </li><li>void clear()  移除这个集合中的所有元素。  </li><li>boolean contains(Object obj)<br>如果这个集合包含了一个与obj相等的对象，返回true。  </li><li>boolean    containsAll(Collection&lt;?&gt; other)<br>如果这个集合包含other集合中的所有元素，返回 true。    </li><li>boolean isEmpty() 如果这个集合没有元素，返回 true。</li><li>Iterator<code>&lt;E&gt;</code>    iterator()<br>返回一个用于访问集合中每个元素的迭代器。  </li><li>boolean remove(Object obj)<br>从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true。  </li><li>boolean removeAll(Collection&lt;?&gt; other)<br>从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true。  </li><li>boolean retainAll(Collection&lt;?&gt; other)<br>仅保留这个集合中那些也包含在other集合里的元素  </li><li>int size()  返回这个集合的元素数。</li><li>Object[]    toArray() 返回这个集合的对象数组。</li><li><code>&lt;T&gt;</code> T[] toArray(T[] arrayToFill)<br>返回这个集合的对象数组。如果arrayToFill足够大，就将集合的元素填入这个数组中，剩余空间补null;否则，分配一个新数组，其成员类型和arrayToFill一样，其长度等于集合的大小，并填充集合元素。  </li><li><p>default boolean removeIf(Predicate&lt;? super E&gt; filter)<br>从这个集合中删除filter返回true的所有元素。如果这个调用改变了集合，返回true </p><p><strong>注意：在使用Object[] toArray()时不能把返回的Object[]数组成强制类型转换其他类型的数组，因为所有数组类型的父类都是Object，甚至Object[]的父类也是Object，所以这种向下类型转换是错误的,会抛出一个ClassCastException</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer[] array = (Integer[])a.toArray();<span class="comment">// Error</span></div><div class="line">Object[] array =  a.toArray();<span class="comment">// Right</span></div></pre></td></tr></table></figure><p>或者使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer[] array = a.toArray(<span class="keyword">new</span> Integer[<span class="number">10</span>]);</div></pre></td></tr></table></figure><p>removeIf函数的参数是一个函数式接口Predicate，表示布尔值函数，可以传递一个lambda表达式描述要删除的元素的特征。例如下面的代码可以删除列表中的所有偶数：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.removeIf(e -&gt; e %<span class="number">2</span> == <span class="number">0</span>);</div></pre></td></tr></table></figure><p>同队列，Java也给类库设计者提供了一个AbstractCollection类，其提供了一些例行方法，可以让实现者更容易实现自己的集合类。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>Collection接口的<code>Iterator&lt;E&gt;    iterator()</code>方法可以返回一个迭代器，它是一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。<br>Iterator接口包含4个方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</div></pre></td></tr></table></figure><p>C++的STL中的迭代器是根据数组索引建模的，即迭代器指向指定位置的元素。但Java中的迭代器应该理解为位于两个元素之间，其起始位置在所有元素之前。调用next方法，迭代器会<strong>越过一个元素并且返回被越过的元素</strong>。通过next方法可以逐个访问集合中的每个元素，但是如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此,需要在每次调用next方法之前调用hasNext方法。如果迭代器还有剩余供访问的元素，这个方法就返回true。如果要想查看一个集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复调用next方法，例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Collection&lt;String&gt; c = . . .;</div><div class="line">Iterator&lt;String&gt; iter = c.iterator();</div><div class="line"><span class="keyword">while</span>(iter.hasNext())</div><div class="line">&#123;</div><div class="line">String element = iter.next();</div><div class="line">   <span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>“for-each”循环可以更简练地表示同样的操作：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String element: c)</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译器简单地将”for-each”循环翻译为<strong>带有迭代器的循环</strong>，”for-each”循环可以和任何实现了Iterable接口的对象一起工作，这个接口只包含一个抽象方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">Interator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Iterable接口表示实现它的类是可以迭代的(即可以返回一个迭代器对象)，Collection接口扩展了Iterable接口，所以<strong>对于标准类库中的任何集合都可以使用”for-each”循环</strong><br>Java SE 8提供了一种更简便的方式，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式(它会处理一个元素)。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止,例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iter.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</div></pre></td></tr></table></figure><p><strong>元素被访问的顺序取决于集合类型。</strong>如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次索引加1.如果访问HashSet中的元素，每个元素将会以某种随机的次序出现。但这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说没有影响。<br>Iterator接口的remove方法将会删除<strong>上一次调用next方法</strong>时返回的元素，也就是说，如果要删除某个元素，必须先用next方法越过它：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = c.iterator();</div><div class="line">it.next();<span class="comment">// skip over the first element</span></div><div class="line">it.remove(); <span class="comment">// now remove it</span></div></pre></td></tr></table></figure></li></ul><p>如果在调用remove方法之前没有调用next方法会抛出一个IllegalStateException。<br>如果想删除两个相邻的元素，不能直接连续调用两次remove：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.remove();<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>必须先越过要删除的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.next();</div><div class="line">it.remove();<span class="comment">//OK</span></div></pre></td></tr></table></figure></p><p>所以删除元素必须在刚越过该元素时就进行，否则”过了这个村就没这个店了”  </p><h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><p>Java集合框架为不同类型的集合定义了大量接口，如下图所示：  <img src="/2017/10/23/Java学习总结之集合/集合框架的接口.jpg" alt="fail" title="集合框架的接口"><br>集合有两个基本接口：<strong>Collection</strong>和<strong>Map</strong>。Collection用于保存一个元素序列，Map用于表示键值对之间的映射关系。在Collection中插入元素使用<code>boolean add(E element)</code>,获取元素使用迭代器访问;在Map中插入元素使用<code>V put(K key,V value)</code>,通过key获取value使用<code>V get(K key)</code><br>List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，使用一个整数索引访问。前者称为顺序访问，后者称为随机访问。<br>List的重要API如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">* <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素  </span></div><div class="line"><span class="function">* ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素，</span></div><div class="line"><span class="function">   初始位置在索引为index元素的前面，索引从0开始  </span></div><div class="line"><span class="function">* <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span> 在给定位置添加一个元素  </span></div><div class="line"><span class="function">* E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> 删除给定位置的元素并返回这个元素  </span></div><div class="line"><span class="function">* E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> 获取给定位置的元素  </span></div><div class="line"><span class="function">* E <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, E element)</span> </span></div><div class="line"><span class="function">   用新元素取代给定位置的元素，并返回原来那个元素  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素  </span></div><div class="line"><span class="function"> 在列表中第一次出现的位置，如果没有这样的元素返回-1  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素</span></div><div class="line"><span class="function"> 在列表中最后一次出现的位置，如果没有这样的元素返回-1</span></div></pre></td></tr></table></figure></p><p>我们发现List接口提供了多个用于随机访问的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span></div></pre></td></tr></table></figure></p><p>当我们给List接口选择具体实现类时，需要考虑顺序访问和随机访问哪种情况更多，如果随机访问占操作的大多数，应该使用数组或动态列表ArrayList实现List接口，否则应该使用链表LinkedList实现List接口。<br>为了避免对链表进行随机访问，Java定义了一个标记接口RandomAccess，这个接口不包含任何方法，但可以用来测试一个特定的集合是否支持高效的随机访问：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(c <span class="keyword">instanceof</span> RandomAccess)</div><div class="line">&#123;</div><div class="line">use random access algorithm</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">use sequential access algorithm</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不建议在LinkedList实现的List列表中使用get、set等随机访问方法，此时应该通过一个ListIterator顺序访问列表。<br>ListIterator接口是Iterator的一个子接口，它是一种更灵活的迭代器，只用于List。下面是ListIterator的重要API：  </p><ul><li>void add(E newElement) 在当前位置前添加一个元素  </li><li>void set(E newElement) 用新元素取代next或previous上次访问的元素。</li><li>boolean hasPrevious() 当反向迭代列表时，还有可供访问的元素，返回true  </li><li>E previous() 返回前一个对象，如果已经到达了列表的头部，就抛出一个NoSuchElementException  </li><li>int nextIndex() 返回下次调用next方法时将返回元素的索引  </li><li>int previous() 返回下次调用previous方法时将返回元素的索引  </li></ul><p><strong>并发修改：</strong>如果在一个迭代器修改集合时，另一个迭代器对它进行遍历，一定会出现混乱。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = . . .;</div><div class="line">ListIterator&lt;String&gt; iter1 = list.ListIterator();</div><div class="line">ListIterator&lt;String&gt; iter2 = list.ListIterator();</div><div class="line">iter1.next();</div><div class="line">iter1.remove();</div><div class="line">iter2.next();<span class="comment">//throws ConcurrentModificationException</span></div></pre></td></tr></table></figure></p><p>上述代码中iter2迭代器在遍历链表时，iter1修改了链表结构，iter2会检测到这种变化，抛出一个ConcurrentModificationException。<br>为了避免出现并发修改异常，请遵循下述简单规则：<strong>可以根据需要给容器附加许多迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读也写的迭代器</strong>。<br>通过调用AbstractCollection类的toString方法可以打印出集合中的所有元素。<br><strong>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集(Set)的add方法不允许增加重复的元素。要适当定义equals方法：只要两个集包含同样的元素就认为是相等的，而不要求有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。<br>SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集试图的方法。<br>最后，Java SE 6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集和映射的方法，TreeSet和TreeMap实现了这些接口。</strong>  </p><h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p><img src="/2017/10/23/Java学习总结之集合/Java库中的具体集合.jpg" alt="fail" title="Java库中的具体集合"><br><img src="/2017/10/23/Java学习总结之集合/集合框架的类.jpg" alt="fail" title="集合框架的类"></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList是链表类，相较于数组以及动态的ArrayList类，能够更高效地从集合的中间位置插入、删除元素，Java中的LinkedList类是<strong>双向链接</strong>的。<br>除了实现了Collection接口和List接口之外，LinkedList还提供了以下API：  </p><ul><li>LinkedList() 构造一个空链表  </li><li>LinkedList(Collection&lt;? extends E&gt; elements)<br>构造一个链表，并将集合中的所有元素添加到这个链表中  </li><li>void addFirst(E element) 将某个元素添加到列表的头部  </li><li>void addLast(E element) 将某个元素添加到列表的尾部  </li><li>E getFirst 返回列表头部的元素  </li><li>E getLast 返回列表尾部的元素  </li><li>E removeFirst() 删除并返回列表头部的元素 </li><li>E removeLast() 删除并返回列表尾部的元素    </li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList是动态数组列表，适用于常常要随机访问元素的情况。下面给出ArrayList的常用API：  </p><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  <h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4>链表和数组可以按照人们的意愿排列元素的次序，但如果要查看某个元素，却忘记了它的位置，需要访问所有元素直到找到为止，将会消耗很多时间。<br>HashSet是一种基于<strong>散列表</strong>的集，实现了Set接口，它无法控制元素的次序，但可以快速查找元素。散列表基于散列码，散列码由类的hashCode方法提供，用于将元素插入散列表的特定位置，hashCode和equals方法应该兼容，即使用equals方法返回true的两个对象应该有相同的散列码，一个自定义类如果重写了equals方法就必须要重写hashCode方法，以便于将该类的对象插入散列表中。<br>在Java中，散列表用链表数组实现，每个<strong>散列单元</strong>被称为<strong>桶</strong>。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，如果桶中没有元素，可以直接插入，如果已经有元素，即发生<strong>散列冲突</strong>，则需要将新元素和桶中已有的所有元素进行比较，如果桶中有元素和新元素相等，就不插入，反之插入。<strong>注意：在HashSet的一个桶中可以有多个不同元素，即使用链地址法解决冲突。</strong>如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。<br>在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。<br>如果想更多地控制散列表的运行性能，就要指定一个初始桶数。通常将桶数设置为预计元素个数的75% ~ 150%,最好将桶数设置为一个<strong>素数</strong>,以防键的集聚。标准类库使用的桶数是2的幂，默认值为16,<strong>为散列表的大小提供的任何值都被自动转换为2的下一个幂</strong>。<br>如果最初的估计过低，散列表太满，散列表会进行再散列，创建一个桶数更多的表。<strong>装填因子</strong>决定何时再散列，比如装填因子为0.75，当散列表中超过75%的位置已经填入了元素，这个表就会用双倍的桶数自动进行再散列，大多数情况装填因子为0.75是比较合理的。<br>下面是HashSet的常用API：  </li><li>HashSet() 构造一个空散列集  </li><li>HashSet(Collection&lt;? extends E&gt; elements)<br>构造一个散列集，并将集合中的所有元素添加到这个散列集中 </li><li>HashSet(int initialCapacity) 构造一个具有指定容量(桶数)的散列集  </li><li>HashSet(int initialCapacity,float loadFactor) 构造一个具有指定容量和装填因子(一个0.0 ~ 1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集      </li></ul><p><strong>特别要注意,在HashSet中没有get和set方法，因为HashSet是无序集，不存在索引概念，如果要访问HashSet中的元素应该使用迭代器，另外contains方法也被重新定义，可以快速查看某个元素是否出现在集中，此时不用查看集中的所有元素，只用通过散列码定位到一个桶，查看这个桶中的所有元素即可</strong>  </p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet和HashSet十分类似，不过当元素以任意顺序插入TreeSet时，TreeSet会保证元素是有序排列的。其底层是由<strong>红黑树</strong>实现的,每次将一个元素添加到树中，都被放置在正确的排序位置上。<br><strong>一个元素添加到树中比添加到散列表中慢</strong>，但是与检查数组或链表中的重复元素相比还是快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。如果对集合中的元素次序没有要求，应该使用HashSet而不是TreeSet，即使排序的花销不大，但也会影响效率。<br><strong>注意：要使用TreeSet，插入的元素必须可排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator</strong><br>从Java SE 6起,TreeSet类实现了Navigable接口，这个接口增加了几个便于定位元素以及反向遍历的方法。  </p><p>下面是TreeSet的常用API：  </p><ul><li>TreeSet() 构造一个空树集  </li><li>TreeSet(Collection&lt;? extends E&gt; elements)<br>构造一个空树集，并将集合中的所有元素添加到这个树集中  </li><li>TreeSet(Comparator&lt;? super E&gt; comparator)  构造一个空树集  </li><li>TreeSet(SortedSet&lt;<code>E</code>&gt; s)<br>构造一个空树集，并将有序集中的所有元素添加到这个树集中，并使用与给定的有序集相同的比较器</li></ul><p>下面是SortedSet的常用API：  </p><ul><li>Comparator&lt;? super E&gt; comparator()<br>返回用于对元素进行排序的比较器。如果元素用Comparable接口的compareTo方法进行比较则返回null  </li><li>E first() 返回有序集中的最小元素  </li><li>E last() 返回有序集中的最大元素   </li></ul><p>下面是NavigableSet的常用API： </p><ul><li>E higher(E value)  </li><li>E lower(E value)<br>返回大于value的最小元素或小于value的最大元素，如果没有这样的元素则返回null  </li><li>E ceiling(E value)  </li><li>E floor(E value)<br>返回大于等于value的最小元素或小于等于value的最大元素，如果没有这样的元素则返回null  </li><li>E poolFirst()  </li><li>E pollLast()<br>删除并返回这个集合中的最大元素或最小元素，这个集合为空时返回null  </li><li>Iterator&lt;<code>E</code>&gt; descendingIterator()<br>返回一个按照递减顺序遍历集中元素的反向迭代器  </li></ul><h4 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h4><p>Deque(双端队列)接口继承自Queue(队列)接口，与之有所不同的是，双端队列可以在队列的头部和尾部添加或删除元素，但也不支持在队列中间添加或删除元素。<br>和普通队列一样，双端队列也可以用ArrayDeque和LinkedList实现。  </p><p>下面是Queue的常用API：  </p><ul><li>boolean add(E element)  </li><li>boolean offer(E element)<br>都是将一个元素入队并返回true，如果队列已满，前者会抛出一个IllegalStateException，后者则返回false  </li><li>E remove()  </li><li>E poll()<br>都是将队头元素出队并返回，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null  </li><li>E element()  </li><li>E peek()<br>都是取队头元素但不删除，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null   </li></ul><p>下面是Deque的常用API：  </p><ul><li>void addFirst(E element)  </li><li>void addLast(E element)  </li><li>boolean offerFirst(E element)  </li><li>boolean offerLast(E element)<br>都是将给定元素添加到双端队列的头部或尾部，如果队列满了，前两个方法会抛出一个IllegalStateException，后两个方法则返回false  </li><li>E removeFirst()  </li><li>E removeLast()  </li><li>E pollFirst()  </li><li>E pollLast()<br>都是删除双端队列的头部或尾部并返回元素，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li><li>E getFirst()  </li><li>E getLast() </li><li>E peekFirst()  </li><li>E peekLast()<br>都是返回双端队列的头部或尾部元素但不删除，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li></ul><p>下面是ArrayDeque的常用API：  </p><ul><li>ArrayDeque() 用默认初始容量16构造一个空队列  </li><li>ArrayDeque(int initialCapacity) 用指定容量构造一个空队列    </li></ul><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先出队。优先队列具有最高级先出(first in, largest out)的行为特征。<br>PriorityQueue的底层是通过堆(小根堆，<strong>将较小的元素设为最高优先级</strong>)实现的，堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。<br>PriorityQueue是一个具体类，没有实现Queue接口，创建一个优先队列的代码为: <code>PrioriryQueue&lt;E&gt; q = new PriorityQueue&lt;&gt;();</code>而不应该将对象引用赋给Queue接口。<br><strong>和TreeSet一样，要实现排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator。</strong>  </p><p>下面是PriorityQueue的常用API：  </p><ul><li>PriorityQueue() 构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity)<br>用指定容量构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity,Comaparator&lt;? super E&gt; c)<br>用指定容量构造一个空优先队列,并指定比较器对元素进行排序  </li></ul><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>集是一个集合，它可以快速查找现有元素。但是，有时我们知道某些键的信息，并想要查找与之对应的元素。映射(map)数据结构就是为此设计的，map用来存放键值对，提供键(Key)就能快速查找到值(Value)<br>Java类库为映射提供了两个实现：HashMap和TreeMap，这两个类都实现了Map接口。<br>HashMap(散列映射)对<strong>键</strong>进行散列，键值对是无序的。TreeMap(树映射)用<strong>键</strong>的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。<strong>与集一样，HashMap比TreeMap快一些，如果不需要按照排列顺序访问键，就最好选择散列。</strong>  </p><p>下面是Map接口的常用API：  </p><ul><li>V get(Object key)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回null  </li><li>default V getOrDefault(Object key,V defaultValue)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回defaultValue  </li><li>V put(K key,V value)<br>将键与对应的值关系插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象，并返回键对应的旧值，如果这个键以前没有出现过则返回null。<strong>键可以为null，但值不能为null</strong>  </li><li>V putAll(Map&lt;? extends K,? extends V&gt; entries)<br>将给定映射中的所有条目添加到这个映射中  </li><li>boolean containsKey(Object key)<br>如果在映射中已经有这个键，返回true </li><li>boolean containsValue(Object value)<br>如果在映射中已经有这个值，返回true  </li><li>default void forEach(BiConsumer&lt;? super K,? super V&gt; action)<br>对这个映射中的所有键值对应用这个动作，参数是一个函数式接口类型，可以传入一个lambda表达式,例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scores.forEach((k,v) -&gt; </div><div class="line">System.out.println(<span class="string">"key="</span> + k + <span class="string">", value="</span> + v));</div></pre></td></tr></table></figure></li></ul><p>下面是HashMap的常用API：   </p><ul><li>HashMap()  构造一个空散列映射</li><li>HashMap(int initialCapacity) 用指定容量构造一个空散列映射 </li><li>HashMap(int initialCapacity,float LoadFactor)<br>用指定容量和装填因子构造一个空散列映射，默认的装填因子是0.75  </li></ul><p>下面是TreeMap的常用API：   </p><ul><li>TreeMap() 构造一个空树映射  </li><li>TreeMap(Comparator&lt;? super K&gt; c)<br>构造一个空树映射，并使用一个指定的比较器对键进行排序  </li><li>TreeMap(Map&lt;? extends K,? extends V&gt; entries) 构造一个空树映射，并将某个映射的所有条目添加到树映射中   </li><li>TreeMap(SortedMap&lt;? extends K,? extends V&gt; entries)<br>构造一个空树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器  </li></ul><p>下面是SortedMap的常用API：   </p><ul><li>Comparator&lt;? super K&gt; comparator()<br>返回对键进行排序的比较器。如果键是用Comparable接口的compareTo方法进行比较的，返回null  </li><li>K firstKey()  </li><li>K lastKey()<br>返回映射中最小元素和最大元素  </li></ul><h4 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h4><p>假设我们要统计一个单词在文件中出现的次数，当得到一个单词时，我们将其计数器加1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>但这可能会出错，如果word第一次出现，counts.get(word)会返回null，从而抛出一个NullPointerException。  </p><p>为了避免这种情况，我们可以用<strong>getOrDefault方法</strong>来取代get方法，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.getOrDefault(word,<span class="number">0</span>) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>另一种方法是首先调用<strong>putIfAbsent方法</strong>，这个方法会在映射中不存在word时插入键值对初始化word的值为0：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">counts.putIfAbsent(word,<span class="number">0</span>);</div><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>还可以做得更好,<strong>merge方法</strong>可以简化这个常见操作。如果键原先不存在，则下面的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.merge(word,<span class="number">1</span>,Integer::sum);</div></pre></td></tr></table></figure></p><p>将把word和1关联，如果word存在，则会使用Integer::sum函数组合原值和1(也就是将原值和1求和)  </p><h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><p>集合框架不认为映射本身是一种集合，不过可以得到映射视图 —— 这是实现了Collection接口或某个子接口的对象。<br>有三种视图：键集、值集合<strong>(不是一个集)</strong>、键值对集。<strong>键集</strong>和<strong>键值对集</strong>是集，因为一个映射中的键是唯一的，但值不能构成集，只能是值集合，因为一个映射中可以有多个相同的值。<br>下面的方法可以从映射中返回这三种视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></div><div class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></div><div class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p><p><strong>需要说明的是，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口，所以可以向使用集合一样使用keySet</strong>  </p><p>键值对是Map.Entry<code>&lt;K,V&gt;</code>类型的，可以使用entrySet()方法返回映射的键值对集，再通过循环对于每个键值对对象使用，getKey方法获取该键值对的键，getValue方法获取该键值对的值。<strong>当然查看键值对最高效的方法是使用forEach方法</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">counts.forEach((k,v) -&gt; &#123;</div><div class="line"><span class="keyword">do</span> something with k,v</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h3&gt;&lt;p&gt;Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Jav
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之泛型程序设计</title>
    <link href="http://habitdiary.cn/2017/10/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://habitdiary.cn/2017/10/22/Java学习总结之泛型程序设计/</id>
    <published>2017-10-22T01:09:10.000Z</published>
    <updated>2017-10-22T11:41:20.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h3><p>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，这是一个泛型程序设计的实例。实际上，在Java增加泛型类之前已经有一个ArrayList类，下面来研究泛型程序设计机制是如何演变的。  </p><h3 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h3><p>在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayLists类只维护一个Object引用的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] elementData;</div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; . . . &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123; . . . &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种方法有两个问题，我们以一个保存文件名的files数组列表为例：<br>1) 当获取一个值时必须进行强制类型转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList files = <span class="keyword">new</span> ArrayList();</div><div class="line">. . .</div><div class="line">String filename = (String)files.get(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>2) 当添加一个值时不进行类型检查，可以添加任何类的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">files.add(<span class="keyword">new</span> File(<span class="string">". . ."</span>));</div></pre></td></tr></table></figure></p><p>此调用在编译和运行时都不会出错，但如果将get的结果强制转换为String会产生一个错误  </p><p>为了解决上述问题，引入了类型参数。ArrayList有一个类型参数用来指示元素类型：<code>ArrayList&lt;T&gt; files = new ArrayList&lt;T&gt;();</code>在Java SE 7及以后的版本，构造函数可以省略类型参数，即<code>ArrayList&lt;T&gt; files = new ArrayList&lt;&gt;();</code><br>这种方法有三个好处：<br>1)get得到的值不必进行强制类型转换<br>2)向数组列表中添加对象时会进行类型检查，如果不符合类型，无法通过编译，出现编译错误比类在运行时出现类的强制转换异常要好得多<br>3)程序具有更好的可读性，比如<code>ArrayList&lt;String&gt; files</code>一看就是聚集了String对象的数组列表  </p><h3 id="定义简单的泛型类"><a href="#定义简单的泛型类" class="headerlink" title="定义简单的泛型类"></a>定义简单的泛型类</h3><p>一个泛型类就是具有一个或多个类型变量的类，下面使用一个简单的Pair类作为例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> T first;</div><div class="line">    <span class="keyword">private</span> T second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair类引入了一个类型变量T，用尖括号括起来，并放在类名的后面。<strong>注意这里的T只是指定了一种类型，不代表类只有一个属性成员，而表示接下来类中出现的T都和尖括号里的类型保持一致,即类定义的类型变量指定方法返回类型以及域和局部变量的类型。</strong><br>泛型类可以有多个类型变量，如可以定义两个域类型不同的Pair类<code>public class Pair&lt;T,U&gt; {. . .}</code><br><strong>类型变量命名规则：</strong>E表示集合的元素类型，K和V分别表示表的关键字和值的类型，T(需要时还可以用临近的字母U和S)表示“任意类型”。<br>实际使用中将类定义尖括号里的T替换为具体类型，类中的T也会进行相应的替换，所以，<strong>泛型类可以看作普通类的工厂</strong>  </p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>前面介绍了如何定义一个泛型类，下面我们来定义一个带有类型参数的简单泛型方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1)类型变量放在修饰符(这里是public static)的后面，返回类型的前面<br>2)泛型方法可以定义在普通类中，也可以定义在泛型类中<br>3)当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q."</span>,<span class="string">"Public"</span>);</div></pre></td></tr></table></figure></p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时，类或方法需要对类型变量加以约束。下面是一个典型的例子，我们要计算数组中的最小元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        T smallest = a[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length;i++)</div><div class="line">        <span class="keyword">if</span>(smallest.compareTo(a[i]) &gt; <span class="number">0</span>)</div><div class="line">            smallest = a[i];</div><div class="line">        <span class="keyword">return</span> smallset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们会发现一个问题，smallest的类型为T，既可以是任何一个类的对象，如何保证T类型有compareTo方法呢？<strong>解决方法是限制T为实现了Comparable接口的类</strong>，即将泛型方法定义改为<code>public static &lt;T extends Comparable&gt; T min(T[] a)</code><br><strong>注意：</strong><br>1)限定类时如果实现的是接口也用extends关键字，如上面的<code>T extends Comparable</code><br>2)只需要在尖括号里限定，之后的T不用再加限定  </p><p>一个类型变量或通配符可以有多个限定，用’&amp;’分隔限定类型，用逗号分隔类型变量，例如：<code>T extends Comparable &amp; Serializable</code> <strong>可以有多个接口限定和至多一个类限定，将标记接口(空接口)放在限定列表的末尾，如果用一个类作为限定，它必须是限定列表中的第一个</strong>  </p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p><strong>对于虚拟机来说没有泛型类型，只有普通类和方法。无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。在编译时泛型类型会被转化为原始类型。</strong>原始类型就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(无限定类型的变量替换为Object)。<br>例如，<code>Pair&lt;T&gt;</code>的原始类型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object first;</div><div class="line">    <span class="keyword">private</span> Object second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first,Object second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>因为T是一个无限定的参数变量，所以直接用Object替换<br>如果是T是一个限定类型的参数变量，用限定列表中的第一个类型替换，比如<code>T extends Comparable &amp; Serializable</code>被替换为<code>Comparable</code>  </p><h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><p>当泛型表达式编译时，编译器会将其编译为原始类型并加入强制类型转换。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Employee&gt; buddies = . . . ;</div><div class="line">Employee buddy = buddies.getFirst();</div></pre></td></tr></table></figure></p><p>编译器会把这个方法调用翻译为两条虚拟机指令：  </p><ul><li>对原始方法Pair.getFirst的调用  </li><li>将返回的Object类型强制转换为Employee类型  </li></ul><p>当存入一个泛型域时编译器也会自动在字节码中插入强制类型转换。  </p><h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><p>类型擦除会发生一些问题，比如一个类subPair继承自类<code>Pair&lt;String&gt;</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">String</span>&gt; //继承一个泛型类</span></div><div class="line"><span class="class"> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;<span class="comment">//重写了父类的方法</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair在编译的时候被类型擦除，Pair的setFirst方法变为了setFirst(Object newValue)，这样SubPair的setFirst(Stirng newValue)方法就无法覆盖父类中的setFirst(Object newValue)方法，因为参数不同，不是同一个方法。<br>SubPair中会出现两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span>&#123;....&#125;</div></pre></td></tr></table></figure></p><p>此时如果有如下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SubPair p = <span class="keyword">new</span> SubPair(. . .);</div><div class="line">Pair&lt;String&gt; pair = p;</div><div class="line">p.setFirst(<span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure></p><p>按理来说，这段测试代码应该不能通过编译，因为要实现多态的话，所调用的方法必须在子类中重写，但是在这里SubPair类并没有重写Pair类中的setFirst方法，只是单纯的继承而已，并且新加了一个参数不同的同名方法。<br>但结果可以运行，因为为了解决这种<strong>类型擦除和多态的冲突</strong>，编译器会在SubPair类中生成一个桥方法，上述两个方法被编译器变成了这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125; <span class="comment">//子类定义的方法不变</span></div><div class="line"></div><div class="line"><span class="comment">//编译器生成的桥方法 </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   setFirst((String) newValue);</div><div class="line">   <span class="comment">//桥内部调用的是子类中定义的setFirst(String newValue)方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看出，这个桥方法实际上就是对超类中setFirst(Object newValue)的重写。这样做的原因是，当程序员在子类中写下setFirst(String newValue)方法时，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免<strong>类型擦除与多态发生冲突。</strong><br>详见博客：<a href="http://www.cnblogs.com/xz816111/p/7643323.html" target="_blank" rel="external">Java中的类型擦除与桥方法</a>  </p><h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><p>在使用Java泛型时需要考虑一些限制。大多数限制都是由类型擦除引起的。  </p><h4 id="1-不能用基本类型实例化类型参数"><a href="#1-不能用基本类型实例化类型参数" class="headerlink" title="1.不能用基本类型实例化类型参数"></a>1.不能用基本类型实例化类型参数</h4><p>类型参数不能为基本类型。比如，没有<code>Pair&lt;double&gt;</code>只有<code>Pair&lt;Double&gt;</code>,其原因是类型擦除，因为擦除之后，Pair类含有Object类型的域，Object不能存储double值。  </p><h4 id="2-运行时类型查询只适用于原始类型"><a href="#2-运行时类型查询只适用于原始类型" class="headerlink" title="2.运行时类型查询只适用于原始类型"></a>2.运行时类型查询只适用于原始类型</h4><p>使用instanceof查询一个对象是否属于某个泛型类会产生编译错误，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;)<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>同样的道理，getClass方法总是返回原始类型。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; stringPair = . . .;</div><div class="line">Pair&lt;Employee&gt; employeePair = . . .;</div><div class="line"><span class="keyword">if</span>(stringPair.getClass() == employeePair.getClass()) <span class="comment">//equal</span></div></pre></td></tr></table></figure></p><p>其比较结果是true，因为两次调用getClass结果都返回Pair.class  </p><h4 id="3-不能创建参数化类型的数组"><a href="#3-不能创建参数化类型的数组" class="headerlink" title="3.不能创建参数化类型的数组"></a>3.不能创建参数化类型的数组</h4><p>不能实例化参数化类型的数组，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt; [<span class="number">10</span>];<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>最安全而有效的方法是使用ArrayList，即<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>  </p><h4 id="4-Varargs警告"><a href="#4-Varargs警告" class="headerlink" title="4.Varargs警告"></a>4.Varargs警告</h4><p>Java不支持泛型类型的数组，但如果向参数个数可变的方法传递一个泛型类型的实例(即传递一个泛型类型对象的数组)这种规则有所放松，你只会得到一个警告，而不是错误。<br>可以用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>或用<code>@SafeVarags</code>标注addAll方法来抑制警告。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;泛型程序设计&quot;&gt;&lt;a href=&quot;#泛型程序设计&quot; class=&quot;headerlink&quot; title=&quot;泛型程序设计&quot;&gt;&lt;/a&gt;泛型程序设计&lt;/h3&gt;&lt;p&gt;泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之线段树</title>
    <link href="http://habitdiary.cn/2017/10/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://habitdiary.cn/2017/10/18/算法学习之线段树/</id>
    <published>2017-10-18T15:11:27.000Z</published>
    <updated>2017-10-18T16:23:57.942Z</updated>
    
    <content type="html"><![CDATA[<p>最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  </p><h3 id="线段树是什么？有什么用？"><a href="#线段树是什么？有什么用？" class="headerlink" title="线段树是什么？有什么用？"></a>线段树是什么？有什么用？</h3><p>线段树类似区间树，它在各个节点保存一条线段(数组中的一段子数组)，主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。<br>你可能会问：查询区间和可以用O(n)的复杂度预处理一个前缀和数组，然后就可以O(1)地查询某段区间和;查询区间最值，也就是RMQ问题，也可以用O(nlogn)的复杂度预处理ST表，然后O(1)地查询区间最值。那么为什么要使用线段树呢？<br>线段树的精髓就在于它能在支持<strong>区间动态修改</strong>的前提下保持每个操作O(logn)的复杂度，这是其他两者做不到的。<br>线段树能进行的操作主要有：1)单点更新，区间查询  2)区间更新，区间查询 3)区间更新，单点查询<br>除了上述操作，线段树还可以解决区间染色和矩形面积交、面积并等问题。  </p><h3 id="线段树基本知识"><a href="#线段树基本知识" class="headerlink" title="线段树基本知识"></a>线段树基本知识</h3><p>线段树的结构：<br><img src="/2017/10/18/算法学习之线段树/1.png" alt="fail">  </p><p>建立一个线段树的示意图(可以维护区间和或最值)：<br><img src="/2017/10/18/算法学习之线段树/2.png" alt="fail">  </p><p>单点修改后重新调整线段树：<br><img src="/2017/10/18/算法学习之线段树/3.png" alt="fail">  </p><p>区间查询区间最值：<br><img src="/2017/10/18/算法学习之线段树/4.png" alt="fail">  </p><p>线段树的结点关系:<br><img src="/2017/10/18/算法学习之线段树/5.png" alt="fail">  </p><h3 id="线段树的代码实现"><a href="#线段树的代码实现" class="headerlink" title="线段树的代码实现"></a>线段树的代码实现</h3><p>下面给出建立线段树和进行各种操作的模板，关键点在代码的注释中有解释：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*node：区间结点号begin：该node的区间左边界end：该node的区间右边界</span></div><div class="line"><span class="comment">  left：查询区间的左边界right：查询区间的右边界pos：查询区间的点*/</span> </div><div class="line">  </div><div class="line"><span class="comment">/*线段树:求和或最值 </span></div><div class="line"><span class="comment">单点更新,区间查询</span></div><div class="line"><span class="comment">区间更新,单点查询(lazy标记表示本节点的信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。lazy初始为0,区间加上k给该区间管理的结点的lazy加k,push_down给子节点加(end-begin+1)*k)</span></div><div class="line"><span class="comment">区间更新,区间查询 </span></div><div class="line"><span class="comment">lson 2*node</span></div><div class="line"><span class="comment">rson 2*node+1</span></div><div class="line"><span class="comment">[begin,end]</span></div><div class="line"><span class="comment">[begin,mid] [mid+1,end] 其中mid为(begin+end)/2 */</span> </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1) </span></div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> lazy[maxn*<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;<span class="comment">//pushUp自底向上更新区间和与最值 </span></div><div class="line">segTree[node]=segTree[lson]+segTree[rson];<span class="comment">//segTree[node]=max(segTree[lson],segTree[rson]) </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//pushDown自顶向下更新lazy数组和给结点加上lazy数组的值 </span></div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;<span class="comment">//lazy[node]为0直接return </span></div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node]; </div><div class="line">lazy[lson]+=lazy[node]; </div><div class="line">lazy[rson]+=lazy[node];<span class="comment">//给左右孩子传递lazy,是+=不是=，因为孩子节点可能被多次延迟标记又没有向下传递 </span></div><div class="line">lazy[node]=<span class="number">0</span>;<span class="comment">//把父节点的lazy置为0 </span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//建树 </span></div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;<span class="comment">//begin==end表示管理的是结点 </span></div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);<span class="comment">//按照顺序输入结点，由于建树类似于树的先根遍历，所以建立的线段树的叶子结点从左到右的值就是输入的顺序 </span></div><div class="line"><span class="comment">//segTree[node]=a[begin] 用于任意顺序输入,先将输入存入a数组,下标从1开始，begin = end = index </span></div><div class="line"><span class="keyword">return</span>;<span class="comment">//输入完成后要return，否则会继续访问左右孩子，可能越界</span></div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//单点更新 </span></div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;<span class="comment">//管理的区间不包含pos,直接return </span></div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125; </div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//区间查询 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查询结点和区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];<span class="comment">//查询区间包含查询结点 </span></div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//int maxx=-1</span></div><div class="line">sum+=query(lson,begin,mid,left,right);<span class="comment">//maxx=max(maxx,query(lson,begin,mid,left,right))</span></div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);<span class="comment">//maxx=max(maxx,query(rson,mid+1,end,left,right))</span></div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//区间更新 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;<span class="comment">//结点和更新区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;<span class="comment">//更新区间包含结点 </span></div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="一、单点更新，区间查询"><a href="#一、单点更新，区间查询" class="headerlink" title="一、单点更新，区间查询"></a>一、单点更新，区间查询</h4><p>HDU1166 敌兵布阵<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1166</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> T,N,a,b;</div><div class="line"><span class="keyword">char</span> command[<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,cas++);</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,command)!=EOF)&#123;</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'E'</span>) <span class="keyword">break</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)</div><div class="line"><span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,<span class="number">1</span>,N,a,b)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'A'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,b);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'S'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,-b);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1754 I Hate It<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1754</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> N,M,A,B;</div><div class="line"><span class="keyword">char</span> C[<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=max(segTree[lson],segTree[rson]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=k;<span class="comment">//直接修改</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line"><span class="keyword">int</span> maxx=<span class="number">0</span>;</div><div class="line">maxx=max(maxx,query(lson,begin,mid,left,right));</div><div class="line">maxx=max(maxx,query(rson,mid+<span class="number">1</span>,end,left,right));</div><div class="line"><span class="keyword">return</span> maxx;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M)!=EOF)&#123;</div><div class="line"> build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"> <span class="keyword">while</span>(M--)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,C,&amp;A,&amp;B);</div><div class="line"><span class="keyword">if</span>(C[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B);</div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="二、区间更新，区间查询"><a href="#二、区间更新，区间查询" class="headerlink" title="二、区间更新，区间查询"></a>二、区间更新，区间查询</h3><p>POJ 3468 A Simple Problem with Integers<br>题目链接:<a href="http://poj.org/problem?id=3468" target="_blank" rel="external">http://poj.org/problem?id=3468</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line">ll segTree[<span class="number">4</span>*maxn];</div><div class="line">ll lazy[<span class="number">4</span>*maxn];</div><div class="line">ll N,Q,A,B,C;</div><div class="line"><span class="keyword">char</span> command[<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(ll node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node];</div><div class="line">lazy[lson]+=lazy[node];</div><div class="line">lazy[rson]+=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll node,ll begin,ll end,ll left,ll right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line">ll sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll node,ll begin,ll end,ll left,ll right,ll k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,command);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;A,&amp;B,&amp;C);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B,C);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1698 Just A Hook<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1698" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1698</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> lazy[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> T,N,Q,X,Y,Z;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=<span class="number">1</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]=(mid-begin+<span class="number">1</span>)*lazy[node];<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">segTree[rson]=(end-mid)*lazy[node];</div><div class="line">lazy[lson]=lazy[node];</div><div class="line">lazy[rson]=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]=(end-begin+<span class="number">1</span>)*k;<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">lazy[node]=k;<span class="comment">//+=改成=,因为此时lazy即使没有下传也不叠加</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;X,&amp;Y,&amp;Z);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,X,Y,Z);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: The total value of the hook is %d.\n"</span>,cas++,query(<span class="number">1</span>,<span class="number">1</span>,N,<span class="number">1</span>,N));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、区间染色问题"><a href="#三、区间染色问题" class="headerlink" title="三、区间染色问题"></a>三、区间染色问题</h3><p>ZOJ 1610 Count the Colors<br>题目链接:<a href="https://vjudge.net/problem/11553/origin" target="_blank" rel="external">https://vjudge.net/problem/11553/origin</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 8005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> col[maxn*<span class="number">4</span>];<span class="comment">//col[node]表示node管辖的区间的颜色 </span></div><div class="line"><span class="keyword">int</span> sum[maxn];<span class="comment">//表示某点的颜色 </span></div><div class="line"><span class="keyword">int</span> res[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">col[lson]=col[rson]=col[node];</div><div class="line">col[node]=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">col[node]=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(col[node]!=<span class="number">-1</span>) pushDown(node);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"><span class="comment">//不用建树,直接在query里存储颜色即可，因为染色不用求区间和或者最值 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">sum[begin]=col[node];<span class="comment">//存储每个点的颜色 </span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid,left,right);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> n,x1,x2,c;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</div><div class="line"><span class="built_in">memset</span>(col,<span class="number">-1</span>,<span class="keyword">sizeof</span>(col));</div><div class="line"><span class="built_in">memset</span>(sum,<span class="number">-1</span>,<span class="keyword">sizeof</span>(sum));</div><div class="line"><span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x1,&amp;x2,&amp;c);</div><div class="line"><span class="keyword">if</span>(x1==x2) <span class="keyword">continue</span>;<span class="comment">//为了保证R-1&gt;=L </span></div><div class="line">update(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,x1,x2<span class="number">-1</span>,c);<span class="comment">//为防止重叠,更新区间[L,R-1]</span></div><div class="line"><span class="comment">/*注意begin=0 end=maxn-1 而不是begin=1 end=n 因为只是涂n次,不一定在1-n范围内涂 */</span> </div><div class="line">&#125;</div><div class="line">query(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++) &#123;</div><div class="line">            <span class="keyword">while</span>(i!=<span class="number">0</span>&amp;&amp;sum[i]!=<span class="number">-1</span>&amp;&amp;sum[i]==sum[i<span class="number">-1</span>])<span class="comment">//涂过同一颜色也加1 </span></div><div class="line">            i++;</div><div class="line">            res[sum[i]]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</div><div class="line"><span class="keyword">if</span>(res[i])</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,res[i]);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>POJ 2528 Mayor’s posters<br>题目链接:<a href="http://poj.org/problem?id=2528" target="_blank" rel="external">http://poj.org/problem?id=2528</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*解法：离散化，如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的</span></div><div class="line"><span class="comment">      1   2   3   4  6   7   8   10</span></div><div class="line"><span class="comment">      —   —   —   —  —   —   —   —</span></div><div class="line"><span class="comment">      1   2   3   4  5   6   7   8</span></div><div class="line"><span class="comment">离散化  X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10</span></div><div class="line"><span class="comment">于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。</span></div><div class="line"><span class="comment">但是只是这样简单的离散化是错误的，</span></div><div class="line"><span class="comment">如三张海报为：1~10 1~4 6~10</span></div><div class="line"><span class="comment">离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10</span></div><div class="line"><span class="comment">第一张海报时：墙的1~4被染为1；</span></div><div class="line"><span class="comment">第二张海报时：墙的1~2被染为2，3~4仍为1；</span></div><div class="line"><span class="comment">第三张海报时：墙的3~4被染为3，1~2仍为2。</span></div><div class="line"><span class="comment">最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。</span></div><div class="line"><span class="comment">新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）</span></div><div class="line"><span class="comment">X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10</span></div><div class="line"><span class="comment">这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3</span></div><div class="line"><span class="comment">最终，1~2为2，3为1，4~5为3，于是输出正确结果3。*/</span> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></div><div class="line"><span class="comment">//不用建树,直接在query里记录hash即可，因为染色不用求区间和或者最值，也不用pushUp </span></div><div class="line"><span class="keyword">int</span> m, li[maxn], ri[maxn];</div><div class="line"><span class="keyword">int</span> poster[maxn&lt;&lt;<span class="number">3</span>], col[maxn&lt;&lt;<span class="number">4</span>], ans; <span class="comment">//col记录当前该位置最上面一层的海报种类,即染色问题的颜色 </span></div><div class="line"><span class="comment">//poster记录海报位置 </span></div><div class="line"><span class="keyword">bool</span> hash[maxn];<span class="comment">//hash用于标记某种种类的海报是否计算过,若已计算过标记为true,不再重复计算 </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">     col[lson] = col[rson] = col[node];<span class="comment">//类似lazy标记，向下传递后清空</span></div><div class="line">     col[node] = <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin, <span class="keyword">int</span> end,<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (begin &gt;= left &amp;&amp; end &lt;= right) &#123;</div><div class="line">         col[node] = k;</div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">    <span class="keyword">if</span>(col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    update(lson,begin,mid,left,right,k);</div><div class="line">    update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (begin == end) &#123;</div><div class="line">        <span class="keyword">if</span> (!hash[col[node]]) &#123;</div><div class="line">        ans++;</div><div class="line">        hash[col[node]] = <span class="literal">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> hh, <span class="keyword">int</span> xx)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mm;</div><div class="line">    <span class="keyword">while</span> (ll &lt;= hh) &#123;</div><div class="line">        mm = (ll + hh) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (poster[mm] == xx) <span class="keyword">return</span> mm;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (poster[mm] &gt; xx)  hh = mm - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> ll = mm + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> t, n, i;</div><div class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;t);</div><div class="line">    <span class="keyword">while</span> (t--) &#123;</div><div class="line">        <span class="built_in">memset</span>(col, <span class="number">-1</span>, <span class="keyword">sizeof</span> (col));<span class="comment">//-1表示没有染色</span></div><div class="line">        <span class="built_in">memset</span> (hash, <span class="literal">false</span>, <span class="keyword">sizeof</span> (hash));<span class="comment">/*因为本题墙的长度为10000000,</span></div><div class="line"><span class="comment">直接做会超时,而实际海报数量只有10000,考虑把每张海报左右两端的两段映射到小范围计算，</span></div><div class="line"><span class="comment">所以考虑离散化,但传统离散化会出错,要如果有两个位置相邻的数字数值不相邻,考虑在中间</span></div><div class="line"><span class="comment">插入一个比大的数小1的数*/</span></div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;n);</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">             <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;li[i], &amp;ri[i]);</div><div class="line">             poster[++cnt] = li[i];</div><div class="line">             poster[++cnt] = ri[i];</div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+cnt+<span class="number">1</span>);</div><div class="line">        m = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</div><div class="line">             <span class="keyword">if</span> (poster[i] != poster[i<span class="number">-1</span>]) poster[++m] = poster[i];<span class="comment">//去重 </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i = m; i &gt; <span class="number">1</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (poster[i] - poster[i<span class="number">-1</span>] &gt; <span class="number">1</span>) poster[++m] = poster[i] - <span class="number">1</span>;<span class="comment">//在末尾加入要增加的点 </span></div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+m+<span class="number">1</span>);<span class="comment">//重新排序 </span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            <span class="keyword">int</span> l = binarySearch(<span class="number">1</span>, m, li[i]);<span class="comment">//在离散化后的poster数组里二分查找每一组的左右端点</span></div><div class="line">            <span class="keyword">int</span> r = binarySearch(<span class="number">1</span>, m, ri[i]);</div><div class="line">            update(<span class="number">1</span>,<span class="number">1</span>,m,l,r,i);</div><div class="line">        &#125;</div><div class="line">        ans = <span class="number">0</span>;</div><div class="line">        query(<span class="number">1</span>, <span class="number">1</span>, m);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、矩形面积交-面积并"><a href="#四、矩形面积交-面积并" class="headerlink" title="四、矩形面积交/面积并"></a>四、矩形面积交/面积并</h3><p>HDU 1542 Atlantis(矩形面积并)<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1542" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1542</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"><span class="comment">//沿x轴扫描,沿y轴建树,线段树的结点是纵向的线段,最下面一层结点以排序后相邻的y1,y2为边界 </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>     //  存储线段信息；</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> x;   <span class="comment">//  该线段的x坐标；</span></div><div class="line">    <span class="keyword">double</span> y_up,y_down;     <span class="comment">//  竖向线段的上下端点；</span></div><div class="line">    <span class="keyword">int</span> flag;<span class="comment">//矩形的左边界为1,右边界为-1 </span></div><div class="line">&#125;line[maxn];</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>//线段树的结点,不再是单个点,是一个区间 </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> l,r;<span class="comment">//区间的左右边界,即某段扫描线的上下端点 </span></div><div class="line">    <span class="keyword">double</span> x;       <span class="comment">//  记录上一个横坐标位置，用于求面积；</span></div><div class="line">    <span class="keyword">int</span> cover;      <span class="comment">//  记录覆盖的线段数;即同一方向的线段数;由flag累加 </span></div><div class="line">    <span class="keyword">bool</span> flag;      <span class="comment">//  标记只有一个区间的节点,即在线段树最底层的结点,我们将一个个连续的区间离散化成一个结点；</span></div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>      <span class="comment">//  建树；</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    node[rt].l=y[l];    <span class="comment">//  维护区间；</span></div><div class="line">    node[rt].r=y[r];</div><div class="line">    node[rt].x=<span class="number">-1</span>;</div><div class="line">    node[rt].flag=<span class="literal">false</span>;</div><div class="line">    node[rt].cover=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;             <span class="comment">//  区间是连续的;</span></div><div class="line">        node[rt].flag=<span class="literal">true</span>; <span class="comment">//  标记为结点; </span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    build(lson,l,mid);</div><div class="line">    build(rson,mid,r);   <span class="comment">//  因为将一个个连续区间离散成点，所以此处mid不需要+1；</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span> </span></div><div class="line"><span class="function"><span class="comment">/*查询+更新x处（l,r）区间面积，l和r代表的是区间查询区间的边界，node[rt].l和node[rt].r代表的是结点边界*/</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//  该方向结点不包含所要查询的区间；</span></div><div class="line">    <span class="keyword">if</span>(node[rt].flag)&#123;  <span class="comment">//  找到只有一个区间的叶子结点；</span></div><div class="line">        <span class="keyword">if</span>(node[rt].cover&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">double</span> pre=node[rt].x;</div><div class="line">            <span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l); <span class="comment">//  计算面积；</span></div><div class="line">            node[rt].x=x;       <span class="comment">//  更新定位x位置，便于下次计算面积；</span></div><div class="line">            node[rt].cover+=flag;   <span class="comment">//  更新覆盖的线段数；</span></div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">            node[rt].x=x;</div><div class="line">            node[rt].cover+=flag;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没有产生面积并也要return 0 </span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> ans1,ans2;</div><div class="line">    ans1=Insert_query(lson,x,l,r,flag);    </div><div class="line">    ans2=Insert_query(rson,x,l,r,flag); </div><div class="line">    <span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> x1,x2,y1,y2;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</div><div class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">            y[cnt]=y1;</div><div class="line">            line[cnt].x=x1;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">1</span>;   <span class="comment">//  表示左边线段；</span></div><div class="line">            y[cnt]=y2;</div><div class="line">            line[cnt].x=x2;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">-1</span>;  <span class="comment">//  表示右边线段；</span></div><div class="line">        &#125;</div><div class="line">        sort(y,y+cnt);        <span class="comment">//  将所有高度由小到大排序，将区间建树表示</span></div><div class="line">        sort(line,line+cnt,cmp);      <span class="comment">//  因为扫描线从左到右扫描，所以按照横坐标从小到大排序后逐一插入线段树</span></div><div class="line">        build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line">        <span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">            area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2lf\n\n"</span>,++Case,area);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1255 覆盖的面积(矩形面积交)<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1255" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1255</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> T,N;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>&#123;</span></div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">double</span> y_up,y_down;</div><div class="line"><span class="keyword">int</span> flag;</div><div class="line">&#125;line[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></div><div class="line"><span class="keyword">double</span> l,r;</div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">int</span> cover;</div><div class="line"><span class="keyword">bool</span> flag;</div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</div><div class="line">node[rt].l=y[l];</div><div class="line">node[rt].r=y[r];</div><div class="line">node[rt].x=<span class="number">-1</span>;</div><div class="line">node[rt].flag=<span class="literal">false</span>;</div><div class="line">node[rt].cover=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;</div><div class="line">node[rt].flag=<span class="literal">true</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,l,mid);</div><div class="line">build(rson,mid,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(node[rt].flag)&#123;</div><div class="line"><span class="keyword">if</span>(node[rt].cover&gt;<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">double</span> pre=node[rt].x;</div><div class="line"><span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l);</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">double</span> ans1,ans2;</div><div class="line">ans1=Insert_query(lson,x,l,r,flag);</div><div class="line">ans2=Insert_query(rson,x,l,r,flag);</div><div class="line"><span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line"><span class="keyword">while</span>(N--)&#123;</div><div class="line"><span class="keyword">double</span> x1,y1,x2,y2;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">y[cnt]=y1;</div><div class="line">line[cnt].x=x1;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">1</span>;</div><div class="line">y[cnt]=y2;</div><div class="line">line[cnt].x=x2;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">sort(y,y+cnt);</div><div class="line">sort(line,line+cnt,cmp);</div><div class="line">build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line"><span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,area);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  &lt;/p&gt;
&lt;h3 id=&quot;线段树是什么？有什么用？&quot;&gt;&lt;a href=&quot;#线段树是什么？有什么用？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="算法" scheme="http://habitdiary.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之抽象类、接口、lambda表达式与内部类</title>
    <link href="http://habitdiary.cn/2017/10/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://habitdiary.cn/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/</id>
    <published>2017-10-16T00:52:06.000Z</published>
    <updated>2017-10-23T15:40:13.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它子类的共同特征。<strong>如果一个父类设计得非常抽象，以至于它没有任何具体的实例，这样的类称为抽象类，使用abstract关键字修饰。抽象类定义了相关子类的共同行为。</strong>  </p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果一个方法非常抽象，只定义了方法，没有提供方法的具体实现，那么我们把它定义为一个抽象方法，它的具体实现由子类提供，即子类覆盖抽象方法提供方法体。<br>抽象方法由abstract关键字修饰，只有方法头，没有花括号和方法体，以分号结尾。比如一个GeometricObject类定义了一个名为getArea的抽象方法，即<code>public abstract double getArea();</code> </p><h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><p>1.抽象方法应该定义为public，以便子类进行重写。<br>2.抽象类的构造器应该定义为protected，因为抽象类不能通过new直接创建实例，其构造器只被子类调用。创建一个具体子类的实例时，它的父类的构造器被调用以初始化父类中定义的数据域。<br>3.一个包含抽象方法的类必须定义为抽象类，一个不包含抽象方法的类也可以定义为抽象类(如果不想让某类创建实例，可以把它定义为抽象类)<br>4.如果子类继承抽象类时没有覆盖其所有的抽象方法，即子类中仍有抽象方法，子类也应该定义为抽象的<br>5.抽象方法是非静态的<br>6.子类可以覆盖父类的方法并将它定义为abstract,这种情况很少见，但它在当父类方法实现在子类中变得无效时是很有用的，在这种情况下，子类必须定义为abstract<br>7.即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object是具体的，但它的子类GeometricObject是抽象的。<br>8.不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。下面的语句创建一个GeometricObject类型的数组是正确的：<code>GeometricObject[] objects = new GeometricObject[10];</code>然后可以创建一个具体子类的实例并把它的引用赋给数组，如：<code>Objects[0] = new Circle();</code></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在很多方面都与抽象类很相似，但它的目的是指明<strong>相关或者不相关类</strong>的多个对象的共同行为，属性成员都是<strong>公共静态常量</strong>，成员方法都是<strong>公共抽象方法</strong>。例如，使用正确的接口，可以指明这些对象是可比较的、可克隆的。为了区分接口和类，Java采用Interface关键字定义接口。在一个java文件内，只能有一个public类或一个public接口，即public类和public接口不能同文件共存。接口没有构造器，没有实例域，也不能使用new操作符创建实例。接口没有构造器的原因有三点：<br>1.构造器用于初始化成员变量，接口没有成员变量，不需要构造器<br>2.类可以实现多个接口，如果多个接口都有构造方法，不好确定构造方法链的调用次序<br>3.作为高度抽象的概念，接口不能实例化对象，也就不需要构造器  </p><p>像常规类一样，每个接口都被编译为独立的字节码文件，可以作为引用变量的数据类型和类型转换的结果，可以使用instanceof关键字等。<br>类实现接口用implements关键字，一个类可以实现多个接口，用逗号隔开即可。一个接口可以继承多个接口，用extends关键字。<br>在定义接口中的数据域和方法时可以简写，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>可简写成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要注意接口中所有的数据域都是public static final，所有的方法都是public abstract，在定义接口中允许省略修饰符，但在子类重写方法时不可缺省public修饰符，否则方法的可见性会缩小为包内可见。  </p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>从Java SE 8开始，允许在接口中增加静态方法，理论上讲是可以的，但这有违于接口作为抽象规范的初衷。  </p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>可以为接口方法提供一个默认实现，用default修饰符标记，这样子类无需重写这个方法也能得到一个接口的默认实现。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样实现Collection的程序员就不用操心实现isEmpty方法了。<br>默认方法的一个重要用法是<strong>“接口演化”</strong>。以Collection接口为例，这个接口作为Java的一部分已经很多年了，假设很久以前定义了一个实现Collection接口的类Bag。后来在Collection接口中增加了一个stream方法，假设stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。如果不重新编译这个类，而是使用原先包含这个类的JAR文件，这个类仍能正常加载，正常构造实例，但如果在一个Bag实例上调用stream方法，会出现一个AbstractMethodError。<strong>但如果把stream方法定义为默认方法就可以解决这个问题，既可以重新编译也可以使用JAR文件加载类并调用stream方法。</strong>  </p><h3 id="解决默认方法的冲突"><a href="#解决默认方法的冲突" class="headerlink" title="解决默认方法的冲突"></a>解决默认方法的冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生冲突。解决冲突规则如下：<br>1) 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。<br>2) 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突，即从中选择一个方法重写。</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable接口定义了compareTo方法，用于比较对象。当想使用Arrays类的sort方法对对象数组进行排序时，对象所属的类必须实现了Comparable接口。<br>Comparable接口是一个带泛型的接口，定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> compareTo应该与equals保持一致，即当且仅当o1.equals(o2)为true时，o1.compareTo(o2) == 0成立。以下是compareTo方法的实现：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> Double.compare(salary,other.salary);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> <strong>在比较浮点数时可以使用Double的静态方法compare,这样就不必担心溢出或精度损失，类似的还有Integer.compare方法等</strong><br> <strong>继承过程中的compareTo，如果由子类决定相等的概念，每个compare方法都应该在开始时检测：<code>if(getClass() != other.getClass()) throw new ClassCastException()</code></strong>：<strong>如果父类决定相等的概念，应该在超类中提供一个compareTo方法，并将这个方法声明为final。</strong>  </p><h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p> Comparator接口意为”比较器”接口，是一个泛型接口，可用于自定义排序规则和大小比较等。要进行自定义排序，Arrays.sort方法有一个重载版本，需要提供一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。接口定义为：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first,T second)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 如果要按长度比较字符串，由于String是按字典序比较字符串，肯定不能让String类用两种方法实现compareTo方法 —— 况且String类也不由我们修改。此时可以定义如下实现Comparator<string>的类：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">lengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first,String second)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> first.length() - second.length();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p><p> 因为要调用compare方法，所以具体比较大小和排序时都要创建一个lengthComparator的实例：<br> <strong>大小比较</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> LengthComparator();</div><div class="line"><span class="keyword">if</span>(comp.compare(words[i],words[j]) &gt; <span class="number">0</span>) ...</div></pre></td></tr></table></figure></p><p> <strong>自定义排序</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] friends = &#123;<span class="string">"Peter"</span>,<span class="string">"Paul"</span>,<span class="string">"Mary"</span>&#125;;</div><div class="line">Arrays.sort(friends,<span class="keyword">new</span> LengthComparator());</div></pre></td></tr></table></figure></p><h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h3><p> 首先，我们考虑为一个包含对象引用的变量建立副本会发生什么，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Employee original = <span class="keyword">new</span> Employee(<span class="string">"John Public"</span>,<span class="number">50000</span>);</div><div class="line">Employee copy = original;</div><div class="line">copy.ratseSalary(<span class="number">10</span>); <span class="comment">//original的salary也被改变</span></div></pre></td></tr></table></figure></p><p> 原变量和副本都会指向同一个对象，这说明，任何一个变量的改变都会影响到另一个变量。如果有一个对象original，希望创建一个对象copy使得其初始状态与original相同，但是之后它们各自回有自己不同的状态，这种情况下就可以使用克隆，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee copy = original.clone();</div><div class="line">copy.raiseSalary(<span class="number">10</span>); <span class="comment">//original的salary不会被改变</span></div></pre></td></tr></table></figure></p><p>Object类中的clone方法将原始对象的每个数据域复制给目标对象，如果一个数据域是基本数据类型，复制的就是它的值，如果是引用类型，复制的就是它的引用，这种克隆称为<strong>浅复制</strong>,即original != copy,但original.hireDay == copy.hireDay。这有时是不符合我们要求的，我们不希望在改变某个对象的引用类型的数据域时影响到另一个对象，这时我们需要<strong>深复制</strong>,即如果数据域是引用类型，复制的是对象的内容而不是引用。<br>无论是<strong>浅复制</strong>还是<strong>深复制</strong>，我们都需要先实现Cloneable接口，否则会产生一个必检异常。Cloneable接口的定义是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们发现这个接口是空的，一个带空体的接口称为标记接口。一个标记接口既不包括常量也不包括方法，它用来表示一个类拥有的某些特定的属性，其惟一的作用是允许在类型查询中使用instanceof关键字。但如果一个请求克隆的对象不实现这个接口，会产生CloneNotSupportedException，即使clone的默认(浅拷贝)实现能够满足要求，还是要实现这一接口。在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone方法，这个方法是从Object类继承的，这个接口只是作为一个标记。  </p><p>Object类中提供的原始clone方法的方法头是<code>protected native Object clone() throws CloneNotSupportedException</code>,关键字native表明这个方法不是用Java写的，但它是JVM针对自身平台实现的。关键字protected限定方法只能在同一个包内或在其子类中访问。由于这个原因：<strong>必须在要实现克隆的子类中覆盖这个方法并把可见性修饰父改为public</strong>。<br>下面给出一个浅复制的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> (Employee) <span class="keyword">super</span>.clone();</div><div class="line">    &#125;</div><div class="line">    . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出一个深复制的例子：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">     . . .</div><div class="line">     Employee cloned = (Employee) <span class="keyword">super</span>.clone;</div><div class="line">     cloned.hireDay = (Date)hireDay.clone();</div><div class="line">     <span class="keyword">return</span> cloned;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们注意到Object类的clone方法的返回值类型是Object，而Employee类的clone方法返回值类型是Employee，这叫做协变返回类型，即<strong>子类在重写父类方法时可以返回父类返回值类型的子类型</strong>。clone方法声明异常也可以改成捕获异常，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">Employee cloned = (Employee) <span class="keyword">super</span>.clone();</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(CloneNotSupportedException e)&#123; <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="复制数组的三种方法"><a href="#复制数组的三种方法" class="headerlink" title="复制数组的三种方法"></a>复制数组的三种方法</h3><p>1.申请一个新数组，遍历原数组逐一复制元素<br>2.使用System类的静态方法arraycopy<br>3.使用<code>数组对象.clone</code>返回一个数组克隆的引用  </p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>区别：<br>1.接口所有的变量必须是public static final;抽象类的变量无限制<br>2.接口没有构造方法，不能用new操作符实例化;抽象类有构造方法，由子类通过构造方法链调用，不能用new操作符实例化<br>3.接口所有方法必须是公共抽象实例方法(Java SE 8开始允许定义静态方法)，抽象类无限制<br>4.一个类只可以继承一个父类，但可以实现多个接口<br>5.所有的类有一个共同的根Object类，接口没有共同的根<br>6.抽象类和子类的关系应该是强的“是一种”关系(strong is-a relationship),而接口和子类的关系是弱的”是一种”关系(weak is-a relationship)。接口比抽象类更灵活，因为实现接口的子类只需要具有统一的行为即可，不需要都属于同一个类型的类。</p><h3 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h3><p> 回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下按钮或选择某个菜单项时应该采取什么行动。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p> 内部类，或者称为嵌套类，是一个定义在另一个类范围中的类。一个内部类可以如常规类一样使用。通常，在一个类只被它的外部类所使用的时候，才将它定义为内部类，内部类机制主要用于设计具有互相协作关系的类集合。比如：  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//OuterClass.java: inner class demo</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line">   <span class="comment">/** A method in the outer class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="comment">//Do something</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// An inner class</span></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">   <span class="comment">/** A method in the inner class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mi</span><span class="params">()</span></span>&#123;</div><div class="line">   data++;</div><div class="line">       m();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 为什么要使用内部类，主要原因有三：<br> 1.内部类可以访问包含它的外部类的所有数据域(包括私有数据域)和方法，没有必要将外部类对象的引用传递给内部类的构造方法,内部类有一个指向外部类对象的隐式引用，如果显式写出，外部类的引用是OuterClass.this<br> 2.内部类可以对同一个包中的其他类隐藏起来<br> 3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷  </p><p> 内部类具有一下特征：<br> 1) 一个内部类被编译成一个名为<code>OuterClassName$InnerClassName</code>的类。例如，一个定义在Test类中的内部类A被编译成<code>Test$A.class</code><br> 2) 一个内部类可以使用可见性修饰符(public、private、protected、default)所定义，和应用于一个类中成员的可见性规则一样<br> 3) 一个内部类可以被定义为static，一个static的内部类可以使用外部类的名字访问,一个static内部类不能访问外部类中的非静态成员<br> 4) 内部类对象通常在外部类中创建，但是你也可以从另外一个类中来创建一个内部类的对象。如果内部类是非静态的，你必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类对象：<code>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</code> 如果内部类是静态的，使用下面语法来创建一个内部类对象:<code>OuterClass.InnerClass innerObject = new OuterClass.InnerClass();</code><br> 5) 内部类所有的静态域必须是final修饰的<strong>静态常量</strong>,不能有静态变量，也不能有静态方法</p><p> 一个简单的内部类的用途是将相互依赖的类结合到一个主类中，这样做减少了源文件的数量(因为非内部类如果用public修饰必须放在不同的源文件中，而内部类可放在同一源文件中)，这样也使得类文件容易组织，因为它们都将主类名作为前缀。另外一个内部类的实际用途是避免类名冲突。  </p><p> 内部类对于定义处理器类非常有用，一个处理器类被设计为针对一个GUI组件创建一个处理器对象(比如，一个按钮)。处理器类不会被其他应用所共享，所以将它定义在主类里面作为一个内部类使用是恰如其分的。  </p><p>广泛意义上的内部类一般来说包括四种：<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>和<strong>静态内部类</strong>。下面就先来了解一下这四种内部类的用法。  </p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p> 　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></div><div class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>  这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。<br>  　不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<code>外部类.this.成员变量 外部类.this.成员方法</code></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p> 可以把内部类定义在一个方法中，称为局部内部类。<strong>局部内部类就像是方法里面的一个局部变量一样，不能有public、protected、private以及static修饰符。它的作用域被限定在声明这个局部类的块中。</strong>局部类有一个优势，即对外部世界完全隐藏起来。即使外部类中的其他代码也不能访问它。除了其所在的方法之外，没有任何方法知道该局部类的存在。<strong>局部内部类只能访问被final修饰的局部变量。</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></div><div class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p> 一个匿名内部类是一个没有名字的内部类，其语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> SuperClassName/InterfaceName()&#123;</div><div class="line"><span class="comment">//implement or override methods in superclass or interface</span></div><div class="line">   </div><div class="line">    <span class="comment">//Other methods if necessary</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> 其含义是<strong>创建一个继承自SuperClass或实现Interface的类的实例，并在类块内重写父类或接口的抽象方法</strong>，应该将匿名内部类理解成<strong>一个匿名子类的匿名对象</strong>,而不是理解成一个类。  </p><p> 匿名内部类有如下特征：<br> 1.没有可见性修饰符<br> 2.没有构造方法(因为没有名字,无法命名构造方法),但可以调用父类的构造方法，即<code>new SuperClassName()</code>调用父类无参构造方法，<code>new SuperClassName(args1,...)</code>调用父类有参构造方法。如果实现的是接口，则不能有任何参数，但是小括号仍然不可缺省<br> 3.必须总是从一个父类继承或者实现一个接口，但是它不能有显式的extends或者implements子句<br> 4.必须实现父类或接口中的所有抽象方法<br> 5.一个匿名内部类被编译成一个名为OuterClassName$n.class的类，例如：如果外部类Test有两个匿名内部类，分别被编译成Test$1.class和Test$2.class  </p><p> <strong>应用一</strong><br> 下面的技巧称为<strong>“双括号初始化”</strong>，这里利用了内部类语法。假设你想构造一个数组列表，并将它传递到一个方法。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">friends.add(<span class="string">"Harry"</span>);</div><div class="line">friends.add(<span class="string">"Tony"</span>);</div><div class="line">invite(friends);</div></pre></td></tr></table></figure></p><p> 如果不再需要这个数组列表，最好让它作为一个匿名列表。语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> invite(<span class="keyword">new</span> ArrayList&lt;String&gt; </div><div class="line"> &#123;</div><div class="line"> &#123;</div><div class="line">    add(<span class="string">"Harry"</span>);</div><div class="line">        add(<span class="string">"Tony"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p> 注意这里的双括号，外括号建立了一个ArrayList的匿名子表，内括号则是一个对象构造块。  </p><p> <strong>应用二</strong><br> 生成日志或调试消息时，通常希望包含当前类的类名，如：<br> <code>System.err.println(&quot;Something awful happened in &quot; + getClass());</code><br> 不过这对于静态方法并不凑效，因为调用getClass()调用的是this.getClass(),但静态方法里没有this，所以应该使用下面的表达式：<code>new Object(){}.getClass().getEnclosingClass()</code>,在这里，new Object(){} 会建立Object的一个匿名子类的匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类 </p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p> 有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象。为此，可以为内部类加上static关键字声明为静态内部类，以便取消产生的引用。与常规内部类不同，静态内部类可以有<strong>静态变量</strong>和<strong>静态方法</strong>。<br> 下面是一个使用静态内部类的典型例子。考虑一下计算一个数组中最大值和最小值的问题，当然，可以编写两个方法，一个计算最大值，一个计算最小值，在调用这两个方法的时候，数组被遍历两次，而如果数组只被遍历一次就可以计算出最大值和最小值，那么效率就大大提高了。通过一个方法就计算出最大值和最小值：这个方法需要返回两个数（max 和 min），为此可以定义一个Pair类来封装这种数据结构，但是Pair是个非常大众的名字，可能在其他地方定义过，会发生名字冲突，此时可以将Pair定义为ArrayAlg类的内部类ArrayAlg.Pair。又因为Pair没有必要访问外围类ArrayAlg的数据域或方法，应该定义为静态内部类。<br> 下面给出代码：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">    <span class="comment">//Pair类，起数据封装的作用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> s)</span></span>&#123;</div><div class="line">            first = f;</div><div class="line">            second = s;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFirst</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> second;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">maxmin</span><span class="params">(<span class="keyword">double</span>[] values)</span></span>&#123;</div><div class="line">        <span class="keyword">double</span> min = Double.POSITIVE_INFNITY;</div><div class="line">        <span class="keyword">double</span> max = Double.NEGATIVE_INFNITY;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> x : values)&#123;</div><div class="line">            <span class="keyword">if</span>(x&lt;min) min = x;</div><div class="line">            <span class="keyword">if</span>(x&gt;max) max = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(max,min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Test te = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">double</span>[] teArgs = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2.13</span>,<span class="number">100.0</span>,<span class="number">11.2</span>,<span class="number">34.5</span>,<span class="number">67.1</span>,<span class="number">88.9</span>&#125;;</div><div class="line">        Pair res = te.maxmin(teArgs);</div><div class="line">        System.out.println(<span class="string">"max = "</span>+res.getFirst());</div><div class="line">        System.out.println(<span class="string">"min = "</span>+res.getSecond());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 特别注意：代码中的Pair类如果没有声明为static，就不能在静态方法minmax中构造Pair的实例，编译器会给出错误报告：没有可用的隐式ArrayAlg类型对象初始化内部类对象  </p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p> lambda表达式可以被看作使用精简语法的匿名内部类，编译器对待一个lambda表达式如同它是从一个匿名内部类创建的对象。它是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda表达式，可以用一种精简的方式表示使用回调或变量行为的代码。如果要编译器理解lambda表达式，其代替的匿名内部类实现的接口必须只包含一个抽象方法，这样的接口被称为函数式接口(功能接口、单抽象方法接口）。在底层，接受lambda表达式的方法会接受实现某函数式接口的类的对象，并在这个对象上调用接口的方法，所以可以把lambda表达式赋给函数式接口(lambda表达式实际是一个实现了该函数式接口的类的类型，这里用到了多态)，不能把lambda表达式赋给Object变量，因为Object不是一个函数式接口。<br> 一个lambda表达式就是一个代码块，以及必须传入代码的变量规范。其基础语法是(expression只有一条语句，不用花括号，也不用分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; expression</div></pre></td></tr></table></figure></p><p> 或者(statements是多条语句，要花括号，每条语句之后要分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; &#123;statements;&#125;</div></pre></td></tr></table></figure></p><p> 一个参数的数据类型既可以显式声明，也可以由编译器隐式推断。如果只有一个参数，并且没有显式的数据类型，圆括号可以被省略。如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">e -&gt; &#123;</div><div class="line"><span class="comment">// Code for processing event e</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 即使lambda表达式没有参数，也要提供空括号，就像无参数方法一样：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span>;i &gt;=<span class="number">0</span> ;i--) System.out.println(i);&#125;</div></pre></td></tr></table></figure></p><p>  无需指定lambda表达式的返回类型，编译器会由上下文推断，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(String first,String second) -&gt; first.length() - second.length()</div></pre></td></tr></table></figure></p><p> 可以在需要int类型结果的上下文中使用  </p><p> 如果一个lambda表达式只在某些分支上返回一个值，而在另外一些分支不返回值，是不合法的。例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> x) -&gt; &#123;<span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</div></pre></td></tr></table></figure></p><p> Comparator接口是一个函数式接口，可以用lambda表达式实现自定义排序的简化：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(words,(first,second) </div><div class="line">-&gt; first.length() - second.length());</div></pre></td></tr></table></figure></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p> 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口。<br> 如果自己设计了一个函数式接口，可以用@FunctionalInterface注解来标记这个接口，这样做有两个好处：<br> 1.可以在你无意中增加一个非抽象方法时产生编译错误<br> 2.javadoc页里会指出你的接口是一个函数式接口</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p> 有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如，假设你希望只要出现一个定时器事件就打印这个事件对象，可以调用：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,event -&gt; System.out.println(event));</div></pre></td></tr></table></figure></p><p> 可以直接把println方法传递到Timer的构造器：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</div></pre></td></tr></table></figure></p><p> 表达式System.out::println是一个方法引用，它等价于lambda表达式<code>x -&gt; System.out.println(x)</code><br> 我们再看一个例子，假设要对字符串排序，而不考虑字母的大小写，可以调用<code>Arrays.sort(strings,String::compareToIgnoreCase);</code></p><p> 方法引用主要有三种情况：  </p><ul><li>object::instanceMethod</li><li>Class::staticMethod  </li><li>Class::instanceMethod    </li></ul><p>对于前两种情况，方法引用等价于提供方法参数的lambda表达式。比如：System.out::println等价于x -&gt; System.out.println(x)，Math::pow等价于(x,y) -&gt; Math.pow(x,y)。第三种情况的第一个参数会称成为调用方法的目标对象，其余参数成为方法参数，比如：String::compareToIgnoreCase等价于(x,y) -&gt; x.compareToIgnoreCase(y)<br>可以在方法里使用this和super,this::equals等同于x -&gt; this.equals(x),super::greet等同于() -&gt; super.greet()  </p><p>类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。  </p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用与方法引用类似，只不过方法名为new。例如<code>Employee::new</code>是Employee构造器的一个引用。至于是哪一个构造器取决于上下文，比如<code>Function&lt;Integer,Employee&gt; func1 = Employee :: new;</code>就相当于<code>Function&lt;Integer,Employee&gt; func = x -&gt; new Employee(x);</code><br>数组类型也有构造器引用，如<code>int[]::new</code>等价于lambda表达式<code>x -&gt; new int[x]</code>  </p><h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>我们之前提到，lambda表达式的重点是<strong>延迟执行</strong>，之所以希望以后再执行代码，有很多原因，如：  </p><ul><li>在一个单独的线程中运行代码  </li><li>多次运行代码  </li><li>在算法的恰当位置运行代码(例如，排序中的比较操作)  </li><li>发生某种情况时执行代码(如，点击了一个按钮、数据到达等) </li><li>只在必要时才运行代码  </li></ul><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/1.jpg" alt="fail" title="常用函数式接口">  </p><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/2.jpg" alt="fail" title="基本类型的函数式接口"></p><p>下面来看一个简单的例子。假设你想要重复一个动作n次。将这个动作和重复次数传递给一个repeat方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,() -&gt; System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure></p><p>要接受这个lambda表达式，需要选择一个函数式接口。在这里，我们可以使用Runnable接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,Runnable action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </div><div class="line">    action.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在让这个例子更复杂一点，我们希望告诉这个动作它出现在那一次迭代中。为此需要选择一个合适的函数式接口，其中要包含一个方法。这个方法有一个int参数而且返回类型为void。处理int值的标准接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntConsumer</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出repeat方法的改进版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,IntConsumer action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)  action.accept(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以如下调用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,i -&gt; System.out.println(<span class="string">"Countdown: "</span> + (<span class="number">9</span> - i)));</div></pre></td></tr></table></figure></p><p>大多数函数标准函数式接口都提供了非抽象方法来生成或合并函数。例如,Predicate.isEqual(a)等同于a::equals,不过如果a为null也能正常工作。已经提供了默认方法and、or和negate来合并谓词。例如,<code>Predicate.isEqual(a).or(Predicate.isEqual(b))</code>就等同于<code>x -&gt; a.equals(x) || b.equals(x)</code></p><h3 id="通过三种方式实现事件处理器"><a href="#通过三种方式实现事件处理器" class="headerlink" title="通过三种方式实现事件处理器"></a>通过三种方式实现事件处理器</h3><h4 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleEvent</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">HBox pane = <span class="keyword">new</span> HBox(<span class="number">10</span>);</div><div class="line">pane.setAlignment(Pos.CENTER);</div><div class="line">Button btOK = <span class="keyword">new</span> Button(<span class="string">"OK"</span>);</div><div class="line">OKHandlerClass handler1 = <span class="keyword">new</span> OKHandlerClass();</div><div class="line">btOK.setOnAction(handler1);</div><div class="line">Button btCancel = <span class="keyword">new</span> Button(<span class="string">"Cancel"</span>);</div><div class="line">CancelHandlerClass handler2 = <span class="keyword">new</span> CancelHandlerClass();</div><div class="line">btCancel.setOnAction(handler2);</div><div class="line">pane.getChildren().addAll(btOK,btCancel);</div><div class="line"></div><div class="line">Scene scene = <span class="keyword">new</span> Scene(pane,<span class="number">100</span>,<span class="number">50</span>);</div><div class="line">primaryStage.setTitle(<span class="string">"HandleEvent"</span>);</div><div class="line">primaryStage.setScene(scene);</div><div class="line">primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OKHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"OK button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"Cancel button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-匿名内部类"><a href="#2-匿名内部类" class="headerlink" title="2.匿名内部类"></a>2.匿名内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process New"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Open"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Save"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Print"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"AnonymousHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3.lambda表达式"></a>3.lambda表达式</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction((ActionEvent e)-&gt;&#123;System.out.println(<span class="string">"Process New"</span>);&#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction((e)-&gt;&#123;System.out.println(<span class="string">"Process Open"</span>);&#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(e-&gt;&#123;System.out.println(<span class="string">"Process Save"</span>);&#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(e-&gt;System.out.println(<span class="string">"Process Print"</span>));</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"LambdaHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p> 见大牛博客  </p><ul><li><a href="http://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="external">Java的三种代理模式</a>  </li><li><a href="http://blog.csdn.net/pangqiandou/article/details/52964066" target="_blank" rel="external">java中Proxy(代理与动态代理)</a>  </li><li><a href="http://layznet.iteye.com/blog/1182924" target="_blank" rel="external">java静态代理和动态代理</a>  </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之反射</title>
    <link href="http://habitdiary.cn/2017/10/14/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <id>http://habitdiary.cn/2017/10/14/Java学习总结之反射/</id>
    <published>2017-10-14T06:32:15.000Z</published>
    <updated>2017-10-19T06:36:34.912Z</updated>
    
    <content type="html"><![CDATA[<p>　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  </p><h3 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1.什么是反射？"></a>1.什么是反射？</h3><p>　　<strong>反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。</strong>也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。<br>　　要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><h3 id="2-反射的作用"><a href="#2-反射的作用" class="headerlink" title="2.反射的作用"></a>2.反射的作用</h3><p>　　1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制<br>　　2.在运行时分析对象的数据域<br>　　3.实现通用的数组操作代码<br>　　4.利用Method对象，这个对象很像C++中的函数指针  </p><h3 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h3><p>　　我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是<code>java.lang.Class&lt;T&gt;</code>泛型类的一个实例，比如<code>Class&lt;MyClass&gt;</code>对象即为一个封装了MyClass类的定义信息的<code>Class&lt;T&gt;</code>实例，从中我们可以得出结论：万物皆对象，<code>任何类型(包括基本类型和引用类型).class</code>都是<code>java.lang.Class&lt;T&gt;</code>的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于<code>java.lang.Class&lt;T&gt;</code>类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。<br>　　在下面的讲解中，我们将以People类和Student类为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(getName() + <span class="string">" "</span> + getAge());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">(String course)</span> </span>&#123;</div><div class="line">        System.out.println(name + <span class="string">" learn "</span> + course);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h4 id="获取class对象有以下三种"><a href="#获取class对象有以下三种" class="headerlink" title="获取class对象有以下三种:"></a>获取class对象有以下三种:</h4><p> 1) 可以通过<code>类名.class</code>得到相应类的Class对象，如:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;People&gt; peopleClass = People.class;</div></pre></td></tr></table></figure><p>2) 如果已知类的<strong>全限定名称(包含包名)</strong>，可以通过Class的forName静态方法得到类的Class对象，如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;People&gt; peopleClass = Class.forName(<span class="string">"cn.habitdiary.People"</span>);</div><div class="line"><span class="comment">//假设People类在cn.habitdiary包中</span></div></pre></td></tr></table></figure><p>　　在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">String name = <span class="string">"xxx"</span>;</div><div class="line">    Class c1 = Class.forName(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>3) 可以通过<code>类的实例对象.getClass()</code>得到相应类的Class对象，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People people = <span class="keyword">new</span> People(<span class="string">"Steven"</span>， <span class="number">20</span>);</div><div class="line">Class&lt;People&gt; peopleClass = people.getClass();</div></pre></td></tr></table></figure><p>　　<code>实例对象.getClass().getName()</code> 可以获取当前对象的类的全限定名称(包含包名)<br>　　<code>实例对象.getClass().getSimpleName()</code>可以获取当前对象的类的底层类简称(不含包名)<br>　　<code>实例对象.getClass().getCanonicalName()</code>大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。<br>　　但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName()  </p><p><strong>注意：<br>　　1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象<br>　　2.Class类是一个泛型类，但有时候我们不能提前确定class对象的类型,就可以用<code>Class&lt;?&gt;</code>来代替，即上面代码中的<code>Class&lt;People&gt; peopleClass</code>可以写成<code>Class&lt;?&gt; peopleClass</code><br>　　3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作<br>　　4.getClass()方法返回的是对象实际类型的class对象，而不是声明类型的class对象<br>　　5.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，比如:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s = <span class="string">"java.util.Random"</span>;</div><div class="line">Object m = Class.forName(s).newInstance();</div></pre></td></tr></table></figure><p>　　<strong>如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。</strong>  </p><h3 id="4-在运行时分析类的能力"><a href="#4-在运行时分析类的能力" class="headerlink" title="4.在运行时分析类的能力"></a>4.在运行时分析类的能力</h3><p>　　下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。<br>Java中为了支持反射机制主要提供了以下的类：<br>java.lang.Class<br>java.lang.reflect.Field<br>java.lang.reflect.Constructor<br>java.lang.reflect.Method<br>java.lang.reflect.Modifier  </p><p><strong>java.lang.Class类的常用API如下：</strong>  </p><ul><li>Field[] getFields()   </li><li>Field[] getDeclaredFields()   </li><li>Method[] getMethods()  </li><li>Method[] getDeclaredMethods()      </li><li>Constructor&lt; ? &gt;[] getConstructors()  </li><li>Constructor&lt; ? &gt;[] getDeclaredConstructors() </li><li>Class&lt; ? &gt; getSupperClass() </li><li>Class&lt; ? &gt;[] getInterfaces()</li></ul><p><strong>提示：</strong>getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有、受保护和默认成员，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象</p><p><strong>其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。<br>这三个类的常用API如下：</strong>  </p><ul><li>String getName() 返回一个用于描述域名、构造器或方法的字符串  </li><li>Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象  </li><li>Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)<br>返回一个用于描述方法抛出异常类型的Class对象数组  </li><li>int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值  </li><li>Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组  </li><li>Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象  </li></ul><p><strong>java.lang.reflect.Modifier类的常用API如下</strong>  </p><ul><li>static String toString(int modifiers)<br>返回修饰符对应的字符串描述</li><li>static boolean isAbstract(int modifiers)  </li><li>static boolean isFinal(int modifiers)</li><li>static boolean isInterface(int modifiers)</li><li>static boolean isNative(int modifiers)</li><li>static boolean isPrivate(int modifiers)</li><li>static boolean isProtected(int modifiers)</li><li>static boolean isPublic(int modifiers)</li><li>static boolean isStatic(int modifiers)</li><li>static boolean isStrict(int modifiers)</li><li>static boolean isSynchronized(int modifiers)</li><li>static boolean isVolatile(int modifiers)<br>上述方法检测修饰符是否是某一特定修饰符<br>java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义   </li></ul><p><strong>下面是一个检测类内部结构的例子</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">import</span> java.lang.Class;</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">if</span>(args.length &gt; <span class="number">0</span>) </div><div class="line">name = args[<span class="number">0</span>];</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">System.out.println(<span class="string">"Enter class name (e.g. java.util.Date)"</span>);</div><div class="line">name = in.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Class&lt;?&gt; c1 = Class.forName(name);</div><div class="line">Class&lt;?&gt; superc1 = c1.getSuperclass();</div><div class="line">String modifiers = Modifier.toString(c1.getModifiers());</div><div class="line"><span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) </div><div class="line">System.out.print(modifiers + <span class="string">" "</span> );</div><div class="line">System.out.print(<span class="string">"class "</span> + name);</div><div class="line"><span class="keyword">if</span>(superc1 != <span class="keyword">null</span> &amp;&amp; superc1 != Object.class)</div><div class="line">System.out.print(<span class="string">"  extends "</span>  +  superc1.getSimpleName());</div><div class="line">System.out.print(<span class="string">"\n&#123;\n"</span>);</div><div class="line">printFields(c1);</div><div class="line">System.out.println();</div><div class="line">printConstructors(c1);</div><div class="line">System.out.println();</div><div class="line">printMethods(c1);</div><div class="line">System.out.println(<span class="string">"&#125;"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(ClassNotFoundException e)</div><div class="line">&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.exit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class&lt;?&gt; c1)</span> </span>&#123;</div><div class="line">Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Constructor&lt;?&gt; c : constructors) &#123;</div><div class="line">String name = c.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(c.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = c.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class&lt;?&gt; c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Method[] methods = c1.getDeclaredMethods();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Method m :methods) &#123;</div><div class="line">Class&lt;?&gt; retType = m.getReturnType();</div><div class="line">String name = m.getName();</div><div class="line"></div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(m.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(retType.getSimpleName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = m.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class&lt;?&gt;  c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Field[] Fields = c1.getDeclaredFields();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Field f : Fields) &#123;</div><div class="line">Class&lt;?&gt; type = f.getType();</div><div class="line">String name = f.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(f.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">"  "</span>);</div><div class="line">System.out.println(type.getSimpleName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-在运行时使用反射分析对象"><a href="#5-在运行时使用反射分析对象" class="headerlink" title="5.在运行时使用反射分析对象"></a>5.在运行时使用反射分析对象</h3><p>　　反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。<br>　　查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Employee harry = <span class="keyword">new</span> Empolyee(<span class="string">"Harry Hacker"</span>,<span class="number">35000</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">1989</span>);</div><div class="line">Class&lt;Employee&gt; c1 = harry.getClass();</div><div class="line">Field f = c1.getDeclaredField(<span class="string">"name"</span>); <span class="comment">//返回某一个特定域</span></div><div class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//由于name是私有域，必须先设置为可访问</span></div><div class="line">Object v = f.get(harry);</div></pre></td></tr></table></figure><p>　　上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value  </p><p><strong>下面是一些相关API</strong><br>在java.lang.reflect.Field中：  </p><ul><li>Object get(Object obj)<br>返回obj对象中用Field对象表示的域值</li><li>xxx getXxx(Object obj)<br>返回obj对象的基本类型的域的值</li><li>void set(Object obj,Object newValue)<br>用一个新值设置obj对象中Field对象表示的域    </li></ul><p>在java.lang.Class中：  </p><ul><li>Field getField(String name)<br>返回指定名称的公有域  </li><li>Field getDeclaredField(String name)  </li><li>返回指定名称的声明的域  </li></ul><p>在java.lang.reflect.AccessibleObject中：  </p><ul><li>void setAccessible(boolean flag)<br>为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置  </li><li>boolean isAccessible()<br>返回反射对象的可访问标志的值  </li><li>static void setAccessible(AccessibleObject[] array,boolean flag)<br>批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 </li></ul><h3 id="6-使用反射编写泛型数组代码"><a href="#6-使用反射编写泛型数组代码" class="headerlink" title="6.使用反射编写泛型数组代码"></a>6.使用反射编写泛型数组代码</h3><p>　　java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee[] a = <span class="keyword">new</span> Employee[<span class="number">100</span>];</div><div class="line">a = Arrays.copyOf(a,<span class="number">2</span> * a.length);</div></pre></td></tr></table></figure></p><p>　　我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a,<span class="keyword">int</span> newLength)&#123;</div><div class="line">Object[] newArray = <span class="keyword">new</span> Object[newLength];</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(a.length,newLength);</div><div class="line">    <span class="keyword">return</span> newArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>　　上述代码存在一个错误，即使用了<code>new Object[newLength]</code>创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。<br><strong>为了解决这个问题，下面提供java.lang.reflect.Array中的API</strong>  </p><ul><li>static Object get(Object array,int index)<br>返回对象数组某个位置上的元素</li><li>static xxx getXxx(Object array,int index)<br>(xxx是基本数据类型)返回基本类型数组某个位置上的值 </li><li>static void set(Object array,int index,Object newValue)<br>设置对象数组某个位置上的元素</li><li>static void setXxx(Object array,int index,xxx newValue)<br>(xxx是基本数据类型)设置基本类型数组某个位置上的值 </li><li>static int getLength(Object array)<br>返回数组的长度  </li><li>static Object newInstance(Class componentType,int length)  </li><li><p>static Object newInstance(Class componentType,int[] length)<br>返回一个具有给定类型、给定维数的新数组  </p><p>下面给出正确的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a,<span class="keyword">int</span> newLength)</span></span>&#123;</div><div class="line">&#123;</div><div class="line">Class c1 = a.getClass();<span class="comment">//获取a数组的类对象</span></div><div class="line">    <span class="keyword">if</span>(!c1.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//确认是一个数组</span></div><div class="line">    Class componentType = c1.getComponentType();</div><div class="line">    <span class="comment">//获取数组类型</span></div><div class="line">    <span class="keyword">int</span> length = Array.getLength(a);</div><div class="line">    Object newArray = Array.newInstance(componentType,newLength);</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</div><div class="line">    <span class="keyword">return</span> newArray;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">a = (<span class="keyword">int</span>[]) goodCopyOf(a,<span class="number">10</span>);</div></pre></td></tr></table></figure><p>　　为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型 </p><h3 id="7-调用任意方法"><a href="#7-调用任意方法" class="headerlink" title="7.调用任意方法"></a>7.调用任意方法</h3><p>　　通过反射还可以调用任意方法，这是通过Method类的invoke方法实现的，方法签名是:<code>Object invoke(Object obj,Object... args)</code>,Object obj表示调用方法的对象，Object…args表示方法的参数列表。<br>如果方法是静态方法，将第一个参数设置为null;如果方法是非静态无参方法，第二个参数列表可以忽略。<br>　　例如：<code>String n = (String)m1.invoke(harry);</code>(m1表示Employee类的getName方法)。如果返回值是基本类型，invoke方法会返回其包装器类型,可以利用自动开箱将其还原为基本数据类型。例如:<code>double s = (Double)m2.invoke(harry);</code>(m2表示Employee类的getSalary方法)<br>getMethods方法和getDeclaredMethods会返回一个Method对象列表，如果要得到特定的Method对象，可以调用Class类的getMethod方法，其签名是Method getMethod(String Methodname,Class…parameterTypes)。<br>例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method m1 = Employee.class.getMethod(<span class="string">"getName"</span>);  </div><div class="line">Method m2 = Employee.class.getMethod(<span class="string">"raiseSalary"</span>,<span class="keyword">double</span>.class);</div></pre></td></tr></table></figure></li></ul><p>　　下面给出一个调用任意方法打印函数表的程序(以自定义的square和Math.sqrt方法为例)：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTableTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">Method square =         MethodTableTest.class.getMethod(<span class="string">"square"</span>,<span class="keyword">double</span>.class);</div><div class="line">    Method sqrt = Math.class.getMethod(<span class="string">"sqrt"</span>,<span class="keyword">double</span>.class);</div><div class="line">    </div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,square);</div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,sqrt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from,<span class="keyword">double</span> to,<span class="keyword">int</span> n,Method f)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    System.out.println(f);</div><div class="line">    <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> x = from;x &lt;= to;x += dx)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">try</span></div><div class="line">      &#123;</div><div class="line">         <span class="keyword">double</span> y = (Double)f.invoke(<span class="keyword">null</span>,x);</div><div class="line">         System.out.printf(<span class="string">"%10.4f | %10/4f\n"</span>,x,y);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span>(Exception e)</div><div class="line">      &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p> <strong>invoke方法如果提供了错误的参数，会抛出一个异常，所以要提供一个异常处理器</strong><br> 建议在有必要的时候才使用invoke方法，有如下原因:<br> 1.invoke方法的参数和返回值必须是Object类型，意味着必须进行多次类型转换，这样会使编译器错过检查代码的机会，等到测试阶段才发现错误，找到并改正会更加困难<br> 2.通过反射调用方法比直接调用方法要明显慢一些</p><p><strong>特别重申：</strong>建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的执行速度更快，更易于维护。    </p><p> 推荐博客：  </p><ul><li><a href="http://www.cnblogs.com/absfree/p/5277665.html" target="_blank" rel="external">Java核心技术点之反射</a>  </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li><li><a href="http://blog.csdn.net/liujiahan629629/article/details/18013523" target="_blank" rel="external">Java中的反射机制</a></li><li><a href="http://www.importnew.com/9078.html" target="_blank" rel="external">Java反射教程</a></li><li><a href="http://www.cnblogs.com/rollenholt/archive/2011/09/02/2163758.html" target="_blank" rel="external">Java反射详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  &lt;/p&gt;
&lt;h3 id=&quot;1-什么是反射？&quot;&gt;&lt;a href=&quot;#1-什么是反射？&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之继承和多态</title>
    <link href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://habitdiary.cn/2017/10/12/Java学习总结之继承和多态/</id>
    <published>2017-10-12T15:18:55.000Z</published>
    <updated>2017-10-14T06:33:23.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父类与子类"><a href="#父类与子类" class="headerlink" title="父类与子类"></a>父类与子类</h3><p>在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。  </p><h4 id="继承有如下几个关键点"><a href="#继承有如下几个关键点" class="headerlink" title="继承有如下几个关键点"></a>继承有如下几个关键点</h4><p>1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法<br>2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们<br>3.不是所有的“是一种”(is-a)关系都该用继承来建模<br>4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承<br>5.Java中类与类的继承是单一继承  </p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super关键字有两种作用：<br><strong>1.调用父类的构造方法</strong><br>因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。<br>形式是<code>super()</code>或<code>super(arguments)</code>，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条<code>super()</code><br>有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。  </p><p><strong>2.调用父类的方法</strong><br>在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用<code>super.方法名</code>来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，<code>super.super.方法名</code>是不合法的。  </p><h3 id="构造方法链"><a href="#构造方法链" class="headerlink" title="构造方法链"></a>构造方法链</h3><p>在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码：  </p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Faculty</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{       <span class="keyword">new</span> Faculty();    }    <span class="function"><span class="keyword">public</span> <span class="title">Faculty</span><span class="params">()</span></span>{        System.out.println(<span class="string">"(4) Performs Faculty's tasks"</span>);    } }<span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>{    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>{        <span class="keyword">this</span>(<span class="string">"(2) Invoke Employee's overloaded constructor"</span>);        System.out.println(<span class="string">"(3) Perfoms Employee's tasks"</span>);    }    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String s)</span></span>{      System.out.println(s);    } } <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>{        System.out.println(<span class="string">"(1) Performs Person's tasks"</span>);     } }</code></pre><p>打印结果为:<br>(1) Performs Person’s tasks<br>(2) Invoke Employee’s overloaded constructor<br>(3) Performs Employee’s tasks<br>(4) Performs Faculty’s tasks  </p><p>我们可以知道：子类的构造方法的第一条语句要么是<strong>super语句(包括编译器隐式插入的)</strong>,要么是<strong>this语句</strong>，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类  </p><p>注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。  </p><h3 id="方法重载与重写"><a href="#方法重载与重写" class="headerlink" title="方法重载与重写"></a>方法重载与重写</h3><p><strong>重载</strong><br>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同)  </p><p><strong>重写</strong><br>方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。<br>为了避免错误，可以使用重写标注，在要重写的方法前加上<code>@Override</code>，该标注会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。</p><p><strong>关于重写的几点注意</strong><br>1.仅当实例方法时刻访问的，它才能被覆盖<br>2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法  </p><p>方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。<br>注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>多态机制的底层实现技术是<strong>动态绑定</strong>，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。</p><p>对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。  </p><p>静态绑定(前期绑定)：<br>在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。</p><p>动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。<br>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p><p>简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。</p><h3 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h3><p>假设下面要调用x.f(args)，方法调用的过程为：<br>1） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(int)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。<br>2） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。<br>3） 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为private方法、构造器不能被继承，更谈不上重写，而static方法和final方法虽然能被继承，但不能被重写。<br>4) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。  </p><p>每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。<br>方法表示例(Manager继承自Employee)：  </p><p>Employee:<br>getName() -&gt; Employee.getName()<br>getSalary() -&gt; Employee.getSalary()<br>getHireDay() -&gt; Employee.getHireDay()<br>raiseSalary(double) -&gt; Employee.raiseSalary(double)  </p><p>Manager:<br>getName() -&gt; Employee.getName()//继承的方法<br>getSalary() -&gt; Manager.getSalary()//重写的方法<br>getHireDay() -&gt; Employee.getHireDay()//继承的方法<br>raiseSalary(double) -&gt; Employee.raiseSalary(double)//继承的方法<br>setBonus(double) -&gt; Manager.setBonus(double)//新增的方法  </p><h3 id="内联优化"><a href="#内联优化" class="headerlink" title="内联优化"></a>内联优化</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联优化所有的final方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高50%。如果确定一个类不会被派生或一个方法不会被重写，建议使用final关键字修饰。  </p><h3 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h3><p>和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。<br>我们可以通过<code>instanceof</code>运算符来检测一个对象是否是某个类或接口的实例，其返回值是boolean类型的。<br>注意:<br>1.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();<br>2.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。  </p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出<code>public class xxx extends Object</code>,在Java中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。<br>下面介绍Object类中的几个重要方法及重写规范：  </p><h4 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="1) equals方法"></a>1) equals方法</h4><p>Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。  </p><p>equals方法的原型是public boolean equals(Object obj),默认实现是:  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>{    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);}</code></pre><p>调用它的语法是<code>object1.equals(object2)</code>，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。<br>比如类Employee定义了数据域：private String name,private double salary,private LocalDate hireDay<br>equals方法重写如下：  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>{    <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//快速检测引用是否相等，相等返回ture</span>    <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">//检测引用是否为空，为空返回false  </span>    <span class="keyword">if</span>(getClass() != obj.getClass())          <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">//检测是否属于同一个类，不是返回false  </span>    Empolyee other = (Employee) obj;<span class="comment">//向下转型  </span>    <span class="keyword">return</span> name.equals(other.name)      &amp;&amp; salary == other.salary      &amp;&amp; hireDay.equals(other.hireDay);      <span class="comment">//逐一比较数据域,有一个不等返回就false，否则返回true</span></code></pre><p><strong>进一步改进：</strong><br><em>改进一</em><br>上述的第4步检测，可以改为  </p><pre><code class="java"><span class="keyword">return</span> Objects.equals(name,other.name)   &amp;&amp; salary == other.salary   &amp;&amp; Objects.equals(hireDay,other.hireDay);</code></pre><p>其中Objects.equals方法可以防备name 或 hireDay 可能为null的情况，如果两个参数都为null，Objects(a,b)返回true;如果其中一个为null，返回false;如果两个参数都不为null,调用a.equals(b)。Objects类在java.util包中。  </p><p>在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。<br>比如Manager类继承自Employee，在父类的基础上增加了private double bonus：  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>{    <span class="keyword">if</span>(!<span class="keyword">super</span>.equals(obj)) <span class="keyword">return</span> <span class="keyword">false</span>;    Manager other = (Manager) obj;    <span class="keyword">return</span> bonus == other.bonus;}</code></pre><p><em>改进二</em><br>上述代码的第3步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用instanceof进行检测，比如雇员的ID作为相等的概念，就可以用xxx instanceof Employee进行检测，并将Empolyee.equals声明为final。  </p><p><strong>equals方法要满足下面的特性</strong>  </p><ol><li>自反性: 对于任何非空引用，x.equals(x)应该返回true  </li><li>对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同  </li><li>传递性：对于任何引用x、y和z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true  </li><li>一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果  </li><li>对于任何非空引用x,x.equals(null)应该返回false</li></ol><p><strong>下面我们给出编写一个完美的equals方法的建议</strong>：<br>1) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测<br>2) 检测引用是否为空，如果为空，不必再检测，直接返回不等<br>3) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:<code>if(getClass() != obj.getClass()) return false</code>;如果所有子类都拥有统一的语义(父类决定相等)，就使用instanceof检测：<code>if(!(obj instanceof ClassName) return false)</code><br>4) 将obj向下转型为相应类的类型变量<br>5) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测<br><strong>数组对象用静态的Arrays.equals方法判等</strong></p><h4 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="2) hashCode方法"></a>2) hashCode方法</h4><p>散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。<br>String类使用下列算法计算散列码：  </p><pre><code class="java"><span class="keyword">int</span> hash = <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length();i++){    hash = <span class="number">31</span> * hash + charAt(i);}</code></pre><p>由于hashCode方法定义在Object类中，方法原型是<code>public int hashCode()</code>,因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。<br><strong>如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。</strong><br>hashCode方法应该返回一个整型数值(可以是负数),<strong>并合理地组合实例域的散列码</strong>，以便能让各个不同的对象产生的散列码更均匀。<br>例如，下面是Employee类的hashCode方法  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * name.hashCode()      + <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode()      + <span class="number">13</span> * hireDay.hashCode();</code></pre><p><strong>进一步改进</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name)      + <span class="number">11</span> * Double.hashCode(salary)      + <span class="number">13</span> * Objects.hashCode(hireDay);</code></pre><p><strong>从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()</strong><br>其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象    </p><p><strong>还有更简单的做法</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> Objects.hash(name,salary,hireDay); }</code></pre><p><strong>Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID</strong>  </p><h4 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="3) toString方法"></a>3) toString方法</h4><p>方法原型是<code>public String toString()</code>,用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：<code>类名@对象十六进制内存地址</code>的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似<code>[I@1a46e30</code>的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。<br>toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。<br>当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。  </p><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如：  </p><pre><code class="java"><span class="keyword">int</span> actualSize = . . .;Employee[] staff = <span class="keyword">new</span> Employee[actualSize];</code></pre><p>但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。<br>ArrayList是一个采用<strong>类型参数</strong>的<strong>泛型类</strong>,声明方式为<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;()</code>,从Java SE 7开始，可以省去右边的类型参数，即<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()</code><br>在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于<code>ArrayList&lt;Object&gt;</code>,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。<br>ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。  </p><h4 id="ArrayList类的常用API"><a href="#ArrayList类的常用API" class="headerlink" title="ArrayList类的常用API"></a>ArrayList类的常用API</h4><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  </li></ul><h4 id="对于数组列表有用的方法"><a href="#对于数组列表有用的方法" class="headerlink" title="对于数组列表有用的方法"></a>对于数组列表有用的方法</h4><p><strong>1.数组和ArrayList互相转换</strong>  </p><p>数组转ArrayList:  </p><pre><code class="java">String[] array = {<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>};ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array));</code></pre><p>ArrayList转数组:  </p><pre><code class="java">String[] array = <span class="keyword">new</span> String[list.size()];list.toArray(array);</code></pre><h4 id="2-Collections类"><a href="#2-Collections类" class="headerlink" title="2.Collections类"></a>2.Collections类</h4><p>Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。</p><p><strong>ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。</strong>  </p><h3 id="final关键字总结"><a href="#final关键字总结" class="headerlink" title="final关键字总结"></a>final关键字总结</h3><p>final关键字在不同语句中有不同的作用：<br>1) <strong>修饰类变量或成员变量</strong> 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。final还可以修饰方法的局部变量，即常量<br>2) <strong>修饰方法</strong> 表示该方法不能被重写<br>3) <strong>修饰类</strong> 表示该类不能被扩展</p><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><h4 id="1-将公共操作和域放在超类"><a href="#1-将公共操作和域放在超类" class="headerlink" title="1.将公共操作和域放在超类"></a>1.将公共操作和域放在超类</h4><h4 id="2-不要使用受保护的域"><a href="#2-不要使用受保护的域" class="headerlink" title="2.不要使用受保护的域"></a>2.不要使用受保护的域</h4><p>protected机制并不能够带来更好的保护，其原因主要有两点:<br>第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。<br>第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。<br>不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的  </p><h4 id="3-使用继承实现-“is-a”-关系"><a href="#3-使用继承实现-“is-a”-关系" class="headerlink" title="3.使用继承实现 “is-a” 关系"></a>3.使用继承实现 “is-a” 关系</h4><h4 id="4-除非所有继承的方法都有意义，否则不要使用继承"><a href="#4-除非所有继承的方法都有意义，否则不要使用继承" class="headerlink" title="4.除非所有继承的方法都有意义，否则不要使用继承"></a>4.除非所有继承的方法都有意义，否则不要使用继承</h4><p>比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。  </p><h4 id="5-在覆盖方法时，不要改变预期的行为"><a href="#5-在覆盖方法时，不要改变预期的行为" class="headerlink" title="5.在覆盖方法时，不要改变预期的行为"></a>5.在覆盖方法时，不要改变预期的行为</h4><h4 id="6-使用多态，而非类型信息"><a href="#6-使用多态，而非类型信息" class="headerlink" title="6.使用多态，而非类型信息"></a>6.使用多态，而非类型信息</h4><p>即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为</p><h4 id="7-不要过多地使用反射"><a href="#7-不要过多地使用反射" class="headerlink" title="7.不要过多地使用反射"></a>7.不要过多地使用反射</h4><p>反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;父类与子类&quot;&gt;&lt;a href=&quot;#父类与子类&quot; class=&quot;headerlink&quot; title=&quot;父类与子类&quot;&gt;&lt;/a&gt;父类与子类&lt;/h3&gt;&lt;p&gt;在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之对象与类</title>
    <link href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
    <id>http://habitdiary.cn/2017/10/12/Java学习总结之对象与类/</id>
    <published>2017-10-12T00:40:34.000Z</published>
    <updated>2017-10-17T14:02:49.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h3><p>　　面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。<br>　　传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。<br>　　对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。  </p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>　　类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。<br>　　对象：由类构造的实例，一个类可以构造多个实例。  　　</p><h3 id="设计类的简单规则"><a href="#设计类的简单规则" class="headerlink" title="设计类的简单规则"></a>设计类的简单规则</h3><p>　　先从设计类的数据域开始，再向类里添加方法。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>1.依赖(use-a)<br>　　如果A类的方法操纵B类的对象，我们说A类依赖于B类。应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。<br>2.聚合(has-a)<br>　　如果A类对象包含B类对象，我们说A类和B类聚合。<br>3.继承(is-a)<br>　　如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。  </p><h3 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h3><p>　　对象是调用构造方法在堆上分配内存产生的(用new + 构造方法来调用)，而对象变量是在栈上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上产生了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。</p><h3 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h3><p>1.创建的实例及成员变量（静、非静态）在堆中<br>2.局部变量在栈中<br>3.类的基本信息和方法定义在方法区</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>相关知识见<a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="external">http://www.uml.org.cn/oobject/201211231.asp</a></p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>　　构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。<br>　　构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，因为它是用来创建实例的，所以它永远是实例方法，不能被static修饰。<br>　　构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。  </p><h3 id="访问对象的数据和方法"><a href="#访问对象的数据和方法" class="headerlink" title="访问对象的数据和方法"></a>访问对象的数据和方法</h3><p>　　在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。   </p><h3 id="引用数据域和null值"><a href="#引用数据域和null值" class="headerlink" title="引用数据域和null值"></a>引用数据域和null值</h3><p>　　如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。</p><h3 id="默认赋值规则"><a href="#默认赋值规则" class="headerlink" title="默认赋值规则"></a>默认赋值规则</h3><p>　　类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。  </p><h3 id="基本变量和引用变量的区别"><a href="#基本变量和引用变量的区别" class="headerlink" title="基本变量和引用变量的区别"></a>基本变量和引用变量的区别</h3><p>　　基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。<br>　　没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。  </p><h3 id="静态-非静态变量、常量和静态-非静态方法"><a href="#静态-非静态变量、常量和静态-非静态方法" class="headerlink" title="静态/非静态变量、常量和静态/非静态方法"></a>静态/非静态变量、常量和静态/非静态方法</h3><p>静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。不要从构造器中传入参数来初始化静态域，最好使用set方法改变静态数据域。<br>非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。<br>常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。<br>静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。<br>非静态方法：又称实例方法，是依赖于具体对象的方法。<br>关系：<br>静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。<br>静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。   </p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance();  </div><div class="line">NumberFormat percentFormatter = NumberFormat.gerPercentInstance();  </div><div class="line"><span class="keyword">double</span> x = <span class="number">0.1</span>;  </div><div class="line">System.out.println(currencyFormatter.format(x));<span class="comment">// prints $0.10</span></div><div class="line">System.out.println(percentFormatter.format(x));<span class="comment">//prints 10%</span></div></pre></td></tr></table></figure></p><p>使用静态工厂方法的原因主要有两个：<br>1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字<br>2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类</p><h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>public<br>修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public</p><p>protected<br>修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问</p><p>default<br>缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。  </p><p>private<br>private成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。  </p><p><img src="http://img.blog.csdn.net/20150409153405264" alt="fail" title="四种可见性修饰符比较">  </p><p>注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句<code>package + 包名</code>，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。</p><h3 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h3><p>精确导入：导入某个包的特定类,如<code>import java.util.Scanner</code><br>通配导入：导入某个包的所有类,如<code>import java.util.*</code><br>当使用多个包中的同名类时，要用包名.类名的格式<br>编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类<br>静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如<code>import static java.lang.System.*</code>导入了System类的静态方法和静态域，就可以不加类名前缀:<code>out.println(&quot;Hello world!&quot;)</code>，out是System类里定义的静态成员，是PrintStream的实例。</p><h3 id="数据域封装"><a href="#数据域封装" class="headerlink" title="数据域封装"></a>数据域封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。<br>实现封装的步骤：<br>1.用private可见性修饰符修饰类成员<br>2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()<br>3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue)  </p><h3 id="向方法传递对象参数"><a href="#向方法传递对象参数" class="headerlink" title="向方法传递对象参数"></a>向方法传递对象参数</h3><p>可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。  </p><h3 id="对象数组和普通数组"><a href="#对象数组和普通数组" class="headerlink" title="对象数组和普通数组"></a>对象数组和普通数组</h3><p>所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。  </p><h3 id="不可变对象和类"><a href="#不可变对象和类" class="headerlink" title="不可变对象和类"></a>不可变对象和类</h3><p>一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。<br>一个类是不可变类要满足以下三个条件：<br>1.所有的数据域都是私有的<br>2.没有修改器方法<br>3.没有一个返回指向可变数据域引用的访问器方法  </p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>就是错误的，因为j的初始化基于i已经被初始化的前提。  </p><p>局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。  </p><p>建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。</p><h3 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h3><p>this关键字有两大作用：<br>1.表示指向调用对象本身的引用名<br>2.可以在构造方法内部调用同一个类的其他构造方法，此时<code>this(参数列表)</code>语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用<code>this(参数列表)</code>的形式来实现它们。这样做可以简化代码，使类易于维护。  </p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h4><p>即依赖编译器对数据域的默认初始化。  </p><h4 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h4><p>在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。  </p><h4 id="无参数的构造器"><a href="#无参数的构造器" class="headerlink" title="无参数的构造器"></a>无参数的构造器</h4><p>即将对数据域的初始化置于一个无参的构造器中。  </p><h4 id="有参数的构造器"><a href="#有参数的构造器" class="headerlink" title="有参数的构造器"></a>有参数的构造器</h4><p>即给构造器传入参数对数据域进行初始化  </p><h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>即用花括号包含的一组数据域赋值代码块，一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块。</p><h4 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h4><p>1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行。<br>2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。<br>3.父类的实例成员和实例初始化块，按在代码中出现的顺序依次执行。<br>4.执行父类的构造方法。<br>5.子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。<br>6.执行子类的构造方法。  </p><p>注意：静态成员只在构造该类的第一个对象时初始化一次，可以看作初始化类。</p><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><h4 id="1-一定要保证数据域私有"><a href="#1-一定要保证数据域私有" class="headerlink" title="1.一定要保证数据域私有"></a>1.一定要保证数据域私有</h4><h4 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2.一定要对数据初始化"></a>2.一定要对数据初始化</h4><p>最好不要依赖默认初始化，会影响程序可读性。  </p><h4 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3.不要在类中使用过多的基本类型"></a>3.不要在类中使用过多的基本类型</h4><p>用其他集合了相关基本类型的类代替多个基本类型使用</p><h4 id="4-不是所有的域都需要独立的域访问器和域修改器"><a href="#4-不是所有的域都需要独立的域访问器和域修改器" class="headerlink" title="4.不是所有的域都需要独立的域访问器和域修改器"></a>4.不是所有的域都需要独立的域访问器和域修改器</h4><p>有的数据域定义后不必要修改</p><h4 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5.将职责过多的类进行分解"></a>5.将职责过多的类进行分解</h4><h4 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6.类名和方法名要能够体现它们的职责"></a>6.类名和方法名要能够体现它们的职责</h4><h4 id="7-优先使用不可变的类"><a href="#7-优先使用不可变的类" class="headerlink" title="7.优先使用不可变的类"></a>7.优先使用不可变的类</h4><p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象程序设计概述&quot;&gt;&lt;a href=&quot;#面向对象程序设计概述&quot; class=&quot;headerlink&quot; title=&quot;面向对象程序设计概述&quot;&gt;&lt;/a&gt;面向对象程序设计概述&lt;/h3&gt;&lt;p&gt;　　面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之区间dp</title>
    <link href="http://habitdiary.cn/2017/10/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8C%BA%E9%97%B4dp/"/>
    <id>http://habitdiary.cn/2017/10/11/算法学习之区间dp/</id>
    <published>2017-10-11T08:11:11.000Z</published>
    <updated>2017-10-18T15:10:45.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。  </p><h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h3><p>设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价<br>每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段  </p><p>For l:=2 to n do // 枚举区间长度<br>for i:=1 to n do // 枚举区间的左端点<br>begin<br>j:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到<br>if j&gt;n then break; // 保证了下标不越界<br>for k:= i to j-1 do // 状态转移，去推出 f[i,j]<br>f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }<br>end;   </p><p>这个结构必须记好，这是区间动态规划的代码结构。  </p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>题目链接:<a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=737" target="_blank" rel="external">http://acm.nyist.net/JudgeOnline/problem.php?pid=737</a></p><p>题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 </p><p>分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。<br>定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。<br>那么dp[i][j] = min(dp[i][k] + dp[k+1][j])<br>那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。<br>这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2）  </p><p>代码1(无优化)<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></div><div class="line"><span class="keyword">int</span> dp[N][N],sum[N];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> a[N];sum[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//因为要求解区间和，先维护前缀和</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> i,j,l,k;</div><div class="line">        <span class="keyword">for</span>(l = <span class="number">2</span>; l &lt;= n; ++l)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; ++i)<span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                j = i + l - <span class="number">1</span>;<span class="comment">//根据左端点和区间长度求区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                dp[i][j] = <span class="number">0x3f3f3f3f</span>;</div><div class="line">                <span class="keyword">for</span>(k = i; k &lt; j; ++k)</div><div class="line">                &#123;</div><div class="line">                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码2(平行四边形优化)<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></div><div class="line"><span class="keyword">int</span> dp[N][N],sum[N],s[N][N];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> a[N];sum[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">            s[i][i]=i;</div><div class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//因为要求解区间和，先维护前缀和</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> i,j,l,k;</div><div class="line">        <span class="keyword">for</span>(l = <span class="number">2</span>; l &lt;= n; ++l)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; ++i) <span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                j = i + l - <span class="number">1</span>;<span class="comment">//根据左端点和区间长度求区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                dp[i][j] = <span class="number">0x3f3f3f3f</span>;</div><div class="line">                <span class="keyword">for</span>(k = s[i][j<span class="number">-1</span>]; k &lt;= s[i+<span class="number">1</span>][j]; ++k)<span class="comment">//四边形优化</span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(dp[i][j]&gt;dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>])</div><div class="line">                         &#123;</div><div class="line">                                dp[i][j]=dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>];</div><div class="line">                                s[i][j]=k;</div><div class="line">                         &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>题目链接：<a href="http://poj.org/problem?id=2955" target="_blank" rel="external">http://poj.org/problem?id=2955</a>  </p><p>题意:给出一串的只有‘（’ ‘）’  ‘[‘  ‘]’四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。  </p><p>分析：<br>定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目<br>1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ;<br>2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)<br>dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] )   </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">120</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s==<span class="string">"end"</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> n = s.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - len; i++)<span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;<span class="comment">//确定区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span>(s[i]==<span class="string">'('</span>&amp;&amp;s[j]==<span class="string">')'</span> || s[i]==<span class="string">'['</span>&amp;&amp;s[j]==<span class="string">']'</span>)</div><div class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</div><div class="line">                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);<span class="comment">//枚举中间位置,注意j不取等号</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果要求打印路径，即输出匹配后的括号  </p><p>题目链接: <a href="http://poj.org/problem?id=1141" target="_blank" rel="external">http://poj.org/problem?id=1141</a>  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">120</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N],pos[N][N];   <span class="comment">/*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/</span></div><div class="line"><span class="built_in">string</span> s;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i&gt;j)  <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(i==j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">')'</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"()"</span>;</div><div class="line">        <span class="keyword">else</span>      <span class="built_in">cout</span>&lt;&lt;<span class="string">"[]"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pos[i][j]==<span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;s[i];</div><div class="line">            show(i+<span class="number">1</span>,j<span class="number">-1</span>);</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;s[j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            show(i,pos[i][j]);</div><div class="line">            show(pos[i][j]+<span class="number">1</span>,j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> len=s.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,k=i; k&lt;len; j++,k++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'('</span>&amp;&amp;s[k]==<span class="string">')'</span> || s[j]==<span class="string">'['</span>&amp;&amp;s[k]==<span class="string">']'</span>)</div><div class="line">                &#123;</div><div class="line">                    dp[j][k]=dp[j+<span class="number">1</span>][k<span class="number">-1</span>]+<span class="number">2</span>;</div><div class="line">                    pos[j][k]=<span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> f=j; f&lt;k; f++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(dp[j][f]+dp[f+<span class="number">1</span>][k]&gt;=dp[j][k])</div><div class="line">                    &#123;</div><div class="line">                        dp[j][k]=dp[j][f]+dp[f+<span class="number">1</span>][k];</div><div class="line">                        pos[j][k]=f;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        show(<span class="number">0</span>,len<span class="number">-1</span>);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><p>题目链接：<a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=746" target="_blank" rel="external">http://acm.nyist.net/JudgeOnline/problem.php?pid=746</a>  </p><p>题意:  给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积  </p><p>分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数<br>设a[i][j]为区间[i,j]所形成的数<br>所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i])  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">25</span>][<span class="number">25</span>];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">25</span>][<span class="number">25</span>];</div><div class="line"><span class="keyword">char</span> str[<span class="number">25</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len, t, m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</div><div class="line">    <span class="keyword">while</span> (t--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str, &amp;m);</div><div class="line">        len = <span class="built_in">strlen</span>(str);</div><div class="line">        m--;</div><div class="line">        <span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</div><div class="line">        <span class="built_in">memset</span> (dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)          <span class="comment">//先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值</span></div><div class="line">        &#123;</div><div class="line">            a[i][i] = str[i] - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</div><div class="line">            &#123;</div><div class="line">                a[i][j] = a[i][j - <span class="number">1</span>] * <span class="number">10</span> + str[j] - <span class="string">'0'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            dp[i][<span class="number">0</span>] = a[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; len; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)</div><div class="line">                &#123;</div><div class="line">                    dp[i][j] = max(dp[i][j], dp[k][j - <span class="number">1</span>] * a[k + <span class="number">1</span>][i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[len - <span class="number">1</span>][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Halloween-Costumes"><a href="#Halloween-Costumes" class="headerlink" title="Halloween Costumes"></a>Halloween Costumes</h3><p>题目链接：<a href="http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422" target="_blank" rel="external">http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422</a>  </p><p>题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会  </p><p>分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有</p><p>①：如果在之后的区间内都不再重复利用这件衣服，那么明显  dp[i][j] = dp[i+1][j] + 1;</p><p>②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，<br>那么转移方程为  dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j])  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">int</span> a[<span class="number">105</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="keyword">int</span> cas = <span class="number">0</span>;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        cas ++;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] = j-i+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + <span class="number">1</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt;= j;k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(a[i] == a[k])</div><div class="line">                    &#123;</div><div class="line">                        dp[i][j] = min(dp[i][j],dp[i][k<span class="number">-1</span>] + dp[k+<span class="number">1</span>][j]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cas,dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Cheapest-Palindrome"><a href="#Cheapest-Palindrome" class="headerlink" title="Cheapest Palindrome"></a>Cheapest Palindrome</h3><p>题目链接:<a href="http://poj.org/problem?id=3280" target="_blank" rel="external">http://poj.org/problem?id=3280</a>  </p><p>题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。  </p><p>分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况：</p><p>1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值；</p><p>2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值</p><p>3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小</p><p>然后dp[i][j]取上面这些情况的最小值  </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>],add[<span class="number">27</span>],del[<span class="number">27</span>];</div><div class="line"><span class="keyword">char</span> s[<span class="number">2005</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">char</span> ch[<span class="number">10</span>];</div><div class="line">            <span class="keyword">int</span> tmp1,tmp2;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,ch,&amp;tmp1,&amp;tmp2);</div><div class="line">            add[ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>]=tmp1;</div><div class="line">            del[ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>]=tmp2;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j]=min(dp[i+<span class="number">1</span>][j]+add[s[i]-<span class="string">'a'</span>+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]+del[s[i]-<span class="string">'a'</span>+<span class="number">1</span>]);</div><div class="line">                <span class="keyword">int</span> tmp=min(dp[i][j<span class="number">-1</span>]+add[s[j]-<span class="string">'a'</span>+<span class="number">1</span>],dp[i][j<span class="number">-1</span>]+del[s[j]-<span class="string">'a'</span>+<span class="number">1</span>]);</div><div class="line">                dp[i][j]=min(dp[i][j],tmp);</div><div class="line">                <span class="keyword">if</span>(s[i]==s[j])</div><div class="line">                dp[i][j]=min(dp[i][j],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Treats-for-the-Cows"><a href="#Treats-for-the-Cows" class="headerlink" title="Treats for the Cows"></a>Treats for the Cows</h3><p>题目链接:<a href="http://poj.org/problem?id=3186" target="_blank" rel="external">http://poj.org/problem?id=3186</a>  </p><p>题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值  </p><p>分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来<br>转移方程：dp[i][j]=max(dp[i+1][j]+p[i]<em>(n+i-j),dp[i][j-1]+p[j]</em>(n+i-j));  其中n-(j-i)是第几次取  </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> p[<span class="number">2010</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">2010</span>][<span class="number">2010</span>];</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</div><div class="line">            dp[i][i]= n * p[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</div><div class="line">        &#123;</div><div class="line">           dp[i][j]=max(dp[i+<span class="number">1</span>][j]+p[i]*(n+i-j),dp[i][j<span class="number">-1</span>]+p[j]*(n+i-j));</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问
      
    
    </summary>
    
    
      <category term="算法" scheme="http://habitdiary.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SSH远程登录实现本地机和服务器的文件传输</title>
    <link href="http://habitdiary.cn/2017/10/07/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <id>http://habitdiary.cn/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/</id>
    <published>2017-10-07T07:55:41.000Z</published>
    <updated>2017-10-07T08:57:11.077Z</updated>
    
    <content type="html"><![CDATA[<p>SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见:  <a href="http://habitdiary.cn/2017/10/07/%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/#more">在Ubuntu下通过SSH连接远程服务器</a>  </p><h3 id="1-用SSH登录远程ubuntu主机"><a href="#1-用SSH登录远程ubuntu主机" class="headerlink" title="(1)用SSH登录远程ubuntu主机"></a>(1)用SSH登录远程ubuntu主机</h3><p>假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu<br>我们在命令行输入以下命令来连接：<br><code>ssh -l ubuntu 118.89.223.117</code><br>之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/1.png" alt="fail">  </p><h3 id="2-从远程Ubuntu主机下载文件-文件夹到本地-scp"><a href="#2-从远程Ubuntu主机下载文件-文件夹到本地-scp" class="headerlink" title="(2)从远程Ubuntu主机下载文件/文件夹到本地(scp)"></a>(2)从远程Ubuntu主机下载文件/文件夹到本地(scp)</h3><p>语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径  </p><p>我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/4.png" alt="fail"><br>要下载文件到本地,我们要结束SSH连接,切换到本地机,输入<code>eixt</code>或<code>quit</code>即可  </p><p>我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/5.png" alt="fail">  </p><p>我们进入本地目录验证一下<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/6.png" alt="fail">  </p><p>hello文件的确下载到了本地</p><h3 id="3-从本地向远程ubuntu主机上传文件-文件夹-scp"><a href="#3-从本地向远程ubuntu主机上传文件-文件夹-scp" class="headerlink" title="(3)从本地向远程ubuntu主机上传文件/文件夹(scp)"></a>(3)从本地向远程ubuntu主机上传文件/文件夹(scp)</h3><p>语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径  </p><p>假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下  </p><p>要上传本地文件,我们要结束SSH连接,切换到本地机,输入<code>eixt</code>或<code>quit</code>即可<br>然后输入命令<code>$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/</code>，输入密码后提示文件上传成功<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/2.png" alt="fail">  </p><p>我们通过SSH登录到远程主机验证一下,<code>pwd</code>打印当前所在位置，发现我们处于/home/ubuntu目录下,<code>ls</code>显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/3.png" alt="fail">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
      <category term="服务器" scheme="http://habitdiary.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu下通过SSH连接远程服务器</title>
    <link href="http://habitdiary.cn/2017/10/07/%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://habitdiary.cn/2017/10/07/在Ubuntu下通过SSH连接远程服务器/</id>
    <published>2017-10-07T07:20:37.000Z</published>
    <updated>2017-10-07T08:51:40.404Z</updated>
    
    <content type="html"><![CDATA[<p>登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一:"></a>步骤一:</h3><p>打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端<br><code>$ sudo apt-get install aptitude</code><br><code>$ sudo aptitude install openssh-server</code> </p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二:"></a>步骤二:</h3><p>启动ssh-server<br><code>$ /etc/init.d/ssh restart</code>  </p><h3 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h3><p>确认ssh-server已经正常工作<br><code>$ netstat -tlp</code><br>tcp6 0 0 *:ssh *:* LISTEN -<br>看到上面一行说明ssh-server已经在运行了  </p><h3 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h3><p>在本地机终端通过ssh登录服务器<br><code>$ ssh -l 远程服务器用户名 服务器ip地址</code><br>接下来会提示输入密码，然后就能成功登录到服务器上了</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/wh_19910525/article/details/7585257" target="_blank" rel="external">http://blog.csdn.net/wh_19910525/article/details/7585257</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
      <category term="服务器" scheme="http://habitdiary.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>强制修改ubuntu密码</title>
    <link href="http://habitdiary.cn/2017/10/06/%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81/"/>
    <id>http://habitdiary.cn/2017/10/06/强制修改ubuntu密码/</id>
    <published>2017-10-06T07:02:39.000Z</published>
    <updated>2017-10-07T08:50:10.892Z</updated>
    
    <content type="html"><![CDATA[<p> 今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。<br> <img src="/2017/10/06/强制修改ubuntu密码/fail.png" alt="fail"><br> 查了资料,总结出两种解决方法:<br> 方法一:加上sudo权限<br> <img src="/2017/10/06/强制修改ubuntu密码/method1.png" alt="fail"><br> 方法二:切换到root用户<br>  <img src="/2017/10/06/强制修改ubuntu密码/method2.png" alt="fail"><br>  mark一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。&lt;br&gt; &lt;img src=&quot;/2017/10/06/强制修改ubuntu密码/fail.png&quot; alt=&quot;fail&quot;&gt;&lt;br&gt; 查了资料,总结出两种解决方法:&lt;br&gt; 方法一:
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="http://habitdiary.cn/2017/10/05/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://habitdiary.cn/2017/10/05/Markdown学习笔记/</id>
    <published>2017-10-05T08:36:06.000Z</published>
    <updated>2017-10-15T12:02:33.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="花了近两天时间终于搭建好了我的个人博客-因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法-例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。"><a href="#花了近两天时间终于搭建好了我的个人博客-因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法-例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。" class="headerlink" title="　　花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。"></a>　　花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。</h3><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><h2 id="标题根据字体大小分级产生层次，有两种写法："><a href="#标题根据字体大小分级产生层次，有两种写法：" class="headerlink" title="标题根据字体大小分级产生层次，有两种写法："></a>标题根据字体大小分级产生层次，有两种写法：</h2><h2 id="写法一："><a href="#写法一：" class="headerlink" title="写法一："></a>写法一：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">一级标题</div><div class="line">==================</div><div class="line">二级标题</div><div class="line">---------------------</div></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h2 id="写法二："><a href="#写法二：" class="headerlink" title="写法二："></a>写法二：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题  </div><div class="line">### 三级标题  </div><div class="line">#### 四级标题</div><div class="line">##### 五级标题  </div><div class="line">###### 六级标题</div></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong><em>可见<code>#</code>的数量越多标题字号越小，要特别注意<code>#</code>和标题之间要留一个空格!</em></strong></p><h1 id="2-内联样式"><a href="#2-内联样式" class="headerlink" title="2. 内联样式"></a>2. 内联样式</h1><h2 id="内联样式能描述文字的粗细、倾斜程度等"><a href="#内联样式能描述文字的粗细、倾斜程度等" class="headerlink" title="内联样式能描述文字的粗细、倾斜程度等"></a>内联样式能描述文字的粗细、倾斜程度等</h2><h2 id="2-1-语义标记："><a href="#2-1-语义标记：" class="headerlink" title="2.1 语义标记："></a>2.1 语义标记：</h2><p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">*这是斜体*</div><div class="line">_这是斜体_</div><div class="line">**这是粗体**  </div><div class="line">***这是加粗斜体***  </div><div class="line">**_这是加粗斜体_**</div><div class="line">~~这是删除线~~</div></pre></td></tr></table></figure></p><p>效果如下:  </p><p><em>这是斜体</em><br><em>这是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del>  </p><p>可见语义标记允许叠加</p><h2 id="2-2-语义标签"><a href="#2-2-语义标签" class="headerlink" title="2.2 语义标签"></a>2.2 语义标签</h2><p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;i&gt;这是斜体&lt;/i&gt;  </div><div class="line">&lt;b&gt;这是粗体&lt;/b&gt;  </div><div class="line">&lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt;  </div><div class="line">&lt;em&gt;这是强调&lt;/em&gt;  </div><div class="line">这是上标 Z&lt;sup&gt;a&lt;/sup&gt;  </div><div class="line">这是下标 Z&lt;sub&gt;a&lt;/sub&gt;</div></pre></td></tr></table></figure></p><p>效果如下：  </p><p><i>这是斜体</i><br><b>这是粗体</b><br><i><b>这是粗斜体</b></i><br><em>这是强调</em><br>这是上标 Z<sup>a</sup><br>这是下标 Z<sub>a</sub>  </p><p>　　可见语义标签可以嵌套，特别要注意<code>&lt;em&gt;&lt;/em&gt;</code>标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用<code>&lt;i&gt;&lt;/i&gt;</code>标签替代</p><h1 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h1><h2 id="3-1-单行式"><a href="#3-1-单行式" class="headerlink" title="3.1 单行式"></a>3.1 单行式</h2><p>  代码:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; hello world</div></pre></td></tr></table></figure><p>  效果如下:  </p><blockquote><p>hello world  </p></blockquote><h2 id="3-2-多行式"><a href="#3-2-多行式" class="headerlink" title="3.2 多行式"></a>3.2 多行式</h2><p>  代码: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; hello world  </div><div class="line">&gt; hello world  </div><div class="line">&gt; hello world</div></pre></td></tr></table></figure><p> 效果如下:  </p><blockquote><p>hello world<br>hello world<br>hello world</p></blockquote><h2 id="3-3-嵌套式"><a href="#3-3-嵌套式" class="headerlink" title="3.3 嵌套式"></a>3.3 嵌套式</h2><p>  代码:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; aaaaaaaaa</div><div class="line">&gt;&gt; bbbbbbbbb</div><div class="line">&gt;&gt;&gt; cccccccccc</div></pre></td></tr></table></figure><p>  效果如下:  </p><blockquote><p>aaaaaaaaa</p><blockquote><p>bbbbbbbbb</p><blockquote><p>cccccccccc</p></blockquote></blockquote></blockquote><h1 id="4-换行与段落缩进"><a href="#4-换行与段落缩进" class="headerlink" title="4. 换行与段落缩进"></a>4. 换行与段落缩进</h1><h2 id="换行-在行末敲两个空格和一个回车"><a href="#换行-在行末敲两个空格和一个回车" class="headerlink" title="换行:  在行末敲两个空格和一个回车"></a>换行:  <strong><em>在行末敲两个空格和一个回车</em></strong></h2><h2 id="段落缩进-将输入法切换为全角后敲击两次空格即可完成两个字符的缩进"><a href="#段落缩进-将输入法切换为全角后敲击两次空格即可完成两个字符的缩进" class="headerlink" title="段落缩进:  将输入法切换为全角后敲击两次空格即可完成两个字符的缩进"></a>段落缩进:  <strong><em>将输入法切换为全角后敲击两次空格即可完成两个字符的缩进</em></strong></h2><h1 id="5-行内标记与代码块"><a href="#5-行内标记与代码块" class="headerlink" title="5. 行内标记与代码块"></a>5. 行内标记与代码块</h1><h2 id="5-1-行内标记-用前后各一个-标记代码块将变成一行"><a href="#5-1-行内标记-用前后各一个-标记代码块将变成一行" class="headerlink" title="5.1 行内标记(用前后各一个`标记代码块将变成一行)"></a>5.1 行内标记(用前后各一个`标记代码块将变成一行)</h2><p>  代码:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标记之外`hello world`标记之外</div></pre></td></tr></table></figure><p>  效果如下:<br>   标记之外<code>hello world</code>标记之外  </p><h2 id="5-2-代码块-用于插入各类型的代码"><a href="#5-2-代码块-用于插入各类型的代码" class="headerlink" title="5.2 代码块(用于插入各类型的代码)"></a>5.2 代码块(用于插入各类型的代码)</h2><p>   方法一 (使用前后各一个```包裹代码生成块,注意```之后换行不需要敲两个空格!!!):<br>   效果如下:  </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;   </div><div class="line"> &lt;div&gt;&lt;/div&gt;</div><div class="line"> &lt;div&gt;&lt;/div&gt;</div><div class="line"> &lt;div&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>  方法二 (使用Tab缩进):<br>  代码及效果如下:<br>  我是文字…  </p><pre><code>&lt;div&gt;     &lt;div&gt;&lt;/div&gt;  &lt;div&gt;&lt;/div&gt;  &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p> <em>注意要在前文后空一行再进行Tab缩进</em></p><p> 方法三 (自定义语法)：<br> <strong>即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮</strong><br> 效果如下：<br> html代码块</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>   </div><div class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>javascript代码块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</div><div class="line">num += i;</div><div class="line"> &#125;</div><div class="line"><span class="built_in">console</span>.log(num);</div></pre></td></tr></table></figure><h1 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h1><p>　　Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。  </p><h2 id="6-1-行内式"><a href="#6-1-行内式" class="headerlink" title="6.1 行内式"></a>6.1 行内式</h2><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明:"></a>语法说明:</h2><ul><li>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<code>[链接文字](链接地址 “链接标题”)</code>这样的形式。链接地址与链接标题前有一个空格。  </li></ul><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是[XJY&apos;s Blog](http://habitdiary.cn)  </div><div class="line">这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;)</div></pre></td></tr></table></figure><p>效果如下:<br>这是<a href="http://habitdiary.cn">XJY’s Blog</a><br>这是<a href="http://habitdiary.cn" title="XJY&#39;s Blog">XJY’s Blog</a>  </p><h2 id="6-2-参考式"><a href="#6-2-参考式" class="headerlink" title="6.2 参考式"></a>6.2 参考式</h2><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><h2 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明:"></a>语法说明:</h2><p>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。  </p><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。</div><div class="line">[1]:http://www.baidu.com &quot;Baidu&quot;</div><div class="line">[2]:http://note.youdao.com/ &quot;youdaonote&quot;</div><div class="line">[3]:http://www.imooc.com/ &quot;IMOOC&quot;</div><div class="line">[网站]:http://note.youdao.com/ &quot;youdaonote&quot;</div></pre></td></tr></table></figure><p>效果如下:  </p><p>我经常去的网站有<a href="http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg" title="爱琴海" target="_blank" rel="external">Baidu</a>、<a href="http://note.youdao.com/" title="youdaonote" target="_blank" rel="external">有道云笔记</a>以及<a href="http://www.imooc.com/" title="IMOOC" target="_blank" rel="external">IMOOC</a>,<a href="http://note.youdao.com/" title="youdaonote" target="_blank" rel="external">有道云笔记</a>是不错的<a href="http://note.youdao.com/" title="youdaonote" target="_blank" rel="external">网站</a>。</p><h2 id="6-3-自动链接"><a href="#6-3-自动链接" class="headerlink" title="6.3 自动链接"></a>6.3 自动链接</h2><h2 id="语法说明-2"><a href="#语法说明-2" class="headerlink" title="语法说明:"></a>语法说明:</h2><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;http://example.com/&gt;</div><div class="line">&lt;address@example.com&gt;</div></pre></td></tr></table></figure><p>效果如下:<br><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a><br><a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x61;&#x64;&#100;&#114;&#101;&#x73;&#115;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;">&#x61;&#x64;&#100;&#114;&#101;&#x73;&#115;&#64;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#109;</a></p><h1 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h1><h2 id="7-1-无序列表"><a href="#7-1-无序列表" class="headerlink" title="7.1 无序列表"></a>7.1 无序列表</h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* 吃饭</div><div class="line">* 睡觉</div><div class="line">* 打代码</div></pre></td></tr></table></figure><p>效果如下:  </p><ul><li>吃饭</li><li>睡觉</li><li>打代码  </li></ul><h2 id="7-2-有序列表"><a href="#7-2-有序列表" class="headerlink" title="7.2 有序列表"></a>7.2 有序列表</h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 把冰箱门打开</div><div class="line">2. 把大象关进去</div><div class="line">3. 把冰箱门带上</div></pre></td></tr></table></figure><p>效果如下:  </p><ol><li>把冰箱门打开</li><li>把大象关进去</li><li>把冰箱门带上</li></ol><h2 id="7-3-序表嵌套"><a href="#7-3-序表嵌套" class="headerlink" title="7.3 序表嵌套"></a>7.3 序表嵌套</h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. one</div><div class="line">    1. one-1</div><div class="line">    2. two-2</div><div class="line">2. two </div><div class="line">    * two-1</div><div class="line">    * two-2</div></pre></td></tr></table></figure><p>效果如下:  </p><ol><li>one<ol><li>one-1</li><li>two-2</li></ol></li><li>two <ul><li>two-1</li><li>two-2  </li></ul></li></ol><h2 id="7-4-任务列表"><a href="#7-4-任务列表" class="headerlink" title="7.4 任务列表"></a>7.4 任务列表</h2><p>代码(方括号里是x表示打勾,空格表示为空):  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- [x] 选项一</div><div class="line">- [ ] 选项二  </div><div class="line">- [ ]  选项三</div></pre></td></tr></table></figure><p>效果如下:  </p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul><h1 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8. 插入图片"></a>8. 插入图片</h1><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><h2 id="8-1-内联式"><a href="#8-1-内联式" class="headerlink" title="8.1 内联式"></a>8.1 内联式</h2><h2 id="语法说明-图片Alt-图片地址-“图片Title”"><a href="#语法说明-图片Alt-图片地址-“图片Title”" class="headerlink" title="语法说明:![图片Alt](图片地址 “图片Title”)"></a>语法说明:<code>![图片Alt](图片地址 “图片Title”)</code></h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">爱琴海</div><div class="line">![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;)</div></pre></td></tr></table></figure><p>效果如下:<br>爱琴海<br><img src="http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg" alt="爱琴海" title="爱琴海">  </p><h2 id="8-2-参照式"><a href="#8-2-参照式" class="headerlink" title="8.2 参照式"></a>8.2 参照式</h2><h2 id="语法说明-3"><a href="#语法说明-3" class="headerlink" title="语法说明:"></a>语法说明:</h2><p>在文档要插入图片的地方写<code>![图片Alt][标记]</code>，在文档的最后写上[标记]:图片地址 “Title”<br>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">爱琴海</div><div class="line">![爱琴海][1]</div><div class="line">[1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;</div></pre></td></tr></table></figure><p>效果如下:<br>爱琴海<br><img src="http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg" alt="爱琴海" title="爱琴海"></p><h4 id="说明-如果要在Hexo中插入本地图片-具体方法见博客：http-blog-csdn-net-sugar-rainbow-article-details-57415705"><a href="#说明-如果要在Hexo中插入本地图片-具体方法见博客：http-blog-csdn-net-sugar-rainbow-article-details-57415705" class="headerlink" title="说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/57415705"></a>说明: 如果要在Hexo中插入本地图片,具体方法见博客：<a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="external">http://blog.csdn.net/sugar_rainbow/article/details/57415705</a></h4><h1 id="9-插入视频"><a href="#9-插入视频" class="headerlink" title="9. 插入视频"></a>9. 插入视频</h1><p>如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p><p>效果如下:  </p><iframe width="560" height="315" src="http://www.miaopai.com/show/9Sve8-3osRBmmpEvONt~uKP-WbvOSRLH.htm" frameborder="0" allowfullscreen></iframe><h2 id="mark一下第一次写博客遇到的神坑"><a href="#mark一下第一次写博客遇到的神坑" class="headerlink" title="mark一下第一次写博客遇到的神坑:"></a>mark一下第一次写博客遇到的神坑:</h2><ul><li>在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 </li></ul><h4 id="最后要感谢提供参考的大牛博客"><a href="#最后要感谢提供参考的大牛博客" class="headerlink" title="最后要感谢提供参考的大牛博客:"></a>最后要感谢提供参考的大牛博客:</h4><ul><li><a href="http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13" target="_blank" rel="external">http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13</a>  </li><li><a href="http://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="external">http://www.jianshu.com/p/b03a8d7b1719</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;花了近两天时间终于搭建好了我的个人博客-因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://habitdiary.cn/tags/Markdown/"/>
    
  </entry>
  
</feed>
