<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XJY&#39;s Blog</title>
  
  <subtitle>你要静候再静候 就算失收始终要守</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://habitdiary.cn/"/>
  <updated>2017-11-08T18:05:02.753Z</updated>
  <id>http://habitdiary.cn/</id>
  
  <author>
    <name>谢均宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java学习总结之异常处理</title>
    <link href="http://habitdiary.cn/2017/11/08/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://habitdiary.cn/2017/11/08/Java学习总结之异常处理/</id>
    <published>2017-11-08T13:42:16.000Z</published>
    <updated>2017-11-08T18:05:02.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在程序运行过程中<strong>(注意是运行阶段，程序可以通过编译)</strong>，如果JVM检测出一个不可能执行的操作，就会出现<strong>运行时错误</strong>。例如，使用一个越界的下标访问数组，程序就会产生一个ArrayIndexOutOfBoundsException的运行时错误。如果程序需要输入一个整数的时候用户输入了一个double值，会得到一个InputMismatchException的运行时错误。<br>在Java中，运行时错误会作为<strong>异常</strong>抛出。<strong>异常</strong>就是一种对象，表示阻止正常进行程序执行的错误或者情况。如果异常没有被处理，那么程序就会非正常终止。<br>人们在遇到错误时会感觉不爽。如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序了，为了避免这类事<br>情的发生，至少应该做到以下几点：  </p><ul><li>向用户通告错误</li><li>保存所有的工作结果</li><li>允许用户以妥善的形式退出程序  </li></ul><p>Java使用一种称为<strong>异常处理</strong>的错误捕获机制处理，从而使程序继续运行或优雅终止。  </p><h3 id="异常处理概述"><a href="#异常处理概述" class="headerlink" title="异常处理概述"></a>异常处理概述</h3><p>异常处理使得程序可以处理非预期的情景，并且继续正常的处理。<br>我们来看一个读取两个整数并显示它们商的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quotient</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">        <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">        <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">        + <span class="string">" is "</span> + (number1 / number2));</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果number2为0,就会产生一个运行时错误，因为不能用一个整数除以0(注意，一个浮点数除以0不会产生异常)。<br>我们可以添加一个if语句来测试第二个数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quotient</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">        <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">        <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">        <span class="keyword">if</span>(number2 != <span class="number">0</span>)</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">        + <span class="string">" is "</span> + (number1 / number2));</div><div class="line">        <span class="keyword">else</span></div><div class="line">        System.out.println(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了介绍异常处理，我们使用一个<strong>方法</strong>来实现两个整数求商的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuotientWithMethod</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(number2 == <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> number1 / number2;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">    <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> result = quotient(number1,number2);</div><div class="line">    System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">    + <span class="string">" is "</span> + result);</div></pre></td></tr></table></figure></p><p>但上述代码有一个问题：当number2为0时，程序在quotient方法内终止。但不应该让一个方法来终止程序 —— <strong>应该由方法的调用者决定是否终止程序，即方法只需要通知其调用者有运行时错误产生，而不应该自己做决定。</strong><br>下面使用异常处理的方法，让quotient方法抛出一个异常，使其被调用这捕获和处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuotientWithException</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (number2 == <span class="number">0</span>) </div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">        <span class="keyword">return</span> number1 / number2;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">    <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span> result = quotient(number1,number2);</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 + <span class="string">" is "</span></div><div class="line">        + result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(ArithmeticException ex) &#123;</div><div class="line">System.out.println(<span class="string">"Exception: an integer "</span> + </div><div class="line">        <span class="string">"cannot be divided by zero"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"Execution continues ..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以看到，上面的代码能使方法抛出一个异常给调用者，并由调用者处理该异常。如果不这么做，被调用的方法本身必须处理异常或者终止程序。但是库方法在设计时通常无法确定在出错时要进行什么操作，最好的做法就是将检测出的错误作为异常抛出给调用者处理，查阅API我们也会发现库方法会对其可能抛出的异常进行说明。异常处理的最根本优势就是<strong>将检测错误(由被调用的方法完成)从处理错误(由调用方法完成)中分离出来。</strong><br>当然，如果运行时错误发生在main方法中，就不必抛出异常了，可以考虑提供一个异常处理器对异常进行捕获和处理。  </p><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>异常是对象，而对象都采用类来定义。在 Java 程序设计语言中， 异常对象都是派生于 Throwable 类的一个实例。稍后还可以看到，如果 Java 中内置的异常类不能够满足需求，用户可以创建自己的异常类。  </p><p>下面是Java中的异常层次结构：  </p><p><img src="/2017/11/08/Java学习总结之异常处理/Java异常层次结构.jpg" alt="fail" title="Java异常层次结构"><br>可以看到，Throwable是所有异常类的根类，所有异常类都直接或间接继承自 Throwable。但在下一层立即分解为两个分支：Error 和 Exception。<br><strong>Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。</strong>应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。这种情况很少出现。<br>在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：<br>一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像 I/O 错误这类<br>问题导致的异常属于其他异常。<br>有一条相当有道理的规则：<strong>如果出现 RuntimeException，那么就一定是你的问题</strong>。<br>也就是说，RuntimeException是可以在编程时避免的。比如，可以通过检测数组下标是否越界来避免IndexOutOfBoundsException，可以通过在使用变量前检测是否为null杜绝NullPointerException。  </p><p><strong>免检异常：</strong>又称非受查异常，RuntimeException、Error以及它们的子类都称为免检异常。意思是编译器不会强制检查程序是否处理或声明了异常。<br><strong>必检异常：</strong>又称受查异常，除了免检异常的其他异常都是必检异常，意思是编译器会强制程序员检查并通过try-catch语句处理它们，或者在方法头进行声明，否则无法通过编译。  </p><h3 id="关于异常处理的更多知识"><a href="#关于异常处理的更多知识" class="headerlink" title="关于异常处理的更多知识"></a>关于异常处理的更多知识</h3><p><strong>异常处理器是通过从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到的。</strong>即如果某方法的异常没有在该方法内被捕获和处理，就会被抛出给它的调用者，并在调用者中搜寻相应的异常处理器，如果还没有找到就继续上抛，如果在整个方法调用链中异常都没有被捕获处理，该异常会被抛给JVM，JVM会终止程序并打印错误信息。<br>Java的异常处理模型基于三种操作：  </p><ul><li>声明异常  </li><li>抛出异常  </li><li>捕获异常  </li></ul><h3 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h3><p>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如，一段读取文件的代码知道有可能读取的文件不存在， 或者内容为空，因此， 试图处理文件信息的代码就需要通知编译器可能会抛出 IOException 类的异常。<br>方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出异常。<br>每个方法只需声明所有它可能抛出的<strong>必检异常类型</strong>，这称为<strong>声明异常</strong>。无需声明免检异常，因为免检异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)。<br>可以声明多个异常，用逗号隔开即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception1, Exception2,...</span></div></pre></td></tr></table></figure></p><p>当然，从前面的示例中可以知道：除了声明异常之外， 还可以捕获异常。这样会使异常不被抛到方法之外，也不需要 throws 规范。稍后，将会讨论如何决定一个异常是被捕获，还是被抛出让其他的处理器进行处理。<br>下面有一些规则：  </p><ul><li>如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用(也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常)  </li><li>如果在超类方法中没有声明/抛出异常，子类也不能声明/抛出异常  </li></ul><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>检测到错误的程序可以创建一个合适的异常类型的实例并抛出它，这就称为<strong>抛出异常</strong>。下面有一个例子，方法的参数必须是非负的，如果传入一个负参数，程序就创建一个IllegalArgumentException实例并抛出它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IllegalArgumentException ex = </div><div class="line"><span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong Argument"</span>);</div><div class="line"><span class="keyword">throw</span> ex;</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong Argument"</span>);</div></pre></td></tr></table></figure></p><p>第一种写法创建了一个异常对象并赋给一个异常类引用变量，并抛出它;第二种写法则直接抛出一个匿名异常对象。<br>Java库中每个异常类一般至少有两个构造方法：一个无参构造方法和一个带可描述这个异常的String参数的构造方法。如上述就使用了带参数的构造方法并传入了”Wrong Argument”的异常描述。可以通过在异常对象上调用getMessage()获取异常描述字符串。<br>抛出异常的三个步骤：  </p><ol><li>找到一个合适的异常类  </li><li>创建这个类的一个对象 </li><li>将对象抛出  </li></ol><p><strong>注意：</strong>这里所说抛出异常是指我们在编写程序时用throw关键字显式抛出异常，但是在很多情况下，异常是由库方法抛出的，throw关键字被封装在库方法中，对用户是不可见的，此时用户程序中是没有显式的throw关键字的。</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>当抛出一个异常时，可以提供try-catch语句来捕获和处理它，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   statements; <span class="comment">// Statements that may throw exceptions</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception exVar1) &#123;</div><div class="line">    handler <span class="keyword">for</span> exception1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception exVar2) &#123;</div><div class="line">    handler <span class="keyword">for</span> exception2;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="keyword">catch</span>(Exception exVarN) &#123;</div><div class="line">    handler <span class="keyword">for</span> exceptionN;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>可以为一个try块提供多个catch语句，因为一个try块可能抛出多种不同类型的异常。<br>如果在执行try块的过程中没有出现异常，则跳过catch子句。<br>如果try块中的某条语句抛出一个异常，Java就会跳过try块中剩余的语句，然后开始查找合适的处理异常的代码，即<strong>异常处理器</strong>。可以从当前的方法开始，沿着方法调用链，按照异常的<strong>反向传播</strong>方向找到这个处理器。从第一个到最后一个逐个检查catch块，判断在catch块中的异常类变量是否是该异常对象的类型。如果是，就将该异常对象赋值给所声明的变量，然后执行catch块中的代码。如果没有发现异常处理器，Java会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来查找处理器。如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息。<strong>寻找处理器的过程称为捕获异常。</strong><br><strong>注意：</strong>如果一个catch块可以捕获一个父类的异常对象，它就能捕获那个父类的所有子类的异常对象。在catch块中异常被指定的顺序是非常重要的，如果父类异常的catch块在子类异常的catch块之前，就会导致编译错误。道理很简单，如果将父类异常的catch块放在子类异常的catch块之前，则子类异常对象一定会被父类异常的catch块捕获，子类异常的catch块就失去了意义。<br>对于使用同样的处理代码处理多个异常的情况，可以使用<strong>多捕获</strong>特征简化异常的代码编写，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">catch</span>(Exception1 | Exception2 | ... | ExceptionN ex) &#123;</div><div class="line"><span class="comment">// Same code for handling these exceptions</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="创建自定义异常类"><a href="#创建自定义异常类" class="headerlink" title="创建自定义异常类"></a>创建自定义异常类</h3><p>在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。在这种情况下，我们可以通过派生Exception类或其子类来创建自定义的异常类。<br>下面给出一个例子，当半径为负时，setRadius方法会抛出一个异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidRadiusException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidRadiusException</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(<span class="string">"Invalid radius "</span> + radius);</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> radius;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>可见异常类里可定义数据域和访问器，使外界能访问到导致异常的非法参数。<br><strong>注意：</strong>建议不要让自定义的异常类继承RuntimeException及其子类，这样会使自定义的异常类称为免检异常，最好使自定义的异常类必检，这样编译器就可以在程序中强制捕获或声明这些异常。</p><h3 id="从异常中获取信息"><a href="#从异常中获取信息" class="headerlink" title="从异常中获取信息"></a>从异常中获取信息</h3><p>异常对象中包含了关于异常的有价值的信息，可以利用Throwable类中的实例方法获取有关的信息，如下所示：<br><img src="/2017/11/08/Java学习总结之异常处理/Throwable1.png" alt="fail"><br><img src="/2017/11/08/Java学习总结之异常处理/Throwable2.png" alt="fail"></p><ul><li>Throwable() 无参构造器  </li><li>Throwable(String message) 带描述异常信息字符串的构造器 </li><li>String getMessage() 返回一个描述该异常对象信息的字符串 </li><li>String toString() 返回三个字符串的连接：1) 异常类的全名; 2) “: “ 一个冒号和一个空格 3) getMessage(方法)  </li><li>void printStackTrace() 在控制台上打印 Throwable对象和它的调用堆栈信息<br>同样Exception和RuntimeException也有类似的方法<br><img src="/2017/11/08/Java学习总结之异常处理/Exception.png" alt="fail"><br><img src="/2017/11/08/Java学习总结之异常处理/RuntimeException.png" alt="fail"><br>堆栈轨迹(stack trace)是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。类似于数据结构中的栈，一个方法被调用就会入栈，即最先被调用的方法(main方法)在栈底，后被调用的方法在栈顶。当一个方法调用结束，就会出栈，也是栈顶方法先出栈，最后main方法也调用完毕，整个方法栈被销毁，程序结束。<br>Throwable的printStackTrace方法就是这样从上到下打印了方法栈，栈顶是产生异常的方法，栈底是main方法。比如下面的代码访问了数组的-1下标，抛出一个ArrayIndexOutOfBoundsException：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">    printArrayElement(array,-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArrayElement</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">System.out.println(a[index]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>打印的堆栈轨迹是：<br><img src="/2017/11/08/Java学习总结之异常处理/stack trace.png" alt="fail"><br>一种更灵活的方法是getStackTrace()，它会得到一个StackTraceElement对象的一个数组，每个元素都是方法堆栈中的一个方法，其API如下：<br><img src="/2017/11/08/Java学习总结之异常处理/getStackTrace.png" alt="fail">  </p><h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>当异常被捕获之后，可以在catch子句中重新抛出异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用的子系统，那么，用于表示子系统的异常类型可能会产生多种解释。ServletException就是这样一个异常类型的例子。执行servlet的代码可能不想知道发生错误的细节原因，但希望明确地知道servlet是否有问题。<br>同原始异常一起抛出一个新异常(带有附加信息)，这称为<strong>异常链</strong>。<br>下面给出了抛出异常链的基本方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">access the database</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SQLException e)</div><div class="line">&#123;</div><div class="line">Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error: "</span> </div><div class="line">    + e.getMessage());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不过，我们发现原始异常被改变了。有一种更好的处理方法，可以将原始异常设置为新异常的”原因”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">access the database</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SQLException e)</div><div class="line">&#123;</div><div class="line">Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</div><div class="line">se.initCause(e);</div><div class="line"><span class="keyword">throw</span> se;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当捕获到异常时，就可以使用下面的这条语句重新得到原始异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Throwable e = se.getCause();</div></pre></td></tr></table></figure></p><p>强烈建议使用这种包装技术，这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。  </p><h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有的异常。但是，这种解决方案比较乏味，这是因为需要在两个地方清除所分配的资源。一个在正常的代码中；另一个在异常代码中。<br>Java 有一种更好的解决方案，这就是 finally 子句。无论异常是否产生，finally子句总是会被执行,即使在到达finally子句之前有一个return语句，finally块还是会执行。在try块(或try-catch块)和finally块之间不能有其他任何代码。finally子句常用于在抛出异常时关闭资源，比如关闭文件和关闭与数据库的连接。<br>比如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(. . .);</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//1</span></div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line"><span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// 3</span></div><div class="line">show error message</div><div class="line"><span class="comment">// 4</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line"><span class="comment">// 5</span></div><div class="line">in.close();</div><div class="line">&#125;</div><div class="line"><span class="comment">//6</span></div></pre></td></tr></table></figure></p><p>在上面的代码中，有下列3种情况会执行finally子句：<br>1) 代码没有抛出异常。在这种情况下，程序首先执行 try 语句块中的全部代码，然后执行 finally 子句中的代码。随后，继续执行 try 语句块之后的下一条语句。也就是说，执行标<br>注的1、2、5、6处  </p><pre><code>2) 抛出一个在 catch 子句中捕获的异常。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try语句块中的所有代码，直到发生异常为止。此时，将跳过 try语句块中的剩余代码，转去执行与该异常匹配的 catch 子句中的代码， 最后执行 finally 子句中的代码。  </code></pre><p> 如果 catch 子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6 处的语句。<br> 如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。在这里， 执行标注<br>1、 3、 5 处的语句。  </p><pre><code>3) 代码抛出了一个异常，但这个异常不是由 catch 子句捕    获的。在这种情况下，程序将执行 try 语句块中的所有语句，直到有异常被抛出为止。此时，将跳过 try 语句块中的剩余代</code></pre><p>码，然后执行 finally 子句中的语句，并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。  </p><pre><code>try 语句可以只有 finally 子句，而没有 catch 子句。例如，下面这条 try 语句：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   InputStream in = . .</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>无论在 try 语句块中是否遇到异常，finally 子句中的 in.close()语句都会被执行。当然,<br>如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 catch 子句捕获。<br>强烈建议解耦合 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">InputStream in = . . .;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line">show error message</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>内层的 try 语句块只有一个职责，就是确保关闭输入流。外层的 try 语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚， 而且还具有一个功能，就是<strong>将会报告 finally 子句中出现的错误。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在程序运行过程中&lt;strong&gt;(注意是运行阶段，程序可以通过编译)&lt;/strong&gt;，如果JVM检测出一个不可能执行的操作，就会出现&lt;st
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java学习总结之集合</title>
    <link href="http://habitdiary.cn/2017/10/23/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>http://habitdiary.cn/2017/10/23/Java学习总结之集合/</id>
    <published>2017-10-23T13:40:35.000Z</published>
    <updated>2017-11-05T15:33:51.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><p>Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Java只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、Bitset和Enumeration接口，其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，但要想建立一个全面的集合类库还需要大量的时间和高超的技能。<br>后来，经过艰难的抉择，设计人员设计出了一组功能完善的数据结构，下面我们来进入集合框架的学习。  </p><h4 id="集合接口与具体实现分离"><a href="#集合接口与具体实现分离" class="headerlink" title="集合接口与具体实现分离"></a>集合接口与具体实现分离</h4><p>Java集合类库将接口与实现分离。比如队列接口，其指出可以在队列的尾部添加元素，在队头删除元素，并可以查找队列中元素的个数等。队列接口的最简形式可能类似下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这个接口并没有说明队列的具体实现，实际上，队列的实现主要有两种方式：<strong>一是使用循环数组，二是使用链表。</strong>如果需要一个循环数组队列，可以使用<strong>ArrayDeque类</strong>;如果需要一个链表队列，就直接使用<strong>LinkedList类</strong>。这两个类都实现了Queue接口。<br>当我们使用队列时，一旦创建了集合就不用关心究竟使用了哪种实现，因此，只有在构建集合时，使用具体的类才有意义。<br>用两种具体类实现Queue接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div></pre></td></tr></table></figure></p><p><strong>注意：一般情况下循环数组比链表更高效，但它是一个有界集合，即容量有限，超过一定范围会进行扩容，降低效率。所以如果处理的数据量较小，优先使用循环数组，但如果程序要收集的对象数量没有上限，最好使用链表实现。</strong><br>在研究API时会发现一组名字以Abstract开头的类，例如，AbstractQueue。这些类是为类库设计者设计的，如果想要实现自己的队列类，会发现扩展AbstractQueue类比实现Queue接口中的所有方法轻松得多。  </p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>在Java类库中，集合类的基本接口是Collection接口，其常用API如下：    </p><ul><li>boolean add(E e)<br>将一个元素添加到集合中。如果由于这个调用改变了集合，返回true。   </li><li>boolean addAll(Collection&lt;? extends E&gt; other)<br>将other集合中的所有元素都添加到这个集合。如果由于这个调用改变了集合，返回true。  </li><li>void clear()  移除这个集合中的所有元素。  </li><li>boolean contains(Object obj)<br>如果这个集合包含了一个与obj相等的对象，返回true。  </li><li>boolean    containsAll(Collection&lt;?&gt; other)<br>如果这个集合包含other集合中的所有元素，返回 true。    </li><li>boolean isEmpty() 如果这个集合没有元素，返回 true。</li><li>Iterator<code>&lt;E&gt;</code>    iterator()<br>返回一个用于访问集合中每个元素的迭代器。  </li><li>boolean remove(Object obj)<br>从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true。  </li><li>boolean removeAll(Collection&lt;?&gt; other)<br>从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true。  </li><li>boolean retainAll(Collection&lt;?&gt; other)<br>仅保留这个集合中那些也包含在other集合里的元素  </li><li>int size()  返回这个集合的元素数。</li><li>Object[]    toArray() 返回这个集合的对象数组。</li><li><code>&lt;T&gt;</code> T[] toArray(T[] arrayToFill)<br>返回这个集合的对象数组。如果arrayToFill足够大，就将集合的元素填入这个数组中，剩余空间补null;否则，分配一个新数组，其成员类型和arrayToFill一样，其长度等于集合的大小，并填充集合元素。  </li><li><p>default boolean removeIf(Predicate&lt;? super E&gt; filter)<br>从这个集合中删除filter返回true的所有元素。如果这个调用改变了集合，返回true </p><p><strong>注意：在使用Object[] toArray()时不能把返回的Object[]数组成强制类型转换其他类型的数组，因为所有数组类型的父类都是Object，甚至Object[]的父类也是Object，所以这种向下类型转换是错误的,会抛出一个ClassCastException</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer[] array = (Integer[])a.toArray();<span class="comment">// Error</span></div><div class="line">Object[] array =  a.toArray();<span class="comment">// Right</span></div></pre></td></tr></table></figure><p>或者使用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer[] array = a.toArray(<span class="keyword">new</span> Integer[<span class="number">10</span>]);</div></pre></td></tr></table></figure><p>removeIf函数的参数是一个函数式接口Predicate，表示布尔值函数，可以传递一个lambda表达式描述要删除的元素的特征。例如下面的代码可以删除列表中的所有偶数：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.removeIf(e -&gt; e %<span class="number">2</span> == <span class="number">0</span>);</div></pre></td></tr></table></figure><p>同队列，Java也给类库设计者提供了一个AbstractCollection类，其提供了一些例行方法，可以让实现者更容易实现自己的集合类。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>Collection接口的<code>Iterator&lt;E&gt;    iterator()</code>方法可以返回一个迭代器，它是一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。<br>Iterator接口包含4个方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</div></pre></td></tr></table></figure><p>C++的STL中的迭代器是根据数组索引建模的，即迭代器指向指定位置的元素。但Java中的迭代器应该理解为位于两个元素之间，其起始位置在所有元素之前。调用next方法，迭代器会<strong>越过一个元素并且返回被越过的元素</strong>。通过next方法可以逐个访问集合中的每个元素，但是如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此,需要在每次调用next方法之前调用hasNext方法。如果迭代器还有剩余供访问的元素，这个方法就返回true。如果要想查看一个集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复调用next方法，例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Collection&lt;String&gt; c = . . .;</div><div class="line">Iterator&lt;String&gt; iter = c.iterator();</div><div class="line"><span class="keyword">while</span>(iter.hasNext())</div><div class="line">&#123;</div><div class="line">String element = iter.next();</div><div class="line">   <span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>“for-each”循环可以更简练地表示同样的操作：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String element: c)</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>编译器简单地将”for-each”循环翻译为<strong>带有迭代器的循环</strong>，”for-each”循环可以和任何实现了Iterable接口的对象一起工作，这个接口只包含一个抽象方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">Interator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Iterable接口表示实现它的类是可以迭代的(即可以返回一个迭代器对象)，Collection接口扩展了Iterable接口，所以<strong>对于标准类库中的任何集合都可以使用”for-each”循环</strong><br>Java SE 8提供了一种更简便的方式，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式(它会处理一个元素)。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止,例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iter.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</div></pre></td></tr></table></figure><p><strong>元素被访问的顺序取决于集合类型。</strong>如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次索引加1.如果访问HashSet中的元素，每个元素将会以某种随机的次序出现。但这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说没有影响。<br>Iterator接口的remove方法将会删除<strong>上一次调用next方法</strong>时返回的元素，也就是说，如果要删除某个元素，必须先用next方法越过它：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = c.iterator();</div><div class="line">it.next();<span class="comment">// skip over the first element</span></div><div class="line">it.remove(); <span class="comment">// now remove it</span></div></pre></td></tr></table></figure></li></ul><p>如果在调用remove方法之前没有调用next方法会抛出一个IllegalStateException。<br>如果想删除两个相邻的元素，不能直接连续调用两次remove：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.remove();<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>必须先越过要删除的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.next();</div><div class="line">it.remove();<span class="comment">//OK</span></div></pre></td></tr></table></figure></p><p>所以删除元素必须在刚越过该元素时就进行，否则”过了这个村就没这个店了”  </p><h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><p>Java集合框架为不同类型的集合定义了大量接口，如下图所示：  <img src="/2017/10/23/Java学习总结之集合/集合框架的接口.png" alt="fail" title="集合框架的接口"><br>集合有两个基本接口：<strong>Collection</strong>和<strong>Map</strong>。Collection用于保存一个元素序列，Map用于表示键值对之间的映射关系。在Collection中插入元素使用<code>boolean add(E element)</code>,获取元素使用迭代器访问;在Map中插入元素使用<code>V put(K key,V value)</code>,通过key获取value使用<code>V get(K key)</code><br>List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，使用一个整数索引访问。前者称为顺序访问，后者称为随机访问。<br>List的重要API如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">* <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素  </span></div><div class="line"><span class="function">* ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素，</span></div><div class="line"><span class="function">   初始位置在索引为index元素的前面，索引从0开始  </span></div><div class="line"><span class="function">* <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span> 在给定位置添加一个元素  </span></div><div class="line"><span class="function">* E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> 删除给定位置的元素并返回这个元素  </span></div><div class="line"><span class="function">* E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> 获取给定位置的元素  </span></div><div class="line"><span class="function">* E <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, E element)</span> </span></div><div class="line"><span class="function">   用新元素取代给定位置的元素，并返回原来那个元素  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素  </span></div><div class="line"><span class="function"> 在列表中第一次出现的位置，如果没有这样的元素返回-1  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素</span></div><div class="line"><span class="function"> 在列表中最后一次出现的位置，如果没有这样的元素返回-1</span></div></pre></td></tr></table></figure></p><p>我们发现List接口提供了多个用于随机访问的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span></div></pre></td></tr></table></figure></p><p>当我们给List接口选择具体实现类时，需要考虑顺序访问和随机访问哪种情况更多，如果随机访问占操作的大多数，应该使用数组或动态列表ArrayList实现List接口，否则应该使用链表LinkedList实现List接口。<br>为了避免对链表进行随机访问，Java定义了一个标记接口RandomAccess，这个接口不包含任何方法，但可以用来测试一个特定的集合是否支持高效的随机访问：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(c <span class="keyword">instanceof</span> RandomAccess)</div><div class="line">&#123;</div><div class="line">use random access algorithm</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">use sequential access algorithm</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不建议在LinkedList实现的List列表中使用get、set等随机访问方法，此时应该通过一个ListIterator顺序访问列表。<br>ListIterator接口是Iterator的一个子接口，它是一种更灵活的迭代器，只用于List。下面是ListIterator的重要API：  </p><ul><li>void add(E newElement) 在当前位置前添加一个元素  </li><li>void set(E newElement) 用新元素取代next或previous上次访问的元素。</li><li>boolean hasPrevious() 当反向迭代列表时，还有可供访问的元素，返回true  </li><li>E previous() 返回前一个对象，如果已经到达了列表的头部，就抛出一个NoSuchElementException  </li><li>int nextIndex() 返回下次调用next方法时将返回元素的索引  </li><li>int previous() 返回下次调用previous方法时将返回元素的索引  </li></ul><p><strong>并发修改：</strong>如果在一个迭代器修改集合时，另一个迭代器对它进行遍历，一定会出现混乱。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = . . .;</div><div class="line">ListIterator&lt;String&gt; iter1 = list.ListIterator();</div><div class="line">ListIterator&lt;String&gt; iter2 = list.ListIterator();</div><div class="line">iter1.next();</div><div class="line">iter1.remove();</div><div class="line">iter2.next();<span class="comment">//throws ConcurrentModificationException</span></div></pre></td></tr></table></figure></p><p>上述代码中iter2迭代器在遍历链表时，iter1修改了链表结构，iter2会检测到这种变化，抛出一个ConcurrentModificationException。<br>为了避免出现并发修改异常，请遵循下述简单规则：<strong>可以根据需要给容器附加许多迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读也写的迭代器</strong>。<br>通过调用AbstractCollection类的toString方法可以打印出集合中的所有元素。<br><strong>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集(Set)的add方法不允许增加重复的元素。要适当定义equals方法：只要两个集包含同样的元素就认为是相等的，而不要求有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。<br>SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集试图的方法。<br>最后，Java SE 6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集和映射的方法，TreeSet和TreeMap实现了这些接口。</strong>  </p><h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p>下面是Java库中的具体集合和集合框架中的类<br><img src="/2017/10/23/Java学习总结之集合/Java库中的具体集合.png" alt="fail" title="Java库中的具体集合"><br><img src="/2017/10/23/Java学习总结之集合/集合框架中的类.png" alt="fail" title="集合框架中的类"></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList是链表类，相较于数组以及动态的ArrayList类，能够更高效地从集合的中间位置插入、删除元素，Java中的LinkedList类是<strong>双向链接</strong>的。<br>除了实现了Collection接口和List接口之外，LinkedList还提供了以下API：  </p><ul><li>LinkedList() 构造一个空链表  </li><li>LinkedList(Collection&lt;? extends E&gt; elements)<br>构造一个链表，并将集合中的所有元素添加到这个链表中  </li><li>void addFirst(E element) 将某个元素添加到列表的头部  </li><li>void addLast(E element) 将某个元素添加到列表的尾部  </li><li>E getFirst 返回列表头部的元素  </li><li>E getLast 返回列表尾部的元素  </li><li>E removeFirst() 删除并返回列表头部的元素 </li><li>E removeLast() 删除并返回列表尾部的元素    </li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList是动态数组列表，适用于常常要随机访问元素的情况。下面给出ArrayList的常用API：  </p><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  </li></ul><p><strong>ArrayList和Vector的区别：</strong>Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vector对象，然而如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。所以建议在不需要同步的时候使用ArrayList，而不要使用Vector</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>链表和数组可以按照人们的意愿排列元素的次序，但如果要查看某个元素，却忘记了它的位置，需要访问所有元素直到找到为止，将会消耗很多时间。<br>HashSet是一种基于<strong>散列表</strong>的集，实现了Set接口，它无法控制元素的次序，但可以快速查找元素。散列表基于散列码，散列码由类的hashCode方法提供，用于将元素插入散列表的特定位置，hashCode和equals方法应该兼容，即使用equals方法返回true的两个对象应该有相同的散列码，一个自定义类如果重写了equals方法就必须要重写hashCode方法，以便于将该类的对象插入散列表中。<br>在Java中，散列表用链表数组实现，每个<strong>散列单元</strong>被称为<strong>桶</strong>。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，如果桶中没有元素，可以直接插入，如果已经有元素，即发生<strong>散列冲突</strong>，则需要将新元素和桶中已有的所有元素进行比较，如果桶中有元素和新元素相等，就不插入，反之插入。<strong>注意：在HashSet的一个桶中可以有多个不同元素，即使用链地址法解决冲突。</strong>如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。<br>在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。<br>如果想更多地控制散列表的运行性能，就要指定一个初始桶数。通常将桶数设置为预计元素个数的75% ~ 150%,最好将桶数设置为一个<strong>素数</strong>,以防键的集聚。标准类库使用的桶数是2的幂，默认值为16,<strong>为散列表的大小提供的任何值都被自动转换为2的下一个幂</strong>。<br>如果最初的估计过低，散列表太满，散列表会进行再散列，创建一个桶数更多的表。<strong>装填因子</strong>决定何时再散列，比如装填因子为0.75，当散列表中超过75%的位置已经填入了元素，这个表就会用双倍的桶数自动进行再散列，大多数情况装填因子为0.75是比较合理的。<br>下面是HashSet的常用API：  </p><ul><li>HashSet() 构造一个空散列集  </li><li>HashSet(Collection&lt;? extends E&gt; elements)<br>构造一个散列集，并将集合中的所有元素添加到这个散列集中 </li><li>HashSet(int initialCapacity) 构造一个具有指定容量(桶数)的散列集  </li><li>HashSet(int initialCapacity,float loadFactor) 构造一个具有指定容量和装填因子(一个0.0 ~ 1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集      </li></ul><p><strong>特别要注意,在HashSet中没有get和set方法，因为HashSet是无序集，不存在索引概念，如果要访问HashSet中的元素应该使用迭代器，另外contains方法也被重新定义，可以快速查看某个元素是否出现在集中，此时不用查看集中的所有元素，只用通过散列码定位到一个桶，查看这个桶中的所有元素即可</strong>  </p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet和HashSet十分类似，不过当元素以任意顺序插入TreeSet时，TreeSet会保证元素是有序排列的。其底层是由<strong>红黑树</strong>实现的,每次将一个元素添加到树中，都被放置在正确的排序位置上。<br><strong>一个元素添加到树中比添加到散列表中慢</strong>，但是与检查数组或链表中的重复元素相比还是快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。如果对集合中的元素次序没有要求，应该使用HashSet而不是TreeSet，即使排序的花销不大，但也会影响效率。<br><strong>注意：要使用TreeSet，插入的元素必须可排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator</strong><br>从Java SE 6起,TreeSet类实现了Navigable接口，这个接口增加了几个便于定位元素以及反向遍历的方法。  </p><p>下面是TreeSet的常用API：  </p><ul><li>TreeSet() 构造一个空树集  </li><li>TreeSet(Collection&lt;? extends E&gt; elements)<br>构造一个空树集，并将集合中的所有元素添加到这个树集中  </li><li>TreeSet(Comparator&lt;? super E&gt; comparator)  构造一个空树集  </li><li>TreeSet(SortedSet&lt;<code>E</code>&gt; s)<br>构造一个空树集，并将有序集中的所有元素添加到这个树集中，并使用与给定的有序集相同的比较器</li></ul><p>下面是SortedSet的常用API：  </p><ul><li>Comparator&lt;? super E&gt; comparator()<br>返回用于对元素进行排序的比较器。如果元素用Comparable接口的compareTo方法进行比较则返回null  </li><li>E first() 返回有序集中的最小元素  </li><li>E last() 返回有序集中的最大元素   </li></ul><p>下面是NavigableSet的常用API： </p><ul><li>E higher(E value)  </li><li>E lower(E value)<br>返回大于value的最小元素或小于value的最大元素，如果没有这样的元素则返回null  </li><li>E ceiling(E value)  </li><li>E floor(E value)<br>返回大于等于value的最小元素或小于等于value的最大元素，如果没有这样的元素则返回null  </li><li>E poolFirst()  </li><li>E pollLast()<br>删除并返回这个集合中的最大元素或最小元素，这个集合为空时返回null  </li><li>Iterator&lt;<code>E</code>&gt; descendingIterator()<br>返回一个按照递减顺序遍历集中元素的反向迭代器  </li></ul><h4 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h4><p>Deque(双端队列)接口继承自Queue(队列)接口，与之有所不同的是，双端队列可以在队列的头部和尾部添加或删除元素，但也不支持在队列中间添加或删除元素。<br>和普通队列一样，双端队列也可以用ArrayDeque和LinkedList实现。  </p><p>下面是Queue的常用API：  </p><ul><li>boolean add(E element)  </li><li>boolean offer(E element)<br>都是将一个元素入队并返回true，如果队列已满，前者会抛出一个IllegalStateException，后者则返回false  </li><li>E remove()  </li><li>E poll()<br>都是将队头元素出队并返回，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null  </li><li>E element()  </li><li>E peek()<br>都是取队头元素但不删除，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null   </li></ul><p>下面是Deque的常用API：  </p><ul><li>void addFirst(E element)  </li><li>void addLast(E element)  </li><li>boolean offerFirst(E element)  </li><li>boolean offerLast(E element)<br>都是将给定元素添加到双端队列的头部或尾部，如果队列满了，前两个方法会抛出一个IllegalStateException，后两个方法则返回false  </li><li>E removeFirst()  </li><li>E removeLast()  </li><li>E pollFirst()  </li><li>E pollLast()<br>都是删除双端队列的头部或尾部并返回元素，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li><li>E getFirst()  </li><li>E getLast() </li><li>E peekFirst()  </li><li>E peekLast()<br>都是返回双端队列的头部或尾部元素但不删除，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li></ul><p>下面是ArrayDeque的常用API：  </p><ul><li>ArrayDeque() 用默认初始容量16构造一个空队列  </li><li>ArrayDeque(int initialCapacity) 用指定容量构造一个空队列    </li></ul><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先出队。优先队列具有最高级先出(first in, largest out)的行为特征。<br>PriorityQueue的底层是通过堆(小根堆，<strong>将较小的元素设为最高优先级</strong>)实现的，堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。<br>PriorityQueue是一个实现了Queue接口的具体类。<br><strong>和TreeSet一样，要实现排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator。</strong>  </p><p><strong>注意：</strong>方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。原因是PriorityQueue内部是一个堆，堆只能保证根具有最高的优先级，但整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历，也就是只能保证数组的第一个元素具有最高优先级。但如果将元素依次出队，出队顺序可以保证是有序的，这是因为在每一次出队后堆会进行调整，将下一个优先级最高的元素移动到根。</p><p>下面是PriorityQueue的常用API：  </p><ul><li>PriorityQueue() 构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity)<br>用指定容量构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity,Comaparator&lt;? super E&gt; c)<br>用指定容量构造一个空优先队列,并指定比较器对元素进行排序  </li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>集是一个集合，它可以快速查找现有元素。但是，有时我们知道某些键的信息，并想要查找与之对应的元素。映射(map)数据结构就是为此设计的，map用来存放键值对，提供键(Key)就能快速查找到值(Value)<br>Java类库为映射提供了两个实现：HashMap和TreeMap，这两个类都实现了Map接口。<br>HashMap(散列映射)对<strong>键</strong>进行散列，键值对是无序的。TreeMap(树映射)用<strong>键</strong>的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。<strong>与集一样，HashMap比TreeMap快一些，如果不需要按照排列顺序访问键，就最好选择散列。</strong>  </p><p>下面是Map接口的常用API：  </p><ul><li>V get(Object key)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回null  </li><li>default V getOrDefault(Object key,V defaultValue)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回defaultValue  </li><li>V put(K key,V value)<br>将键与对应的值关系插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象，并返回键对应的旧值，如果这个键以前没有出现过则返回null。<strong>键可以为null，但值不能为null</strong>  </li><li>V putAll(Map&lt;? extends K,? extends V&gt; entries)<br>将给定映射中的所有条目添加到这个映射中  </li><li>boolean containsKey(Object key)<br>如果在映射中已经有这个键，返回true </li><li>boolean containsValue(Object value)<br>如果在映射中已经有这个值，返回true  </li><li>default void forEach(BiConsumer&lt;? super K,? super V&gt; action)<br>对这个映射中的所有键值对应用这个动作，参数是一个函数式接口类型，可以传入一个lambda表达式,例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scores.forEach((k,v) -&gt; </div><div class="line">System.out.println(<span class="string">"key="</span> + k + <span class="string">", value="</span> + v));</div></pre></td></tr></table></figure></li></ul><p>下面是HashMap的常用API：   </p><ul><li>HashMap()  构造一个空散列映射</li><li>HashMap(int initialCapacity) 用指定容量构造一个空散列映射 </li><li>HashMap(int initialCapacity,float LoadFactor)<br>用指定容量和装填因子构造一个空散列映射，默认的装填因子是0.75  </li></ul><p>下面是TreeMap的常用API：   </p><ul><li>TreeMap() 构造一个空树映射  </li><li>TreeMap(Comparator&lt;? super K&gt; c)<br>构造一个空树映射，并使用一个指定的比较器对键进行排序  </li><li>TreeMap(Map&lt;? extends K,? extends V&gt; entries) 构造一个空树映射，并将某个映射的所有条目添加到树映射中   </li><li>TreeMap(SortedMap&lt;? extends K,? extends V&gt; entries)<br>构造一个空树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器  </li></ul><p>下面是SortedMap的常用API：   </p><ul><li>Comparator&lt;? super K&gt; comparator()<br>返回对键进行排序的比较器。如果键是用Comparable接口的compareTo方法进行比较的，返回null  </li><li>K firstKey()  </li><li>K lastKey()<br>返回映射中最小元素和最大元素  </li></ul><h4 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h4><p>假设我们要统计一个单词在文件中出现的次数，当得到一个单词时，我们将其计数器加1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>但这可能会出错，如果word第一次出现，counts.get(word)会返回null，从而抛出一个NullPointerException。  </p><p>为了避免这种情况，我们可以用<strong>getOrDefault方法</strong>来取代get方法，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.getOrDefault(word,<span class="number">0</span>) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>另一种方法是首先调用<strong>putIfAbsent方法</strong>，这个方法会在映射中不存在word时插入键值对初始化word的值为0：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">counts.putIfAbsent(word,<span class="number">0</span>);</div><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>还可以做得更好,<strong>merge方法</strong>可以简化这个常见操作。如果键原先不存在，则下面的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.merge(word,<span class="number">1</span>,Integer::sum);</div></pre></td></tr></table></figure></p><p>将把word和1关联，如果word存在，则会使用Integer::sum函数组合原值和1(也就是将原值和1求和)  </p><h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><p>集合框架不认为映射本身是一种集合，不过可以得到映射视图 —— 这是实现了Collection接口或某个子接口的对象。<br>有三种视图：键集、值集合<strong>(不是一个集)</strong>、键值对集。<strong>键集</strong>和<strong>键值对集</strong>是集，因为一个映射中的键是唯一的，但值不能构成集，只能是值集合，因为一个映射中可以有多个相同的值。<br>下面的方法可以从映射中返回这三种视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></div><div class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></div><div class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p><p><strong>需要说明的是，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口，所以可以向使用集合一样使用keySet</strong>  </p><p>键值对是Map.Entry<code>&lt;K,V&gt;</code>类型的，可以使用entrySet()方法返回映射的键值对集，再通过循环对于每个键值对对象使用，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Employee&gt; entry: staff.entrySet())</div><div class="line">&#123;</div><div class="line">String k = entry.getKey();</div><div class="line">    Employee v = entry.getValue();</div><div class="line">    <span class="comment">// do something with k,v</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>getKey方法获取该键值对的键，getValue方法获取该键值对的值，setValue方法将键值对的值设置为新值并返回原值。<br>当然查看键值对最高效的方法是使用forEach方法</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">counts.forEach((k,v) -&gt; &#123;</div><div class="line"><span class="keyword">do</span> something with k,v</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p><strong>注意:</strong>可以在键集视图上调用迭代器的remove方法，结果会在映射中删除这个键和与它关联的值，但不能调用add方法，否则会抛出一个UnsupportedOperationException;可以在值集合视图删除元素，所删除的值和相应的键将从映射中删除，也不能增加元素;可以在键值对集合中删除元素，将从映射中删除相应的键值对，但也不能增加元素。<strong>总之，可删不可增。</strong>  </p><h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p>当一个映射中引用某个值的所有键都消亡，即没有任何途径引用这个值时，这个值成为了无用对象。但是垃圾回收器跟踪<strong>活动的对象</strong>，只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收。于是，长期存活的映射中可能会存在一些无用的值，此时需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用WeakHashMap。当对键的唯一应用来自散列条目时，这种数据结构会协助垃圾回收期协同工作一起删除键值对。<br>下面是这种机制的内部运行情况。WeakHashMap使用<strong>弱引用</strong>保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种特定类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。  </p><p><img src="/2017/10/23/Java学习总结之集合/WeakHashMap.png" alt="fail"></p><p>更多细节见：<a href="http://mikewang.blog.51cto.com/3826268/880775/" target="_blank" rel="external">深入理解WeakHashMap</a>  </p><h4 id="LinkedHashSet-amp-LinkedHashMap"><a href="#LinkedHashSet-amp-LinkedHashMap" class="headerlink" title="LinkedHashSet &amp; LinkedHashMap"></a>LinkedHashSet &amp; LinkedHashMap</h4><p>LinkedHashSet和LinkedHashMap会按照<strong>元素插入顺序</strong>存放元素或键值对。当条目插入到表中时，就会并入到双向链表中。<br><img src="/2017/10/23/Java学习总结之集合/双向链表.png" alt="fail"><br>也可以使用<code>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</code>来构造一个按照<strong>元素访问顺序</strong>迭代键值对的LinkedHashMap。每次调用get或put，受到影响的条目将从当前位置删除，并放到条目链表的尾部(只有条目在链表中位置会受影响，而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中)。<br>访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已满时，可以将迭代器加入到表中，并将前几个元素删除掉。这些是近期最少使用的几个元素。<br>甚至可以让这一过程自动化。即构造一个LinkedHashMap的子类，然后覆盖下面的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></div></pre></td></tr></table></figure></p><p>每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。例如，下面的高速缓存可以存放100个元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Map&lt;K, V&gt; cache = <span class="keyword">new</span> </div><div class="line">LinkedHashMap&lt;&gt;(<span class="number">128</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>)</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() &gt; <span class="number">100</span>; </div><div class="line">        <span class="comment">/*当元素个数 &lt;= 100，直接插入元素，</span></div><div class="line"><span class="comment">        否则进行替换，删除“最近最少使用”的元素，</span></div><div class="line"><span class="comment">        插入新元素*/</span></div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p><p>另外，还可以对eldest条目进行评估，以此决定是否应该将它删除。例如，可以检查与这个条目一起存在的时间戳。<br><img src="/2017/10/23/Java学习总结之集合/LinkedHashSet.png" alt="fail"></p><p><img src="/2017/10/23/Java学习总结之集合/LinkedHashMap.png" alt="fail"></p><h4 id="EnumSet-amp-EnumMap"><a href="#EnumSet-amp-EnumMap" class="headerlink" title="EnumSet &amp; EnumMap"></a>EnumSet &amp; EnumMap</h4><p>EnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1.<br>EnumSet没有公共的构造器，可以使用静态工厂方法构造这个集，下面给出得到EnumSet的几个常用方法：<br><img src="/2017/10/23/Java学习总结之集合/枚举集.png" alt="fail"><br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;</div><div class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</div><div class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</div><div class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);</div><div class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY);</div></pre></td></tr></table></figure></p><p>可以使用Set接口的常用方法来修改EnumSet<br>EnumMap是一个<strong>键类型</strong>为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时，需要在构造器中指定键类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EnumMap&lt;Weekday, Employee&gt; personInChange = <span class="keyword">new</span> EnumMap&lt;&gt;(Weekday.class);</div></pre></td></tr></table></figure></p><p>这样就构造了一个键为Weekday类型的空映射。</p><h4 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h4><p>类IdentityHashMap有特殊的作用。在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。而且，在对两个对象进行比较时，IdentityHashMap类使用 == ，而不使用equals<br>也就是说，不同的键对象，即使内容相同，也被视为不同的对象。在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况。<br><img src="/2017/10/23/Java学习总结之集合/IdentityHashMap.png" alt="fail"></p><h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>通过使用<strong>视图</strong>可以获取其他的实现了Collection接口或Map接口的对象，映射类的keySet方法就是这样一个示例。这个方法看似创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。<strong>然而事实并非如此，keySet方法返回一个实现了Set接口的类对象，这个类的方法对原映射进行操作。这样的集合称为视图。</strong>  </p><h4 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h4><p>Arrays类的静态方法asList将返回一个<strong>包装了普通Java数组的List包装器</strong>。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</div><div class="line">   ...</div><div class="line">   List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</div></pre></td></tr></table></figure></p><p>返回的对象不是ArrayList，而是一个视图对象，带有访问底层数组的get和set方法。<br><strong>改变数组大小的所有方法(例如，与迭代器相关的add和remove方法)都会抛出一个UnsupportedOperationException。</strong><br>asList方法可以接收可变数目的参数，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span>,<span class="string">"Bob"</span>,<span class="string">"Carl"</span>);</div></pre></td></tr></table></figure></p><p>这个方法调用<code>Collections.nCopies(n,anObject)</code><br>将返回一个实现了List接口的<strong>不可修改的对象</strong>，并给人一种包含n个元素，每个元素都像是一个anObject的错觉。<br>例如，下面的调用将创建一个包含100个字符串的List，每个串都被设置为”DEFAULT”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; settings = Collections.nCopies(<span class="number">100</span>,<span class="string">"DEFAULT"</span>);</div></pre></td></tr></table></figure></p><p>存储代价很小，可用于不需要修改元素的情况。这是视图技术的一种巧妙的应用。<br><strong>注意：</strong>Collections类包含很多使用的方法，这些方法的参数和返回值都是集合，不要将它和Collection接口混起来。  </p><p>如果调用以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.singleton(anObject);</div></pre></td></tr></table></figure></p><p>将返回一个实现了Set接口的视图对象(与产生List视图的ncopies方法不同)，即一个不可修改的单元素集，而不需要付出建立数据结构的开销。singletonList方法与singletonMap方法类似。<br>类似地，对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等等。特别是，集的类型可以推导得出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; deepThoughts = Collections.emptySet();</div></pre></td></tr></table></figure></p><h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立子范围视图。例如，假设有一个列表staff，想从中取出第10个-第19个元素。可以使用subList方法来获得一个列表的子范围视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List group2 = staff.subList(<span class="number">10</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure></p><p>第一个索引包含在内，第二个索引则不包含在内。可以将<strong>任何操作</strong>应用于子范围，该操作会影响整个列表。例如，可以删除整个子范围：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">group2.clear();</div></pre></td></tr></table></figure></p><p>现在，staff列表中该范围的元素也被删除，并且group2为空。<br>对于SortedSet和SortedMap，可以使用排序顺序而不是元素位置建立子范围。SortedSet接口声明了3个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,E to)</span></span></div><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></span></div><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></span></div></pre></td></tr></table></figure></p><p>这些方法返回大于等于from且小于to的所有元素构成的子集。</p><p>SortedMap也有类似的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K from,K to)</span></span></div><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span></div><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span></div></pre></td></tr></table></figure></p><p>返回映射视图，该映射包含<strong>键</strong>落在指定范围内的所有元素。<br>Java SE 6引入的NavigableSet接口赋予子范围操作更多控制能力。可以指定是否包括边界：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive,E to,<span class="keyword">boolean</span> toInclusive)</span></span></div><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to,<span class="keyword">boolean</span> toInclusive)</span></span></div><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from,<span class="keyword">boolean</span> fromInclusive)</span></span></div></pre></td></tr></table></figure></p><h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p><img src="/2017/10/23/Java学习总结之集合/不可修改的视图1.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/不可修改的视图2.png" alt="fail"></p><h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p><img src="/2017/10/23/Java学习总结之集合/同步视图.png" alt="fail"></p><h4 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h4><p><img src="/2017/10/23/Java学习总结之集合/受查视图.png" alt="fail"></p><h4 id="关于可选操作的说明"><a href="#关于可选操作的说明" class="headerlink" title="关于可选操作的说明"></a>关于可选操作的说明</h4><p><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明2.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明3.png" alt="fail"></p><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>内容较多，见Java核心技术卷一 P388 ~ P396，并查阅相关API</p><h3 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h3><p>见Java核心技术 P396 ~ P402</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h3&gt;&lt;p&gt;Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Jav
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之泛型程序设计</title>
    <link href="http://habitdiary.cn/2017/10/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://habitdiary.cn/2017/10/22/Java学习总结之泛型程序设计/</id>
    <published>2017-10-22T01:09:10.000Z</published>
    <updated>2017-11-06T15:26:40.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h3><p>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，这是一个泛型程序设计的实例。实际上，在Java增加泛型类之前已经有一个ArrayList类，下面来研究泛型程序设计机制是如何演变的。  </p><h3 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h3><p>在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayLists类只维护一个Object引用的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] elementData;</div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; . . . &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123; . . . &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种方法有两个问题，我们以一个保存文件名的files数组列表为例：<br>1) 当获取一个值时必须进行强制类型转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList files = <span class="keyword">new</span> ArrayList();</div><div class="line">. . .</div><div class="line">String filename = (String)files.get(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>2) 当添加一个值时不进行类型检查，可以添加任何类的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">files.add(<span class="keyword">new</span> File(<span class="string">". . ."</span>));</div></pre></td></tr></table></figure></p><p>此调用在编译和运行时都不会出错，但如果将get的结果强制转换为String会产生一个错误  </p><p>为了解决上述问题，引入了类型参数。ArrayList有一个类型参数用来指示元素类型：<code>ArrayList&lt;T&gt; files = new ArrayList&lt;T&gt;();</code>在Java SE 7及以后的版本，构造函数可以省略类型参数，即<code>ArrayList&lt;T&gt; files = new ArrayList&lt;&gt;();</code><br>这种方法有三个好处：<br>1)get得到的值不必进行强制类型转换<br>2)向数组列表中添加对象时会进行类型检查，如果不符合类型，无法通过编译，出现编译错误比类在运行时出现类的强制转换异常要好得多<br>3)程序具有更好的可读性，比如<code>ArrayList&lt;String&gt; files</code>一看就是聚集了String对象的数组列表  </p><h3 id="定义简单的泛型类"><a href="#定义简单的泛型类" class="headerlink" title="定义简单的泛型类"></a>定义简单的泛型类</h3><p>一个泛型类就是具有一个或多个类型变量的类，下面使用一个简单的Pair类作为例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> T first;</div><div class="line">    <span class="keyword">private</span> T second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair类引入了一个类型变量T，用尖括号括起来，并放在类名的后面。<strong>注意这里的T只是指定了一种类型，不代表类只有一个属性成员，而表示接下来类中出现的T都和尖括号里的类型保持一致,即类定义的类型变量指定方法返回类型以及域和局部变量的类型。</strong><br>泛型类可以有多个类型变量，如可以定义两个域类型不同的Pair类<code>public class Pair&lt;T,U&gt; {. . .}</code><br><strong>类型变量命名规则：</strong>E表示集合的元素类型，K和V分别表示表的关键字和值的类型，T(需要时还可以用临近的字母U和S)表示“任意类型”。<br>实际使用中将类定义尖括号里的T替换为具体类型，类中的T也会进行相应的替换，所以，<strong>泛型类可以看作普通类的工厂</strong>  </p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>前面介绍了如何定义一个泛型类，下面我们来定义一个带有类型参数的简单泛型方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1)类型变量放在修饰符(这里是public static)的后面，返回类型的前面<br>2)泛型方法可以定义在普通类中，也可以定义在泛型类中<br>3)当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q."</span>,<span class="string">"Public"</span>);</div></pre></td></tr></table></figure></p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时，类或方法需要对类型变量加以约束。下面是一个典型的例子，我们要计算数组中的最小元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        T smallest = a[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length;i++)</div><div class="line">        <span class="keyword">if</span>(smallest.compareTo(a[i]) &gt; <span class="number">0</span>)</div><div class="line">            smallest = a[i];</div><div class="line">        <span class="keyword">return</span> smallset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们会发现一个问题，smallest的类型为T，既可以是任何一个类的对象，如何保证T类型有compareTo方法呢？<strong>解决方法是限制T为实现了Comparable接口的类</strong>，即将泛型方法定义改为<code>public static &lt;T extends Comparable&gt; T min(T[] a)</code><br><strong>注意：</strong><br>1)限定类时如果实现的是接口也用extends关键字，如上面的<code>T extends Comparable</code><br>2)只需要在尖括号里限定，之后的T不用再加限定  </p><p>一个类型变量或通配符可以有多个限定，用’&amp;’分隔限定类型，用逗号分隔类型变量，例如：<code>T extends Comparable &amp; Serializable</code> <strong>可以有多个接口限定和至多一个类限定，将标记接口(空接口)放在限定列表的末尾，如果用一个类作为限定，它必须是限定列表中的第一个</strong>  </p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p><strong>对于虚拟机来说没有泛型类型，只有普通类和方法。无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。在编译时泛型类型会被转化为原始类型。</strong>原始类型就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(无限定类型的变量替换为Object)。<br>例如，<code>Pair&lt;T&gt;</code>的原始类型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object first;</div><div class="line">    <span class="keyword">private</span> Object second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first,Object second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>因为T是一个无限定的参数变量，所以直接用Object替换<br>如果是T是一个限定类型的参数变量，用限定列表中的第一个类型替换，比如<code>T extends Comparable &amp; Serializable</code>被替换为<code>Comparable</code>  </p><h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><p>当泛型表达式编译时，编译器会将其编译为原始类型并加入强制类型转换。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Employee&gt; buddies = . . . ;</div><div class="line">Employee buddy = buddies.getFirst();</div></pre></td></tr></table></figure></p><p>编译器会把这个方法调用翻译为两条虚拟机指令：  </p><ul><li>对原始方法Pair.getFirst的调用  </li><li>将返回的Object类型强制转换为Employee类型  </li></ul><p>当存入一个泛型域时编译器也会自动在字节码中插入强制类型转换。  </p><h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><p>类型擦除会发生一些问题，比如一个类subPair继承自类<code>Pair&lt;String&gt;</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">String</span>&gt; //继承一个泛型类</span></div><div class="line"><span class="class"> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;<span class="comment">//重写了父类的方法</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair在编译的时候被类型擦除，Pair的setFirst方法变为了setFirst(Object newValue)，这样SubPair的setFirst(Stirng newValue)方法就无法覆盖父类中的setFirst(Object newValue)方法，因为参数不同，不是同一个方法。<br>SubPair中会出现两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span>&#123;....&#125;</div></pre></td></tr></table></figure></p><p>此时如果有如下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SubPair p = <span class="keyword">new</span> SubPair(. . .);</div><div class="line">Pair&lt;String&gt; pair = p;</div><div class="line">p.setFirst(<span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure></p><p>按理来说，这段测试代码应该不能通过编译，因为要实现多态的话，所调用的方法必须在子类中重写，但是在这里SubPair类并没有重写Pair类中的setFirst方法，只是单纯的继承而已，并且新加了一个参数不同的同名方法。<br>但结果可以运行，因为为了解决这种<strong>类型擦除和多态的冲突</strong>，编译器会在SubPair类中生成一个桥方法，上述两个方法被编译器变成了这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125; <span class="comment">//子类定义的方法不变</span></div><div class="line"></div><div class="line"><span class="comment">//编译器生成的桥方法 </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   setFirst((String) newValue);</div><div class="line">   <span class="comment">//桥内部调用的是子类中定义的setFirst(String newValue)方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看出，这个桥方法实际上就是对超类中setFirst(Object newValue)的重写。这样做的原因是，当程序员在子类中写下setFirst(String newValue)方法时，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免<strong>类型擦除与多态发生冲突。</strong><br>详见博客：<a href="http://www.cnblogs.com/xz816111/p/7643323.html" target="_blank" rel="external">Java中的类型擦除与桥方法</a>  </p><h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><p>在使用Java泛型时需要考虑一些限制。大多数限制都是由类型擦除引起的。  </p><h4 id="1-不能用基本类型实例化类型参数"><a href="#1-不能用基本类型实例化类型参数" class="headerlink" title="1.不能用基本类型实例化类型参数"></a>1.不能用基本类型实例化类型参数</h4><p>类型参数不能为基本类型。比如，没有<code>Pair&lt;double&gt;</code>只有<code>Pair&lt;Double&gt;</code>,其原因是类型擦除，因为擦除之后，Pair类含有Object类型的域，Object不能存储double值。  </p><h4 id="2-运行时类型查询只适用于原始类型"><a href="#2-运行时类型查询只适用于原始类型" class="headerlink" title="2.运行时类型查询只适用于原始类型"></a>2.运行时类型查询只适用于原始类型</h4><p>使用instanceof查询一个对象是否属于某个泛型类会产生编译错误，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;)<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>同样的道理，getClass方法总是返回原始类型。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; stringPair = . . .;</div><div class="line">Pair&lt;Employee&gt; employeePair = . . .;</div><div class="line"><span class="keyword">if</span>(stringPair.getClass() == employeePair.getClass()) <span class="comment">//equal</span></div></pre></td></tr></table></figure></p><p>其比较结果是true，因为两次调用getClass结果都返回Pair.class  </p><h4 id="3-不能创建参数化类型的数组"><a href="#3-不能创建参数化类型的数组" class="headerlink" title="3.不能创建参数化类型的数组"></a>3.不能创建参数化类型的数组</h4><p>不能实例化参数化类型的数组，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt; [<span class="number">10</span>];<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>最安全而有效的方法是使用ArrayList，即<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>  </p><h4 id="4-Varargs警告"><a href="#4-Varargs警告" class="headerlink" title="4.Varargs警告"></a>4.Varargs警告</h4><p>考虑下面的方法，它有可变长的泛型类型参数ts：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll,T...ts)</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(t : ts) coll.add(t);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>现在如果调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Collection&lt;Pair&lt;String&gt;&gt; table = . . .;</div><div class="line">Pair&lt;String&gt; pair1 = . . .;</div><div class="line">Pair&lt;String&gt; pair2 = . . .;</div><div class="line">addAll(table,pair1,pair2);</div></pre></td></tr></table></figure></p><p>JVM会为了可变长参数建立一个Pair<string>数组，这违反了前面的规则。<br><strong>这里特别注意</strong>：Java不支持泛型类型的数组，但如果向参数个数可变的方法传递一个泛型类型的实例(即传递一个泛型类型对象的数组)这种规则有所放松，你只会得到一个警告，而不是错误。可以用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>或用<code>@SafeVarags</code>标注addAll方法来抑制警告。<br>即如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SafeVarargs</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll,T...ts)</span></span></div></pre></td></tr></table></figure></string></p><p>现在就可以提供泛型类型来调用这个方法了。</p><h4 id="5-不能实例化类型变量"><a href="#5-不能实例化类型变量" class="headerlink" title="5.不能实例化类型变量"></a>5.不能实例化类型变量</h4><p>不能使用像new T(…),new T[…]或T.class这样的表达式中的类型变量。例如，下面的Pair<code>&lt;T&gt;</code>构造器是非法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">new</span> T();second = <span class="keyword">new</span> T();&#125;<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>类型擦除将T改变成Object，而且本意肯定不希望调用new Object()。在Java SE 8之后，最好的解决方法是让调用者提供一个构造器表达式。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</div></pre></td></tr></table></figure></p><p>makePair方法接受一个Supplier<code>&lt;T&gt;</code>，这是一个函数式接口，表示一个无参数而且返回类型为T的函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt; (constr.get(),constr.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比较传统的解决方法是通过反射调用Class.newInstance方法来构造泛型对象。<br>遗憾的是，细节有点复杂。不能调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first = T.class.newInstance();<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>表达式T.class是不合法的，因为它会被类型擦除为Object.class。必须像下面这样设计API以便得到一个Class对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt; (c1.newInstance(),c1.newInstance())&#125;;</div><div class="line">    <span class="keyword">catch</span>(Exception ex) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方法可以按照下列方式调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</div></pre></td></tr></table></figure></p><p>注意，Class类本身是泛型。例如,String.class是一个Class<code>&lt;String&gt;</code>的实例(事实上，它是唯一的实例)。因此,makePair方法能够推断除pair的类型。  </p><h4 id="6-不能构造泛型数组"><a href="#6-不能构造泛型数组" class="headerlink" title="6.不能构造泛型数组"></a>6.不能构造泛型数组</h4><p>就像不能实例化一个泛型实例一样，也不能实例化数组。不过原因有所不同，毕竟数组会填充null值，构造时看上去是安全的。不过，数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除。例如，考虑下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];&#125;<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>类型擦除会让这个方法永远构造Comparable[2]数组。<br>如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object[],并且在屈原素时进行类型转换。例如，ArrayList可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] elements;</div><div class="line">    . . .</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (E) elements[i];&#125;<span class="comment">//取元素时强制类型转换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i,E e)</span> </span>&#123; elements[i] = e;&#125;<span class="comment">//改变元素时不必强转</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实际的实现没有那么清晰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> E[] elements;</div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;elements = (E[]) <span class="keyword">new</span> Object[<span class="number">10</span>];&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里的强制类型转换E[]是一个假象，而类型擦除使其无法察觉。<br>由于 minmax 方法返回 T[] 数组，使得这一技术无法施展， 如果掩盖这个类型会有运行时错误结果。假设实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a)</div><div class="line">&#123;</div><div class="line">Object[] mm = <span class="keyword">new</span> Object[<span class="number">2</span>];</div><div class="line">. . .</div><div class="line"><span class="keyword">return</span> (T[]) mm; <span class="comment">// compiles with warning</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用 String[] ss = ArrayAlg.minmax(“Tom”, “Dick”, “Harry”);<br>编译时不会有任何警告。当 Object[] 引用赋给 Comparable[] 变量时，将会发生 ClassCastException异常。<br>在这种情况下， 最好让用户提供一个数组构造器表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] ss = ArrayAlg.minmax (String[]::<span class="keyword">new</span>，<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</div></pre></td></tr></table></figure></p><p>构造器表达式 String::new 指示一个函数，给定所需的长度，会构造一个指定长度的<br>String数组。<br>minmax方法使用这个参数生成一个有正确类型的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmax(IntFunction&lt;T[]&gt; constr, T... a)</div><div class="line">&#123;</div><div class="line">T[] mm = constr.apply(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比较老式的方法是利用反射， 调用 Array.newInstance:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmaxfT... a)</div><div class="line">&#123;</div><div class="line">T[] mm = (T[]) Array.newlnstance (a.getClass().getComponentType() , <span class="number">2</span>);</div><div class="line"> . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ArrayList 类的 toArray 方法就没有这么幸运。它需要生成一个 T[] 数组， 但没有成分类型。因此， 有下面两种不同的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object[] toArray()</div><div class="line">T[] toArray(T[] result)</div></pre></td></tr></table></figure></p><p>第二个方法接收一个数组参数。如果数组足够大,就使用这个数组。否则,用 result 的成分类型构造一个足够大的新数组。  </p><h4 id="7-泛型类的静态上下文中类型变量无效"><a href="#7-泛型类的静态上下文中类型变量无效" class="headerlink" title="7.泛型类的静态上下文中类型变量无效"></a>7.泛型类的静态上下文中类型变量无效</h4><p>不能在静态域或方法中引用类型变量。例如， 下列高招将无法施展：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> T singlelnstance; <span class="comment">// Error</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T getSinglelnstanceO <span class="comment">// Error</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (singleinstance == <span class="keyword">null</span>) <span class="comment">//construct new instance of T</span></div><div class="line"><span class="keyword">return</span> singlelnstance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="8-不能抛出或捕获泛型类的实例"><a href="#8-不能抛出或捕获泛型类的实例" class="headerlink" title="8.不能抛出或捕获泛型类的实例"></a>8.不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类对象。实际上， 甚至泛型类扩展 Throwable 都是不合法的。<br>例如， 以下定义就不能正常编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* . . . */</span> &#125; </div><div class="line"><span class="comment">// Error can't extend Throwable</span></div></pre></td></tr></table></figure></p><p>catch 子句中不能使用类型变量。例如， 以下方法将不能编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (T e) <span class="comment">// Error can 't catch type variable</span></div><div class="line">&#123;</div><div class="line">Logger.global.info(...)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不过，在异常规范中使用类型变量是允许的。以下方法是合法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T <span class="comment">// OK</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Throwable real Cause)</div><div class="line">&#123;</div><div class="line">t.initCause(real Cause);</div><div class="line"><span class="keyword">throw</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="9-可以消除对受查异常的检查"><a href="#9-可以消除对受查异常的检查" class="headerlink" title="9.可以消除对受查异常的检查"></a>9.可以消除对受查异常的检查</h4><p>Java 异常处理的一个基本原则是， 必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。关键在于以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">throw</span> (T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设这个方法包含在类 Block 中，如果调用<code>Block.&lt;RuntimeException&gt;throwAs(t);</code><br>编译器就会认为 t 是一个非受查异常。 以下代码会把所有异常都转换为编译器所认为的非受查异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Throwable t)</div><div class="line">&#123;</div><div class="line">Block.&lt;RuntimeException&gt;throwAs(t) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面把这个代码包装在一个抽象类中。用户可以覆盖 body 方法来提供一个具体的动作。调用 toThread 时， 会得到 Thread 类的一个对象， 它的 run 方法不会介意受查异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">toThrea</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Thread()</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">body();</div><div class="line">            &#125;</div><div class="line"><span class="keyword">catch</span> (Throwable t)</div><div class="line">&#123;</div><div class="line">            Block.&lt;RuntimeException&gt; throwAs(t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">throw</span> (T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>例如， 以下程序运行了一个线程， 它会拋出一个受查异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">new</span> Block()</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"ququx"</span>) ,<span class="string">"UTF-8"</span>);</div><div class="line"><span class="keyword">while</span> (in.hasNext())</div><div class="line">System.out.println(in.next());</div><div class="line">&#125;</div><div class="line"> &#125; </div><div class="line">   .toThread() .start();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行这个程序时， 会得到一个栈轨迹， 其中包含一个FileNotFoundException ( 当然,假设你没有提供一个名为 ququx 的文件)。<br>这有什么意义呢？ 正常情况下， 你必须捕获线程 run 方法中的所有受查异常， 把它们”包装”到非受查异常中， 因为 run 方法声明为不抛出任何受查异常。<br>不过在这里并没有做这种”包装”。我们只是抛出异常， 并”哄骗”编译器， 让它认为这不是一个受查异常。<br>通过使用泛型类、 擦除和 @SuppressWarnings 注解， 就能消除 Java 类型系统的部分基本限制。  </p><h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><p>当泛型类型被擦除时，无法创建引发冲突的条件。下面是一个示例。假定像下面这样将equals 方法添加到 Pair 类中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>考虑一个Pair<code>&lt;String&gt;</code>。从概念上讲，它有两个equals方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span> <span class="comment">// defined in Pair&lt;T&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span> <span class="comment">// inherited from Object</span></span></div></pre></td></tr></table></figure></p><p>但是，直觉把我们引入歧途。方法擦除<code>boolean equals(T)</code>，就是<code>boolean equals(Object)</code><br>与 Object.equals 方法发生冲突。<br>当然，补救的办法是重新命名引发错误的方法。<br>泛型规范说明还提到另外一个原则:”要想支持擦除的转换， 就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。”例如，<br>下述代码是非法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Coinparab1e</span>&lt;<span class="title">Emp1oyee</span>&gt; </span>&#123; . . . &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Hanager</span>&gt; </span></div><div class="line"><span class="class"></span>&#123; . . . &#125; <span class="comment">// Error</span></div></pre></td></tr></table></figure></p><p>Manager 会实现 Comparable<code>&lt;Employee&gt;</code> 和 Comparable<code>&lt;Manager&gt;</code>, 这是同一接口的不同参数化。<br>这一限制与类型擦除的关系并不十分明确。毕竟，下列非泛型版本是合法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123; . . . &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123; . . . &#125;</div></pre></td></tr></table></figure></p><p>其原因非常微妙， 有可能与合成的桥方法产生冲突。实现了 Comparable<code>&lt;X&gt;</code> 的类可以获得一个桥方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123; <span class="keyword">return</span> compareTo((X) other); &#125;</div></pre></td></tr></table></figure></p><p>对于不同类型的 X 不能有两个这样的方法。</p><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;泛型程序设计&quot;&gt;&lt;a href=&quot;#泛型程序设计&quot; class=&quot;headerlink&quot; title=&quot;泛型程序设计&quot;&gt;&lt;/a&gt;泛型程序设计&lt;/h3&gt;&lt;p&gt;泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之线段树</title>
    <link href="http://habitdiary.cn/2017/10/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://habitdiary.cn/2017/10/18/算法学习之线段树/</id>
    <published>2017-10-18T15:11:27.000Z</published>
    <updated>2017-10-18T16:23:57.942Z</updated>
    
    <content type="html"><![CDATA[<p>最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  </p><h3 id="线段树是什么？有什么用？"><a href="#线段树是什么？有什么用？" class="headerlink" title="线段树是什么？有什么用？"></a>线段树是什么？有什么用？</h3><p>线段树类似区间树，它在各个节点保存一条线段(数组中的一段子数组)，主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。<br>你可能会问：查询区间和可以用O(n)的复杂度预处理一个前缀和数组，然后就可以O(1)地查询某段区间和;查询区间最值，也就是RMQ问题，也可以用O(nlogn)的复杂度预处理ST表，然后O(1)地查询区间最值。那么为什么要使用线段树呢？<br>线段树的精髓就在于它能在支持<strong>区间动态修改</strong>的前提下保持每个操作O(logn)的复杂度，这是其他两者做不到的。<br>线段树能进行的操作主要有：1)单点更新，区间查询  2)区间更新，区间查询 3)区间更新，单点查询<br>除了上述操作，线段树还可以解决区间染色和矩形面积交、面积并等问题。  </p><h3 id="线段树基本知识"><a href="#线段树基本知识" class="headerlink" title="线段树基本知识"></a>线段树基本知识</h3><p>线段树的结构：<br><img src="/2017/10/18/算法学习之线段树/1.png" alt="fail">  </p><p>建立一个线段树的示意图(可以维护区间和或最值)：<br><img src="/2017/10/18/算法学习之线段树/2.png" alt="fail">  </p><p>单点修改后重新调整线段树：<br><img src="/2017/10/18/算法学习之线段树/3.png" alt="fail">  </p><p>区间查询区间最值：<br><img src="/2017/10/18/算法学习之线段树/4.png" alt="fail">  </p><p>线段树的结点关系:<br><img src="/2017/10/18/算法学习之线段树/5.png" alt="fail">  </p><h3 id="线段树的代码实现"><a href="#线段树的代码实现" class="headerlink" title="线段树的代码实现"></a>线段树的代码实现</h3><p>下面给出建立线段树和进行各种操作的模板，关键点在代码的注释中有解释：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*node：区间结点号begin：该node的区间左边界end：该node的区间右边界</span></div><div class="line"><span class="comment">  left：查询区间的左边界right：查询区间的右边界pos：查询区间的点*/</span> </div><div class="line">  </div><div class="line"><span class="comment">/*线段树:求和或最值 </span></div><div class="line"><span class="comment">单点更新,区间查询</span></div><div class="line"><span class="comment">区间更新,单点查询(lazy标记表示本节点的信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。lazy初始为0,区间加上k给该区间管理的结点的lazy加k,push_down给子节点加(end-begin+1)*k)</span></div><div class="line"><span class="comment">区间更新,区间查询 </span></div><div class="line"><span class="comment">lson 2*node</span></div><div class="line"><span class="comment">rson 2*node+1</span></div><div class="line"><span class="comment">[begin,end]</span></div><div class="line"><span class="comment">[begin,mid] [mid+1,end] 其中mid为(begin+end)/2 */</span> </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1) </span></div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> lazy[maxn*<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;<span class="comment">//pushUp自底向上更新区间和与最值 </span></div><div class="line">segTree[node]=segTree[lson]+segTree[rson];<span class="comment">//segTree[node]=max(segTree[lson],segTree[rson]) </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//pushDown自顶向下更新lazy数组和给结点加上lazy数组的值 </span></div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;<span class="comment">//lazy[node]为0直接return </span></div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node]; </div><div class="line">lazy[lson]+=lazy[node]; </div><div class="line">lazy[rson]+=lazy[node];<span class="comment">//给左右孩子传递lazy,是+=不是=，因为孩子节点可能被多次延迟标记又没有向下传递 </span></div><div class="line">lazy[node]=<span class="number">0</span>;<span class="comment">//把父节点的lazy置为0 </span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//建树 </span></div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;<span class="comment">//begin==end表示管理的是结点 </span></div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);<span class="comment">//按照顺序输入结点，由于建树类似于树的先根遍历，所以建立的线段树的叶子结点从左到右的值就是输入的顺序 </span></div><div class="line"><span class="comment">//segTree[node]=a[begin] 用于任意顺序输入,先将输入存入a数组,下标从1开始，begin = end = index </span></div><div class="line"><span class="keyword">return</span>;<span class="comment">//输入完成后要return，否则会继续访问左右孩子，可能越界</span></div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//单点更新 </span></div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;<span class="comment">//管理的区间不包含pos,直接return </span></div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125; </div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//区间查询 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查询结点和区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];<span class="comment">//查询区间包含查询结点 </span></div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//int maxx=-1</span></div><div class="line">sum+=query(lson,begin,mid,left,right);<span class="comment">//maxx=max(maxx,query(lson,begin,mid,left,right))</span></div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);<span class="comment">//maxx=max(maxx,query(rson,mid+1,end,left,right))</span></div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//区间更新 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;<span class="comment">//结点和更新区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;<span class="comment">//更新区间包含结点 </span></div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="一、单点更新，区间查询"><a href="#一、单点更新，区间查询" class="headerlink" title="一、单点更新，区间查询"></a>一、单点更新，区间查询</h4><p>HDU1166 敌兵布阵<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1166</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> T,N,a,b;</div><div class="line"><span class="keyword">char</span> command[<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,cas++);</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,command)!=EOF)&#123;</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'E'</span>) <span class="keyword">break</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)</div><div class="line"><span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,<span class="number">1</span>,N,a,b)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'A'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,b);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'S'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,-b);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1754 I Hate It<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1754</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> N,M,A,B;</div><div class="line"><span class="keyword">char</span> C[<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=max(segTree[lson],segTree[rson]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=k;<span class="comment">//直接修改</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line"><span class="keyword">int</span> maxx=<span class="number">0</span>;</div><div class="line">maxx=max(maxx,query(lson,begin,mid,left,right));</div><div class="line">maxx=max(maxx,query(rson,mid+<span class="number">1</span>,end,left,right));</div><div class="line"><span class="keyword">return</span> maxx;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M)!=EOF)&#123;</div><div class="line"> build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"> <span class="keyword">while</span>(M--)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,C,&amp;A,&amp;B);</div><div class="line"><span class="keyword">if</span>(C[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B);</div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="二、区间更新，区间查询"><a href="#二、区间更新，区间查询" class="headerlink" title="二、区间更新，区间查询"></a>二、区间更新，区间查询</h3><p>POJ 3468 A Simple Problem with Integers<br>题目链接:<a href="http://poj.org/problem?id=3468" target="_blank" rel="external">http://poj.org/problem?id=3468</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line">ll segTree[<span class="number">4</span>*maxn];</div><div class="line">ll lazy[<span class="number">4</span>*maxn];</div><div class="line">ll N,Q,A,B,C;</div><div class="line"><span class="keyword">char</span> command[<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(ll node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node];</div><div class="line">lazy[lson]+=lazy[node];</div><div class="line">lazy[rson]+=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll node,ll begin,ll end,ll left,ll right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line">ll sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll node,ll begin,ll end,ll left,ll right,ll k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,command);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;A,&amp;B,&amp;C);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B,C);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1698 Just A Hook<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1698" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1698</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> lazy[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> T,N,Q,X,Y,Z;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=<span class="number">1</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]=(mid-begin+<span class="number">1</span>)*lazy[node];<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">segTree[rson]=(end-mid)*lazy[node];</div><div class="line">lazy[lson]=lazy[node];</div><div class="line">lazy[rson]=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]=(end-begin+<span class="number">1</span>)*k;<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">lazy[node]=k;<span class="comment">//+=改成=,因为此时lazy即使没有下传也不叠加</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;X,&amp;Y,&amp;Z);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,X,Y,Z);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: The total value of the hook is %d.\n"</span>,cas++,query(<span class="number">1</span>,<span class="number">1</span>,N,<span class="number">1</span>,N));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、区间染色问题"><a href="#三、区间染色问题" class="headerlink" title="三、区间染色问题"></a>三、区间染色问题</h3><p>ZOJ 1610 Count the Colors<br>题目链接:<a href="https://vjudge.net/problem/11553/origin" target="_blank" rel="external">https://vjudge.net/problem/11553/origin</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 8005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> col[maxn*<span class="number">4</span>];<span class="comment">//col[node]表示node管辖的区间的颜色 </span></div><div class="line"><span class="keyword">int</span> sum[maxn];<span class="comment">//表示某点的颜色 </span></div><div class="line"><span class="keyword">int</span> res[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">col[lson]=col[rson]=col[node];</div><div class="line">col[node]=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">col[node]=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(col[node]!=<span class="number">-1</span>) pushDown(node);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"><span class="comment">//不用建树,直接在query里存储颜色即可，因为染色不用求区间和或者最值 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">sum[begin]=col[node];<span class="comment">//存储每个点的颜色 </span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid,left,right);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> n,x1,x2,c;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</div><div class="line"><span class="built_in">memset</span>(col,<span class="number">-1</span>,<span class="keyword">sizeof</span>(col));</div><div class="line"><span class="built_in">memset</span>(sum,<span class="number">-1</span>,<span class="keyword">sizeof</span>(sum));</div><div class="line"><span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x1,&amp;x2,&amp;c);</div><div class="line"><span class="keyword">if</span>(x1==x2) <span class="keyword">continue</span>;<span class="comment">//为了保证R-1&gt;=L </span></div><div class="line">update(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,x1,x2<span class="number">-1</span>,c);<span class="comment">//为防止重叠,更新区间[L,R-1]</span></div><div class="line"><span class="comment">/*注意begin=0 end=maxn-1 而不是begin=1 end=n 因为只是涂n次,不一定在1-n范围内涂 */</span> </div><div class="line">&#125;</div><div class="line">query(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++) &#123;</div><div class="line">            <span class="keyword">while</span>(i!=<span class="number">0</span>&amp;&amp;sum[i]!=<span class="number">-1</span>&amp;&amp;sum[i]==sum[i<span class="number">-1</span>])<span class="comment">//涂过同一颜色也加1 </span></div><div class="line">            i++;</div><div class="line">            res[sum[i]]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</div><div class="line"><span class="keyword">if</span>(res[i])</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,res[i]);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>POJ 2528 Mayor’s posters<br>题目链接:<a href="http://poj.org/problem?id=2528" target="_blank" rel="external">http://poj.org/problem?id=2528</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*解法：离散化，如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的</span></div><div class="line"><span class="comment">      1   2   3   4  6   7   8   10</span></div><div class="line"><span class="comment">      —   —   —   —  —   —   —   —</span></div><div class="line"><span class="comment">      1   2   3   4  5   6   7   8</span></div><div class="line"><span class="comment">离散化  X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10</span></div><div class="line"><span class="comment">于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。</span></div><div class="line"><span class="comment">但是只是这样简单的离散化是错误的，</span></div><div class="line"><span class="comment">如三张海报为：1~10 1~4 6~10</span></div><div class="line"><span class="comment">离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10</span></div><div class="line"><span class="comment">第一张海报时：墙的1~4被染为1；</span></div><div class="line"><span class="comment">第二张海报时：墙的1~2被染为2，3~4仍为1；</span></div><div class="line"><span class="comment">第三张海报时：墙的3~4被染为3，1~2仍为2。</span></div><div class="line"><span class="comment">最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。</span></div><div class="line"><span class="comment">新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）</span></div><div class="line"><span class="comment">X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10</span></div><div class="line"><span class="comment">这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3</span></div><div class="line"><span class="comment">最终，1~2为2，3为1，4~5为3，于是输出正确结果3。*/</span> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></div><div class="line"><span class="comment">//不用建树,直接在query里记录hash即可，因为染色不用求区间和或者最值，也不用pushUp </span></div><div class="line"><span class="keyword">int</span> m, li[maxn], ri[maxn];</div><div class="line"><span class="keyword">int</span> poster[maxn&lt;&lt;<span class="number">3</span>], col[maxn&lt;&lt;<span class="number">4</span>], ans; <span class="comment">//col记录当前该位置最上面一层的海报种类,即染色问题的颜色 </span></div><div class="line"><span class="comment">//poster记录海报位置 </span></div><div class="line"><span class="keyword">bool</span> hash[maxn];<span class="comment">//hash用于标记某种种类的海报是否计算过,若已计算过标记为true,不再重复计算 </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">     col[lson] = col[rson] = col[node];<span class="comment">//类似lazy标记，向下传递后清空</span></div><div class="line">     col[node] = <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin, <span class="keyword">int</span> end,<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (begin &gt;= left &amp;&amp; end &lt;= right) &#123;</div><div class="line">         col[node] = k;</div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">    <span class="keyword">if</span>(col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    update(lson,begin,mid,left,right,k);</div><div class="line">    update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (begin == end) &#123;</div><div class="line">        <span class="keyword">if</span> (!hash[col[node]]) &#123;</div><div class="line">        ans++;</div><div class="line">        hash[col[node]] = <span class="literal">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> hh, <span class="keyword">int</span> xx)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mm;</div><div class="line">    <span class="keyword">while</span> (ll &lt;= hh) &#123;</div><div class="line">        mm = (ll + hh) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (poster[mm] == xx) <span class="keyword">return</span> mm;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (poster[mm] &gt; xx)  hh = mm - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> ll = mm + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> t, n, i;</div><div class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;t);</div><div class="line">    <span class="keyword">while</span> (t--) &#123;</div><div class="line">        <span class="built_in">memset</span>(col, <span class="number">-1</span>, <span class="keyword">sizeof</span> (col));<span class="comment">//-1表示没有染色</span></div><div class="line">        <span class="built_in">memset</span> (hash, <span class="literal">false</span>, <span class="keyword">sizeof</span> (hash));<span class="comment">/*因为本题墙的长度为10000000,</span></div><div class="line"><span class="comment">直接做会超时,而实际海报数量只有10000,考虑把每张海报左右两端的两段映射到小范围计算，</span></div><div class="line"><span class="comment">所以考虑离散化,但传统离散化会出错,要如果有两个位置相邻的数字数值不相邻,考虑在中间</span></div><div class="line"><span class="comment">插入一个比大的数小1的数*/</span></div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;n);</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">             <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;li[i], &amp;ri[i]);</div><div class="line">             poster[++cnt] = li[i];</div><div class="line">             poster[++cnt] = ri[i];</div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+cnt+<span class="number">1</span>);</div><div class="line">        m = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</div><div class="line">             <span class="keyword">if</span> (poster[i] != poster[i<span class="number">-1</span>]) poster[++m] = poster[i];<span class="comment">//去重 </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i = m; i &gt; <span class="number">1</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (poster[i] - poster[i<span class="number">-1</span>] &gt; <span class="number">1</span>) poster[++m] = poster[i] - <span class="number">1</span>;<span class="comment">//在末尾加入要增加的点 </span></div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+m+<span class="number">1</span>);<span class="comment">//重新排序 </span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            <span class="keyword">int</span> l = binarySearch(<span class="number">1</span>, m, li[i]);<span class="comment">//在离散化后的poster数组里二分查找每一组的左右端点</span></div><div class="line">            <span class="keyword">int</span> r = binarySearch(<span class="number">1</span>, m, ri[i]);</div><div class="line">            update(<span class="number">1</span>,<span class="number">1</span>,m,l,r,i);</div><div class="line">        &#125;</div><div class="line">        ans = <span class="number">0</span>;</div><div class="line">        query(<span class="number">1</span>, <span class="number">1</span>, m);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、矩形面积交-面积并"><a href="#四、矩形面积交-面积并" class="headerlink" title="四、矩形面积交/面积并"></a>四、矩形面积交/面积并</h3><p>HDU 1542 Atlantis(矩形面积并)<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1542" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1542</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"><span class="comment">//沿x轴扫描,沿y轴建树,线段树的结点是纵向的线段,最下面一层结点以排序后相邻的y1,y2为边界 </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>     //  存储线段信息；</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> x;   <span class="comment">//  该线段的x坐标；</span></div><div class="line">    <span class="keyword">double</span> y_up,y_down;     <span class="comment">//  竖向线段的上下端点；</span></div><div class="line">    <span class="keyword">int</span> flag;<span class="comment">//矩形的左边界为1,右边界为-1 </span></div><div class="line">&#125;line[maxn];</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>//线段树的结点,不再是单个点,是一个区间 </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> l,r;<span class="comment">//区间的左右边界,即某段扫描线的上下端点 </span></div><div class="line">    <span class="keyword">double</span> x;       <span class="comment">//  记录上一个横坐标位置，用于求面积；</span></div><div class="line">    <span class="keyword">int</span> cover;      <span class="comment">//  记录覆盖的线段数;即同一方向的线段数;由flag累加 </span></div><div class="line">    <span class="keyword">bool</span> flag;      <span class="comment">//  标记只有一个区间的节点,即在线段树最底层的结点,我们将一个个连续的区间离散化成一个结点；</span></div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>      <span class="comment">//  建树；</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    node[rt].l=y[l];    <span class="comment">//  维护区间；</span></div><div class="line">    node[rt].r=y[r];</div><div class="line">    node[rt].x=<span class="number">-1</span>;</div><div class="line">    node[rt].flag=<span class="literal">false</span>;</div><div class="line">    node[rt].cover=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;             <span class="comment">//  区间是连续的;</span></div><div class="line">        node[rt].flag=<span class="literal">true</span>; <span class="comment">//  标记为结点; </span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    build(lson,l,mid);</div><div class="line">    build(rson,mid,r);   <span class="comment">//  因为将一个个连续区间离散成点，所以此处mid不需要+1；</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span> </span></div><div class="line"><span class="function"><span class="comment">/*查询+更新x处（l,r）区间面积，l和r代表的是区间查询区间的边界，node[rt].l和node[rt].r代表的是结点边界*/</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//  该方向结点不包含所要查询的区间；</span></div><div class="line">    <span class="keyword">if</span>(node[rt].flag)&#123;  <span class="comment">//  找到只有一个区间的叶子结点；</span></div><div class="line">        <span class="keyword">if</span>(node[rt].cover&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">double</span> pre=node[rt].x;</div><div class="line">            <span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l); <span class="comment">//  计算面积；</span></div><div class="line">            node[rt].x=x;       <span class="comment">//  更新定位x位置，便于下次计算面积；</span></div><div class="line">            node[rt].cover+=flag;   <span class="comment">//  更新覆盖的线段数；</span></div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">            node[rt].x=x;</div><div class="line">            node[rt].cover+=flag;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没有产生面积并也要return 0 </span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> ans1,ans2;</div><div class="line">    ans1=Insert_query(lson,x,l,r,flag);    </div><div class="line">    ans2=Insert_query(rson,x,l,r,flag); </div><div class="line">    <span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> x1,x2,y1,y2;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</div><div class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">            y[cnt]=y1;</div><div class="line">            line[cnt].x=x1;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">1</span>;   <span class="comment">//  表示左边线段；</span></div><div class="line">            y[cnt]=y2;</div><div class="line">            line[cnt].x=x2;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">-1</span>;  <span class="comment">//  表示右边线段；</span></div><div class="line">        &#125;</div><div class="line">        sort(y,y+cnt);        <span class="comment">//  将所有高度由小到大排序，将区间建树表示</span></div><div class="line">        sort(line,line+cnt,cmp);      <span class="comment">//  因为扫描线从左到右扫描，所以按照横坐标从小到大排序后逐一插入线段树</span></div><div class="line">        build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line">        <span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">            area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2lf\n\n"</span>,++Case,area);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1255 覆盖的面积(矩形面积交)<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1255" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1255</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> T,N;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>&#123;</span></div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">double</span> y_up,y_down;</div><div class="line"><span class="keyword">int</span> flag;</div><div class="line">&#125;line[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></div><div class="line"><span class="keyword">double</span> l,r;</div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">int</span> cover;</div><div class="line"><span class="keyword">bool</span> flag;</div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</div><div class="line">node[rt].l=y[l];</div><div class="line">node[rt].r=y[r];</div><div class="line">node[rt].x=<span class="number">-1</span>;</div><div class="line">node[rt].flag=<span class="literal">false</span>;</div><div class="line">node[rt].cover=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;</div><div class="line">node[rt].flag=<span class="literal">true</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,l,mid);</div><div class="line">build(rson,mid,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(node[rt].flag)&#123;</div><div class="line"><span class="keyword">if</span>(node[rt].cover&gt;<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">double</span> pre=node[rt].x;</div><div class="line"><span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l);</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">double</span> ans1,ans2;</div><div class="line">ans1=Insert_query(lson,x,l,r,flag);</div><div class="line">ans2=Insert_query(rson,x,l,r,flag);</div><div class="line"><span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line"><span class="keyword">while</span>(N--)&#123;</div><div class="line"><span class="keyword">double</span> x1,y1,x2,y2;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">y[cnt]=y1;</div><div class="line">line[cnt].x=x1;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">1</span>;</div><div class="line">y[cnt]=y2;</div><div class="line">line[cnt].x=x2;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">sort(y,y+cnt);</div><div class="line">sort(line,line+cnt,cmp);</div><div class="line">build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line"><span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,area);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  &lt;/p&gt;
&lt;h3 id=&quot;线段树是什么？有什么用？&quot;&gt;&lt;a href=&quot;#线段树是什么？有什么用？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="算法" scheme="http://habitdiary.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之抽象类、接口、lambda表达式与内部类</title>
    <link href="http://habitdiary.cn/2017/10/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://habitdiary.cn/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/</id>
    <published>2017-10-16T00:52:06.000Z</published>
    <updated>2017-11-03T03:18:36.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它子类的共同特征。<strong>如果一个父类设计得非常抽象，以至于它没有任何具体的实例，这样的类称为抽象类，使用abstract关键字修饰。抽象类定义了相关子类的共同行为。</strong>  </p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果一个方法非常抽象，只定义了方法，没有提供方法的具体实现，那么我们把它定义为一个抽象方法，它的具体实现由子类提供，即子类覆盖抽象方法提供方法体。<br>抽象方法由abstract关键字修饰，只有方法头，没有花括号和方法体，以分号结尾。比如一个GeometricObject类定义了一个名为getArea的抽象方法，即<code>public abstract double getArea();</code> </p><h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><p>1.抽象方法应该定义为public，以便子类进行重写。<br>2.抽象类的构造器应该定义为protected，因为抽象类不能通过new直接创建实例，其构造器只被子类调用。创建一个具体子类的实例时，它的父类的构造器被调用以初始化父类中定义的数据域。<br>3.一个包含抽象方法的类必须定义为抽象类，一个不包含抽象方法的类也可以定义为抽象类(如果不想让某类创建实例，可以把它定义为抽象类)<br>4.如果子类继承抽象类时没有覆盖其所有的抽象方法，即子类中仍有抽象方法，子类也应该定义为抽象的<br>5.抽象方法是非静态的<br>6.子类可以覆盖父类的方法并将它定义为abstract,这种情况很少见，但它在当父类方法实现在子类中变得无效时是很有用的，在这种情况下，子类必须定义为abstract<br>7.即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object是具体的，但它的子类GeometricObject是抽象的。<br>8.不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。下面的语句创建一个GeometricObject类型的数组是正确的：<code>GeometricObject[] objects = new GeometricObject[10];</code>然后可以创建一个具体子类的实例并把它的引用赋给数组，如：<code>Objects[0] = new Circle();</code></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在很多方面都与抽象类很相似，但它的目的是指明<strong>相关或者不相关类</strong>的多个对象的共同行为，属性成员都是<strong>公共静态常量</strong>，成员方法都是<strong>公共抽象方法</strong>。例如，使用正确的接口，可以指明这些对象是可比较的、可克隆的。为了区分接口和类，Java采用Interface关键字定义接口。在一个java文件内，只能有一个public类或一个public接口，即public类和public接口不能同文件共存。接口没有构造器，没有实例域，也不能使用new操作符创建实例。接口没有构造器的原因有三点：<br>1.构造器用于初始化成员变量，接口没有成员变量，不需要构造器<br>2.类可以实现多个接口，如果多个接口都有构造方法，不好确定构造方法链的调用次序<br>3.作为高度抽象的概念，接口不能实例化对象，也就不需要构造器  </p><p>像常规类一样，每个接口都被编译为独立的字节码文件，可以作为引用变量的数据类型和类型转换的结果，可以使用instanceof关键字等。<br>类实现接口用implements关键字，一个类可以实现多个接口，用逗号隔开即可。一个接口可以继承多个接口，用extends关键字。<br>在定义接口中的数据域和方法时可以简写，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>可简写成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要注意接口中所有的数据域都是public static final，所有的方法都是public abstract，在定义接口中允许省略修饰符，但在子类重写方法时不可缺省public修饰符，否则方法的可见性会缩小为包内可见。  </p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>从Java SE 8开始，允许在接口中增加静态方法，理论上讲是可以的，但这有违于接口作为抽象规范的初衷。  </p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>可以为接口方法提供一个默认实现，用default修饰符标记，这样子类无需重写这个方法也能得到一个接口的默认实现。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样实现Collection的程序员就不用操心实现isEmpty方法了。<br>默认方法的一个重要用法是<strong>“接口演化”</strong>。以Collection接口为例，这个接口作为Java的一部分已经很多年了，假设很久以前定义了一个实现Collection接口的类Bag。后来在Collection接口中增加了一个stream方法，假设stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。如果不重新编译这个类，而是使用原先包含这个类的JAR文件，这个类仍能正常加载，正常构造实例，但如果在一个Bag实例上调用stream方法，会出现一个AbstractMethodError。<strong>但如果把stream方法定义为默认方法就可以解决这个问题，既可以重新编译也可以使用JAR文件加载类并调用stream方法。</strong>  </p><h3 id="解决默认方法的冲突"><a href="#解决默认方法的冲突" class="headerlink" title="解决默认方法的冲突"></a>解决默认方法的冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生冲突。解决冲突规则如下：<br>1) 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。<br>2) 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突，即从中选择一个方法重写。</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable接口定义了compareTo方法，用于比较对象。当想使用Arrays类的sort方法对对象数组进行排序时，对象所属的类必须实现了Comparable接口。<br>Comparable接口是一个带泛型的接口，定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> compareTo应该与equals保持一致，即当且仅当o1.equals(o2)为true时，o1.compareTo(o2) == 0成立。以下是compareTo方法的实现：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> Double.compare(salary,other.salary);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> <strong>在比较浮点数时可以使用Double的静态方法compare,这样就不必担心溢出或精度损失，类似的还有Integer.compare方法等</strong><br> <strong>继承过程中的compareTo，如果由子类决定相等的概念，每个compare方法都应该在开始时检测：<code>if(getClass() != other.getClass()) throw new ClassCastException()</code></strong>：<strong>如果父类决定相等的概念，应该在超类中提供一个compareTo方法，并将这个方法声明为final。</strong>  </p><h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p> Comparator接口意为”比较器”接口，是一个泛型接口，可用于自定义排序规则和大小比较等。要进行自定义排序，Arrays.sort方法有一个重载版本，需要提供一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。接口定义为：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first,T second)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 如果要按长度比较字符串，由于String是按字典序比较字符串，肯定不能让String类用两种方法实现compareTo方法 —— 况且String类也不由我们修改。此时可以定义如下实现Comparator<string>的类：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">lengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first,String second)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> first.length() - second.length();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p><p> 因为要调用compare方法，所以具体比较大小和排序时都要创建一个lengthComparator的实例：<br> <strong>大小比较</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> LengthComparator();</div><div class="line"><span class="keyword">if</span>(comp.compare(words[i],words[j]) &gt; <span class="number">0</span>) ...</div></pre></td></tr></table></figure></p><p> <strong>自定义排序</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] friends = &#123;<span class="string">"Peter"</span>,<span class="string">"Paul"</span>,<span class="string">"Mary"</span>&#125;;</div><div class="line">Arrays.sort(friends,<span class="keyword">new</span> LengthComparator());</div></pre></td></tr></table></figure></p><h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h3><p> 首先，我们考虑为一个包含对象引用的变量建立副本会发生什么，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Employee original = <span class="keyword">new</span> Employee(<span class="string">"John Public"</span>,<span class="number">50000</span>);</div><div class="line">Employee copy = original;</div><div class="line">copy.ratseSalary(<span class="number">10</span>); <span class="comment">//original的salary也被改变</span></div></pre></td></tr></table></figure></p><p> 原变量和副本都会指向同一个对象，这说明，任何一个变量的改变都会影响到另一个变量。如果有一个对象original，希望创建一个对象copy使得其初始状态与original相同，但是之后它们各自回有自己不同的状态，这种情况下就可以使用克隆，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee copy = original.clone();</div><div class="line">copy.raiseSalary(<span class="number">10</span>); <span class="comment">//original的salary不会被改变</span></div></pre></td></tr></table></figure></p><p>Object类中的clone方法将原始对象的每个数据域复制给目标对象，如果一个数据域是基本数据类型，复制的就是它的值，如果是引用类型，复制的就是它的引用，这种克隆称为<strong>浅复制</strong>,即original != copy,但original.hireDay == copy.hireDay。这有时是不符合我们要求的，我们不希望在改变某个对象的引用类型的数据域时影响到另一个对象，这时我们需要<strong>深复制</strong>,即如果数据域是引用类型，复制的是对象的内容而不是引用。<br>无论是<strong>浅复制</strong>还是<strong>深复制</strong>，我们都需要先实现Cloneable接口，否则会产生一个必检异常。Cloneable接口的定义是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们发现这个接口是空的，一个带空体的接口称为标记接口。一个标记接口既不包括常量也不包括方法，它用来表示一个类拥有的某些特定的属性，其惟一的作用是允许在类型查询中使用instanceof关键字。但如果一个请求克隆的对象不实现这个接口，会产生CloneNotSupportedException，即使clone的默认(浅拷贝)实现能够满足要求，还是要实现这一接口。在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone方法，这个方法是从Object类继承的，这个接口只是作为一个标记。  </p><p>Object类中提供的原始clone方法的方法头是<code>protected native Object clone() throws CloneNotSupportedException</code>,关键字native表明这个方法不是用Java写的，但它是JVM针对自身平台实现的。关键字protected限定方法只能在同一个包内或在其子类中访问。由于这个原因：<strong>必须在要实现克隆的子类中覆盖这个方法并把可见性修饰父改为public</strong>。<br>下面给出一个浅复制的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> (Employee) <span class="keyword">super</span>.clone();</div><div class="line">    &#125;</div><div class="line">    . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出一个深复制的例子：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">     . . .</div><div class="line">     Employee cloned = (Employee) <span class="keyword">super</span>.clone;</div><div class="line">     cloned.hireDay = (Date)hireDay.clone();</div><div class="line">     <span class="keyword">return</span> cloned;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们注意到Object类的clone方法的返回值类型是Object，而Employee类的clone方法返回值类型是Employee，这叫做协变返回类型，即<strong>子类在重写父类方法时可以返回父类返回值类型的子类型</strong>。clone方法声明异常也可以改成捕获异常，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">Employee cloned = (Employee) <span class="keyword">super</span>.clone();</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(CloneNotSupportedException e)&#123; <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="复制数组的四种方法"><a href="#复制数组的四种方法" class="headerlink" title="复制数组的四种方法"></a>复制数组的四种方法</h3><p>1.申请一个新数组，遍历原数组逐一复制元素<br>2.使用System类的静态方法arraycopy<br>3.使用<code>数组对象.clone</code>返回一个数组克隆的引用<br>4.使用Arrays类的copyOf方法  </p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>区别：<br>1.接口所有的变量必须是public static final;抽象类的变量无限制<br>2.接口没有构造方法，不能用new操作符实例化;抽象类有构造方法，由子类通过构造方法链调用，不能用new操作符实例化<br>3.接口所有方法必须是公共抽象实例方法(Java SE 8开始允许定义静态方法)，抽象类无限制<br>4.一个类只可以继承一个父类，但可以实现多个接口<br>5.所有的类有一个共同的根Object类，接口没有共同的根<br>6.抽象类和子类的关系应该是强的“是一种”关系(strong is-a relationship),而接口和子类的关系是弱的”是一种”关系(weak is-a relationship)。接口比抽象类更灵活，因为实现接口的子类只需要具有统一的行为即可，不需要都属于同一个类型的类。</p><h3 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h3><p> 回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下按钮或选择某个菜单项时应该采取什么行动。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p> 内部类，或者称为嵌套类，是一个定义在另一个类范围中的类。一个内部类可以如常规类一样使用。通常，在一个类只被它的外部类所使用的时候，才将它定义为内部类，内部类机制主要用于设计具有互相协作关系的类集合。比如：  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//OuterClass.java: inner class demo</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line">   <span class="comment">/** A method in the outer class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="comment">//Do something</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// An inner class</span></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">   <span class="comment">/** A method in the inner class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mi</span><span class="params">()</span></span>&#123;</div><div class="line">   data++;</div><div class="line">       m();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 为什么要使用内部类，主要原因有三：<br> 1.内部类可以访问包含它的外部类的所有数据域(包括私有数据域)和方法，没有必要将外部类对象的引用传递给内部类的构造方法,内部类有一个指向外部类对象的隐式引用，如果显式写出，外部类的引用是OuterClass.this<br> 2.内部类可以对同一个包中的其他类隐藏起来<br> 3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷  </p><p> 内部类具有一下特征：<br> 1) 一个内部类被编译成一个名为<code>OuterClassName$InnerClassName</code>的类。例如，一个定义在Test类中的内部类A被编译成<code>Test$A.class</code><br> 2) 一个内部类可以使用可见性修饰符(public、private、protected、default)所定义，和应用于一个类中成员的可见性规则一样<br> 3) 一个内部类可以被定义为static，一个static的内部类可以使用外部类的名字访问,一个static内部类不能访问外部类中的非静态成员<br> 4) 内部类对象通常在外部类中创建，但是你也可以从另外一个类中来创建一个内部类的对象。如果内部类是非静态的，你必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类对象：<code>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</code> 如果内部类是静态的，使用下面语法来创建一个内部类对象:<code>OuterClass.InnerClass innerObject = new OuterClass.InnerClass();</code><br> 5) 内部类所有的静态域必须是final修饰的<strong>静态常量</strong>,不能有静态变量，也不能有静态方法</p><p> 一个简单的内部类的用途是将相互依赖的类结合到一个主类中，这样做减少了源文件的数量(因为非内部类如果用public修饰必须放在不同的源文件中，而内部类可放在同一源文件中)，这样也使得类文件容易组织，因为它们都将主类名作为前缀。另外一个内部类的实际用途是避免类名冲突。  </p><p> 内部类对于定义处理器类非常有用，一个处理器类被设计为针对一个GUI组件创建一个处理器对象(比如，一个按钮)。处理器类不会被其他应用所共享，所以将它定义在主类里面作为一个内部类使用是恰如其分的。  </p><p>广泛意义上的内部类一般来说包括四种：<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>和<strong>静态内部类</strong>。下面就先来了解一下这四种内部类的用法。  </p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p> 　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></div><div class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>  这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。<br>  　不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<code>外部类.this.成员变量 外部类.this.成员方法</code></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p> 可以把内部类定义在一个方法中，称为局部内部类。<strong>局部内部类就像是方法里面的一个局部变量一样，不能有public、protected、private以及static修饰符。它的作用域被限定在声明这个局部类的块中。</strong>局部类有一个优势，即对外部世界完全隐藏起来。即使外部类中的其他代码也不能访问它。除了其所在的方法之外，没有任何方法知道该局部类的存在。<strong>局部内部类只能访问被final修饰的局部变量。</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></div><div class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p> 一个匿名内部类是一个没有名字的内部类，其语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> SuperClassName/InterfaceName()&#123;</div><div class="line"><span class="comment">//implement or override methods in superclass or interface</span></div><div class="line">   </div><div class="line">    <span class="comment">//Other methods if necessary</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> 其含义是<strong>创建一个继承自SuperClass或实现Interface的类的实例，并在类块内重写父类或接口的抽象方法</strong>，应该将匿名内部类理解成<strong>一个匿名子类的匿名对象</strong>,而不是理解成一个类。  </p><p> 匿名内部类有如下特征：<br> 1.没有可见性修饰符<br> 2.没有构造方法(因为没有名字,无法命名构造方法),但可以调用父类的构造方法，即<code>new SuperClassName()</code>调用父类无参构造方法，<code>new SuperClassName(args1,...)</code>调用父类有参构造方法。如果实现的是接口，则不能有任何参数，但是小括号仍然不可缺省<br> 3.必须总是从一个父类继承或者实现一个接口，但是它不能有显式的extends或者implements子句<br> 4.必须实现父类或接口中的所有抽象方法<br> 5.一个匿名内部类被编译成一个名为OuterClassName$n.class的类，例如：如果外部类Test有两个匿名内部类，分别被编译成Test$1.class和Test$2.class  </p><p> <strong>应用一</strong><br> 下面的技巧称为<strong>“双括号初始化”</strong>，这里利用了内部类语法。假设你想构造一个数组列表，并将它传递到一个方法。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">friends.add(<span class="string">"Harry"</span>);</div><div class="line">friends.add(<span class="string">"Tony"</span>);</div><div class="line">invite(friends);</div></pre></td></tr></table></figure></p><p> 如果不再需要这个数组列表，最好让它作为一个匿名列表。语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> invite(<span class="keyword">new</span> ArrayList&lt;String&gt; </div><div class="line"> &#123;</div><div class="line"> &#123;</div><div class="line">    add(<span class="string">"Harry"</span>);</div><div class="line">        add(<span class="string">"Tony"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p> 注意这里的双括号，外括号建立了一个ArrayList的匿名子表，内括号则是一个对象构造块。  </p><p> <strong>应用二</strong><br> 生成日志或调试消息时，通常希望包含当前类的类名，如：<br> <code>System.err.println(&quot;Something awful happened in &quot; + getClass());</code><br> 不过这对于静态方法并不凑效，因为调用getClass()调用的是this.getClass(),但静态方法里没有this，所以应该使用下面的表达式：<code>new Object(){}.getClass().getEnclosingClass()</code>,在这里，new Object(){} 会建立Object的一个匿名子类的匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类 </p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p> 有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象。为此，可以为内部类加上static关键字声明为静态内部类，以便取消产生的引用。与常规内部类不同，静态内部类可以有<strong>静态变量</strong>和<strong>静态方法</strong>。<br> 下面是一个使用静态内部类的典型例子。考虑一下计算一个数组中最大值和最小值的问题，当然，可以编写两个方法，一个计算最大值，一个计算最小值，在调用这两个方法的时候，数组被遍历两次，而如果数组只被遍历一次就可以计算出最大值和最小值，那么效率就大大提高了。通过一个方法就计算出最大值和最小值：这个方法需要返回两个数（max 和 min），为此可以定义一个Pair类来封装这种数据结构，但是Pair是个非常大众的名字，可能在其他地方定义过，会发生名字冲突，此时可以将Pair定义为ArrayAlg类的内部类ArrayAlg.Pair。又因为Pair没有必要访问外围类ArrayAlg的数据域或方法，应该定义为静态内部类。<br> 下面给出代码：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">    <span class="comment">//Pair类，起数据封装的作用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> s)</span></span>&#123;</div><div class="line">            first = f;</div><div class="line">            second = s;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFirst</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> second;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">maxmin</span><span class="params">(<span class="keyword">double</span>[] values)</span></span>&#123;</div><div class="line">        <span class="keyword">double</span> min = Double.POSITIVE_INFNITY;</div><div class="line">        <span class="keyword">double</span> max = Double.NEGATIVE_INFNITY;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> x : values)&#123;</div><div class="line">            <span class="keyword">if</span>(x&lt;min) min = x;</div><div class="line">            <span class="keyword">if</span>(x&gt;max) max = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(max,min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Test te = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">double</span>[] teArgs = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2.13</span>,<span class="number">100.0</span>,<span class="number">11.2</span>,<span class="number">34.5</span>,<span class="number">67.1</span>,<span class="number">88.9</span>&#125;;</div><div class="line">        Pair res = te.maxmin(teArgs);</div><div class="line">        System.out.println(<span class="string">"max = "</span>+res.getFirst());</div><div class="line">        System.out.println(<span class="string">"min = "</span>+res.getSecond());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 特别注意：代码中的Pair类如果没有声明为static，就不能在静态方法minmax中构造Pair的实例，编译器会给出错误报告：没有可用的隐式ArrayAlg类型对象初始化内部类对象  </p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p> lambda表达式可以被看作使用精简语法的匿名内部类，编译器对待一个lambda表达式如同它是从一个匿名内部类创建的对象。它是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda表达式，可以用一种精简的方式表示使用回调或变量行为的代码。如果要编译器理解lambda表达式，其代替的匿名内部类实现的接口必须只包含一个抽象方法，这样的接口被称为函数式接口(功能接口、单抽象方法接口）。在底层，接受lambda表达式的方法会接受实现某函数式接口的类的对象，并在这个对象上调用接口的方法，所以可以把lambda表达式赋给函数式接口(lambda表达式实际是一个实现了该函数式接口的类的类型，这里用到了多态)，不能把lambda表达式赋给Object变量，因为Object不是一个函数式接口。<br> 一个lambda表达式就是一个代码块，以及必须传入代码的变量规范。其基础语法是(expression只有一条语句，不用花括号，也不用分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; expression</div></pre></td></tr></table></figure></p><p> 或者(statements是多条语句，要花括号，每条语句之后要分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; &#123;statements;&#125;</div></pre></td></tr></table></figure></p><p> 一个参数的数据类型既可以显式声明，也可以由编译器隐式推断。如果只有一个参数，并且没有显式的数据类型，圆括号可以被省略。如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">e -&gt; &#123;</div><div class="line"><span class="comment">// Code for processing event e</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 即使lambda表达式没有参数，也要提供空括号，就像无参数方法一样：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span>;i &gt;=<span class="number">0</span> ;i--) System.out.println(i);&#125;</div></pre></td></tr></table></figure></p><p>  无需指定lambda表达式的返回类型，编译器会由上下文推断，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(String first,String second) -&gt; first.length() - second.length()</div></pre></td></tr></table></figure></p><p> 可以在需要int类型结果的上下文中使用  </p><p> 如果一个lambda表达式只在某些分支上返回一个值，而在另外一些分支不返回值，是不合法的。例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> x) -&gt; &#123;<span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</div></pre></td></tr></table></figure></p><p> Comparator接口是一个函数式接口，可以用lambda表达式实现自定义排序的简化：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(words,(first,second) </div><div class="line">-&gt; first.length() - second.length());</div></pre></td></tr></table></figure></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p> 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口。<br> 如果自己设计了一个函数式接口，可以用@FunctionalInterface注解来标记这个接口，这样做有两个好处：<br> 1.可以在你无意中增加一个非抽象方法时产生编译错误<br> 2.javadoc页里会指出你的接口是一个函数式接口</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p> 有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如，假设你希望只要出现一个定时器事件就打印这个事件对象，可以调用：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,event -&gt; System.out.println(event));</div></pre></td></tr></table></figure></p><p> 可以直接把println方法传递到Timer的构造器：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</div></pre></td></tr></table></figure></p><p> 表达式System.out::println是一个方法引用，它等价于lambda表达式<code>x -&gt; System.out.println(x)</code><br> 我们再看一个例子，假设要对字符串排序，而不考虑字母的大小写，可以调用<code>Arrays.sort(strings,String::compareToIgnoreCase);</code></p><p> 方法引用主要有三种情况：  </p><ul><li>object::instanceMethod</li><li>Class::staticMethod  </li><li>Class::instanceMethod    </li></ul><p>对于前两种情况，方法引用等价于提供方法参数的lambda表达式。比如：System.out::println等价于x -&gt; System.out.println(x)，Math::pow等价于(x,y) -&gt; Math.pow(x,y)。第三种情况的第一个参数会称成为调用方法的目标对象，其余参数成为方法参数，比如：String::compareToIgnoreCase等价于(x,y) -&gt; x.compareToIgnoreCase(y)<br>可以在方法里使用this和super,this::equals等同于x -&gt; this.equals(x),super::greet等同于() -&gt; super.greet()  </p><p>类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。  </p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用与方法引用类似，只不过方法名为new。例如<code>Employee::new</code>是Employee构造器的一个引用。至于是哪一个构造器取决于上下文，比如<code>Function&lt;Integer,Employee&gt; func1 = Employee :: new;</code>就相当于<code>Function&lt;Integer,Employee&gt; func = x -&gt; new Employee(x);</code><br>数组类型也有构造器引用，如<code>int[]::new</code>等价于lambda表达式<code>x -&gt; new int[x]</code>  </p><h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>我们之前提到，lambda表达式的重点是<strong>延迟执行</strong>，之所以希望以后再执行代码，有很多原因，如：  </p><ul><li>在一个单独的线程中运行代码  </li><li>多次运行代码  </li><li>在算法的恰当位置运行代码(例如，排序中的比较操作)  </li><li>发生某种情况时执行代码(如，点击了一个按钮、数据到达等) </li><li>只在必要时才运行代码  </li></ul><p>下面是常用的函数式接口和基本类型的函数式接口：  </p><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/1.png" alt="fail" title="常用函数式接口">  </p><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/2.png" alt="fail" title="基本类型的函数式接口"></p><p>下面来看一个简单的例子。假设你想要重复一个动作n次。将这个动作和重复次数传递给一个repeat方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,() -&gt; System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure></p><p>要接受这个lambda表达式，需要选择一个函数式接口。在这里，我们可以使用Runnable接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,Runnable action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </div><div class="line">    action.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在让这个例子更复杂一点，我们希望告诉这个动作它出现在那一次迭代中。为此需要选择一个合适的函数式接口，其中要包含一个方法。这个方法有一个int参数而且返回类型为void。处理int值的标准接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntConsumer</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出repeat方法的改进版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,IntConsumer action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)  action.accept(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以如下调用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,i -&gt; System.out.println(<span class="string">"Countdown: "</span> + (<span class="number">9</span> - i)));</div></pre></td></tr></table></figure></p><p>大多数函数标准函数式接口都提供了非抽象方法来生成或合并函数。例如,Predicate.isEqual(a)等同于a::equals,不过如果a为null也能正常工作。已经提供了默认方法and、or和negate来合并谓词。例如,<code>Predicate.isEqual(a).or(Predicate.isEqual(b))</code>就等同于<code>x -&gt; a.equals(x) || b.equals(x)</code></p><h3 id="通过三种方式实现事件处理器"><a href="#通过三种方式实现事件处理器" class="headerlink" title="通过三种方式实现事件处理器"></a>通过三种方式实现事件处理器</h3><h4 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleEvent</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">HBox pane = <span class="keyword">new</span> HBox(<span class="number">10</span>);</div><div class="line">pane.setAlignment(Pos.CENTER);</div><div class="line">Button btOK = <span class="keyword">new</span> Button(<span class="string">"OK"</span>);</div><div class="line">OKHandlerClass handler1 = <span class="keyword">new</span> OKHandlerClass();</div><div class="line">btOK.setOnAction(handler1);</div><div class="line">Button btCancel = <span class="keyword">new</span> Button(<span class="string">"Cancel"</span>);</div><div class="line">CancelHandlerClass handler2 = <span class="keyword">new</span> CancelHandlerClass();</div><div class="line">btCancel.setOnAction(handler2);</div><div class="line">pane.getChildren().addAll(btOK,btCancel);</div><div class="line"></div><div class="line">Scene scene = <span class="keyword">new</span> Scene(pane,<span class="number">100</span>,<span class="number">50</span>);</div><div class="line">primaryStage.setTitle(<span class="string">"HandleEvent"</span>);</div><div class="line">primaryStage.setScene(scene);</div><div class="line">primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OKHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"OK button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"Cancel button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-匿名内部类"><a href="#2-匿名内部类" class="headerlink" title="2.匿名内部类"></a>2.匿名内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process New"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Open"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Save"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Print"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"AnonymousHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3.lambda表达式"></a>3.lambda表达式</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction((ActionEvent e)-&gt;&#123;System.out.println(<span class="string">"Process New"</span>);&#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction((e)-&gt;&#123;System.out.println(<span class="string">"Process Open"</span>);&#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(e-&gt;&#123;System.out.println(<span class="string">"Process Save"</span>);&#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(e-&gt;System.out.println(<span class="string">"Process Print"</span>));</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"LambdaHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p> 见大牛博客  </p><ul><li><a href="http://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="external">Java的三种代理模式</a>  </li><li><a href="http://blog.csdn.net/pangqiandou/article/details/52964066" target="_blank" rel="external">java中Proxy(代理与动态代理)</a>  </li><li><a href="http://layznet.iteye.com/blog/1182924" target="_blank" rel="external">java静态代理和动态代理</a>  </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之反射</title>
    <link href="http://habitdiary.cn/2017/10/14/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <id>http://habitdiary.cn/2017/10/14/Java学习总结之反射/</id>
    <published>2017-10-14T06:32:15.000Z</published>
    <updated>2017-10-19T06:36:34.912Z</updated>
    
    <content type="html"><![CDATA[<p>　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  </p><h3 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1.什么是反射？"></a>1.什么是反射？</h3><p>　　<strong>反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。</strong>也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。<br>　　要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><h3 id="2-反射的作用"><a href="#2-反射的作用" class="headerlink" title="2.反射的作用"></a>2.反射的作用</h3><p>　　1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制<br>　　2.在运行时分析对象的数据域<br>　　3.实现通用的数组操作代码<br>　　4.利用Method对象，这个对象很像C++中的函数指针  </p><h3 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h3><p>　　我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是<code>java.lang.Class&lt;T&gt;</code>泛型类的一个实例，比如<code>Class&lt;MyClass&gt;</code>对象即为一个封装了MyClass类的定义信息的<code>Class&lt;T&gt;</code>实例，从中我们可以得出结论：万物皆对象，<code>任何类型(包括基本类型和引用类型).class</code>都是<code>java.lang.Class&lt;T&gt;</code>的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于<code>java.lang.Class&lt;T&gt;</code>类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。<br>　　在下面的讲解中，我们将以People类和Student类为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(getName() + <span class="string">" "</span> + getAge());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">(String course)</span> </span>&#123;</div><div class="line">        System.out.println(name + <span class="string">" learn "</span> + course);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h4 id="获取class对象有以下三种"><a href="#获取class对象有以下三种" class="headerlink" title="获取class对象有以下三种:"></a>获取class对象有以下三种:</h4><p> 1) 可以通过<code>类名.class</code>得到相应类的Class对象，如:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;People&gt; peopleClass = People.class;</div></pre></td></tr></table></figure><p>2) 如果已知类的<strong>全限定名称(包含包名)</strong>，可以通过Class的forName静态方法得到类的Class对象，如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class&lt;People&gt; peopleClass = Class.forName(<span class="string">"cn.habitdiary.People"</span>);</div><div class="line"><span class="comment">//假设People类在cn.habitdiary包中</span></div></pre></td></tr></table></figure><p>　　在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">String name = <span class="string">"xxx"</span>;</div><div class="line">    Class c1 = Class.forName(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>3) 可以通过<code>类的实例对象.getClass()</code>得到相应类的Class对象，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People people = <span class="keyword">new</span> People(<span class="string">"Steven"</span>， <span class="number">20</span>);</div><div class="line">Class&lt;People&gt; peopleClass = people.getClass();</div></pre></td></tr></table></figure><p>　　<code>实例对象.getClass().getName()</code> 可以获取当前对象的类的全限定名称(包含包名)<br>　　<code>实例对象.getClass().getSimpleName()</code>可以获取当前对象的类的底层类简称(不含包名)<br>　　<code>实例对象.getClass().getCanonicalName()</code>大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。<br>　　但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName()  </p><p><strong>注意：<br>　　1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象<br>　　2.Class类是一个泛型类，但有时候我们不能提前确定class对象的类型,就可以用<code>Class&lt;?&gt;</code>来代替，即上面代码中的<code>Class&lt;People&gt; peopleClass</code>可以写成<code>Class&lt;?&gt; peopleClass</code><br>　　3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作<br>　　4.getClass()方法返回的是对象实际类型的class对象，而不是声明类型的class对象<br>　　5.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，比如:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s = <span class="string">"java.util.Random"</span>;</div><div class="line">Object m = Class.forName(s).newInstance();</div></pre></td></tr></table></figure><p>　　<strong>如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。</strong>  </p><h3 id="4-在运行时分析类的能力"><a href="#4-在运行时分析类的能力" class="headerlink" title="4.在运行时分析类的能力"></a>4.在运行时分析类的能力</h3><p>　　下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。<br>Java中为了支持反射机制主要提供了以下的类：<br>java.lang.Class<br>java.lang.reflect.Field<br>java.lang.reflect.Constructor<br>java.lang.reflect.Method<br>java.lang.reflect.Modifier  </p><p><strong>java.lang.Class类的常用API如下：</strong>  </p><ul><li>Field[] getFields()   </li><li>Field[] getDeclaredFields()   </li><li>Method[] getMethods()  </li><li>Method[] getDeclaredMethods()      </li><li>Constructor&lt; ? &gt;[] getConstructors()  </li><li>Constructor&lt; ? &gt;[] getDeclaredConstructors() </li><li>Class&lt; ? &gt; getSupperClass() </li><li>Class&lt; ? &gt;[] getInterfaces()</li></ul><p><strong>提示：</strong>getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有、受保护和默认成员，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象</p><p><strong>其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。<br>这三个类的常用API如下：</strong>  </p><ul><li>String getName() 返回一个用于描述域名、构造器或方法的字符串  </li><li>Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象  </li><li>Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)<br>返回一个用于描述方法抛出异常类型的Class对象数组  </li><li>int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值  </li><li>Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组  </li><li>Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象  </li></ul><p><strong>java.lang.reflect.Modifier类的常用API如下</strong>  </p><ul><li>static String toString(int modifiers)<br>返回修饰符对应的字符串描述</li><li>static boolean isAbstract(int modifiers)  </li><li>static boolean isFinal(int modifiers)</li><li>static boolean isInterface(int modifiers)</li><li>static boolean isNative(int modifiers)</li><li>static boolean isPrivate(int modifiers)</li><li>static boolean isProtected(int modifiers)</li><li>static boolean isPublic(int modifiers)</li><li>static boolean isStatic(int modifiers)</li><li>static boolean isStrict(int modifiers)</li><li>static boolean isSynchronized(int modifiers)</li><li>static boolean isVolatile(int modifiers)<br>上述方法检测修饰符是否是某一特定修饰符<br>java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义   </li></ul><p><strong>下面是一个检测类内部结构的例子</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">import</span> java.lang.Class;</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">if</span>(args.length &gt; <span class="number">0</span>) </div><div class="line">name = args[<span class="number">0</span>];</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">System.out.println(<span class="string">"Enter class name (e.g. java.util.Date)"</span>);</div><div class="line">name = in.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Class&lt;?&gt; c1 = Class.forName(name);</div><div class="line">Class&lt;?&gt; superc1 = c1.getSuperclass();</div><div class="line">String modifiers = Modifier.toString(c1.getModifiers());</div><div class="line"><span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) </div><div class="line">System.out.print(modifiers + <span class="string">" "</span> );</div><div class="line">System.out.print(<span class="string">"class "</span> + name);</div><div class="line"><span class="keyword">if</span>(superc1 != <span class="keyword">null</span> &amp;&amp; superc1 != Object.class)</div><div class="line">System.out.print(<span class="string">"  extends "</span>  +  superc1.getSimpleName());</div><div class="line">System.out.print(<span class="string">"\n&#123;\n"</span>);</div><div class="line">printFields(c1);</div><div class="line">System.out.println();</div><div class="line">printConstructors(c1);</div><div class="line">System.out.println();</div><div class="line">printMethods(c1);</div><div class="line">System.out.println(<span class="string">"&#125;"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(ClassNotFoundException e)</div><div class="line">&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.exit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class&lt;?&gt; c1)</span> </span>&#123;</div><div class="line">Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Constructor&lt;?&gt; c : constructors) &#123;</div><div class="line">String name = c.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(c.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = c.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class&lt;?&gt; c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Method[] methods = c1.getDeclaredMethods();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Method m :methods) &#123;</div><div class="line">Class&lt;?&gt; retType = m.getReturnType();</div><div class="line">String name = m.getName();</div><div class="line"></div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(m.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(retType.getSimpleName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = m.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class&lt;?&gt;  c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Field[] Fields = c1.getDeclaredFields();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Field f : Fields) &#123;</div><div class="line">Class&lt;?&gt; type = f.getType();</div><div class="line">String name = f.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(f.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">"  "</span>);</div><div class="line">System.out.println(type.getSimpleName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-在运行时使用反射分析对象"><a href="#5-在运行时使用反射分析对象" class="headerlink" title="5.在运行时使用反射分析对象"></a>5.在运行时使用反射分析对象</h3><p>　　反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。<br>　　查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Employee harry = <span class="keyword">new</span> Empolyee(<span class="string">"Harry Hacker"</span>,<span class="number">35000</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">1989</span>);</div><div class="line">Class&lt;Employee&gt; c1 = harry.getClass();</div><div class="line">Field f = c1.getDeclaredField(<span class="string">"name"</span>); <span class="comment">//返回某一个特定域</span></div><div class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//由于name是私有域，必须先设置为可访问</span></div><div class="line">Object v = f.get(harry);</div></pre></td></tr></table></figure><p>　　上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value  </p><p><strong>下面是一些相关API</strong><br>在java.lang.reflect.Field中：  </p><ul><li>Object get(Object obj)<br>返回obj对象中用Field对象表示的域值</li><li>xxx getXxx(Object obj)<br>返回obj对象的基本类型的域的值</li><li>void set(Object obj,Object newValue)<br>用一个新值设置obj对象中Field对象表示的域    </li></ul><p>在java.lang.Class中：  </p><ul><li>Field getField(String name)<br>返回指定名称的公有域  </li><li>Field getDeclaredField(String name)  </li><li>返回指定名称的声明的域  </li></ul><p>在java.lang.reflect.AccessibleObject中：  </p><ul><li>void setAccessible(boolean flag)<br>为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置  </li><li>boolean isAccessible()<br>返回反射对象的可访问标志的值  </li><li>static void setAccessible(AccessibleObject[] array,boolean flag)<br>批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 </li></ul><h3 id="6-使用反射编写泛型数组代码"><a href="#6-使用反射编写泛型数组代码" class="headerlink" title="6.使用反射编写泛型数组代码"></a>6.使用反射编写泛型数组代码</h3><p>　　java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee[] a = <span class="keyword">new</span> Employee[<span class="number">100</span>];</div><div class="line">a = Arrays.copyOf(a,<span class="number">2</span> * a.length);</div></pre></td></tr></table></figure></p><p>　　我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a,<span class="keyword">int</span> newLength)&#123;</div><div class="line">Object[] newArray = <span class="keyword">new</span> Object[newLength];</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(a.length,newLength);</div><div class="line">    <span class="keyword">return</span> newArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>　　上述代码存在一个错误，即使用了<code>new Object[newLength]</code>创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。<br><strong>为了解决这个问题，下面提供java.lang.reflect.Array中的API</strong>  </p><ul><li>static Object get(Object array,int index)<br>返回对象数组某个位置上的元素</li><li>static xxx getXxx(Object array,int index)<br>(xxx是基本数据类型)返回基本类型数组某个位置上的值 </li><li>static void set(Object array,int index,Object newValue)<br>设置对象数组某个位置上的元素</li><li>static void setXxx(Object array,int index,xxx newValue)<br>(xxx是基本数据类型)设置基本类型数组某个位置上的值 </li><li>static int getLength(Object array)<br>返回数组的长度  </li><li>static Object newInstance(Class componentType,int length)  </li><li><p>static Object newInstance(Class componentType,int[] length)<br>返回一个具有给定类型、给定维数的新数组  </p><p>下面给出正确的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a,<span class="keyword">int</span> newLength)</span></span>&#123;</div><div class="line">&#123;</div><div class="line">Class c1 = a.getClass();<span class="comment">//获取a数组的类对象</span></div><div class="line">    <span class="keyword">if</span>(!c1.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//确认是一个数组</span></div><div class="line">    Class componentType = c1.getComponentType();</div><div class="line">    <span class="comment">//获取数组类型</span></div><div class="line">    <span class="keyword">int</span> length = Array.getLength(a);</div><div class="line">    Object newArray = Array.newInstance(componentType,newLength);</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</div><div class="line">    <span class="keyword">return</span> newArray;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">a = (<span class="keyword">int</span>[]) goodCopyOf(a,<span class="number">10</span>);</div></pre></td></tr></table></figure><p>　　为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型 </p><h3 id="7-调用任意方法"><a href="#7-调用任意方法" class="headerlink" title="7.调用任意方法"></a>7.调用任意方法</h3><p>　　通过反射还可以调用任意方法，这是通过Method类的invoke方法实现的，方法签名是:<code>Object invoke(Object obj,Object... args)</code>,Object obj表示调用方法的对象，Object…args表示方法的参数列表。<br>如果方法是静态方法，将第一个参数设置为null;如果方法是非静态无参方法，第二个参数列表可以忽略。<br>　　例如：<code>String n = (String)m1.invoke(harry);</code>(m1表示Employee类的getName方法)。如果返回值是基本类型，invoke方法会返回其包装器类型,可以利用自动开箱将其还原为基本数据类型。例如:<code>double s = (Double)m2.invoke(harry);</code>(m2表示Employee类的getSalary方法)<br>getMethods方法和getDeclaredMethods会返回一个Method对象列表，如果要得到特定的Method对象，可以调用Class类的getMethod方法，其签名是Method getMethod(String Methodname,Class…parameterTypes)。<br>例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method m1 = Employee.class.getMethod(<span class="string">"getName"</span>);  </div><div class="line">Method m2 = Employee.class.getMethod(<span class="string">"raiseSalary"</span>,<span class="keyword">double</span>.class);</div></pre></td></tr></table></figure></li></ul><p>　　下面给出一个调用任意方法打印函数表的程序(以自定义的square和Math.sqrt方法为例)：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTableTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">Method square =         MethodTableTest.class.getMethod(<span class="string">"square"</span>,<span class="keyword">double</span>.class);</div><div class="line">    Method sqrt = Math.class.getMethod(<span class="string">"sqrt"</span>,<span class="keyword">double</span>.class);</div><div class="line">    </div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,square);</div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,sqrt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from,<span class="keyword">double</span> to,<span class="keyword">int</span> n,Method f)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    System.out.println(f);</div><div class="line">    <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> x = from;x &lt;= to;x += dx)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">try</span></div><div class="line">      &#123;</div><div class="line">         <span class="keyword">double</span> y = (Double)f.invoke(<span class="keyword">null</span>,x);</div><div class="line">         System.out.printf(<span class="string">"%10.4f | %10/4f\n"</span>,x,y);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span>(Exception e)</div><div class="line">      &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p> <strong>invoke方法如果提供了错误的参数，会抛出一个异常，所以要提供一个异常处理器</strong><br> 建议在有必要的时候才使用invoke方法，有如下原因:<br> 1.invoke方法的参数和返回值必须是Object类型，意味着必须进行多次类型转换，这样会使编译器错过检查代码的机会，等到测试阶段才发现错误，找到并改正会更加困难<br> 2.通过反射调用方法比直接调用方法要明显慢一些</p><p><strong>特别重申：</strong>建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的执行速度更快，更易于维护。    </p><p> 推荐博客：  </p><ul><li><a href="http://www.cnblogs.com/absfree/p/5277665.html" target="_blank" rel="external">Java核心技术点之反射</a>  </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li><li><a href="http://blog.csdn.net/liujiahan629629/article/details/18013523" target="_blank" rel="external">Java中的反射机制</a></li><li><a href="http://www.importnew.com/9078.html" target="_blank" rel="external">Java反射教程</a></li><li><a href="http://www.cnblogs.com/rollenholt/archive/2011/09/02/2163758.html" target="_blank" rel="external">Java反射详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  &lt;/p&gt;
&lt;h3 id=&quot;1-什么是反射？&quot;&gt;&lt;a href=&quot;#1-什么是反射？&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之继承和多态</title>
    <link href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://habitdiary.cn/2017/10/12/Java学习总结之继承和多态/</id>
    <published>2017-10-12T15:18:55.000Z</published>
    <updated>2017-10-14T06:33:23.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父类与子类"><a href="#父类与子类" class="headerlink" title="父类与子类"></a>父类与子类</h3><p>在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。  </p><h4 id="继承有如下几个关键点"><a href="#继承有如下几个关键点" class="headerlink" title="继承有如下几个关键点"></a>继承有如下几个关键点</h4><p>1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法<br>2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们<br>3.不是所有的“是一种”(is-a)关系都该用继承来建模<br>4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承<br>5.Java中类与类的继承是单一继承  </p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super关键字有两种作用：<br><strong>1.调用父类的构造方法</strong><br>因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。<br>形式是<code>super()</code>或<code>super(arguments)</code>，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条<code>super()</code><br>有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。  </p><p><strong>2.调用父类的方法</strong><br>在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用<code>super.方法名</code>来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，<code>super.super.方法名</code>是不合法的。  </p><h3 id="构造方法链"><a href="#构造方法链" class="headerlink" title="构造方法链"></a>构造方法链</h3><p>在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码：  </p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Faculty</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>{    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{       <span class="keyword">new</span> Faculty();    }    <span class="function"><span class="keyword">public</span> <span class="title">Faculty</span><span class="params">()</span></span>{        System.out.println(<span class="string">"(4) Performs Faculty's tasks"</span>);    } }<span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>{    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>{        <span class="keyword">this</span>(<span class="string">"(2) Invoke Employee's overloaded constructor"</span>);        System.out.println(<span class="string">"(3) Perfoms Employee's tasks"</span>);    }    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String s)</span></span>{      System.out.println(s);    } } <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{     <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>{        System.out.println(<span class="string">"(1) Performs Person's tasks"</span>);     } }</code></pre><p>打印结果为:<br>(1) Performs Person’s tasks<br>(2) Invoke Employee’s overloaded constructor<br>(3) Performs Employee’s tasks<br>(4) Performs Faculty’s tasks  </p><p>我们可以知道：子类的构造方法的第一条语句要么是<strong>super语句(包括编译器隐式插入的)</strong>,要么是<strong>this语句</strong>，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类  </p><p>注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。  </p><h3 id="方法重载与重写"><a href="#方法重载与重写" class="headerlink" title="方法重载与重写"></a>方法重载与重写</h3><p><strong>重载</strong><br>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同)  </p><p><strong>重写</strong><br>方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。<br>为了避免错误，可以使用重写标注，在要重写的方法前加上<code>@Override</code>，该标注会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。</p><p><strong>关于重写的几点注意</strong><br>1.仅当实例方法时刻访问的，它才能被覆盖<br>2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法  </p><p>方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。<br>注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>多态机制的底层实现技术是<strong>动态绑定</strong>，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。</p><p>对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。  </p><p>静态绑定(前期绑定)：<br>在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。</p><p>动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。<br>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p><p>简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。</p><h3 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h3><p>假设下面要调用x.f(args)，方法调用的过程为：<br>1） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(int)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。<br>2） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。<br>3） 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为private方法、构造器不能被继承，更谈不上重写，而static方法和final方法虽然能被继承，但不能被重写。<br>4) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。  </p><p>每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。<br>方法表示例(Manager继承自Employee)：  </p><p>Employee:<br>getName() -&gt; Employee.getName()<br>getSalary() -&gt; Employee.getSalary()<br>getHireDay() -&gt; Employee.getHireDay()<br>raiseSalary(double) -&gt; Employee.raiseSalary(double)  </p><p>Manager:<br>getName() -&gt; Employee.getName()//继承的方法<br>getSalary() -&gt; Manager.getSalary()//重写的方法<br>getHireDay() -&gt; Employee.getHireDay()//继承的方法<br>raiseSalary(double) -&gt; Employee.raiseSalary(double)//继承的方法<br>setBonus(double) -&gt; Manager.setBonus(double)//新增的方法  </p><h3 id="内联优化"><a href="#内联优化" class="headerlink" title="内联优化"></a>内联优化</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联优化所有的final方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高50%。如果确定一个类不会被派生或一个方法不会被重写，建议使用final关键字修饰。  </p><h3 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h3><p>和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。<br>我们可以通过<code>instanceof</code>运算符来检测一个对象是否是某个类或接口的实例，其返回值是boolean类型的。<br>注意:<br>1.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();<br>2.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。  </p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出<code>public class xxx extends Object</code>,在Java中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。<br>下面介绍Object类中的几个重要方法及重写规范：  </p><h4 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="1) equals方法"></a>1) equals方法</h4><p>Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。  </p><p>equals方法的原型是public boolean equals(Object obj),默认实现是:  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>{    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);}</code></pre><p>调用它的语法是<code>object1.equals(object2)</code>，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。<br>比如类Employee定义了数据域：private String name,private double salary,private LocalDate hireDay<br>equals方法重写如下：  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>{    <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//快速检测引用是否相等，相等返回ture</span>    <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">//检测引用是否为空，为空返回false  </span>    <span class="keyword">if</span>(getClass() != obj.getClass())          <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">//检测是否属于同一个类，不是返回false  </span>    Empolyee other = (Employee) obj;<span class="comment">//向下转型  </span>    <span class="keyword">return</span> name.equals(other.name)      &amp;&amp; salary == other.salary      &amp;&amp; hireDay.equals(other.hireDay);      <span class="comment">//逐一比较数据域,有一个不等返回就false，否则返回true</span></code></pre><p><strong>进一步改进：</strong><br><em>改进一</em><br>上述的第4步检测，可以改为  </p><pre><code class="java"><span class="keyword">return</span> Objects.equals(name,other.name)   &amp;&amp; salary == other.salary   &amp;&amp; Objects.equals(hireDay,other.hireDay);</code></pre><p>其中Objects.equals方法可以防备name 或 hireDay 可能为null的情况，如果两个参数都为null，Objects(a,b)返回true;如果其中一个为null，返回false;如果两个参数都不为null,调用a.equals(b)。Objects类在java.util包中。  </p><p>在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。<br>比如Manager类继承自Employee，在父类的基础上增加了private double bonus：  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>{    <span class="keyword">if</span>(!<span class="keyword">super</span>.equals(obj)) <span class="keyword">return</span> <span class="keyword">false</span>;    Manager other = (Manager) obj;    <span class="keyword">return</span> bonus == other.bonus;}</code></pre><p><em>改进二</em><br>上述代码的第3步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用instanceof进行检测，比如雇员的ID作为相等的概念，就可以用xxx instanceof Employee进行检测，并将Empolyee.equals声明为final。  </p><p><strong>equals方法要满足下面的特性</strong>  </p><ol><li>自反性: 对于任何非空引用，x.equals(x)应该返回true  </li><li>对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同  </li><li>传递性：对于任何引用x、y和z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true  </li><li>一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果  </li><li>对于任何非空引用x,x.equals(null)应该返回false</li></ol><p><strong>下面我们给出编写一个完美的equals方法的建议</strong>：<br>1) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测<br>2) 检测引用是否为空，如果为空，不必再检测，直接返回不等<br>3) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:<code>if(getClass() != obj.getClass()) return false</code>;如果所有子类都拥有统一的语义(父类决定相等)，就使用instanceof检测：<code>if(!(obj instanceof ClassName) return false)</code><br>4) 将obj向下转型为相应类的类型变量<br>5) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测<br><strong>数组对象用静态的Arrays.equals方法判等</strong></p><h4 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="2) hashCode方法"></a>2) hashCode方法</h4><p>散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。<br>String类使用下列算法计算散列码：  </p><pre><code class="java"><span class="keyword">int</span> hash = <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length();i++){    hash = <span class="number">31</span> * hash + charAt(i);}</code></pre><p>由于hashCode方法定义在Object类中，方法原型是<code>public int hashCode()</code>,因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。<br><strong>如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。</strong><br>hashCode方法应该返回一个整型数值(可以是负数),<strong>并合理地组合实例域的散列码</strong>，以便能让各个不同的对象产生的散列码更均匀。<br>例如，下面是Employee类的hashCode方法  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * name.hashCode()      + <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode()      + <span class="number">13</span> * hireDay.hashCode();</code></pre><p><strong>进一步改进</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name)      + <span class="number">11</span> * Double.hashCode(salary)      + <span class="number">13</span> * Objects.hashCode(hireDay);</code></pre><p><strong>从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()</strong><br>其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象    </p><p><strong>还有更简单的做法</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> Objects.hash(name,salary,hireDay); }</code></pre><p><strong>Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID</strong>  </p><h4 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="3) toString方法"></a>3) toString方法</h4><p>方法原型是<code>public String toString()</code>,用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：<code>类名@对象十六进制内存地址</code>的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似<code>[I@1a46e30</code>的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。<br>toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。<br>当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。  </p><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如：  </p><pre><code class="java"><span class="keyword">int</span> actualSize = . . .;Employee[] staff = <span class="keyword">new</span> Employee[actualSize];</code></pre><p>但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。<br>ArrayList是一个采用<strong>类型参数</strong>的<strong>泛型类</strong>,声明方式为<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;()</code>,从Java SE 7开始，可以省去右边的类型参数，即<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()</code><br>在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于<code>ArrayList&lt;Object&gt;</code>,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。<br>ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。  </p><h4 id="ArrayList类的常用API"><a href="#ArrayList类的常用API" class="headerlink" title="ArrayList类的常用API"></a>ArrayList类的常用API</h4><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  </li></ul><h4 id="对于数组列表有用的方法"><a href="#对于数组列表有用的方法" class="headerlink" title="对于数组列表有用的方法"></a>对于数组列表有用的方法</h4><p><strong>1.数组和ArrayList互相转换</strong>  </p><p>数组转ArrayList:  </p><pre><code class="java">String[] array = {<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>};ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array));</code></pre><p>ArrayList转数组:  </p><pre><code class="java">String[] array = <span class="keyword">new</span> String[list.size()];list.toArray(array);</code></pre><h4 id="2-Collections类"><a href="#2-Collections类" class="headerlink" title="2.Collections类"></a>2.Collections类</h4><p>Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。</p><p><strong>ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。</strong>  </p><h3 id="final关键字总结"><a href="#final关键字总结" class="headerlink" title="final关键字总结"></a>final关键字总结</h3><p>final关键字在不同语句中有不同的作用：<br>1) <strong>修饰类变量或成员变量</strong> 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。final还可以修饰方法的局部变量，即常量<br>2) <strong>修饰方法</strong> 表示该方法不能被重写<br>3) <strong>修饰类</strong> 表示该类不能被扩展</p><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><h4 id="1-将公共操作和域放在超类"><a href="#1-将公共操作和域放在超类" class="headerlink" title="1.将公共操作和域放在超类"></a>1.将公共操作和域放在超类</h4><h4 id="2-不要使用受保护的域"><a href="#2-不要使用受保护的域" class="headerlink" title="2.不要使用受保护的域"></a>2.不要使用受保护的域</h4><p>protected机制并不能够带来更好的保护，其原因主要有两点:<br>第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。<br>第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。<br>不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的  </p><h4 id="3-使用继承实现-“is-a”-关系"><a href="#3-使用继承实现-“is-a”-关系" class="headerlink" title="3.使用继承实现 “is-a” 关系"></a>3.使用继承实现 “is-a” 关系</h4><h4 id="4-除非所有继承的方法都有意义，否则不要使用继承"><a href="#4-除非所有继承的方法都有意义，否则不要使用继承" class="headerlink" title="4.除非所有继承的方法都有意义，否则不要使用继承"></a>4.除非所有继承的方法都有意义，否则不要使用继承</h4><p>比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。  </p><h4 id="5-在覆盖方法时，不要改变预期的行为"><a href="#5-在覆盖方法时，不要改变预期的行为" class="headerlink" title="5.在覆盖方法时，不要改变预期的行为"></a>5.在覆盖方法时，不要改变预期的行为</h4><h4 id="6-使用多态，而非类型信息"><a href="#6-使用多态，而非类型信息" class="headerlink" title="6.使用多态，而非类型信息"></a>6.使用多态，而非类型信息</h4><p>即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为</p><h4 id="7-不要过多地使用反射"><a href="#7-不要过多地使用反射" class="headerlink" title="7.不要过多地使用反射"></a>7.不要过多地使用反射</h4><p>反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;父类与子类&quot;&gt;&lt;a href=&quot;#父类与子类&quot; class=&quot;headerlink&quot; title=&quot;父类与子类&quot;&gt;&lt;/a&gt;父类与子类&lt;/h3&gt;&lt;p&gt;在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之对象与类</title>
    <link href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
    <id>http://habitdiary.cn/2017/10/12/Java学习总结之对象与类/</id>
    <published>2017-10-12T00:40:34.000Z</published>
    <updated>2017-10-17T14:02:49.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h3><p>　　面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。<br>　　传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。<br>　　对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。  </p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>　　类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。<br>　　对象：由类构造的实例，一个类可以构造多个实例。  　　</p><h3 id="设计类的简单规则"><a href="#设计类的简单规则" class="headerlink" title="设计类的简单规则"></a>设计类的简单规则</h3><p>　　先从设计类的数据域开始，再向类里添加方法。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>1.依赖(use-a)<br>　　如果A类的方法操纵B类的对象，我们说A类依赖于B类。应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。<br>2.聚合(has-a)<br>　　如果A类对象包含B类对象，我们说A类和B类聚合。<br>3.继承(is-a)<br>　　如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。  </p><h3 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h3><p>　　对象是调用构造方法在堆上分配内存产生的(用new + 构造方法来调用)，而对象变量是在栈上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上产生了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。</p><h3 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h3><p>1.创建的实例及成员变量（静、非静态）在堆中<br>2.局部变量在栈中<br>3.类的基本信息和方法定义在方法区</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>相关知识见<a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="external">http://www.uml.org.cn/oobject/201211231.asp</a></p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>　　构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。<br>　　构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，因为它是用来创建实例的，所以它永远是实例方法，不能被static修饰。<br>　　构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。  </p><h3 id="访问对象的数据和方法"><a href="#访问对象的数据和方法" class="headerlink" title="访问对象的数据和方法"></a>访问对象的数据和方法</h3><p>　　在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。   </p><h3 id="引用数据域和null值"><a href="#引用数据域和null值" class="headerlink" title="引用数据域和null值"></a>引用数据域和null值</h3><p>　　如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。</p><h3 id="默认赋值规则"><a href="#默认赋值规则" class="headerlink" title="默认赋值规则"></a>默认赋值规则</h3><p>　　类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。  </p><h3 id="基本变量和引用变量的区别"><a href="#基本变量和引用变量的区别" class="headerlink" title="基本变量和引用变量的区别"></a>基本变量和引用变量的区别</h3><p>　　基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。<br>　　没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。  </p><h3 id="静态-非静态变量、常量和静态-非静态方法"><a href="#静态-非静态变量、常量和静态-非静态方法" class="headerlink" title="静态/非静态变量、常量和静态/非静态方法"></a>静态/非静态变量、常量和静态/非静态方法</h3><p>静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。不要从构造器中传入参数来初始化静态域，最好使用set方法改变静态数据域。<br>非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。<br>常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。<br>静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。<br>非静态方法：又称实例方法，是依赖于具体对象的方法。<br>关系：<br>静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。<br>静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。   </p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance();  </div><div class="line">NumberFormat percentFormatter = NumberFormat.gerPercentInstance();  </div><div class="line"><span class="keyword">double</span> x = <span class="number">0.1</span>;  </div><div class="line">System.out.println(currencyFormatter.format(x));<span class="comment">// prints $0.10</span></div><div class="line">System.out.println(percentFormatter.format(x));<span class="comment">//prints 10%</span></div></pre></td></tr></table></figure></p><p>使用静态工厂方法的原因主要有两个：<br>1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字<br>2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类</p><h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>public<br>修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public</p><p>protected<br>修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问</p><p>default<br>缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。  </p><p>private<br>private成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。  </p><p><img src="http://img.blog.csdn.net/20150409153405264" alt="fail" title="四种可见性修饰符比较">  </p><p>注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句<code>package + 包名</code>，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。</p><h3 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h3><p>精确导入：导入某个包的特定类,如<code>import java.util.Scanner</code><br>通配导入：导入某个包的所有类,如<code>import java.util.*</code><br>当使用多个包中的同名类时，要用包名.类名的格式<br>编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类<br>静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如<code>import static java.lang.System.*</code>导入了System类的静态方法和静态域，就可以不加类名前缀:<code>out.println(&quot;Hello world!&quot;)</code>，out是System类里定义的静态成员，是PrintStream的实例。</p><h3 id="数据域封装"><a href="#数据域封装" class="headerlink" title="数据域封装"></a>数据域封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。<br>实现封装的步骤：<br>1.用private可见性修饰符修饰类成员<br>2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()<br>3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue)  </p><h3 id="向方法传递对象参数"><a href="#向方法传递对象参数" class="headerlink" title="向方法传递对象参数"></a>向方法传递对象参数</h3><p>可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。  </p><h3 id="对象数组和普通数组"><a href="#对象数组和普通数组" class="headerlink" title="对象数组和普通数组"></a>对象数组和普通数组</h3><p>所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。  </p><h3 id="不可变对象和类"><a href="#不可变对象和类" class="headerlink" title="不可变对象和类"></a>不可变对象和类</h3><p>一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。<br>一个类是不可变类要满足以下三个条件：<br>1.所有的数据域都是私有的<br>2.没有修改器方法<br>3.没有一个返回指向可变数据域引用的访问器方法  </p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>就是错误的，因为j的初始化基于i已经被初始化的前提。  </p><p>局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。  </p><p>建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。</p><h3 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h3><p>this关键字有两大作用：<br>1.表示指向调用对象本身的引用名<br>2.可以在构造方法内部调用同一个类的其他构造方法，此时<code>this(参数列表)</code>语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用<code>this(参数列表)</code>的形式来实现它们。这样做可以简化代码，使类易于维护。  </p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h4><p>即依赖编译器对数据域的默认初始化。  </p><h4 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h4><p>在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。  </p><h4 id="无参数的构造器"><a href="#无参数的构造器" class="headerlink" title="无参数的构造器"></a>无参数的构造器</h4><p>即将对数据域的初始化置于一个无参的构造器中。  </p><h4 id="有参数的构造器"><a href="#有参数的构造器" class="headerlink" title="有参数的构造器"></a>有参数的构造器</h4><p>即给构造器传入参数对数据域进行初始化  </p><h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>即用花括号包含的一组数据域赋值代码块，一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块。</p><h4 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h4><p>1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行。<br>2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。<br>3.父类的实例成员和实例初始化块，按在代码中出现的顺序依次执行。<br>4.执行父类的构造方法。<br>5.子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。<br>6.执行子类的构造方法。  </p><p>注意：静态成员只在构造该类的第一个对象时初始化一次，可以看作初始化类。</p><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><h4 id="1-一定要保证数据域私有"><a href="#1-一定要保证数据域私有" class="headerlink" title="1.一定要保证数据域私有"></a>1.一定要保证数据域私有</h4><h4 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2.一定要对数据初始化"></a>2.一定要对数据初始化</h4><p>最好不要依赖默认初始化，会影响程序可读性。  </p><h4 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3.不要在类中使用过多的基本类型"></a>3.不要在类中使用过多的基本类型</h4><p>用其他集合了相关基本类型的类代替多个基本类型使用</p><h4 id="4-不是所有的域都需要独立的域访问器和域修改器"><a href="#4-不是所有的域都需要独立的域访问器和域修改器" class="headerlink" title="4.不是所有的域都需要独立的域访问器和域修改器"></a>4.不是所有的域都需要独立的域访问器和域修改器</h4><p>有的数据域定义后不必要修改</p><h4 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5.将职责过多的类进行分解"></a>5.将职责过多的类进行分解</h4><h4 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6.类名和方法名要能够体现它们的职责"></a>6.类名和方法名要能够体现它们的职责</h4><h4 id="7-优先使用不可变的类"><a href="#7-优先使用不可变的类" class="headerlink" title="7.优先使用不可变的类"></a>7.优先使用不可变的类</h4><p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象程序设计概述&quot;&gt;&lt;a href=&quot;#面向对象程序设计概述&quot; class=&quot;headerlink&quot; title=&quot;面向对象程序设计概述&quot;&gt;&lt;/a&gt;面向对象程序设计概述&lt;/h3&gt;&lt;p&gt;　　面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之区间dp</title>
    <link href="http://habitdiary.cn/2017/10/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8C%BA%E9%97%B4dp/"/>
    <id>http://habitdiary.cn/2017/10/11/算法学习之区间dp/</id>
    <published>2017-10-11T08:11:11.000Z</published>
    <updated>2017-10-18T15:10:45.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。  </p><h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h3><p>设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价<br>每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段  </p><p>For l:=2 to n do // 枚举区间长度<br>for i:=1 to n do // 枚举区间的左端点<br>begin<br>j:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到<br>if j&gt;n then break; // 保证了下标不越界<br>for k:= i to j-1 do // 状态转移，去推出 f[i,j]<br>f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }<br>end;   </p><p>这个结构必须记好，这是区间动态规划的代码结构。  </p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>题目链接:<a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=737" target="_blank" rel="external">http://acm.nyist.net/JudgeOnline/problem.php?pid=737</a></p><p>题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 </p><p>分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。<br>定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。<br>那么dp[i][j] = min(dp[i][k] + dp[k+1][j])<br>那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。<br>这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2）  </p><p>代码1(无优化)<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></div><div class="line"><span class="keyword">int</span> dp[N][N],sum[N];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> a[N];sum[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//因为要求解区间和，先维护前缀和</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> i,j,l,k;</div><div class="line">        <span class="keyword">for</span>(l = <span class="number">2</span>; l &lt;= n; ++l)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; ++i)<span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                j = i + l - <span class="number">1</span>;<span class="comment">//根据左端点和区间长度求区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                dp[i][j] = <span class="number">0x3f3f3f3f</span>;</div><div class="line">                <span class="keyword">for</span>(k = i; k &lt; j; ++k)</div><div class="line">                &#123;</div><div class="line">                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码2(平行四边形优化)<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></div><div class="line"><span class="keyword">int</span> dp[N][N],sum[N],s[N][N];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> a[N];sum[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">            s[i][i]=i;</div><div class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//因为要求解区间和，先维护前缀和</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> i,j,l,k;</div><div class="line">        <span class="keyword">for</span>(l = <span class="number">2</span>; l &lt;= n; ++l)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; ++i) <span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                j = i + l - <span class="number">1</span>;<span class="comment">//根据左端点和区间长度求区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                dp[i][j] = <span class="number">0x3f3f3f3f</span>;</div><div class="line">                <span class="keyword">for</span>(k = s[i][j<span class="number">-1</span>]; k &lt;= s[i+<span class="number">1</span>][j]; ++k)<span class="comment">//四边形优化</span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(dp[i][j]&gt;dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>])</div><div class="line">                         &#123;</div><div class="line">                                dp[i][j]=dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>];</div><div class="line">                                s[i][j]=k;</div><div class="line">                         &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>题目链接：<a href="http://poj.org/problem?id=2955" target="_blank" rel="external">http://poj.org/problem?id=2955</a>  </p><p>题意:给出一串的只有‘（’ ‘）’  ‘[‘  ‘]’四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。  </p><p>分析：<br>定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目<br>1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ;<br>2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)<br>dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] )   </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">120</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s==<span class="string">"end"</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> n = s.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - len; i++)<span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;<span class="comment">//确定区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span>(s[i]==<span class="string">'('</span>&amp;&amp;s[j]==<span class="string">')'</span> || s[i]==<span class="string">'['</span>&amp;&amp;s[j]==<span class="string">']'</span>)</div><div class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</div><div class="line">                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);<span class="comment">//枚举中间位置,注意j不取等号</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果要求打印路径，即输出匹配后的括号  </p><p>题目链接: <a href="http://poj.org/problem?id=1141" target="_blank" rel="external">http://poj.org/problem?id=1141</a>  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">120</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N],pos[N][N];   <span class="comment">/*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/</span></div><div class="line"><span class="built_in">string</span> s;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i&gt;j)  <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(i==j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">')'</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"()"</span>;</div><div class="line">        <span class="keyword">else</span>      <span class="built_in">cout</span>&lt;&lt;<span class="string">"[]"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pos[i][j]==<span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;s[i];</div><div class="line">            show(i+<span class="number">1</span>,j<span class="number">-1</span>);</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;s[j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            show(i,pos[i][j]);</div><div class="line">            show(pos[i][j]+<span class="number">1</span>,j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> len=s.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,k=i; k&lt;len; j++,k++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'('</span>&amp;&amp;s[k]==<span class="string">')'</span> || s[j]==<span class="string">'['</span>&amp;&amp;s[k]==<span class="string">']'</span>)</div><div class="line">                &#123;</div><div class="line">                    dp[j][k]=dp[j+<span class="number">1</span>][k<span class="number">-1</span>]+<span class="number">2</span>;</div><div class="line">                    pos[j][k]=<span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> f=j; f&lt;k; f++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(dp[j][f]+dp[f+<span class="number">1</span>][k]&gt;=dp[j][k])</div><div class="line">                    &#123;</div><div class="line">                        dp[j][k]=dp[j][f]+dp[f+<span class="number">1</span>][k];</div><div class="line">                        pos[j][k]=f;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        show(<span class="number">0</span>,len<span class="number">-1</span>);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><p>题目链接：<a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=746" target="_blank" rel="external">http://acm.nyist.net/JudgeOnline/problem.php?pid=746</a>  </p><p>题意:  给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积  </p><p>分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数<br>设a[i][j]为区间[i,j]所形成的数<br>所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i])  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">25</span>][<span class="number">25</span>];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">25</span>][<span class="number">25</span>];</div><div class="line"><span class="keyword">char</span> str[<span class="number">25</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len, t, m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</div><div class="line">    <span class="keyword">while</span> (t--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str, &amp;m);</div><div class="line">        len = <span class="built_in">strlen</span>(str);</div><div class="line">        m--;</div><div class="line">        <span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</div><div class="line">        <span class="built_in">memset</span> (dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)          <span class="comment">//先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值</span></div><div class="line">        &#123;</div><div class="line">            a[i][i] = str[i] - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</div><div class="line">            &#123;</div><div class="line">                a[i][j] = a[i][j - <span class="number">1</span>] * <span class="number">10</span> + str[j] - <span class="string">'0'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            dp[i][<span class="number">0</span>] = a[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; len; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)</div><div class="line">                &#123;</div><div class="line">                    dp[i][j] = max(dp[i][j], dp[k][j - <span class="number">1</span>] * a[k + <span class="number">1</span>][i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[len - <span class="number">1</span>][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Halloween-Costumes"><a href="#Halloween-Costumes" class="headerlink" title="Halloween Costumes"></a>Halloween Costumes</h3><p>题目链接：<a href="http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422" target="_blank" rel="external">http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422</a>  </p><p>题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会  </p><p>分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有</p><p>①：如果在之后的区间内都不再重复利用这件衣服，那么明显  dp[i][j] = dp[i+1][j] + 1;</p><p>②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，<br>那么转移方程为  dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j])  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">int</span> a[<span class="number">105</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="keyword">int</span> cas = <span class="number">0</span>;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        cas ++;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] = j-i+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + <span class="number">1</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt;= j;k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(a[i] == a[k])</div><div class="line">                    &#123;</div><div class="line">                        dp[i][j] = min(dp[i][j],dp[i][k<span class="number">-1</span>] + dp[k+<span class="number">1</span>][j]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cas,dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Cheapest-Palindrome"><a href="#Cheapest-Palindrome" class="headerlink" title="Cheapest Palindrome"></a>Cheapest Palindrome</h3><p>题目链接:<a href="http://poj.org/problem?id=3280" target="_blank" rel="external">http://poj.org/problem?id=3280</a>  </p><p>题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。  </p><p>分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况：</p><p>1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值；</p><p>2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值</p><p>3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小</p><p>然后dp[i][j]取上面这些情况的最小值  </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>],add[<span class="number">27</span>],del[<span class="number">27</span>];</div><div class="line"><span class="keyword">char</span> s[<span class="number">2005</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">char</span> ch[<span class="number">10</span>];</div><div class="line">            <span class="keyword">int</span> tmp1,tmp2;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,ch,&amp;tmp1,&amp;tmp2);</div><div class="line">            add[ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>]=tmp1;</div><div class="line">            del[ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>]=tmp2;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j]=min(dp[i+<span class="number">1</span>][j]+add[s[i]-<span class="string">'a'</span>+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]+del[s[i]-<span class="string">'a'</span>+<span class="number">1</span>]);</div><div class="line">                <span class="keyword">int</span> tmp=min(dp[i][j<span class="number">-1</span>]+add[s[j]-<span class="string">'a'</span>+<span class="number">1</span>],dp[i][j<span class="number">-1</span>]+del[s[j]-<span class="string">'a'</span>+<span class="number">1</span>]);</div><div class="line">                dp[i][j]=min(dp[i][j],tmp);</div><div class="line">                <span class="keyword">if</span>(s[i]==s[j])</div><div class="line">                dp[i][j]=min(dp[i][j],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Treats-for-the-Cows"><a href="#Treats-for-the-Cows" class="headerlink" title="Treats for the Cows"></a>Treats for the Cows</h3><p>题目链接:<a href="http://poj.org/problem?id=3186" target="_blank" rel="external">http://poj.org/problem?id=3186</a>  </p><p>题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值  </p><p>分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来<br>转移方程：dp[i][j]=max(dp[i+1][j]+p[i]<em>(n+i-j),dp[i][j-1]+p[j]</em>(n+i-j));  其中n-(j-i)是第几次取  </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> p[<span class="number">2010</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">2010</span>][<span class="number">2010</span>];</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</div><div class="line">            dp[i][i]= n * p[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</div><div class="line">        &#123;</div><div class="line">           dp[i][j]=max(dp[i+<span class="number">1</span>][j]+p[i]*(n+i-j),dp[i][j<span class="number">-1</span>]+p[j]*(n+i-j));</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问
      
    
    </summary>
    
    
      <category term="算法" scheme="http://habitdiary.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之Java基本程序设计结构</title>
    <link href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
    <id>http://habitdiary.cn/2017/10/10/Java学习总结之Java基本程序设计结构/</id>
    <published>2017-10-10T15:55:53.000Z</published>
    <updated>2017-11-08T14:10:58.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java是一种<strong>强类型</strong>语言，即意味着必须为每一个变量声明一种类型。在Java中一共有8种基本数据类型，其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真值的boolean类型。  </p><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1) 整型"></a>1) 整型</h4><p>整型用于表示没有小数部分的值，它允许是负数，Java提供了4种整型：<br>类型　　　　存储需求　　　　　　　　取值范围<br>byte　　　　 1字节　　　　　　　　　-2<sup>7</sup> ~ 2<sup>7</sup>-1<br>short　　　　2字节　　　　　　　　　-2<sup>15</sup> ~ 2<sup>15</sup>-1<br>int　　　　　4字节　　　　　　　　　-2<sup>31</sup> ~ 2<sup>31</sup>-1<br>long　　　　 8字节　　　　　　　　　-2<sup>63</sup> ~ 2<sup>63</sup>-1  </p><p>在通常情况下,int类型最常用。如果要表示星球上居住的人数，就需要使用long类型了。byte和short类型用于特定的应用场合，比如底层的文件处理或者需要控制占用存储空间量的大数组。<br>整型的直接量默认是int，即2表示int类型的2，为了表示一个long型的整型直接量，在其后追加字母L或l即可(建议使用L,以免和数字1混淆)。语句<code>byte b = 128</code>会造成编译错误，因为128是整型直接量且超过了byte的取值范围。<br>默认情况下，整型直接量是一个十进制整数。要表示一个二进制整数直接量，使用0b或0B开头;表示一个八进制整数直接量，使用0开头;表示一个十六进制整数直接量，使用0x或0X开头。<br>为了提高可读性,Java允许在数值直接量的两个数字之间使用下划线,例如<code>long ssn = 232_45_4519</code><br><strong>Java没有任何无符号(unsigned)形式的int、long、short或byte类型</strong></p><h4 id="2）浮点类型"><a href="#2）浮点类型" class="headerlink" title="2）浮点类型"></a>2）浮点类型</h4><p>浮点类型用于表示有小数部分的数值，Java提供了2种浮点类型：<br>类型　　　　存储需求　　　　　　　　取值范围<br>float　　　　 4字节　　负数范围：-3.4028235E+38 ~ -1.4E-45<br>　　　　　　　　　　　正数范围：  1.4E-45 ~ 3.4028235E+38<br>           　　　　　　　　　　　　　　　　(有效位数为6~7位)<br>double 　　　8字节　　负数范围：-1.7976931348623157E+308 　　　　　　　　　　　　　　　　~ -4.9E-324　　　<br>　<br>      　　　　　　　　　　　正数范围： 4.9E-324 ~<br> 　　　　　　　　　　　　　　　　1.7976931348623157E+308<br>　　　　　　　　　　　　　　　　(有效位数为15位)<br>double表示这种类型的数值精度是float的两倍,float称为单精度型,double称为双精度型。通常情况下,应该使用double型,因为它比float型更精确。<br>可以以E或e为指数用科学计数法表示浮点数,例如1.2345E+2,在十六进制中,则使用p表示指数而不是e，且尾数采用十六进制时指数的基数是2而不是10<br>浮点数直接量是double型,即5.0被认为是double型的,可以通过追加f或F表示float型直接量,当然也可以在浮点数值后面添加后缀D或d表示double型(虽然没有必要多此一举)<br>常量<strong>Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN</strong>(以及相应的Float类型的常量)分别表示正无穷大、负无穷大和不是一个数。例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。<br>不能用如下的方式检测一个特定的值是否等于Double.NaN:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(x == Double.NaN) <span class="comment">// is never true</span></div></pre></td></tr></table></figure></p><p>应该改成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(Double.isNaN(x)) <span class="comment">// check whether x is "not a number"</span></div></pre></td></tr></table></figure></p><p>浮点数在运算时会产生一定误差,如果对精度有极高要求，应该使用BigDecimal类</p><h4 id="3）Unicode和char类型"><a href="#3）Unicode和char类型" class="headerlink" title="3）Unicode和char类型"></a>3）Unicode和char类型</h4><p>char类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些则需要两个char值。<br>char类型的字面量值要用单引号括起来。例如：’A’是编码值为65所对应的字符常量。它与”A”不同，”A”是包含一个字符A的字符串。char类型可以表示为十六进制值，范围从’\u0000’到’\uFFFF’<br>有一些用于表示特殊字符的<strong>转义序列</strong>,如下：<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/特殊字符的转义序列.png" alt="fail" title="特殊字符的转义序列">  </p><p> <strong>注释中的\u也会起转义作用,如下：</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// \u00A0 is a newline </span></div><div class="line">  (\u00A0会被替换成换行符)</div><div class="line"></div><div class="line"><span class="comment">// Look inside c:\users </span></div><div class="line">  (会产生编译错误,因为\u后面未跟着<span class="number">4</span>个十六进制数)</div></pre></td></tr></table></figure></p><h4 id="4-boolean类型"><a href="#4-boolean类型" class="headerlink" title="4) boolean类型"></a>4) boolean类型</h4><p>boolean类型有两个值：false和true，用来判定逻辑条件。<strong>不同于C/C++中0代表false，非0代表true，Java中整型值和布尔值之间不能进行相互转换。</strong><br>比如,下面的语句在C/C++中是允许的,表示一个无限循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">do</span> something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是在Java中不允许这么做,可以改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">do</span> something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以打印boolean类型的变量或者布尔表达式，会呈现true或者false  </p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>将一个小范围类型变量转化为大范围类型的变量称为<strong>拓宽类型</strong>，反之称为<strong>缩窄类型</strong>。把小范围类型变量赋值给大范围类型的变量或小范围类型变量和大范围类型变量共同参与运算,Java会自动拓宽类型。而如果要缩窄类型，必须显式完成。<br><strong>注意：<br>1.类型转换不改变被转换的变量，例如，下面的代码中的d在类型转换之后值不变：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> d = <span class="number">4.5</span>;</div><div class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)d; <span class="comment">// i becomes 4, but d is still 4.5</span></div></pre></td></tr></table></figure></p><p><strong>2.x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。因此，下面代码是正确的：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">sum += <span class="number">4.5</span>;<span class="comment">// 等价于sum = (int)(sum + 4.5)</span></div></pre></td></tr></table></figure></p><p><strong>3.将一个int型变量赋值给short型或byte型的变量，必须显式地使用类型转换，如下面的语句会产生编译错误：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"><span class="keyword">byte</span> b = i; <span class="comment">// Error because explicit casting is required</span></div></pre></td></tr></table></figure></p><p>然而如果整型直接量在目标变量允许的范围内，那么将整型直接量赋给short型或byte型就不需要显式类型转换，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</div></pre></td></tr></table></figure></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量用于表示在程序中可能被改变的值。<strong>变量声明</strong>告知编译器根据数据类型为变量分配合适的内存空间。变量声明的语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">datatype variableName;</div></pre></td></tr></table></figure></p><p>如果几个变量为同一类型,允许一起声明它们：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">datatype variable1, variable2, ..., variablen;</div></pre></td></tr></table></figure></p><p>可以在声明变量的同时初始化，也可以先声明后初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 声明同时初始化变量</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> count;</div><div class="line">count = <span class="number">1</span>; <span class="comment">//先声明，后初始化</span></div></pre></td></tr></table></figure></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是一个赋值后保持不变的量,用final关键字修饰，在类中定义的常量一般用static final修饰。常量必须在同一条语句中声明和赋值，不可先声明再赋值。<br>使用常量有三个好处：<br>1)不必重复输入同一个值<br>2)如果必须修改常量的值，只需在源代码的一处改动<br>3)给常量赋一个描述性的名字会提高程序的易读性</p><h3 id="数值操作符"><a href="#数值操作符" class="headerlink" title="数值操作符"></a>数值操作符</h3><p>数值数据类型的操作符包括标准的算术操作符：加号(+)、减号(-)、乘号(<code>*</code>)、除号( / )、求余号(%)<br><strong>注意：<br>1.只有当被除数是负数时,余数才是负的,如 -7 % 3 = -1, -26 % -8 = -2,20 % -13 = 7,即无论正负,商和除数乘积的绝对值不能超过被除数的绝对值<br>2.整数除0会产生一个异常，而浮点数除0将会得到无穷大或NaN结果</strong>  </p><h3 id="增强赋值操作符"><a href="#增强赋值操作符" class="headerlink" title="增强赋值操作符"></a>增强赋值操作符</h3><p>x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。其中op可以是加号(+)、减号(-)、乘号(<code>*</code>)、除号( / )、求余号(%)  </p><h3 id="自增和自减操作符"><a href="#自增和自减操作符" class="headerlink" title="自增和自减操作符"></a>自增和自减操作符</h3><p>分为++var、–var、var++、var–四种，加减号决定<strong>给var加1还是减1</strong>，前置还是后置符号决定<strong>先更新后使用值还是先使用值后更新</strong></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>Java中有一系列用于比较关系的运算符：==(等于)、!=(不等于)、&lt;(小于)、&gt;(大于)、&lt;=(小于等于)、&gt;=(大于等于)  </p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑操作符!(非)、&amp;&amp;(与)、||(或)和^(异或)可以用于产生复合型布尔表达式，逻辑操作符被称为<strong>短路操作符或懒惰操作符</strong>，即按顺序执行表达式，如果某一步已经可以判断整个表达式的真假，不再继续执行，否则继续执行。  </p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>处理整型类型时，可以直接对组成整型数值的各个位完成操作。位运算符包括：&amp;(按位与)、|(按位或)、^(按位异或)、~(按位取反)、&lt;&lt;(左移，高位舍弃，低位补0)、&gt;&gt;(右移，低位舍弃，高位用符号位填充)、&gt;&gt;&gt;(右移，低位舍弃，高位0填充)<br><strong>注意：<br>1) 移位运算符的右操作数要完成模32的运算(除非左操作数是long类型，在这种情况下右操作数要模64),例如1<code>&lt;&lt;</code>35等价于1<code>&lt;&lt;</code>3<br>2) &amp; 和 | 也可以用在布尔表达式中，此时它们是逻辑操作符，但不会短路<br>3) 可以使用掩码技术得到一个数二进制的某一位：<br>int fourthBitFromRight = (n &amp; 0b1000) / 0b1000<br>上式将n的右数第4位保留，将其他位掩掉，再除以0b1000，就得到了该位上的数</strong> </p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>Java中的选择语句类型有：单分支if语句、双分支if-else语句、嵌套if语句、多分支if-else语句、switch语句、条件表达式</p><h4 id="1-单分支if语句"><a href="#1-单分支if语句" class="headerlink" title="1) 单分支if语句"></a>1) 单分支if语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(布尔表达式)&#123;</div><div class="line">语句(组);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 分支中如果只有单条语句可以省略外围花括号，否则不能省略</p><h4 id="2-双分支if-else语句"><a href="#2-双分支if-else语句" class="headerlink" title="2) 双分支if-else语句"></a>2) 双分支if-else语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(布尔表达式)&#123;</div><div class="line">布尔表达式为真时执行的语句(组);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">else</span>&#123;</div><div class="line">    布尔表达式为假时执行的语句(组);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 嵌套层数没有限制，但为了程序可读性，尽量不要进行过多的嵌套，且嵌套语句应有适当的缩进保持层次关系。</p><h4 id="3-嵌套的if语句和多分支的if-else语句"><a href="#3-嵌套的if语句和多分支的if-else语句" class="headerlink" title="3) 嵌套的if语句和多分支的if-else语句"></a>3) 嵌套的if语句和多分支的if-else语句</h4><p>下面是一个嵌套的if语句，if(j &gt; k)嵌套在语句if(i &gt; k)内<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(i &gt; k) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; k)</div><div class="line">    System.out.println(<span class="string">"i and j greater than k"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">System.out.println(<span class="string">"i is less than or equal to k"</span>);</div></pre></td></tr></table></figure></p><p>下面是一个多分支的if-else语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90.0</span>)</div><div class="line">System.out.print(<span class="string">"A"</span>);</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(score &gt;= <span class="number">80.0</span>)</div><div class="line">      System.out.print(<span class="string">"B"</span>);</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">70.0</span>)  </div><div class="line">          System.out.print(<span class="string">"C"</span>);</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(score &gt;= <span class="number">60.0</span>)</div><div class="line">             System.out.print(<span class="string">"D"</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">             system.out.print(<span class="string">"E"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了可读性，建议改写成如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90.0</span>)</div><div class="line">System.out.print(<span class="string">"A"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80.0</span>)  </div><div class="line">System.out.print(<span class="string">"B"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">70.0</span>)  </div><div class="line">System.out.print(<span class="string">"C"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60.0</span>)</div><div class="line">System.out.print(<span class="string">"D"</span>);</div><div class="line"><span class="keyword">else</span></div><div class="line">System.out.print(<span class="string">"E"</span>);</div></pre></td></tr></table></figure></p><p><strong>注意：只有在前面的所有条件都为false才测试下一个条件</strong> </p><h4 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4) switch语句"></a>4) switch语句</h4><p>switch语句常用于多分支的选择问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span>(<span class="keyword">switch</span>表达式)&#123;</div><div class="line"><span class="keyword">case</span> value1: 语句(组)<span class="number">1</span>;</div><div class="line">     <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> value2: 语句(组)<span class="number">2</span>;</div><div class="line">     <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">    <span class="keyword">case</span> valueN: 语句(组)N;</div><div class="line">     <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: 当没有一个给出的<span class="keyword">case</span>与<span class="keyword">switch</span>表达式匹配时执行的语句(组)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：<br>1) switch表达式可以为char、byte、short、int或者String型值(整型中只有long不行),并且总要用括号括住<br>2) value1,…,valueN必须与switch表达式具有相同的数据类型，且是常量表达式，不能出现变量，例如：x、y+1等<br>3) 当switch表达式的值与case语句匹配时,执行从该case开始的语句，直到遇到一个break语句或到达switch语句的结束。break语句是可选的,会立即终止switch语句<br>4) default语句是可选的，当没有一个给出的case与switch表达式匹配时执行default语句指定的操作，如果加default语句，就什么也不做</strong></p><h4 id="5-条件表达式"><a href="#5-条件表达式" class="headerlink" title="5) 条件表达式"></a>5) 条件表达式</h4><p>条件表达式基于一个条件计算表达式的值，它是Java中唯一的三元操作符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span>-expression ? expression1 : expression2;</div><div class="line"><span class="comment">//(布尔表达式? 表达式1:表达式2)</span></div></pre></td></tr></table></figure></p><p>如果布尔表达式的值为true，则条件表达式的结果为表达式1;否则，结果为表达式2。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println((num % <span class="number">2</span> == <span class="number">0</span>) ? <span class="string">"num is even"</span> : <span class="string">"num is odd"</span>);</div></pre></td></tr></table></figure></p><p>注意冒号两边是<strong>表达式</strong>，不能是其他操作。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="1-块作用域"><a href="#1-块作用域" class="headerlink" title="1) 块作用域"></a>1) 块作用域</h4><p>块(即复合语句)是指由一对大括号括起来的若干条简单的Java语句。<strong>块确定了变量的作用域，变量只在包含自己的块中可见。一个块可以嵌套在另一个块中。</strong>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line">    . . .</div><div class="line">    &#123;</div><div class="line">       <span class="keyword">int</span> k;</div><div class="line">       . . .</div><div class="line">    &#125; <span class="comment">// k is only defined up to here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是不能在嵌套的两个块中声明同名变量，例如下面的语句会产生编译错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line">    . . .</div><div class="line">    &#123;</div><div class="line">       <span class="keyword">int</span> k;</div><div class="line">       <span class="keyword">int</span> n;<span class="comment">//Erro -- can't redefine n in inner block</span></div><div class="line">       . . .</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这与C++不同，在C++中允许在嵌套的块中定义同名变量，内层变量会覆盖外层定义的变量。  </p><h4 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2) while循环"></a>2) while循环</h4><p>while循环在条件为真的情况下，重复地执行语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(循环继续条件)&#123;</div><div class="line"><span class="comment">//循环体  </span></div><div class="line">    语句(组);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当程序不幸出现了死循环，如果是从命令窗口运行程序的，按CTRL+C键来结束  </p><h4 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3) do-while循环"></a>3) do-while循环</h4><p>do-while循环和while循环基本一样，不同的是while循环是前测循环，即先检测循环条件后执行循环体;do-while是后测循环，即先执行循环体后检测循环条件。只有在一开始就不满足循环继续条件时，两种循环的执行次数不同，即while循环不执行，do-while循环执行一次。否则两种循环的执行次数相同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line"><span class="comment">// 循环体;</span></div><div class="line">    语句(组);</div><div class="line">&#125;<span class="keyword">while</span>(循环继续条件);</div></pre></td></tr></table></figure></p><p><strong>注意do-while循环后面的分号不要丢！</strong>  </p><h4 id="4-for循环"><a href="#4-for循环" class="headerlink" title="4) for循环"></a>4) for循环</h4><p>for循环的基本语法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(初始操作;循环继续条件;每次迭代后的操作) &#123;</div><div class="line"><span class="comment">//循环体  </span></div><div class="line">    语句(组);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>初始动作可以是0个或是多个以逗号隔开的变量声明语句或赋值表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(    ;i &lt; <span class="number">100</span>;i++)&#123;</div><div class="line">System.out.println(<span class="string">"Welcome to Java!"</span>);</div><div class="line">&#125;<span class="comment">// 将初始动作省略，放在循环语句之前执行</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>,n = <span class="number">0</span>; m + n &lt; <span class="number">10</span>; m++,n++)&#123;</div><div class="line">System.out.println(<span class="string">"Welcome to Java!"</span>);</div><div class="line">&#125;<span class="comment">// 多个初始化动作</span></div></pre></td></tr></table></figure></p><p>每次迭代后的操作也可以是0个或多个逗号隔开的语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;  )&#123;</div><div class="line">System.out.println(<span class="string">"Welcome to Java!"</span>);</div><div class="line">    i++;</div><div class="line">&#125;<span class="comment">// 将每次迭代后的操作放入循环体内  </span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">100</span>;System.out.println(i),i++);</div><div class="line"><span class="comment">// 每次迭代后执行多个操作</span></div></pre></td></tr></table></figure></p><p>下面的三种循环写法是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(  ;  ;  )&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(  ;<span class="keyword">true</span>;  )&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="5-for-each循环"><a href="#5-for-each循环" class="headerlink" title="5) for-each循环"></a>5) for-each循环</h4><p>Java有一种很强的循环结构，可以用来依次处理数组中的每个元素(其他类型的元素集合亦可)而不必为指定的下表值而分心。<br>这种增强的for循环的语句格式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(variable : collection) statement</div></pre></td></tr></table></figure></p><p>定义一个变量用于暂存集合中的每一个元素，并执行相应的语句(组)，collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象(例如ArrayList)。<br><strong>for-each循环只能用于按顺序遍历数组或集合的情况，如果要使用其他顺序，应该使用其他循环语句</strong></p><h4 id="6-break和continue"><a href="#6-break和continue" class="headerlink" title="6) break和continue"></a>6) break和continue</h4><p><strong>continue跳出本次迭代进入下一次迭代，break跳出整个循环。</strong><br>虽然不提倡使用goto语句，但偶尔使用goto语句跳出循环还是有益处的。Java中提供了类似于C++中goto语句的带标签的break语句和continue语句，用于跳出多重嵌套的循环语句。<br><strong>标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。另外要注意，只能跳出语句块，而不能跳入语句块。</strong><br>下面的代码使用了带标签的break语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;   </div><div class="line">label1:</div><div class="line"><span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++) &#123;</div><div class="line"><span class="keyword">if</span>(i == <span class="number">5</span>)</div><div class="line"><span class="keyword">break</span> label1;</div><div class="line">&#125;</div><div class="line">System.out.println(i);<span class="comment">// i = 5</span></div></pre></td></tr></table></figure></p><p>上述代码中，i在等于5时跳出循环到循环首部的标签label1位置，由于是带标签的break语句，不再重新进入循环，而是跳过循环执行下面的打印语句。</p><p>如果把改成带标签的continue语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;   </div><div class="line">label2:</div><div class="line"><span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++) &#123;</div><div class="line"><span class="keyword">if</span>(i == <span class="number">5</span>)</div><div class="line"><span class="keyword">continue</span>  label2;</div><div class="line">&#125;</div><div class="line">System.out.println(i); <span class="comment">// i = 10</span></div></pre></td></tr></table></figure></p><p>上述代码中，i在等于5时也跳出循环到循环首部的标签label2位置，但由于是带标签的continue语句，会重新进入循环。</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>有时，变量的取值只在一个有限集合内。例如：销售的服装或比萨饼只有小、中、大、超大这四种尺寸。此时可以给每种尺寸编号为1、2、3、4,但是为了程序的可读性，可以定义一个枚举类。<br>可以把枚举类看作普通类，它们都可以定义一些属性和方法，不同之处是：枚举类不能使用 extends 关键字继承其他类，因为 枚举类已经继承了 java.lang.Enum<code>&lt;T&gt;</code>(java是单一继承),其中T是定义的枚举类类型，可类比每个普通类的Class对象都是Class<code>&lt;T&gt;</code>类的实例。<strong>Enum类是一个抽象类。</strong><br>下面定义一个简单的枚举类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</div></pre></td></tr></table></figure></p><p>其中<strong>enum</strong>是定义枚举类的关键字，可类比普通类的<strong>class</strong>。<strong>Size</strong>是枚举类名，类比普通类名。<br>SMALL、MEDIUM、LARGE、EXTRA_LARGE是枚举值，为枚举类的静态成员，static关键字被省略，类型为Size，可以用<code>Size.枚举实例名</code>来访问，命名习惯同常量。Size变量只能存储枚举类中定义的枚举值或null，尽量不要构造新的Size类型对象。<br>可以在枚举类中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候使用，下面是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size</div><div class="line">&#123;</div><div class="line">SMALL(<span class="string">"S"</span>),MEDIUM(<span class="string">"M"</span>),LARGE(<span class="string">"L"</span>),EXTRA_LARGE(<span class="string">"XL"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String abbreviation;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreaviation)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.abbreviation = abbreviation;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> abbreviation&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>枚举值的声明必须是枚举类定义的第一条语句。枚举类的构造器必须为private，保证了构造器只能用于枚举类中定义的枚举值的构造，而不让客户代码构造新的枚举值。当访问枚举值时，构造方法被调用，枚举值构造方法中的参数被赋值给Abbreviation。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSize</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Size size = Size.LARGE;</div><div class="line">        System.out.println(size.getAbbreviation);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果打印出”L”  </p><p>枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal)构造函数中，在这里，每个枚举值的名称都被转换成一个字符串，且按照在枚举类中出现的先后次序，从0开始进行编号。<br>下面是枚举类的常用API：  </p><ul><li>int compareTo(E o)<br>按照序号(枚举类中的定义次序)比较此枚举与指定对象的顺序   </li><li>String toString()<br>返回枚举常量的名称  </li><li>static <code>&lt;T extends Enum&lt;T&gt;&gt;</code> T valueOf(Class<code>&lt;T&gt;</code> enumType, String name)<br>返回带指定名称的指定枚举类型的枚举常量(是toString的逆操作)，例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> Size s = Enum.valueof(Size.class,<span class="string">"SMALL"</span>);</div><div class="line"> ```  </div><div class="line"> s的值为Size.SMALL  </div><div class="line"> </div><div class="line">* <span class="keyword">static</span> T[] values()  </div><div class="line">返回一个包含全部枚举值的数组，例如：  </div><div class="line">```java</div><div class="line">Size[] values = Size.values();</div></pre></td></tr></table></figure></li></ul><p>返回一个包含Size.SMALL,Size.MEDIUM,Size.LARGE,  Size.EXTRA_LARGE的数组  </p><p><strong>要比较两个枚举值是否相同，既可以使用equals也可以使用==</strong>  </p><p>枚举类型可以在一个类内定义，此时枚举类被作为内部类对待。程序编译后，将创建一个名为<code>OuterClassName$EnumName</code>的字节码文件。  </p><p>可以在if或switch语句中使用枚举变量，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(size.equals(Size.SMALL)&#123;</div><div class="line"><span class="comment">// process SMALL</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size.equals(Size.MEDIUM)&#123;</div><div class="line"><span class="comment">// process MEDIUM</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">...</div></pre></td></tr></table></figure></p><p>等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span>(size)&#123;</div><div class="line"><span class="keyword">case</span> SMALL:</div><div class="line">    <span class="comment">// process SMALL</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MEDIUM:</div><div class="line">    <span class="comment">// process MEDIUM</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>在switch语句中，case标签是一个无限定的枚举值(即SMALL，而不是Size.SMALL)</strong></p><p>更多用法见：<a href="http://blog.csdn.net/qq_27093465/article/details/52180865" target="_blank" rel="external">Java枚举(enum)详解7种常见的用法</a></p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="1-输入"><a href="#1-输入" class="headerlink" title="1) 输入"></a>1) 输入</h4><p>从控制台读取”标准输入流”System.in，需要构造一个<strong>Scanner</strong>对象，并与”标准输入流”System.in关联。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</div></pre></td></tr></table></figure></p><p>下面给出Scanner类的常用API：  </p><ul><li>Scanner(InputStream in)<br>用给定的输入流创建一个Scanner对象  </li><li>String nextLine()<br>读取输入的下一行内容(以回车作为分隔符)  </li><li>String next()<br>读取输入的下一个单词(以空白字符如空格、回车作为分割符)  </li><li>int nextInt()<br>读取下一个int  </li><li>double nextDouble()<br>读取下一个double()  </li><li>boolean hasNext()<br>检测输入是否还有单词  </li><li>boolean hasNextInt()<br>检测输入是否还有int  </li><li>boolean hasDouble()<br>检测输入是否还有double  </li></ul><p>因为输入是可见的，所以Scanner类不使用于从控制台读取密码。Java SE 6特别引入了Console类实现不回显的输入。要想读取一个密码，可以采用下列代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Console cons = System.console();</div><div class="line">String username = cons.readLine(<span class="string">"User name: "</span>);</div><div class="line"><span class="keyword">char</span>[] passwd = cons.readPassword(<span class="string">"Password: "</span>);</div></pre></td></tr></table></figure></p><p><strong>几点注意：<br>1.Console类不能用new构造对象，属于单例模式，构造方法被private修饰<br>2.为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理后，应该马上用一个填充值覆盖数组元素。<br>3.采用Console对象处理输入不如Scanner方便，每次只能读取一行输入，而没有能够读取一个单词或一个数值的方法</strong>  </p><p>下面给出Console类的常用API：  </p><ul><li>static Console console()<br>返回一个Console对象  </li><li>static char[] readPassword(String prompt, Object…args)<br>显示提示字符串prompt并读取用户输入，直到输入行结束,结果存放在字符数组中。args参数用来提供输入格式。  </li><li>static String readLine(String prompt,Object…args)<br>显示提示字符串prompt并读取用户输入，直到输入行结束，结果存放在字符串中。args参数用来提供输入格式。  </li></ul><h4 id="2-输出"><a href="#2-输出" class="headerlink" title="2) 输出"></a>2) 输出</h4><p>可以使用 System.out.print(x) 将数值 x 输出到控制台上。这条命令将以 x 对应的数据类型所允许的最大非 0 数字位数打印输出 x 。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> x = <span class="number">10000.0</span> / <span class="number">3.0</span>;</div><div class="line">System.out.print(x);</div></pre></td></tr></table></figure></p><p>打印<br>3333.3333333333335<br>如果希望显示美元、美分等符号， 则有可能会出现问题。<br>在早期的 Java 版本中，格式化数值曾引起过一些争议。庆幸的是，Java SE 5.0 沿用了 C语言库函数中的 printf方法。例如，调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%8.2f"</span>,x);</div></pre></td></tr></table></figure></p><p>可以用 8 个字符的宽度和小数点后两个字符的精度打印 x。也就是说，打印输出一个空格和7 个字符， 如下所示：<br>3333.33<br>在 printf中，可以使用多个参数， 例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"Hello, %s. Next year, you'll be %d"</span>, name, age);</div></pre></td></tr></table></figure></p><p>每一个以 % 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数。  </p><p>下表列出了所有转换符：<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/用于printf的转换符.png" alt="fail" title="用于printf的转换符"><br>另外，还可以给出控制格式化输出的各种标志。例如，逗号<br>标志增加了分组的分隔符。即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%,.2f"</span>, <span class="number">10000.0</span> / <span class="number">3.0</span>);</div></pre></td></tr></table></figure></p><p>打印<br>3,333.33  </p><p>下表列出了用于printf的所有标志<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/用于printf的标志.png" alt="fail" title="用于printf的标志">  </p><p>可以使用静态的 String.format 方法创建一个格式化的字符串，而不打印输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String message = String.format(<span class="string">"Hello, %s. Next year, you'll be %d"</span>, name , age);</div></pre></td></tr></table></figure></p><p>基于完整性的考虑， 下面简略地介绍 printf方法中日期与时间的格式化选项(已经过时)。在新代码中， 应当使用 java.time 包的方法。 不过你可能会在遗留代码中看到 Date 类和相关的格式化选项。格式包括两个字母， 以 t 开始， 以下表中的任意字母结束。<br>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%tc"</span>, <span class="keyword">new</span> Date());</div></pre></td></tr></table></figure></p><p>这条语句将用下面的格式打印当前的日期和时间：<br>Mon Feb 09 18:05:19 PST 2015<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/日期和时间的转换符1.png" alt="fail"><br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/日期和时间的转换符2.png" alt="fail" title="日期和时间的转换符">  </p><p>从上表可以看到，某些格式只给出了指定日期的部分信息。例如，只有日期或月份。如果需要多次对日期操作才能实现对每一部分进行格式化的目的就太笨拙了。为此，可以采用一个格式化的字符串指出要被格式化的<strong>参数索引</strong>。索引必须紧跟在%后面， 并以<code>$</code>终止。 例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%1$s %2$tB %2$te,%2$tY"</span>,<span class="string">"Due date:"</span>,<span class="keyword">new</span> Date());</div></pre></td></tr></table></figure></p><p>打印<br>Due date: February 9, 2015</p><p>还可以选择使用 &lt; 标志。它指示前面格式说明中的参数将被再次使用。也就是说，下列语句将产生与前面语句同样的输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out .printf(<span class="string">"%s %tB %&lt;te, %&lt;tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> Date());</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>参数索引值从1开始，而不是从0开始，%1<code>$</code>…对第一个参数格式化。这就避免了与0标志混淆。  </p><p>现在，已经了解了 printf 方法的所有特性。下表给出了格式说明符的语法图： </p><p><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/格式说明符语法.png" alt="fail" title="格式说明符语法">  </p><h4 id="3-重定向语法"><a href="#3-重定向语法" class="headerlink" title="3) 重定向语法"></a>3) 重定向语法</h4><p>Java使用System.out(系统类的输出流对象)来表示标准输出设备，默认情况下是显示器，而用System.in(系统类的输入流对象)来表示标准输入设备，默认情况下是键盘。<br>有时，我们需要从文件而不是键盘读入数据，并希望将程序输出结果保存到文件中而不是打印在控制台上。此时，可以在命令行利用Shell的重定向语法将任意文件关联到System.in和System.out，例如下面的语句实现了从input.txt文件输入并将程序输出结果输入output.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java MyProg &lt; input.txt &gt; output.txt</div></pre></td></tr></table></figure></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1) 定义方法"></a>1) 定义方法</h4><p>下面先来看一个方法的定义，其作用是返回两个整数中的较大者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</div><div class="line"><span class="keyword">int</span> result;</div><div class="line">    <span class="keyword">if</span>(num1 &gt; num2)</div><div class="line">    result = num1;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    result = num2;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中花括号前的部分是<strong>方法头</strong>，花括号包括的部分是<strong>方法体</strong>。方法头包括<strong>修饰符(public static)、返回值类型(int)、方法名(max)、形式参数(int num1、int num2)</strong>。形式参数构成<strong>参数列表</strong>，方法名和参数列表构成<strong>方法签名</strong>。<br>对带返回值的方法而言，return语句是必需的，且如果存在多个选择分支，要确保任何分支都有返回值。对于void方法，也可以在方法中使用return结束方法调用。</p><h4 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2) 调用方法"></a>2) 调用方法</h4><p>如调用上述max方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> z = max(x,y);</div></pre></td></tr></table></figure></p><p>其中x,y是实际参数。</p><p>每当调用一个方法时，系统会创建一个<strong>活动记录</strong>(也称为活动框架)，用于保存方法中的参数和变量。活动记录置于一个内存区域中，称为<strong>调用堆栈(call stack)</strong>。调用堆栈也称为执行堆栈、运行时堆栈，或者一个机器堆栈，常简称为”堆栈”。当一个方法调用另一个方法时，调用者的活动记录保持不动，一个新的活动记录被创建用于被调用的新方法,一个新的记录”入栈”。一个方法结束返回到调用者时，相应的活动记录被释放，其中的参数和变量被销毁，栈顶的记录”出栈”。堆栈的最底层活动记录是main方法的记录，当整个程序结束，main方法记录”出栈”,栈为空，程序结束。  </p><p>当调用带参数的方法时，如果参数是基本数据类型，实参的值传递给形参(即拷贝)，这个过程称为<strong>按值传递</strong>，无论形参在方法中是否改变，实参都不受影响;如果参数是引用类型，则传递的是引用值，可以理解为<strong>传共享</strong>，形参和实参指向同一对象，此时实际对象可能会被改变。  </p><p>main方法也有参数，是一个String数组，可以在命令行里给main方法传递字符串参数(也可以通过eclipse传递参数，在运行——运行配置——自变量里传递)。例如，下面的命令行用三个字符串arg0、arg1、arg2启动程序TestMain：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java TestMain arg0 arg1 arg2</div></pre></td></tr></table></figure></p><p>其中arg0、arg1、arg2都是字符串，但是在命令行中出现时不需要双引号，但如果字符串包含空格，就必须用双引号括住。<br>当调用main方法时，Java解释器会创建一个数组存储命令行参数，然后将该数组的引用传递给args。例如，如果调用有n个命令行参数的程序，Java解释器创建一个如下所示的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args = <span class="keyword">new</span> String[n];</div></pre></td></tr></table></figure></p><p>然后Java解释器传递参数args去调用main方法<br><strong>注意：如果命令行没有传递参数，那么使用new String[0]创建数组。在这种情况下args引用了一个长度为0的空数组，它的值不是null，但是args.length是0</strong></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java和许多高级语言都提供了一种称作数组的数据结构，可以用它来存储一个元素个数固定且元素类型相同的有序集。<br>数组一旦被创建，它的大小不能改变。使用一个数组引用变量，通过下标来访问数组中的元素。  </p><h4 id="1-声明和创建数组-以一维数组为例"><a href="#1-声明和创建数组-以一维数组为例" class="headerlink" title="1) 声明和创建数组(以一维数组为例)"></a>1) 声明和创建数组(以一维数组为例)</h4><p>来看下面的语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">elementType[] arrayRefVar = <span class="keyword">new</span> elementType[arraySize];</div><div class="line"><span class="comment">//(元素类型[] 数组引用变量 = new 元素类型[数组大小])</span></div></pre></td></tr></table></figure></p><p>该语句完成了三个操作：<br>1.<code>elementType[] arrayRefVar</code>声明了一个elementType类型的数组引用变量arrayRefVar<br>2.<code>new elementType[arraySize]</code>创建了一个大小为arraySize的elementType的数组<br>3.<code>=</code> 把数组引用赋给数组引用变量  </p><p><strong>注意：</strong><br>1.<code>elementType[] arrayRefVar</code>只是声明数组变量，并不在内存中给数组分配任何空间，它只是创建一个对数组应用的存储位置，如果变量不包含对数组的引用，这个变量的值为null<br>2.<code>new elementType[arraySize]</code>在内存中给数组元素分配了存储空间<br>3.一个数组变量看起来似乎是存储了一个数组，但实际上它存储的是只是数组的引用。<br>4.当创建数组后，它的元素被赋予默认值，数值型基本数据类型的默认值为0,char型的默认值为’\u0000’(空字符，但长度为1),boolean型的默认值为false，非基本数据类型的默认值均为null<br>5.与C++不同，Java允许动态开数组，即无需在编译期就确定数组大小，可以在程序运行时决定数组大小并创建相应大小的数组。</p><h4 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2) 初始化数组"></a>2) 初始化数组</h4><p>1.逐一赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myList = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">myList[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">myList[<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line">myList[<span class="number">2</span>] = <span class="number">3</span>;</div><div class="line">myList[<span class="number">3</span>] = <span class="number">4</span>;</div><div class="line">myList[<span class="number">4</span>] = <span class="number">5</span>;</div></pre></td></tr></table></figure></p><p>2.数组初始化语法  </p><p>下面的语法可以给数组的前k个元素赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">elementType[] arrayRefVar = &#123;value0, value1, .., valuek&#125;;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>在使用数组初始化语法时，必须将声明、创建和初始化放在一条语句中，将它们分开会产生语法错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myList;</div><div class="line">myList = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//Error</span></div></pre></td></tr></table></figure></p><h4 id="3-访问数组元素"><a href="#3-访问数组元素" class="headerlink" title="3) 访问数组元素"></a>3) 访问数组元素</h4><p>可以用arrayRefVar.length得到数组长度，数组元素的下标为0 ～ arrayRefVar.length - 1。可以直接使用下标随机访问数组元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayRefVar[index] (数组引用变量[下标])</div></pre></td></tr></table></figure></p><p>如果要打印数组，可以使用一个循环打印逐一数组元素。<strong>如果是字符数组，可以使用一条打印语句打印</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>[] city = &#123;<span class="string">'B'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'g'</span>&#125;;</div><div class="line">System.out.println(city);</div></pre></td></tr></table></figure></p><h4 id="4-复制数组"><a href="#4-复制数组" class="headerlink" title="4) 复制数组"></a>4) 复制数组</h4><p>要将一个数组中的内容复制到另一个中，如果使用<code>=</code>直接赋值，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list2 = list1;</div></pre></td></tr></table></figure></p><p>上述语句只是将list1的引用值复制给了list2，这条语句执行后，list1和list2都指向了同一个数组，如果改变其中一者，另一者也会受到同样的影响。list2原先所引用的数组不能再引用，它就变成了垃圾，会被JVM自动回收。<strong>在Java中，可以使用赋值语句复制基本类型的值，但不能复制数组等引用类型的值。</strong>  </p><p>复制数组的四种方法<br>1.申请一个新数组，遍历原数组逐一复制元素<br>2.使用System类的静态方法arraycopy<br>3.使用<code>数组对象.clone</code>返回一个数组克隆的引用<br>4.使用Arrays类的copyOf方法  </p><h4 id="5-匿名数组"><a href="#5-匿名数组" class="headerlink" title="5) 匿名数组"></a>5) 匿名数组</h4><p>来看下面的语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> elementType[] &#123;value0,value1, ... ,valuek&#125;;</div></pre></td></tr></table></figure></p><p>该语句创建了一个没有显式引用变量的数组并进行了初始化，这样的数组称为<strong>匿名数组</strong>。注意匿名数组的<strong>方括号里不指定数组长度!</strong>  </p><h4 id="6-可变长参数列表"><a href="#6-可变长参数列表" class="headerlink" title="6) 可变长参数列表"></a>6) 可变长参数列表</h4><p>可以把类型相同但个数可变的参数传递给方法，语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeName...parameterName (类型名...参数名)</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1.在方法声明中，指定类型后紧跟着省略号(…)<br>2.只能给方法中指定一个可变长参数，且该参数必须是最后一个参数，任何常规参数必须在它之前<br>3.Java将可变长参数当成数组对待，当用数目可变的参数调用方法时，Java会创建一个数组并把参数传给它  </p><h4 id="7-Arrays类"><a href="#7-Arrays类" class="headerlink" title="7) Arrays类"></a>7) Arrays类</h4><p>Arrays类中包含了许多对处理数组的方法  </p><p>下面是Arrays类的常用API：  </p><p><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/Arrays类常用API1.png" alt="fail"><br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/Arrays类常用API2.png" alt="fail" title="Arrays类常用API">  </p><p>如果计算机有多个处理器，可以使用parallelSort，比sort更高效。  </p><h4 id="8-多维数组"><a href="#8-多维数组" class="headerlink" title="8) 多维数组"></a>8) 多维数组</h4><p>以二维数组为例，二维数组引用变量有三种表示方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">elementType arrayRefVar[][]</div><div class="line">elementType[] arrayRefVar[]</div><div class="line">elementType[][] arrayRefVar</div></pre></td></tr></table></figure></p><p>推荐使用<code>elementType[][] arrayRefVar</code>声明二维数组引用变量。<br>初始化语法也适用于多维数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] array = &#123;</div><div class="line">     &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</div><div class="line">     &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">array[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">array[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line">array[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">3</span>;</div><div class="line">array[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">4</span>;</div></pre></td></tr></table></figure></p><p><strong>二维数组其实是一个数组，它的每个元素都是一个一维数组，即它是数组的数组。</strong><br>x.length可以获取二维数组的第一维长度，x[index].length可以获取index行对应的第二维长度。如果没有初始化二维数组二维数组的所有元素默认为null，因为二维数组的元素是数组类型，默认值为null<br><strong>二维数组中的每一行本身就是一个数组，因此，各行的长度可以不同。这样的数组称为锯齿数组</strong>，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] triangleArray = &#123;</div><div class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">    &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">    &#123;<span class="number">5</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>其余没有赋值的部分并不会被赋为默认值，就是未分配空间,如果进行访问会抛出ArrayIndexOutOfBoundsException</strong>  </p><p>二维数组在创建时可以省略第二维长度(留到后续指定)，但必须指定第一维长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] triangleArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];</div><div class="line">triangleArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">triangleArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">triangleArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</div><div class="line">triangleArray[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">triangleArray[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div></pre></td></tr></table></figure></p><p>如果想打印多维数组，可以使用嵌套循环打印，也可以使用Arrays类的<strong>deepToString</strong>方法。</p><h3 id="零敲碎打"><a href="#零敲碎打" class="headerlink" title="零敲碎打"></a>零敲碎打</h3><ul><li>一个Java源文件内只能有一个public类,且该类名称必须与文件名相同  </li><li>main方法是程序的入口，JVM将从指定类中的main方法开始执行。根据Java语言规范，main方法必须声明为<code>public static void main(String[] args)</code></li><li>在源代码中，字符串常量不能跨行，因此，下面的语句会造成编译错误：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"Welcome to the</span></div><div class="line"><span class="string">world of Java!"</span>);</div></pre></td></tr></table></figure></li></ul><p>为了改正错误，可以将该字符串分成几个单独的子串，然后再用连接符(+)将它们组合起来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"Welcome to the“ +</span></div><div class="line"><span class="string">”world of Java!"</span>);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h3&gt;&lt;p&gt;Java是一种&lt;strong&gt;强类型&lt;/strong&gt;语言，即意味着必须为每一个变量声明一种类型。在Java中一共有8种基本
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之Java程序设计概述</title>
    <link href="http://habitdiary.cn/2017/10/07/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <id>http://habitdiary.cn/2017/10/07/Java学习总结之Java程序设计概述/</id>
    <published>2017-10-07T13:46:26.000Z</published>
    <updated>2017-11-02T17:27:11.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、走进Java"><a href="#一、走进Java" class="headerlink" title="一、走进Java"></a>一、走进Java</h3><p>Java是一个完整的平台,有一个庞大的库,其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。它是功能完善的通用程序设计语言，可以用来开发健壮的任务关键的应用程序。现在，它不仅用于Web程序设计，而且用于在服务器、台式计算机和移动设备上开发跨平台的独立应用程序。</p><h3 id="二、Java”白皮书”的关键术语"><a href="#二、Java”白皮书”的关键术语" class="headerlink" title="二、Java”白皮书”的关键术语"></a>二、Java”白皮书”的关键术语</h3><h4 id="1-简单性"><a href="#1-简单性" class="headerlink" title="1) 简单性"></a>1) 简单性</h4><p>Java语法是C++语法的一个“纯净”版本。这里没有头文件、指针运算(甚至指针语法)、结构、联合、操作符重载、虚基类等。其剔除了C++中许多很少使用、难以理解、易混淆的特性。目前看来，这些特性带来的麻烦远远多于其带来的好处。  </p><h4 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2) 面向对象"></a>2) 面向对象</h4><p>简单地讲，面向对象设计是一种程序设计技术。传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。</p><h4 id="3-分布式"><a href="#3-分布式" class="headerlink" title="3) 分布式"></a>3) 分布式</h4><p>Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。  </p><h4 id="4-健壮性"><a href="#4-健壮性" class="headerlink" title="4) 健壮性"></a>4) 健壮性</h4><p>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java投入了大量的精力进行早期的问题检测(编译时检测)，后期动态的检测(运行时检测)，并消除了容易出错的情况。  </p><h4 id="5-安全性"><a href="#5-安全性" class="headerlink" title="5) 安全性"></a>5) 安全性</h4><p>Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。  </p><h4 id="6-体系结构中立"><a href="#6-体系结构中立" class="headerlink" title="6) 体系结构中立"></a>6) 体系结构中立</h4><p>Java源文件经过编译生成中间字节码文件(.class)，这是一种体系结构中立的文件格式，精心设计的字节码不仅可以很容易地在任何带Java虚拟机(JVM)的平台上运行，而且还可以动态地翻译成本地机器代码，即Java程序可以”一次编译，处处运行”。当然，解释虚拟机指令肯定会比全速运行机器指令慢很多。虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程称为<strong>即时编译</strong>。  </p><h4 id="7-可移植性"><a href="#7-可移植性" class="headerlink" title="7) 可移植性"></a>7) 可移植性</h4><p>与C和C++不同，Java规范中没有”依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。例如，Java中的int永远是32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是int类型的大小不能低于short int，并且不能高于long int。在Java中，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。</p><h4 id="8-解释型"><a href="#8-解释型" class="headerlink" title="8) 解释型"></a>8) 解释型</h4><p>Java源程序(.java)在编写完成后，经过编译生成中间字节码文件(.class)，字节码文件被JVM解释执行，不同于C/C++等编译型语言，字节码被解释称机器代码后立即执行，不产生中间机器代码文件。</p><h4 id="9-高性能"><a href="#9-高性能" class="headerlink" title="9) 高性能"></a>9) 高性能</h4><p>尽管对解释后的字节码性能已经比较满意，但有些场合下还需要更加高效的性能。字节码可以(在运行时刻)动态地翻译成对应运行这个应用的特定CPU的机器码。  </p><h4 id="10-多线程"><a href="#10-多线程" class="headerlink" title="10) 多线程"></a>10) 多线程</h4><p>多线程可以带来更好的交互响应和实时行为。我们非常关注并发性，因为我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。Java是第一个支持并发程序设计的主流语言。  </p><h4 id="11-动态性"><a href="#11-动态性" class="headerlink" title="11) 动态性"></a>11) 动态性</h4><p>Java能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时的类型信息十分简单。  </p><h3 id="三、名词释疑"><a href="#三、名词释疑" class="headerlink" title="三、名词释疑"></a>三、名词释疑</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>即Java开发工具包(Java Development Kit)，是<strong>编写</strong>Java程序的程序员使用的软件，包括<strong>开发和运行</strong>Java程序的软件。 </p><h4 id="OpenJDK"><a href="#OpenJDK" class="headerlink" title="OpenJDK"></a>OpenJDK</h4><p>Java SE的一个免费开源实现，不包含浏览器集成或JavaFX  </p><h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><p>即Software Development Kit,是一个过时的术语，用于描述1998 ～ 2006年之间的JDK  </p><h4 id="J2"><a href="#J2" class="headerlink" title="J2"></a>J2</h4><p>一个过时的术语，用于描述1998 ～ 2006年之间的Java版本  </p><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>即Java运行时环境(Java Runtime Environment)，是<strong>运行</strong>Java程序的用户使用的软件，它包含Java虚拟机但不包含编译器，为<strong>不需要开发只需要运行</strong>Java程序的用户提供。</p><h4 id="Sever-JRE"><a href="#Sever-JRE" class="headerlink" title="Sever JRE"></a>Sever JRE</h4><p>在服务器上运行Java程序的软件。</p><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>即Java虚拟机(Java Virtual Machine)，用于解释执行中间字节码文件。  </p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>即应用程序接口(Application Program Interface),也称为库，包括为开发Java程序而预定义的类和接口。  </p><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>即集成开发环境(Integrated Development Environment),是为了快速开发程序而提供的开发工具，编辑、编译、链接、调试和在线帮助都集成在一个图形用户界面中。</p><h4 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h4><p>能在Web浏览器中运行的Java程序称为Java小程序(applet)</p><h4 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h4><p>即Java标准版(Java Standard Edition),可以用来开发客户端的应用程序。应用程序可以独立运行或作为applet在Web浏览器中运行。  </p><h4 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h4><p>即Java企业版(Java Enterprise Edition),可以用来开发服务器端的应用程序，例如，Java servlet和JavaServer Pages(JSP)，以及JavaServer Faces(JSF)。 </p><h4 id="Java-ME"><a href="#Java-ME" class="headerlink" title="Java ME"></a>Java ME</h4><p>即Java微型版(Java Micro Edition)，可以用来开发移动设备的应用程序，例如手机。  </p><h4 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h4><p>开发Java GUI程序的框架，在Oracle的Java SE发布版本中提供。  </p><h3 id="四、JDK、JRE和JVM三者的关系"><a href="#四、JDK、JRE和JVM三者的关系" class="headerlink" title="四、JDK、JRE和JVM三者的关系"></a>四、JDK、JRE和JVM三者的关系</h3><p>见大牛博客：<a href="http://playkid.blog.163.com/blog/static/56287260201372113842153/" target="_blank" rel="external">JDK、JRE、JVM三者间的关系</a></p><h3 id="五、创建、编译和执行Java程序的过程"><a href="#五、创建、编译和执行Java程序的过程" class="headerlink" title="五、创建、编译和执行Java程序的过程"></a>五、创建、编译和执行Java程序的过程</h3><p>Java源程序编写后被保存为.java文件，通过Java编译器编译生成字节码.class文件，字节码文件和所需的库代码被送去JVM解释执行。在执行一个Java程序时，JVM首先会用一个称为<strong>类加载器(class loader)</strong>的程序将类的字节码加载到内存中。如果你的程序中使用其他类，类加载程序会在需要它们之前动态地加载它们。当加载该类后，JVM使用一个字节码验证器(bytecode verifier)的程序来检验字节码的合法性，确保字节码不会违反Java的安全规范，以确保来自网络的Java程序不会篡改和危害你的计算机。  </p><h3 id="六、通过命令行编译、运行Java程序"><a href="#六、通过命令行编译、运行Java程序" class="headerlink" title="六、通过命令行编译、运行Java程序"></a>六、通过命令行编译、运行Java程序</h3><p>在命令行里输入以下命令编译Java程序：<br>java classname.java<br>编译成功后，使用以下语句运行程序：<br>java classname //注意此处不要加.class后缀  </p><h3 id="七、注释"><a href="#七、注释" class="headerlink" title="七、注释"></a>七、注释</h3><h4 id="1-行注释"><a href="#1-行注释" class="headerlink" title="1) 行注释"></a>1) 行注释</h4><p>行注释以<code>//</code>开始，不能跨行  </p><h4 id="2-块注释"><a href="#2-块注释" class="headerlink" title="2) 块注释"></a>2) 块注释</h4><p>块注释以<code>/*</code>开始，以<code>*/</code>结尾，可以跨行  </p><h4 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3) 文档注释"></a>3) 文档注释</h4><p>文档注释以<code>/**</code>开始，以<code>*/</code>结尾，它能使用JDK的javadoc命令提取一个HTML文件。使用javadoc注释来注释整个类或整个方法，为了将这些注释提取出来放在一个javadoc HTML文件中，这些注释必须放在类或者方法头前面。要注释方法中的某一步骤，使用行注释<code>//</code></p><h3 id="八、程序设计错误"><a href="#八、程序设计错误" class="headerlink" title="八、程序设计错误"></a>八、程序设计错误</h3><h4 id="1-语法错误"><a href="#1-语法错误" class="headerlink" title="1) 语法错误"></a>1) 语法错误</h4><p>在编译过程中出现的错误称为<strong>语法错误</strong>或<strong>编译错误</strong>。  </p><h4 id="2-运行时错误"><a href="#2-运行时错误" class="headerlink" title="2) 运行时错误"></a>2) 运行时错误</h4><p>运行时错误是引起程序非正常中断的错误，即程序能通过编译，但在运行时环境检测到一个不可能执行的操作，就会出现运行错误。  </p><h4 id="3-逻辑错误"><a href="#3-逻辑错误" class="headerlink" title="3) 逻辑错误"></a>3) 逻辑错误</h4><p>当程序没有按预期的方式执行就会发生逻辑错误。  </p><h3 id="九、Java标识符"><a href="#九、Java标识符" class="headerlink" title="九、Java标识符"></a>九、Java标识符</h3><p>Java标识符用于命名类、接口、变量、常量、方法等，有如下规则：  </p><ul><li>标识符是由<strong>字母、数字、下划线(<code>_</code>)和美元符号(<code>$</code>)</strong>组成的字符序列  </li><li>必须以<strong>字母、下划线(<code>_</code>)或美元符号(<code>$</code>)</strong>开头，不能以数字开头  </li><li>标识符不能是保留字  </li><li>标识符不能是<strong>true、false或null</strong>等字面常量  </li><li>标识符可以为任意长度  </li><li>不要用字符<code>$</code>命名标识符，习惯上<code>$</code>只用于机器自动产生的源代码中 </li></ul><h3 id="十、命名规范"><a href="#十、命名规范" class="headerlink" title="十、命名规范"></a>十、命名规范</h3><p><strong>注意：在命名时尽量避免采用缩写作为标识符，用完整的词汇会更具有描述性，比如numberOfStudents比numStds、numOfStuds或者numOfStudents要好。另外，Java是区分大小写的。</strong></p><h4 id="1-类名和接口"><a href="#1-类名和接口" class="headerlink" title="1) 类名和接口"></a>1) 类名和接口</h4><p>每个单词的首字母大写,例如类名ComputeArea和System  </p><h4 id="2-变量和方法"><a href="#2-变量和方法" class="headerlink" title="2) 变量和方法"></a>2) 变量和方法</h4><p>使用小写字母命名变量和方法，如有多个单词则第一个单词字母小写，后面每个单词的首字母大写，例如变量radius以及方法setRadius  </p><h4 id="3-常量"><a href="#3-常量" class="headerlink" title="3) 常量"></a>3) 常量</h4><p>大写常量的所有字母，如果有多个单词，单词之间用下划线连接，例如，常量PI和常量MAX_VALUE  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、走进Java&quot;&gt;&lt;a href=&quot;#一、走进Java&quot; class=&quot;headerlink&quot; title=&quot;一、走进Java&quot;&gt;&lt;/a&gt;一、走进Java&lt;/h3&gt;&lt;p&gt;Java是一个完整的平台,有一个庞大的库,其中包含了很多可重用的代码和一个提供诸如安全性、跨
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SSH远程登录实现本地机和服务器的文件传输</title>
    <link href="http://habitdiary.cn/2017/10/07/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <id>http://habitdiary.cn/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/</id>
    <published>2017-10-07T07:55:41.000Z</published>
    <updated>2017-10-07T08:57:11.077Z</updated>
    
    <content type="html"><![CDATA[<p>SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见:  <a href="http://habitdiary.cn/2017/10/07/%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/#more">在Ubuntu下通过SSH连接远程服务器</a>  </p><h3 id="1-用SSH登录远程ubuntu主机"><a href="#1-用SSH登录远程ubuntu主机" class="headerlink" title="(1)用SSH登录远程ubuntu主机"></a>(1)用SSH登录远程ubuntu主机</h3><p>假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu<br>我们在命令行输入以下命令来连接：<br><code>ssh -l ubuntu 118.89.223.117</code><br>之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/1.png" alt="fail">  </p><h3 id="2-从远程Ubuntu主机下载文件-文件夹到本地-scp"><a href="#2-从远程Ubuntu主机下载文件-文件夹到本地-scp" class="headerlink" title="(2)从远程Ubuntu主机下载文件/文件夹到本地(scp)"></a>(2)从远程Ubuntu主机下载文件/文件夹到本地(scp)</h3><p>语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径  </p><p>我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/4.png" alt="fail"><br>要下载文件到本地,我们要结束SSH连接,切换到本地机,输入<code>eixt</code>或<code>quit</code>即可  </p><p>我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/5.png" alt="fail">  </p><p>我们进入本地目录验证一下<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/6.png" alt="fail">  </p><p>hello文件的确下载到了本地</p><h3 id="3-从本地向远程ubuntu主机上传文件-文件夹-scp"><a href="#3-从本地向远程ubuntu主机上传文件-文件夹-scp" class="headerlink" title="(3)从本地向远程ubuntu主机上传文件/文件夹(scp)"></a>(3)从本地向远程ubuntu主机上传文件/文件夹(scp)</h3><p>语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径  </p><p>假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下  </p><p>要上传本地文件,我们要结束SSH连接,切换到本地机,输入<code>eixt</code>或<code>quit</code>即可<br>然后输入命令<code>$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/</code>，输入密码后提示文件上传成功<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/2.png" alt="fail">  </p><p>我们通过SSH登录到远程主机验证一下,<code>pwd</code>打印当前所在位置，发现我们处于/home/ubuntu目录下,<code>ls</code>显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/3.png" alt="fail">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
      <category term="服务器" scheme="http://habitdiary.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu下通过SSH连接远程服务器</title>
    <link href="http://habitdiary.cn/2017/10/07/%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://habitdiary.cn/2017/10/07/在Ubuntu下通过SSH连接远程服务器/</id>
    <published>2017-10-07T07:20:37.000Z</published>
    <updated>2017-10-07T08:51:40.404Z</updated>
    
    <content type="html"><![CDATA[<p>登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一:"></a>步骤一:</h3><p>打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端<br><code>$ sudo apt-get install aptitude</code><br><code>$ sudo aptitude install openssh-server</code> </p><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二:"></a>步骤二:</h3><p>启动ssh-server<br><code>$ /etc/init.d/ssh restart</code>  </p><h3 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h3><p>确认ssh-server已经正常工作<br><code>$ netstat -tlp</code><br>tcp6 0 0 *:ssh *:* LISTEN -<br>看到上面一行说明ssh-server已经在运行了  </p><h3 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h3><p>在本地机终端通过ssh登录服务器<br><code>$ ssh -l 远程服务器用户名 服务器ip地址</code><br>接下来会提示输入密码，然后就能成功登录到服务器上了</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/wh_19910525/article/details/7585257" target="_blank" rel="external">http://blog.csdn.net/wh_19910525/article/details/7585257</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
      <category term="服务器" scheme="http://habitdiary.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>强制修改ubuntu密码</title>
    <link href="http://habitdiary.cn/2017/10/06/%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81/"/>
    <id>http://habitdiary.cn/2017/10/06/强制修改ubuntu密码/</id>
    <published>2017-10-06T07:02:39.000Z</published>
    <updated>2017-10-07T08:50:10.892Z</updated>
    
    <content type="html"><![CDATA[<p> 今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。<br> <img src="/2017/10/06/强制修改ubuntu密码/fail.png" alt="fail"><br> 查了资料,总结出两种解决方法:<br> 方法一:加上sudo权限<br> <img src="/2017/10/06/强制修改ubuntu密码/method1.png" alt="fail"><br> 方法二:切换到root用户<br>  <img src="/2017/10/06/强制修改ubuntu密码/method2.png" alt="fail"><br>  mark一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。&lt;br&gt; &lt;img src=&quot;/2017/10/06/强制修改ubuntu密码/fail.png&quot; alt=&quot;fail&quot;&gt;&lt;br&gt; 查了资料,总结出两种解决方法:&lt;br&gt; 方法一:
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="http://habitdiary.cn/2017/10/05/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://habitdiary.cn/2017/10/05/Markdown学习笔记/</id>
    <published>2017-10-05T08:36:06.000Z</published>
    <updated>2017-10-15T12:02:33.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="花了近两天时间终于搭建好了我的个人博客-因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法-例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。"><a href="#花了近两天时间终于搭建好了我的个人博客-因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法-例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。" class="headerlink" title="　　花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。"></a>　　花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。</h3><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><h2 id="标题根据字体大小分级产生层次，有两种写法："><a href="#标题根据字体大小分级产生层次，有两种写法：" class="headerlink" title="标题根据字体大小分级产生层次，有两种写法："></a>标题根据字体大小分级产生层次，有两种写法：</h2><h2 id="写法一："><a href="#写法一：" class="headerlink" title="写法一："></a>写法一：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">一级标题</div><div class="line">==================</div><div class="line">二级标题</div><div class="line">---------------------</div></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h2 id="写法二："><a href="#写法二：" class="headerlink" title="写法二："></a>写法二：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题  </div><div class="line">### 三级标题  </div><div class="line">#### 四级标题</div><div class="line">##### 五级标题  </div><div class="line">###### 六级标题</div></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong><em>可见<code>#</code>的数量越多标题字号越小，要特别注意<code>#</code>和标题之间要留一个空格!</em></strong></p><h1 id="2-内联样式"><a href="#2-内联样式" class="headerlink" title="2. 内联样式"></a>2. 内联样式</h1><h2 id="内联样式能描述文字的粗细、倾斜程度等"><a href="#内联样式能描述文字的粗细、倾斜程度等" class="headerlink" title="内联样式能描述文字的粗细、倾斜程度等"></a>内联样式能描述文字的粗细、倾斜程度等</h2><h2 id="2-1-语义标记："><a href="#2-1-语义标记：" class="headerlink" title="2.1 语义标记："></a>2.1 语义标记：</h2><p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">*这是斜体*</div><div class="line">_这是斜体_</div><div class="line">**这是粗体**  </div><div class="line">***这是加粗斜体***  </div><div class="line">**_这是加粗斜体_**</div><div class="line">~~这是删除线~~</div></pre></td></tr></table></figure></p><p>效果如下:  </p><p><em>这是斜体</em><br><em>这是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是加粗斜体</em></strong><br><strong><em>这是加粗斜体</em></strong><br><del>这是删除线</del>  </p><p>可见语义标记允许叠加</p><h2 id="2-2-语义标签"><a href="#2-2-语义标签" class="headerlink" title="2.2 语义标签"></a>2.2 语义标签</h2><p>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;i&gt;这是斜体&lt;/i&gt;  </div><div class="line">&lt;b&gt;这是粗体&lt;/b&gt;  </div><div class="line">&lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt;  </div><div class="line">&lt;em&gt;这是强调&lt;/em&gt;  </div><div class="line">这是上标 Z&lt;sup&gt;a&lt;/sup&gt;  </div><div class="line">这是下标 Z&lt;sub&gt;a&lt;/sub&gt;</div></pre></td></tr></table></figure></p><p>效果如下：  </p><p><i>这是斜体</i><br><b>这是粗体</b><br><i><b>这是粗斜体</b></i><br><em>这是强调</em><br>这是上标 Z<sup>a</sup><br>这是下标 Z<sub>a</sub>  </p><p>　　可见语义标签可以嵌套，特别要注意<code>&lt;em&gt;&lt;/em&gt;</code>标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用<code>&lt;i&gt;&lt;/i&gt;</code>标签替代</p><h1 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h1><h2 id="3-1-单行式"><a href="#3-1-单行式" class="headerlink" title="3.1 单行式"></a>3.1 单行式</h2><p>  代码:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; hello world</div></pre></td></tr></table></figure><p>  效果如下:  </p><blockquote><p>hello world  </p></blockquote><h2 id="3-2-多行式"><a href="#3-2-多行式" class="headerlink" title="3.2 多行式"></a>3.2 多行式</h2><p>  代码: </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; hello world  </div><div class="line">&gt; hello world  </div><div class="line">&gt; hello world</div></pre></td></tr></table></figure><p> 效果如下:  </p><blockquote><p>hello world<br>hello world<br>hello world</p></blockquote><h2 id="3-3-嵌套式"><a href="#3-3-嵌套式" class="headerlink" title="3.3 嵌套式"></a>3.3 嵌套式</h2><p>  代码:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; aaaaaaaaa</div><div class="line">&gt;&gt; bbbbbbbbb</div><div class="line">&gt;&gt;&gt; cccccccccc</div></pre></td></tr></table></figure><p>  效果如下:  </p><blockquote><p>aaaaaaaaa</p><blockquote><p>bbbbbbbbb</p><blockquote><p>cccccccccc</p></blockquote></blockquote></blockquote><h1 id="4-换行与段落缩进"><a href="#4-换行与段落缩进" class="headerlink" title="4. 换行与段落缩进"></a>4. 换行与段落缩进</h1><h2 id="换行-在行末敲两个空格和一个回车"><a href="#换行-在行末敲两个空格和一个回车" class="headerlink" title="换行:  在行末敲两个空格和一个回车"></a>换行:  <strong><em>在行末敲两个空格和一个回车</em></strong></h2><h2 id="段落缩进-将输入法切换为全角后敲击两次空格即可完成两个字符的缩进"><a href="#段落缩进-将输入法切换为全角后敲击两次空格即可完成两个字符的缩进" class="headerlink" title="段落缩进:  将输入法切换为全角后敲击两次空格即可完成两个字符的缩进"></a>段落缩进:  <strong><em>将输入法切换为全角后敲击两次空格即可完成两个字符的缩进</em></strong></h2><h1 id="5-行内标记与代码块"><a href="#5-行内标记与代码块" class="headerlink" title="5. 行内标记与代码块"></a>5. 行内标记与代码块</h1><h2 id="5-1-行内标记-用前后各一个-标记代码块将变成一行"><a href="#5-1-行内标记-用前后各一个-标记代码块将变成一行" class="headerlink" title="5.1 行内标记(用前后各一个`标记代码块将变成一行)"></a>5.1 行内标记(用前后各一个`标记代码块将变成一行)</h2><p>  代码:  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">标记之外`hello world`标记之外</div></pre></td></tr></table></figure><p>  效果如下:<br>   标记之外<code>hello world</code>标记之外  </p><h2 id="5-2-代码块-用于插入各类型的代码"><a href="#5-2-代码块-用于插入各类型的代码" class="headerlink" title="5.2 代码块(用于插入各类型的代码)"></a>5.2 代码块(用于插入各类型的代码)</h2><p>   方法一 (使用前后各一个```包裹代码生成块,注意```之后换行不需要敲两个空格!!!):<br>   效果如下:  </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;   </div><div class="line"> &lt;div&gt;&lt;/div&gt;</div><div class="line"> &lt;div&gt;&lt;/div&gt;</div><div class="line"> &lt;div&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>  方法二 (使用Tab缩进):<br>  代码及效果如下:<br>  我是文字…  </p><pre><code>&lt;div&gt;     &lt;div&gt;&lt;/div&gt;  &lt;div&gt;&lt;/div&gt;  &lt;div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p> <em>注意要在前文后空一行再进行Tab缩进</em></p><p> 方法三 (自定义语法)：<br> <strong>即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮</strong><br> 效果如下：<br> html代码块</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>   </div><div class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>javascript代码块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</div><div class="line">num += i;</div><div class="line"> &#125;</div><div class="line"><span class="built_in">console</span>.log(num);</div></pre></td></tr></table></figure><h1 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h1><p>　　Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。  </p><h2 id="6-1-行内式"><a href="#6-1-行内式" class="headerlink" title="6.1 行内式"></a>6.1 行内式</h2><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明:"></a>语法说明:</h2><ul><li>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<code>[链接文字](链接地址 “链接标题”)</code>这样的形式。链接地址与链接标题前有一个空格。  </li></ul><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这是[XJY&apos;s Blog](http://habitdiary.cn)  </div><div class="line">这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;)</div></pre></td></tr></table></figure><p>效果如下:<br>这是<a href="http://habitdiary.cn">XJY’s Blog</a><br>这是<a href="http://habitdiary.cn" title="XJY&#39;s Blog">XJY’s Blog</a>  </p><h2 id="6-2-参考式"><a href="#6-2-参考式" class="headerlink" title="6.2 参考式"></a>6.2 参考式</h2><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><h2 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明:"></a>语法说明:</h2><p>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。  </p><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。</div><div class="line">[1]:http://www.baidu.com &quot;Baidu&quot;</div><div class="line">[2]:http://note.youdao.com/ &quot;youdaonote&quot;</div><div class="line">[3]:http://www.imooc.com/ &quot;IMOOC&quot;</div><div class="line">[网站]:http://note.youdao.com/ &quot;youdaonote&quot;</div></pre></td></tr></table></figure><p>效果如下:  </p><p>我经常去的网站有<a href="http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg" title="爱琴海" target="_blank" rel="external">Baidu</a>、<a href="http://note.youdao.com/" title="youdaonote" target="_blank" rel="external">有道云笔记</a>以及<a href="http://www.imooc.com/" title="IMOOC" target="_blank" rel="external">IMOOC</a>,<a href="http://note.youdao.com/" title="youdaonote" target="_blank" rel="external">有道云笔记</a>是不错的<a href="http://note.youdao.com/" title="youdaonote" target="_blank" rel="external">网站</a>。</p><h2 id="6-3-自动链接"><a href="#6-3-自动链接" class="headerlink" title="6.3 自动链接"></a>6.3 自动链接</h2><h2 id="语法说明-2"><a href="#语法说明-2" class="headerlink" title="语法说明:"></a>语法说明:</h2><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;http://example.com/&gt;</div><div class="line">&lt;address@example.com&gt;</div></pre></td></tr></table></figure><p>效果如下:<br><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a><br><a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x61;&#x64;&#100;&#114;&#101;&#x73;&#115;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;">&#x61;&#x64;&#100;&#114;&#101;&#x73;&#115;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a></p><h1 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h1><h2 id="7-1-无序列表"><a href="#7-1-无序列表" class="headerlink" title="7.1 无序列表"></a>7.1 无序列表</h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* 吃饭</div><div class="line">* 睡觉</div><div class="line">* 打代码</div></pre></td></tr></table></figure><p>效果如下:  </p><ul><li>吃饭</li><li>睡觉</li><li>打代码  </li></ul><h2 id="7-2-有序列表"><a href="#7-2-有序列表" class="headerlink" title="7.2 有序列表"></a>7.2 有序列表</h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 把冰箱门打开</div><div class="line">2. 把大象关进去</div><div class="line">3. 把冰箱门带上</div></pre></td></tr></table></figure><p>效果如下:  </p><ol><li>把冰箱门打开</li><li>把大象关进去</li><li>把冰箱门带上</li></ol><h2 id="7-3-序表嵌套"><a href="#7-3-序表嵌套" class="headerlink" title="7.3 序表嵌套"></a>7.3 序表嵌套</h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1. one</div><div class="line">    1. one-1</div><div class="line">    2. two-2</div><div class="line">2. two </div><div class="line">    * two-1</div><div class="line">    * two-2</div></pre></td></tr></table></figure><p>效果如下:  </p><ol><li>one<ol><li>one-1</li><li>two-2</li></ol></li><li>two <ul><li>two-1</li><li>two-2  </li></ul></li></ol><h2 id="7-4-任务列表"><a href="#7-4-任务列表" class="headerlink" title="7.4 任务列表"></a>7.4 任务列表</h2><p>代码(方括号里是x表示打勾,空格表示为空):  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- [x] 选项一</div><div class="line">- [ ] 选项二  </div><div class="line">- [ ]  选项三</div></pre></td></tr></table></figure><p>效果如下:  </p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> 选项三</li></ul><h1 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8. 插入图片"></a>8. 插入图片</h1><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><h2 id="8-1-内联式"><a href="#8-1-内联式" class="headerlink" title="8.1 内联式"></a>8.1 内联式</h2><h2 id="语法说明-图片Alt-图片地址-“图片Title”"><a href="#语法说明-图片Alt-图片地址-“图片Title”" class="headerlink" title="语法说明:![图片Alt](图片地址 “图片Title”)"></a>语法说明:<code>![图片Alt](图片地址 “图片Title”)</code></h2><p>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">爱琴海</div><div class="line">![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;)</div></pre></td></tr></table></figure><p>效果如下:<br>爱琴海<br><img src="http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg" alt="爱琴海" title="爱琴海">  </p><h2 id="8-2-参照式"><a href="#8-2-参照式" class="headerlink" title="8.2 参照式"></a>8.2 参照式</h2><h2 id="语法说明-3"><a href="#语法说明-3" class="headerlink" title="语法说明:"></a>语法说明:</h2><p>在文档要插入图片的地方写<code>![图片Alt][标记]</code>，在文档的最后写上[标记]:图片地址 “Title”<br>代码:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">爱琴海</div><div class="line">![爱琴海][1]</div><div class="line">[1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;</div></pre></td></tr></table></figure><p>效果如下:<br>爱琴海<br><img src="http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg" alt="爱琴海" title="爱琴海"></p><h4 id="说明-如果要在Hexo中插入本地图片-具体方法见博客：http-blog-csdn-net-sugar-rainbow-article-details-57415705"><a href="#说明-如果要在Hexo中插入本地图片-具体方法见博客：http-blog-csdn-net-sugar-rainbow-article-details-57415705" class="headerlink" title="说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/57415705"></a>说明: 如果要在Hexo中插入本地图片,具体方法见博客：<a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="external">http://blog.csdn.net/sugar_rainbow/article/details/57415705</a></h4><h1 id="9-插入视频"><a href="#9-插入视频" class="headerlink" title="9. 插入视频"></a>9. 插入视频</h1><p>如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p><p>效果如下:  </p><iframe width="560" height="315" src="http://www.miaopai.com/show/9Sve8-3osRBmmpEvONt~uKP-WbvOSRLH.htm" frameborder="0" allowfullscreen></iframe><h2 id="mark一下第一次写博客遇到的神坑"><a href="#mark一下第一次写博客遇到的神坑" class="headerlink" title="mark一下第一次写博客遇到的神坑:"></a>mark一下第一次写博客遇到的神坑:</h2><ul><li>在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 </li></ul><h4 id="最后要感谢提供参考的大牛博客"><a href="#最后要感谢提供参考的大牛博客" class="headerlink" title="最后要感谢提供参考的大牛博客:"></a>最后要感谢提供参考的大牛博客:</h4><ul><li><a href="http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13" target="_blank" rel="external">http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13</a>  </li><li><a href="http://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="external">http://www.jianshu.com/p/b03a8d7b1719</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;花了近两天时间终于搭建好了我的个人博客-因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://habitdiary.cn/tags/Markdown/"/>
    
  </entry>
  
</feed>
