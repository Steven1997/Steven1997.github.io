<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XJY&#39;s Blog</title>
  
  <subtitle>你要静候再静候 就算失收始终要守</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://habitdiary.cn/"/>
  <updated>2018-02-05T13:34:50.978Z</updated>
  <id>http://habitdiary.cn/</id>
  
  <author>
    <name>谢均宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java学习总结之并发</title>
    <link href="http://habitdiary.cn/2018/02/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%B9%B6%E5%8F%91/"/>
    <id>http://habitdiary.cn/2018/02/01/Java学习总结之并发/</id>
    <published>2018-02-01T14:54:54.000Z</published>
    <updated>2018-02-05T13:34:50.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>操作系统的多任务指的是在同一刻运行多个程序的能力。例如，在编辑或下载邮件的同时可以打印文件。今天，人们很可能有单台拥有多个 CPU 的计算机, 但是 , 并发执行的进程数目并不是由 CPU 数目制约的。操作系统将 CPU 的时间片分配给每一个进程，给人并行处理的感觉。  </p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p><strong>并行：</strong>多个cpu或者多台机器同时执行一段处理逻辑，是真正的同时运行。<br><strong>并发：</strong>如果只有一个CPU，如何做到多个进程同时运行呢？我们先来看操作系统的一些相关概念。大部分操作系统(如Windows、Linux)的任务调度是采用<strong>时间片轮转的抢占式调度方式</strong>，即把CPU的执行时间分为很多小块，每一小块的时间相等且固定，我们把任务执行的这一小块时间叫做时间片。任务正在执行时的状态叫运行状态，一个任务执行一小段时间后会被强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来，每个任务在CPU的调度下轮流执行。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。<br>下面是时间片以及CPU轮转调度的示意图：<br><img src="/2018/02/01/Java学习总结之并发/CPU调度.png" alt="fail"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由<strong>程序、数据集合和进程控制块</strong>三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。  </p><p><strong>进程具有的特征：</strong><br><strong>动态性：</strong>进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br><strong>并发性：</strong>任何进程都可以同其他进程一起并发执行；<br><strong>独立性：</strong>进程是系统进行资源分配和调度的一个独立单位；<br><strong>结构性：</strong>进程由程序、数据和进程控制块三部分组成。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。<br>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。<strong>简言之，线程是比进程还要小的运行单位，可以看作是子程序，一个进程包含一个或多个线程。</strong>  </p><h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>JVM调用main()所产生的线程。</p><h4 id="当前线程"><a href="#当前线程" class="headerlink" title="当前线程"></a>当前线程</h4><p>当前正在运行的进程，可通过Thread.currentThread()来获取当前线程。  </p><h4 id="后台线程-守护线程"><a href="#后台线程-守护线程" class="headerlink" title="后台线程(守护线程)"></a>后台线程(守护线程)</h4><p>指为其他线程提供服务的线程，也称为守护线程。比如JVM的垃圾回收、内存管理等线程都是守护线程。当所有前台线程(用户线程)都结束，程序只剩下后台线程的时候，JVM就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。可以通过isDaemon()和setDaemon()方法来判断一个线程是否为后台线程和设置一个线程为后台线程。<br>守护线程有时会被初学者错误地使用，他们不打算考虑关机(shutdown)动作。但这是很危险的。守护线程应该永远不去访问固有资源, 如文件、数据库, 因为它会在任何时候甚至在一个操作的中间发生中断。比如一个守护线程在操作资源的时候，如果所有用户线程都退出了，JVM将直接杀死该守护线程而无法执行finally块中的关闭资源的语句。  </p><p>来看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</div><div class="line">            System.out.println(<span class="string">"我是非守护线程"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        threadStart();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadStart</span><span class="params">()</span></span>&#123;</div><div class="line">        DemoThread dt = <span class="keyword">new</span> DemoThread();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(dt);</div><div class="line">        thread.setDaemon(<span class="keyword">true</span>);</div><div class="line">         </div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果：<br>1、当直接启动时，不会打印出内容<br>2、当去掉thread.setDaemon(true)时，会打印出“我是非守护线程”。</p><p>原因分析：当thread被设置为守护线程时，主线程是前台线程，执行完之后就直接结束，JVM直接杀死thread，这个守护线程中的内容就不会继续执行下去；当去掉那一行时，thread就默认为前台线程，jvm会等所有前台线程执行完之后才会结束，thread线程就打印出内容  </p><h4 id="前台线程-用户线程、非守护线程"><a href="#前台线程-用户线程、非守护线程" class="headerlink" title="前台线程(用户线程、非守护线程)"></a>前台线程(用户线程、非守护线程)</h4><p>是指接受后台线程服务的线程，其实前台后台线程是联系在一起。由前台线程创建的线程默认也是前台线程。</p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>只包含一个线程的程序，即主线程(主方法所在线程)。  </p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>可以同时运行一个以上线程的程序。在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制。当选择下一个线程时，操作系统考虑线程的优先级。  </p><p>下面是单线程和多线程的关系示意图：<br><img src="/2018/02/01/Java学习总结之并发/单线程和多线程.png" alt="fail"></p><h3 id="进程和线程的区别与关系"><a href="#进程和线程的区别与关系" class="headerlink" title="进程和线程的区别与关系"></a>进程和线程的区别与关系</h3><p>1.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆、栈、程序计数器PC等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见。<strong>共享内存空间使线程之间的通信比进程之间的通信更有效、更容易，但也更具风险。</strong><br>2.创建一个新进程或进程之间的切换会有较大的开销，线程则更”轻量级”，创建、撤销、切换一个线程比启动一个新进程的开销要小得多。<br>3.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。<br>4.进程是操作系统进行资源分配和调度的最小单位，线程是程序执行的最小单位。    </p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul><li><strong>新建状态:</strong> 使用 new 关键字创建一个 Thread 类或其子类的线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序调用它的start()方法启动这个线程，随后线程便进入了就绪状态。</li><li><strong>就绪状态(可运行状态):</strong> 当线程对象调用了start()方法之后，该线程并不是立即开始运行，而是进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度，获取CPU使用权后才进入运行状态。</li><li><strong>运行状态:</strong> 如果就绪状态的线程获取 CPU 使用权，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。处于运行状态的线程如果CPU的时间片用完或者调用了yield()方法都会转化为就绪状态。而如果线程调用了sleep()方法、join()方法、wait()方法、获取synchronized同步锁失败或发出了I/O请求<strong>(比如等待用户输入)</strong>，线程都会进入阻塞状态。</li><li><strong>阻塞状态:</strong> 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态(注意阻塞状态无法直接转入运行状态，阻塞解除只能转入就绪状态！)。可以分为三种：<br><strong>1)等待阻塞：</strong>运行状态中的线程执行 wait() 方法，使线程进入到<strong>等待队列</strong>，即进入等待阻塞状态(wait()会释放线程持有的锁)，当调用notice()或noticeAll()方法线程重新转入就绪状态。<br><strong>2)同步阻塞：</strong>也称<strong>锁池状态</strong>，线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)进入同步阻塞状态，当其他线程释放该锁，并且线程调度器允许本线程持有它的时候，线程重新转入就绪状态。<br><strong>3)其他阻塞：</strong>通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 请求完毕<strong>(比如用户输入完毕)</strong>，线程重新转入就绪状态。</li><li><strong>死亡状态(终止状态):</strong><br>一个线程执行完毕或者异常终止，该线程就切换到终止状态。其他四个状态都可以通过调用stop()方法来进入死亡状态，但stop()方法已经过时了，不建议使用。</li></ul><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>即前面提到的线程的五个状态之间的转化，可以通过调用Thread类的方法来影响线程的生命周期。  </p><p><strong>下面是线程生命周期的示意图：</strong><br><img src="/2018/02/01/Java学习总结之并发/线程的生命周期.png" alt="fail">  </p><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Thread类是一个线程类，位于java.lang包下。它实现了Runnable接口。<br>1、构造方法<br><img src="/2018/02/01/Java学习总结之并发/Thread类构造方法.png" alt="fail"><br>2、常量<br><img src="/2018/02/01/Java学习总结之并发/Thread类常量.png" alt="fail"><br>3、常见方法<br><img src="/2018/02/01/Java学习总结之并发/Thread方法1.png" alt="fail"><br><img src="/2018/02/01/Java学习总结之并发/Thread方法2.png" alt="fail"><br>更多见大牛博客<a href="http://blog.csdn.net/u014290221/article/details/51436710" target="_blank" rel="external">JAVA线程-Thread类的方法</a>  </p><h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><ul><li>只有一个方法run();</li><li>Runnable是Java中用于实现线程的接口  </li><li>任何实现线程功能的类都必须实现该接口</li></ul><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>创建线程主要有三种方式：<br><strong>一、继承Thread类创建线程类</strong><br>继承Thread类的方法尽管被列为一种多线程实现方式，但Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。  </p><p><strong>下面是使用这种方法创建线程的具体步骤：</strong><br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。</p><p>来看下面的一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.thread;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(getName()+<span class="string">"该线程正在执行！"</span>);</div><div class="line">        <span class="comment">//通过getName()获取线程名</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"主线程1"</span>);</div><div class="line">MyThread mt=<span class="keyword">new</span> MyThread();</div><div class="line">mt.start();<span class="comment">//启动线程</span></div><div class="line">System.out.println(<span class="string">"主线程2"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上述代码中，我们就通过创建一个继承自Thread类的子类MyThread的对象来创建了一个线程mt，此时该程序中共包含3个线程，一个是mt，一个是主方法所在的主线程，一个是垃圾收集器线程。三条输出语句的打印次序是随机的，这是因为某个线程何时获得CPU的使用权是CPU轮转调度的结果。<br>值得注意的是，<strong>在Java中，每次程序运行至少启动2个线程。一个是主线程，一个是垃圾收集器线程。因为当执行一个程序的时候，实际上都会启动一个JVM，启动一个JVM就是在操作系统中启动了一个进程。</strong><br>我们通过下面的循环输出语句可以令这种线程间的时间片轮转调度更明显：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.thread1;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</div><div class="line">System.out.println(getName()+<span class="string">"正在运行"</span>+i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">MyThread mt1=<span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</div><div class="line">MyThread mt2=<span class="keyword">new</span> MyThread(<span class="string">"线程2"</span>);</div><div class="line">mt1.start();</div><div class="line">mt2.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="/2018/02/01/Java学习总结之并发/运行结果.png" alt="fail"><br>可以看到线程的打印语句随机交替出现，这就证明了线程获得CPU使用权是随机的。<br><strong>注意：</strong><br>1、不要直接调用Thread类或Runnable对象的run方法，如果直接调用run方法，只会执行同一个线程中的任务，而不会启动新的线程。启动线程的唯一方法就是通过Thread类的start()实例方法，这个方法将创建一个执行run方法的新线程。<br>2、不要重复启动同一个线程，比如重复两次调用mt.start(),程序会抛出一个IllegalThreadStateException异常。<br>3、这种继承Thread类创建线程类的方法已不再推荐，应该将要并行运行的任务与运行机制解耦合。如果有很多个任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池来解决这个问题，有关内容参看博客后面的内容。  </p><p><strong>二、通过实现Runnable接口创建线程类</strong><br>我们使用这种方法创建线程的频率更高。<br><strong>提供这种方式的原因有如下：</strong><br>1.Java不支持多继承，如果自定义类已经继承另一个类，就无法继承Thread，此时，必须实现Runnable接口。<br>2.我们有时不打算重写Thread类的其他方法。  </p><p><strong>下面是使用这种方法创建线程的具体步骤：</strong><br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的构造方法Thread(Runnable target)的target参数来创建Thread对象，该Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。  </p><p>来看下面一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.runnable;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (i &lt;= <span class="number">10</span>)</div><div class="line">System.out.println(Thread.currentThread().getName()</div><div class="line">            +<span class="string">"正在运行"</span> + (i++)); </div><div class="line">            <span class="comment">/*无法直接调用getName()方法，而是要通过</span></div><div class="line"><span class="comment">            Thread.currentThread()先获取当前线程的</span></div><div class="line"><span class="comment">            对象，再在其上调用getName()方法*/</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">PrintRunnable pr = <span class="keyword">new</span> PrintRunnable();</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(pr);</div><div class="line">t1.start();</div><div class="line"><span class="comment">//PrintRunnable pr1 = new PrintRunnable();</span></div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(pr);</div><div class="line">t2.start();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这段代码中，t1和t2共享PrintRunnable对象的成员变量i，所以语句被两个线程一共交替打印了十次。如果两个线程的pr是不同的PrintRunnable对象，则两个线程交替着各打印十次语句。这就是多个线程共享资源的简单例子。</p><p><strong>注意：</strong>由于Runnable只有一个抽象方法，是一个函数式接口，所以我们也可以通过<strong>匿名内部类或lambda表达式</strong>的方式来简化上述创建线程的步骤。  </p><p><strong>三、通过Callable和Future创建线程</strong>  </p><p><strong>下面是使用这种方法创建线程的具体步骤：</strong><br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值，Callable接口是一个泛型接口。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值，它是一个泛型类。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。  </p><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> cn.habitdiary.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();</div><div class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</div><div class="line">System.out.println(Thread.currentThread().getName()+</div><div class="line">            <span class="string">" 的循环变量i的值"</span>+i);</div><div class="line"><span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</div><div class="line"><span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());</div><div class="line">&#125;</div><div class="line">        <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; </div><div class="line">        <span class="keyword">catch</span> (ExecutionException e)&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()</div><div class="line">        +<span class="string">" "</span>+i);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>四、创建线程的三种方式的对比</strong>  </p><p><strong>1)采用实现Runnable、Callable接口的方式创建多线程</strong><br><strong>优势：</strong><br>1.线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>2.在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>3.线程池只能放入实现Runable或callable类的线程，不能直接放入继承Thread的类。</p><p><strong>劣势：</strong>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。  </p><p><strong>2)使用继承Thread类的方式创建多线程</strong><br><strong>优势：</strong>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br><strong>劣势：</strong>线程类已经继承了Thread类，所以不能再继承其他父类。且继承Thread不适合线程间进行资源共享。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="1、线程的优先级"><a href="#1、线程的优先级" class="headerlink" title="1、线程的优先级"></a>1、线程的优先级</h4><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。JVM提供了10个线程优先级，即1到10的整数，超出这个范围会抛出异常，但它们与常见的操作系统都不能很好的映射，比如Windows只有7个优先级。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类里三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。主线程的优先级为5。默认情况下，一个线程继承它的父线程的优先级。<br>Thread类中提供了三个常量来表示优先级，分别为：<br>Thread.MIN_PRIORITY(等价于1)<br>Thread.MAX_PRIORITY(等价于10)<br>Thread.NORM_PRIORITY(等价于5)<br>每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于操作系统环境和CPU的调度方式的，不能保证线程执行的顺序，即优先级高的线程呢不一定先执行。例如虽然设置了优先级，但启动线程start()有先后顺序等影响了线程的执行顺序。初级程序员常常过度使用线程优先级，不要将程序构建为功能的正确性依赖于优先级。<br>如果确实要使用优先级，应该避免初学者常犯的一个错误。如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时,首先会在具有高优先级的线程中进行选择,尽管这样会使低优先级的线程完全饿死。  </p><p>Thread类提供了改变和获取某线程优先级的方法<br><img src="/2018/02/01/Java学习总结之并发/优先级.png" alt="fail">  </p><h4 id="2、线程休眠"><a href="#2、线程休眠" class="headerlink" title="2、线程休眠"></a>2、线程休眠</h4><p>线程休眠是使线程让出CPU使用权的最简单做法，某线程休眠的时候，会将CPU交给其他线程，以便轮换执行，而它自身进入阻塞状态，休眠一定时间后，线程会苏醒，进入就绪状态等待执行。线程的休眠方法是<code>Thread.sleep(long millis)</code>和<code>Thread.sleep(long millis,int nanos)</code>，均为静态方法，millis参数设定睡眠的时间，以毫秒为单位。<strong>调用sleep休眠的哪个线程呢？在哪个线程中调用sleep，哪个线程就休眠。</strong><br>来看一个例子，线程1休眠后，让出CPU，线程2执行，线程2执行完后，线程2休眠，让出CPU供线程1执行(此时线程1已经休眠结束，在就绪状态)，如此循环执行，直到结束。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> Thread;</div><div class="line">  </div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">          Thread t1=<span class="keyword">new</span> MyThread_1();</div><div class="line">          Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable1());</div><div class="line">          t1.start();</div><div class="line">          t2.start();</div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread_1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程1第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             <span class="keyword">try</span>&#123;</div><div class="line">                 Thread.sleep(<span class="number">500</span>);</div><div class="line">             &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程2第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             <span class="keyword">try</span>&#123;</div><div class="line">                 Thread.sleep(<span class="number">500</span>);</div><div class="line">             &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>结果如下：<br><img src="/2018/02/01/Java学习总结之并发/Sleep.png" alt="fail"></p><p><strong>注意：</strong>调用sleep()方法时必须处理可能抛出的InterruptedException，一般用try-catch块即可。  </p><p><strong>sleep方法的应用场景：</strong>可以实现计时器效果或定期刷新数据的效果，但是由于线程在苏醒之后不会直接进入运行状态，而是进入就绪状态等待获取CPU使用权，所以同一线程两次执行的时间间隔会略大于休眠时间，不能保证精确定时。  </p><p><strong>我是彩蛋:</strong> 了解了线程休眠，我们就可以写出传说中的睡眠排序了hhh，参考大牛博客<a href="https://www.jianshu.com/p/4f526ea40df4" target="_blank" rel="external">排序算法–睡眠排序、面条排序、猴子排序 (非常严肃)</a></p><h4 id="3、线程加入"><a href="#3、线程加入" class="headerlink" title="3、线程加入"></a>3、线程加入</h4><p>join方法，重载形式如下：<br><img src="/2018/02/01/Java学习总结之并发/join.png" alt="fail"><br>在当前线程中调用要加入的线程的join()方法，则当前线程转入阻塞状态，转而执行新加入的线程，即新加入的线程被优先执行，抢占了CPU资源，直到该进程运行结束(如果调用带参的join方法，则超出时限该进程就会让出CPU)，当前线程再由阻塞转为就绪状态。可以认为join方法的作用是父线程等待子线程执行完成后再执行，换句话说是将异步执行的线程合并为同步执行的线程。  </p><p>下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.join;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i++)</div><div class="line">System.out.println(getName()+<span class="string">"正在执行"</span>+i+<span class="string">"次！"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">MyThread mt=<span class="keyword">new</span> MyThread();</div><div class="line">mt.start();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">mt.join(<span class="number">1</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)&#123;</div><div class="line">System.out.println(<span class="string">"主线程运行第"</span>+i+<span class="string">"次！"</span>);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"主线程运行结束！"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>join方法也会抛出InterruptedException，要进行异常处理。  </p><h4 id="4、线程让步"><a href="#4、线程让步" class="headerlink" title="4、线程让步"></a>4、线程让步</h4><p>让步使用Thread.yield()方法，yield方法为静态方法，功能是让当前运行线程回到可运行状态，以允许具有<strong>相同优先级的其他线程</strong>获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。让出的时间和让出给哪个线程都是不可设定的，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了<strong>同等优先级</strong>的其他线程。<br>例子：一个线程先让步，让另一个线程先执行，然后再执行该线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.thread;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">          Thread t1=<span class="keyword">new</span> MyThread();</div><div class="line">          Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</div><div class="line">          t2.start();</div><div class="line">          t1.start();</div><div class="line">          </div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程1第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程2第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             Thread.yield();</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p><strong>sleep()和yield()的区别</strong><br>    sleep()使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>    sleep 方法使当前运行中的线程休眠一段时间，进入阻塞状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。<br>       另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()方法执行时，当前线程仍处在就绪状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep() 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。   </p><h4 id="5、未捕获异常处理器"><a href="#5、未捕获异常处理器" class="headerlink" title="5、未捕获异常处理器"></a>5、未捕获异常处理器</h4><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>在大多数实际的多线程应用中, 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象, 并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？可以想象,线程彼此踩了对方的脚。根据各线程访问数据的次序，可能会产生讹误的对象。这样一个情况通常称为<strong>竞争条件(race condition)</strong>。  </p><p>我们先来看一个银行存取款的例子。  </p><p><strong>Bank类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.bank;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> String account;<span class="comment">// 账号</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> balance;<span class="comment">// 账户余额</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(String account, <span class="keyword">int</span> balance)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.account = account;</div><div class="line"><span class="keyword">this</span>.balance = balance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> account;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(String account)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.account = account;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> balance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.balance = balance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"Bank [账号："</span> + account + <span class="string">", 余额："</span> </div><div class="line">        + balance + <span class="string">"]"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 存款</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// 获取当前的账号余额</span></div><div class="line"><span class="keyword">int</span> balance = getBalance();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 修改余额，存100元</span></div><div class="line">balance += <span class="number">100</span>;</div><div class="line"><span class="comment">// 修改账户余额</span></div><div class="line">setBalance(balance);</div><div class="line"><span class="comment">// 输出存款后的账户余额</span></div><div class="line">System.out.println(<span class="string">"存款后的账户余额为："</span> + balance);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawAccount</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">/* 在不同的位置处添加sleep方法来模拟方法在执行过程因为</span></div><div class="line"><span class="comment">           时间片轮转而发生暂停的情况*/</span></div><div class="line"></div><div class="line"><span class="comment">// 获得当前的帐户余额</span></div><div class="line"><span class="keyword">int</span> balance = getBalance();</div><div class="line"><span class="comment">// 修改余额，取200</span></div><div class="line">balance = balance - <span class="number">200</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 修改帐户余额</span></div><div class="line">setBalance(balance);</div><div class="line">System.out.println(<span class="string">"取款后的帐户余额："</span> + balance);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>SaveAccount类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.bank;</div><div class="line"><span class="comment">//存款</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveAccount</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Bank bank;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SaveAccount</span><span class="params">(Bank bank)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.bank=bank;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">bank.saveAccount();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>DrawAccount类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.bank;</div><div class="line"><span class="comment">//取款</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawAccount</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Bank bank;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DrawAccount</span><span class="params">(Bank bank)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.bank=bank;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">bank.drawAccount();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Test类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.bank;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 创建帐户，给定余额为1000</span></div><div class="line">Bank bank=<span class="keyword">new</span> Bank(<span class="string">"1001"</span>,<span class="number">1000</span>);</div><div class="line"><span class="comment">//创建线程对象</span></div><div class="line">SaveAccount sa=<span class="keyword">new</span> SaveAccount(bank);</div><div class="line">DrawAccount da=<span class="keyword">new</span> DrawAccount(bank);</div><div class="line">Thread save=<span class="keyword">new</span> Thread(sa);</div><div class="line">Thread draw=<span class="keyword">new</span> Thread(da);</div><div class="line">save.start();</div><div class="line">draw.start();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">draw.join();</div><div class="line">save.join();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(bank);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们把程序设计为账户初始金额1000元，存100元，取200元，余额应该为900元。但输出结果如下：<br><img src="/2018/02/01/Java学习总结之并发/Bank.png" alt="fail">  </p><p>这样的银行系统给人极不可靠的感觉，我们来分析一下原因：由于存取款方法都对同一个数据balance进行操作，很可能在执行存款方法的SaveAccount线程运行到<code>balance += 100</code>时被剥夺了CPU使用权，所以还没来得及修改账户余额，而其中的balance局部变量为1100。此时转入执行取款方法的DrawAccount线程，由于账户余额未被修改还是1000，当这个线程运行到<code>balance = balance + 200;</code>时，balance局部变量为800，此时线程可能又转入SaveAccount线程，继续执行setBalance方法把账户余额设置为1100元并打印输出，之后又回到DrawAccount把账户余额设置为800元再打印输出，于是造成了混乱。<br>混乱的可能还不只如此，这里我们引入一个<strong>原子性</strong>的概念。在Java中，对基本数据类型的变量的<strong>读取和简单赋值操作</strong>是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>比如下面4条赋值语句：<br>1）x = 10  　　　　2）x = y  　　　3）x++ 　　　4）x = x + 2<br><strong>只有1)是原子性操作，2)要先读取y的值并放入寄存器，再赋值给内存中的x，3)和4)则都要先读取x的值。</strong><br>所以一条非原子性的Java语句由多条指令组成，它在执行过程中的任何一个时间点都可能被其他线程打断。<br>所以上述问题的发生的原因就在于存取款方法不是原子性的，它们在执行的过程中可能被其他线程在随机时间点打断，而这些方法操作的又是同一个数据，所以造成了数据更新延迟、更新的数据被覆盖等讹误。</p><p>为了解决这一问题达到线程同步的目的。我们需要引入<strong>锁</strong>。多线程的锁，其实本质上就是给一块内存空间的访问添加访问权限，因为Java中是没有办法直接对某一块内存进行操作的，又因为Java是面向对象的语言，一切皆对象，所以具体的表现就是某一个对象承担锁的功能，每一个对象都可以是一个锁。现在的Java语言中，提供了2种锁，一种是语言特性提供的内置锁，还有一种是java.util.concurrent.locks 包中的显式锁。我们来一一介绍： </p><h4 id="1、内置锁"><a href="#1、内置锁" class="headerlink" title="1、内置锁"></a>1、内置锁</h4><p>内置锁是用语言特性实现的锁，即使用 synchronized 关键字，又叫同步锁、互斥锁，Java的所有对象都有一个同步锁，甚至每个类的class对象也对应一个同步锁。<br>我们先引入一个临界区的概念，<strong>临界区是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行</strong>。<br>Java提供了同步机制。当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已有其他线程进入临界区。如果没有其他线程进入临界区，它就可以进入临界区，即获得了该同步锁；如果已有线程进入了临界区，即同步锁被其他线程占用，它就被同步机制挂起，直到进入的线程离开这个临界区并释放锁，JVM允许它持有锁才能进入临界区。如果在等待进入临界区的线程不止一个，JVM会随机选择其中的一个，其余的将继续等待。<br><strong>使用synchronized内置锁的好处在于，无论线程是执行完临界区代码正常退出还是抛出异常，JVM都会自动释放锁。</strong>   </p><p>synchronized 修饰的对象包括以下几种：  </p><h4 id="修饰一个代码块"><a href="#修饰一个代码块" class="headerlink" title="修饰一个代码块"></a>修饰一个代码块</h4><p>被修饰的代码块称为<strong>同步代码块</strong>，其作用的范围(临界区)是大括号{}括起来的代码，锁住的对象是括号里的obj对象。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(obj)  <span class="comment">/*obj是同步锁锁住的对象,如果是this，</span></div><div class="line"><span class="comment">                        就表示锁住当前对象*/</span></div><div class="line">   &#123;</div><div class="line">       System.out.println(<span class="string">"我是同步代码块"</span>);</div><div class="line">       <span class="keyword">try</span></div><div class="line">       &#123;</div><div class="line">           Thread.sleep(<span class="number">500</span>);</div><div class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">       &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><h4 id="修饰一个非静态方法"><a href="#修饰一个非静态方法" class="headerlink" title="修饰一个非静态方法"></a>修饰一个非静态方法</h4><p>被修饰的方法称为同步方法，临界区是整个方法，锁住的对象是调用这个方法的对象。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span> </span></div><div class="line"><span class="function"></span>&#123; </div><div class="line">System.out.println(<span class="string">"我是同步方法1"</span>); </div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123; </div><div class="line">Thread.sleep(<span class="number">500</span>); </div><div class="line">&#125; </div><div class="line">    <span class="keyword">catch</span> (InterruptedException e) </div><div class="line">&#123; </div><div class="line">e.printStackTrace(); </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面使用同步代码块的写法是等价的，临界区是整个方法，锁住的也是调用方法的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span> </span></div><div class="line"><span class="function"></span>&#123; </div><div class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">    System.out.println(<span class="string">"我是同步方法2"</span>); </div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123; </div><div class="line">Thread.sleep(<span class="number">500</span>); </div><div class="line">&#125; </div><div class="line">    <span class="keyword">catch</span> (InterruptedException e) </div><div class="line">&#123; </div><div class="line">e.printStackTrace(); </div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line">&#125;在</div></pre></td></tr></table></figure></p><h4 id="修改一个类"><a href="#修改一个类" class="headerlink" title="修改一个类"></a>修改一个类</h4><p>其临界区是synchronized后面大括号括起来的部分，作用的对象是这个类的所有对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(Test.class)&#123;</div><div class="line">       System.out.println(＂我修饰Test类＂);</div><div class="line">       <span class="keyword">try</span></div><div class="line"> &#123;</div><div class="line">           Thread.sleep(<span class="number">500</span>);</div><div class="line">       &#125; </div><div class="line">       <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">       &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="修饰一个静态方法"><a href="#修饰一个静态方法" class="headerlink" title="修饰一个静态方法"></a>修饰一个静态方法</h4><p>其临界区是整个静态方法，锁住的对象是这个类的所有对象。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span></span>&#123; </div><div class="line">System.out.println(<span class="string">"我修饰静态方法"</span>); </div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123; </div><div class="line">Thread.sleep(<span class="number">500</span>); </div><div class="line">&#125; </div><div class="line">    <span class="keyword">catch</span> (InterruptedException e) </div><div class="line">&#123; </div><div class="line">e.printStackTrace(); </div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面使用同步代码块的写法是等价的，临界区是整个静态方法，锁住的对象也是这个类的所有对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (Test.class)</div><div class="line">    &#123;</div><div class="line">        System.out.println(＂我修饰静态方法＂);</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">        &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="对象锁-方法锁-和类锁"><a href="#对象锁-方法锁-和类锁" class="headerlink" title="对象锁(方法锁)和类锁"></a>对象锁(方法锁)和类锁</h4><p>根据锁住的是对象还是类，我们把同步锁分为<strong>对象锁(方法锁)和类锁。</strong><br>对象锁就是方法锁，是用于非静态方法或者一个对象实例上的;类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。<br><strong>也就是说，对象锁只是锁住了一个对象的代码段，防止多个线程同时执行同一对象的同一代码段，但多个线程访问不同对象的这一代码段不受干扰。而类锁则可以锁住同一个类的所有实例对象，它起到了全局锁的作用，真正锁住了代码段。</strong></p><p>例子见大牛博客：<a href="https://www.cnblogs.com/QQParadise/articles/5059824.html" target="_blank" rel="external">synchronized锁住的是代码还是对象</a></p><p><strong>注意：</strong> 我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。原因是基于以上的思想，锁的代码段过长，其他线程等待进入临界区的时间会很长。</p><p><strong>学习了synchronized关键字，我们就可以解决银行转账的讹误了！只要用给setAccount()和drawAccount()加锁即可。</strong></p><p><strong>使用内置锁的缺点：</strong>内置锁在采取的是无限等待的策略，一旦开始等待，就既不能中断也不能取消，容易产生饥饿与死锁的问题。在线程调用notify方法时，会随机选择相应对象的等待队列的一个线程将其唤醒，而不是按照FIFO(先入先出)的方式，如果有强烈的公平性要求，就无法满足。  </p><h4 id="2、显式锁"><a href="#2、显式锁" class="headerlink" title="2、显式锁"></a>2、显式锁</h4><p>java.util.concurrent.locks 包中提供了可重入锁(ReentrantLock)，是一种递归无阻塞的同步机制。它是一种显式锁，需要显式进行 lock 以及 unlock 操作。  </p><p>用 ReentrantLock 保护代码块的基本结构如下 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">myLock.lock() ; <span class="comment">// myLock是一个ReentrantLock对象</span></div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//被同步的临界区</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">myLock.unlock(); <span class="comment">//即使异常抛出也要关闭锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这一结构确保任何时刻只有一个线程进人临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞，直到第一个线程释放锁对象。  </p><p><strong>可重入锁：</strong>又称递归锁，可重入是指一个线程可以重复获得已持有的锁。即一个线程获得了某个对象的锁，此时这个对象还没有释放，当这个线程再次想获得这个对象的锁的时候还是可以获得的。<strong>synchronized和ReentrantLock都是可重入的。</strong><br>应用场景：<br>1、递归调用一个带锁的方法<br>2、在一个带锁的方法里嵌套调用另一个需要同一个对象的锁的方法。<br><strong>如果锁是不可重入的，那么内部方法将无法获得外部方法的锁，一直等待外部方法释放该锁，于是造成了死锁。</strong> </p><p>每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计加1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个ReentrantLock锁住的方法或synchronized方法/块时，计数器会递减，直到计数器为0才释放该锁。  </p><p><strong>注意：</strong><br>1.把解锁操作置于 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。<br>2.如果使用锁，就不能使用带资源的 try 语句。首先，解锁方法名不是 close。不过，即使将它重命名，带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享的那个变量 (而不是新变量)。</p><h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>通常, 线程进人临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程，我们在条件对象上可以调用Condition类的await(),signal(),signalAll()方法，它们的功能分别对应Object类的wait(),notify(),notifyAll()方法，但前者一般和ReentrantLock配合使用，后者和synchronized块配合使用。我们来介绍Java 库中条件对象的实现。<br>下面是条件对象相关的API<br><img src="/2018/02/01/Java学习总结之并发/条件对象.png" alt="fail">  </p><p>我们来看一个满足账户余额充足条件才能取款的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Condition sufficientFunds; <span class="comment">//条件对象</span></div><div class="line">    <span class="keyword">private</span> Lock bankLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//锁对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;<span class="comment">//账户余额</span></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    ...</div><div class="line">        sufficientFunds = bankLock.newCondition();</div><div class="line">        <span class="comment">//获得该锁的条件对象</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawAccount</span><span class="params">(<span class="keyword">int</span> amount)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    bankLock.lock();</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">        <span class="keyword">while</span>(balance &lt; amount)</div><div class="line">            sufficientFunds.await();</div><div class="line">            <span class="comment">//saveAccount</span></div><div class="line">            ...</div><div class="line">            sufficientFunds.signalAll();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">finally</span></div><div class="line">         &#123;</div><div class="line">         bankLock.unlock();</div><div class="line">         &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>我们一般使用类似结构检测条件是否满足：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!(ok to proceed))</div><div class="line">condition.await();</div></pre></td></tr></table></figure></p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>当线程的 run 方法执行方法体中最后一条语句后，或者出现了在方法中没有捕获的异常时, 线程将终止。在 Java 的早期版本中，还有一个 stop 方法, 其他线程可以调用它终止线程。但是，这个方法现在已经被弃用了。<br>没有可以强制线程终止的方法。然而,interrupt方法可以用来<strong>请求终止线程</strong>。<br>当对一个线程调用 interrupt 方法时, 线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该<strong>不时地检査这个标志</strong>，以判断线程是否被中断。要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用 islnterrupted 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> more work</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是，如果线程被阻塞，就无法检测中断状态。这是产生 InterruptedException 异常的地方。当在一个被阻塞的线程 (调用 sleep 或 wait)上调用 interrupt 方法时, 阻塞调用将会被 InterruptedException 异常中断。<br>没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。<strong>但是, 更普遍的情况是, 线程将简单地将中断作为一个终止的请求。</strong>这种线程的 run 方法具有如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Runnable r= () -&gt; &#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted &amp;&amp; </div><div class="line">    more work to <span class="keyword">do</span>)&#123;</div><div class="line"><span class="keyword">do</span> more work</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"><span class="comment">// thread was interruputed during sleep or wait</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span>&#123;</div><div class="line"> cleanup,<span class="keyword">if</span> required</div><div class="line">    &#125;<span class="comment">// exiting the run method terminates the thread</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>如果在每次工作迭代之后都调用 sleep 方法 (或者其他的可阻塞方法，isInterrupted 检测既没有必要也没有用处。如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并拋出InterruptedException。因此,如果你的循环调用sleep,不要检测中断状态。相反,要如下所示捕获InterruptedException异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Runnable r= () -&gt; &#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line"><span class="keyword">while</span> (more work to <span class="keyword">do</span>)&#123;</div><div class="line"><span class="keyword">do</span> more work</div><div class="line">                Thread.sleep(delay);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"><span class="comment">// thread was interruputed during sleep or wait</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span>&#123;</div><div class="line"> cleanup,<span class="keyword">if</span> required</div><div class="line">    &#125;<span class="comment">// exiting the run method terminates the thread</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>有两个非常类似的方法, interrupted 和isInterrupted。Interrupted 方法是一个静态方法，它检测当前的线程是否被中断。而且，调用 interrupted 方法会清除该线程的中断状态。另一方面，isInterrupted 方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。  </p><p>在很多发布的代码中会发现 InterruptedException 异常被抑制在很低的层次上，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span></span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">try</span> &#123; sleep(delay) ; &#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e) &#123; &#125; <span class="comment">// Don't ignore!</span></div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不要这样做！如果不认为在 catch 子句中做这一处理有什么好处的话，仍然有两种合理的选择:  </p><ul><li>在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">try</span> &#123; sleep(delay);&#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e) </div><div class="line">&#123;</div><div class="line">Thread.currentThread().interrupt();</div><div class="line">&#125; </div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>或者, 更好的选择是, 用 throws InterruptedException 标记你的方法, 不采用 try 语句块捕获异常。于是，调用者(或者 最终的 run 方法)可以捕获这一异常。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">...</div><div class="line">    sleep(delay);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面是与线程中断有关的API<br><img src="/2018/02/01/Java学习总结之并发/线程中断.png" alt="fail"></p><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>有时我们需要在线程之间进行通信，如上面银行的例子，如果账户余额不足，就要通知取款的线程暂停取款，等存款的线程把钱存入银行后再取款。</p><h4 id="线程等待和线程通知"><a href="#线程等待和线程通知" class="headerlink" title="线程等待和线程通知"></a>线程等待和线程通知</h4><p>我们来了解几个<strong>用于同步方法和同步代码块中</strong>进行线程间通信的常用方法。<strong>它们都是Object类的final方法，都只能在同步方法或同步代码块中调用，否则将抛出一个IllegalMonitorStateException。</strong>  </p><p><strong>wait方法</strong><br>wait()方法导致进入该同步方法或同步代码块的线程进入等待阻塞状态，并释放它持有的同步锁，它有三个重载的方法。<br>1.void wait()<br>导致进入该方法的线程进入等待状态，直到它被通知或者被中断。<br>2.wait(long millis) 设定一个超时间隔，如果在规定时间内没有被通知或中断，线程将被唤醒，millis是毫秒数。<br>3.wait(long millis,int nanos) 设定一个超时间隔，如果在规定时间内没有被通知或中断，线程将被唤醒，millis是毫秒数，nanos是纳秒数。  </p><p>如果在等待阻塞状态线程被中断会抛出一个InterruptedException异常。  </p><p><strong>notify方法</strong><br>在同步方法或同步代码块调用该方法后，JVM会随机选择一个在该对象上调用wait方法的的线程，解除其阻塞状态。</p><p><strong>notifyAll方法</strong><br>在同步方法或同步代码块调用该方法后，会解除所有在该对象上调用wait方法的线程的阻塞状态。  </p><p><strong>注意：</strong>线程被唤醒只是从等待阻塞状态进入了就绪状态，可以参与锁的竞争，但并不代表它已经获得了锁。  </p><h4 id="sleep方法和wait方法的区别"><a href="#sleep方法和wait方法的区别" class="headerlink" title="sleep方法和wait方法的区别"></a>sleep方法和wait方法的区别</h4><p>最简单的区别是，wait方法只能用于同步方法或同步代码块，而sleep方法可以直接调用。而更深层次的区别在于sleep方法只是暂时让出CPU的执行权，并不释放同步锁。而wait方法则会释放锁。sleep()必须捕获异常，wait()不用捕获异常。一个调用了sleep()或wait()方法的线程如果调用interrupt()方法请求中断，都会立即抛出InterruptedException。  </p><h4 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h4><p>下面使用wait()和notifyAll()配合实现一个经典的生产者-消费者模型，即一个线程生产，一个线程消费。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Queue.java</span></div><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line"><span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(!flag)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"消费："</span>+n);</div><div class="line">flag=<span class="keyword">false</span>;<span class="comment">//消费完毕，容器中没有数据</span></div><div class="line">notifyAll();</div><div class="line"><span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(flag)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"生产："</span>+n);</div><div class="line"><span class="keyword">this</span>.n = n;</div><div class="line">flag=<span class="keyword">true</span>;<span class="comment">//生产完毕，容器中已经有数据</span></div><div class="line">notifyAll();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Producer.java</span></div><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Queue queue;</div><div class="line">Producer(Queue queue)&#123;</div><div class="line"><span class="keyword">this</span>.queue=queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">queue.set(i++);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Consumer.java</span></div><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Queue queue;</div><div class="line">Consumer(Queue queue)&#123;</div><div class="line"><span class="keyword">this</span>.queue=queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">queue.get();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Queue queue=<span class="keyword">new</span> Queue();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue)).start();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(queue)).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>如果最后一个活动线程在解除其他线程的阻塞状态之前就调用了wait()或await()，那么它也被阻塞，没有任何线程可以解除其他线程的阻塞，所有的线程都在互相等待，那么程序就发生了死锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;多任务&quot;&gt;&lt;a href=&quot;#多任务&quot; class=&quot;headerlink&quot; title=&quot;多任务&quot;&gt;&lt;/a&gt;多任务&lt;/h3&gt;&lt;p&gt;操作系统的多任务指的是在同一刻运行多个程序的能力。例如，在编辑或下载邮件的同时可以打印文件。今天，人们很可能有单台拥有多个 CPU 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之核心API</title>
    <link href="http://habitdiary.cn/2018/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%A0%B8%E5%BF%83API/"/>
    <id>http://habitdiary.cn/2018/01/30/Java学习总结之核心API/</id>
    <published>2018-01-30T13:11:34.000Z</published>
    <updated>2018-02-14T05:14:17.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 的核心 API 是非常庞大的，这给开发者来说带来了很大的方便。所谓的 API 就是一些已经写好、可直接调用的类库。Java 里有非常庞大的 API，其中有一些类库是我们必须得掌握的，只有熟练掌握了 Java 一些核心的 API，我们才能更好的使用 Java。<br><img src="/2018/01/30/Java学习总结之核心API/general.png" alt="fail"></p><p><center>参考资料：实验楼JDK 核心 API</center><br>下面我们以包为单位对开发中常用的核心API进行总结。  </p><h3 id="java-lang包"><a href="#java-lang包" class="headerlink" title="java.lang包"></a>java.lang包</h3><p>在程序中，java.lang 包并不需要像其他包一样需要import关键字进行引入。系统会自动加载，所以我们可以直接取用其中的所有类。下面我们就来详细地学习一下 java.lang 包吧。</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>Java 是一种面向对象语言，Java 中的类把方法与数据连接在一起，构成了自包含式的处理单元。但在 Java 中不能定义基本数据类型(primitive type)对象，这样存在一个问题：即<strong>基本数据类型不具备对象特性，就不能进行对象化交互。</strong>为了能将基本类型视为对象进行处理，并能连接相关的方法，Java 为每个基本类型都提供了包装类。如 int 型数值的包装类 Integer，boolean 型数值的包装<br>类 Boolean 等，这样便可以把这些基本类型转换为对象来处理了。下面将介绍Java 中提供的各种包装类。<br><img src="/2018/01/30/Java学习总结之核心API/包装类.png" alt="fail"><br>在这八个类名中，除了<strong>Integer类</strong>和<strong>Character类</strong>，其它六个类的类名和基本数据类型一致，只是类名的首字母大写，这八种包装类都是<strong>被final关键字修饰的，没有无参的构造方法，且是不可变的。</strong>其实还有两个包装类，但它们没有对应的基本数据类型，即java.math包中的BigInteger类和BigDecimal类，主要应用于高精度的运算，BigInteger 支持任意精度的整数，BigDecimal 支持任意精度带小数点的运算，它们没有被final关键字修饰。关于这两个类我们将在java.math包中进行详细介绍。  </p><h4 id="基本类型与包装类型的异同"><a href="#基本类型与包装类型的异同" class="headerlink" title="基本类型与包装类型的异同:"></a>基本类型与包装类型的异同:</h4><p>1、在 Java 中，一切皆对象，但八大基本类型却不是对象。<br>2、声明方式的不同，基本类型无需通过 new 关键字来创建，而包装类型需 new 关键字。<br>3、存储方式及位置的不同，基本类型是直接存储变量的值保存在栈中能高效的存取，包装类型需要通过引用指向实例，具体的实例保存在堆中。<br>4、初始值的不同，包装类型的初始值为 null，基本类型的的初始值视具体的类型而定，比如 int 类型的初始值为 0，boolean 类型为 false。<br>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。</p><h4 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h4><p>在八种包装类中，<strong>数值包装类</strong>(除了Character和Boolean，它们的直接父类是Object)以及之后会介绍的java.math包中的<strong>BigInteger类</strong>和<strong>BigDecimal类</strong>都有一个共同的<strong>抽象父类</strong>，即<strong>Number类</strong>。在学习包装类之前，我们先来学习Number类。<br>抽象类 Number 是父类,Number 的子类必须提供将表示的数值转换成 byte / double / float / long / int / short 的方法。Number 类的方法被 Number 的各子类所实现,常用方法如下:  </p><p><img src="/2018/01/30/Java学习总结之核心API/Number类.png" alt="fail">  </p><h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><p>1、构造方法有两种:<br>a) 以 int 型变量作为参数创建 Integer 对象,实例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer number=<span class="keyword">new</span> Integer(<span class="number">7</span>);</div></pre></td></tr></table></figure></p><p>b) 以 String 型变量作为参数创建 Integer 对象,实例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer number=<span class="keyword">new</span> Integer(“<span class="number">7</span>”);</div></pre></td></tr></table></figure></p><p>2、常用方法:<br><img src="/2018/01/30/Java学习总结之核心API/Integer类.png" alt="fail"><br>需要注意的是Integer也存在除了intValue()之外的其他xxxValue()方法，可以把Integer类型的对象转换为任意基本数值类型，这是从Number类继承的方法。还有，parseInt()方法有多个重载方法，可以把字符串转换为不同进制的基本数据类型。  </p><p>3、常用的常量:<br>a) MAX_VALUE: 表示 int 型可取的最大值<br>b) MIN_VALUE: 表示 int 型可取的最小值<br>c) SIZE:表示以二进制补码形式表示 int 值的位数<br>d) TYPE: 表示基本类型 Class 实例</p><p>4、基本数据类型、包装类、字符串三者之间的转换：<br>a)基本数据类型和包装类之间的转换<br>我们先来认识两个概念：装箱与拆箱。<br>装箱：把基本数据类型转换成包装类，分为自动装箱和手动装箱。<br>拆箱：把包装类转换成基本数据类型，分为自动拆箱和手动拆箱。<br>下面通过代码来演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//装箱：把基本数据类型转换成包装类</span></div><div class="line"></div><div class="line">        <span class="comment">//自动装箱</span></div><div class="line"><span class="keyword">int</span> t1 = <span class="number">2</span>;</div><div class="line">Integer t2 = t1;</div><div class="line">        </div><div class="line"><span class="comment">//手动装箱</span></div><div class="line">        <span class="comment">//1、构造方法</span></div><div class="line">Integer t3 = <span class="keyword">new</span> Integer(t1);</div><div class="line">        <span class="comment">//2、包装类的valueOf()</span></div><div class="line">        Integer t4 = Integer.valueOf(t1);</div><div class="line">        </div><div class="line">        <span class="comment">//拆箱：把包装类转换成基本数据类型</span></div><div class="line">        </div><div class="line"><span class="comment">//自动拆箱</span></div><div class="line"><span class="keyword">int</span> t4 = t2;</div><div class="line">        </div><div class="line"><span class="comment">//手动拆箱</span></div><div class="line"><span class="keyword">int</span> t5 = t2.intValue();</div><div class="line">```  </div><div class="line">b)基本数据类型和字符串之间的转换   </div><div class="line">直接看代码：  </div><div class="line">```java</div><div class="line"><span class="comment">//基本数据类型转换为字符串</span></div><div class="line"><span class="keyword">int</span> t1=<span class="number">2</span>;</div><div class="line">String t2=Integer.toString(t1);</div><div class="line">        <span class="comment">//也可直接用'+'进行字符串连接，会自动调用toString()</span></div><div class="line">        </div><div class="line">        <span class="comment">//字符串转换为基本数据类型</span></div><div class="line">        <span class="comment">//1、包装类的parseInt</span></div><div class="line"><span class="keyword">int</span> t3=Integer.parseInt(t2);</div><div class="line"><span class="comment">/*2、包装类的valueOf()先将字符串转换为包装类，</span></div><div class="line"><span class="comment">        再通过自动拆箱完成基本类型转换*/</span></div><div class="line"><span class="keyword">int</span> t4=Integer.valueOf(t2);</div></pre></td></tr></table></figure></p><p>c)包装类和字符串之间的转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装类转换为字符串</span></div><div class="line">Integer t1 = <span class="number">10</span>;</div><div class="line">String t2 = t1.toString();</div><div class="line"></div><div class="line"><span class="comment">//字符串转换为包装类  </span></div><div class="line"><span class="comment">//1、构造方法  </span></div><div class="line">Integer t3 = <span class="keyword">new</span> Integer(<span class="string">"10"</span>);</div><div class="line"><span class="comment">//2、包装类的valueOf()</span></div><div class="line">Integer t4 = Integer.valueOf(<span class="string">"10"</span>);</div></pre></td></tr></table></figure></p><p>5、包装类对象间的比较<br>我们先来看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> wrap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Integer one=<span class="keyword">new</span> Integer(<span class="number">100</span>);</div><div class="line">Integer two=<span class="keyword">new</span> Integer(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"one==two的结果："</span>+(one==two));<span class="comment">//1 false</span></div><div class="line"></div><div class="line">Integer three=<span class="number">100</span>;<span class="comment">//自动装箱</span></div><div class="line">        <span class="comment">//自动装箱时隐式调用Integer three=Integer.valueOf(100);</span></div><div class="line">        System.out.println(<span class="string">"one==three的结果"</span>+(one==three));<span class="comment">//2 false</span></div><div class="line">System.out.println(<span class="string">"three==100的结果："</span>+(three==<span class="number">100</span>));<span class="comment">//3 自动拆箱 true</span></div><div class="line"><span class="comment">//Integer four=100;</span></div><div class="line">Integer four=Integer.valueOf(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"three==four的结果："</span>+(three==four));<span class="comment">//4 true</span></div><div class="line"></div><div class="line">Integer five=<span class="number">200</span>;</div><div class="line">System.out.println(<span class="string">"five==200的结果："</span>+(five==<span class="number">200</span>));<span class="comment">//5 true</span></div><div class="line"></div><div class="line">Integer six=<span class="number">200</span>;</div><div class="line">System.out.println(<span class="string">"five==six的结果："</span>+(five==six));<span class="comment">//6 false</span></div><div class="line"></div><div class="line">Double d1=Double.valueOf(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"d1==100的结果："</span>+(d1==<span class="number">100</span>));<span class="comment">//7 true</span></div><div class="line"></div><div class="line">Double d2=Double.valueOf(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"d1==d2的结果："</span>+(d1==d2));<span class="comment">//8 false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们先来引入一个对象池的概念，Java的内存空间主要分为栈、堆、常量池(对象池)，对象池可以认为是Java提供的缓存技术。当我们调用Integer的valueOf()方法且传入的参数在-128~127之间时<strong>(注意自动装箱的原理实际上就是编译器隐式调用了这个方法)</strong>，会首先在常量池中查找是否存在该对象，如果不存在，就在常量池中创建该对象，并让存在于栈中的Integer引用变量指向它;如果对象池中已经存在这个对象就直接让栈中的Integer引用变量指向它。<br><img src="/2018/01/30/Java学习总结之核心API/对象池.png" alt="fail">     </p><p>我们来逐一解释输出的结果：<br>1处结果为false，因为每次使用new关键字，会在堆上新开辟一块内存空间，所以用==判断结果一定为false。<br>2处结果为false，因为one指向的是堆上开辟的空间，而three自动装箱，会在对象池里创建对象，并指向对象池的对应空间，所以==判断结果为false。<br>3处结果为true，因为当包装类和基本数据类型进行比较时会自动拆箱，相当于比较100==100,结果自然是true。<br>4处结果为true，因为前面three自动装箱已经隐式调用valueOf方法并在对象池中创建过一个100的Integer对象(100在-128~127之间，所以会在对象池中创建该对象)，所以当four再次调用valueOf方法时会在对象池中进行寻找，找到该对象后four也指向该对象，所以three和four指向的是同一个对象，结果为true。<br>5处结果为true，原因同3,不赘述。<br>6处结果为false，这是因为200不在-128~127的范围，不能使用对象池。<br>7处结果为true，自动拆箱，即比较100.0==100，结果为true。<br>8处结果为false，因为在包装类中，Double和Float不存在对象池。  </p><p><strong>最后提醒：比较包装类的值不要使用==，此时并不会对两个包装类进行自动拆箱，而是和其他类型对象比较一样比较其地址，所以比较值还是使用equals或compareTo方法！！！</strong></p><h4 id="Boolean类"><a href="#Boolean类" class="headerlink" title="Boolean类"></a>Boolean类</h4><p>Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean类型的对象只包含一个类型为 boolean 的字段。此外,此类还为 boolean 和String 的相互转换提供了许多方法,并提供了处理 boolean 时非常有用的其他一些常量和方法。<br>1、构造方法:<br>a) 创建一个表示 value 参数的 boolean 对象,实例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean b = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>b)以 String 变量作为参数,创建 boolean 对象。此时,如果传入的字符串不为 null,且忽略大小写后的内容等于”true”,则生成 Boolean 对象值为 true,反之为 false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Boolean b1 = <span class="keyword">new</span> Boolean(<span class="string">"ok"</span>); </div><div class="line">System.out.println(b1); <span class="comment">//输出false</span></div><div class="line">Boolean b2=<span class="keyword">new</span> Boolean(<span class="string">"TRUE"</span>);</div><div class="line">System.out.println(b2); <span class="comment">//输出true</span></div></pre></td></tr></table></figure></p><p>2、常用方法:<br><img src="/2018/01/30/Java学习总结之核心API/Boolean类.png" alt="fail"><br>3、常用的常量:<br>a) TRUE:对应基值 true 的 Boolean 对象;<br>b) FALSR:对应基值 false 的 Boolean 对象;<br>c) TYPE:表示基本类型 Class 实例</p><h4 id="Byte类"><a href="#Byte类" class="headerlink" title="Byte类"></a>Byte类</h4><p>Byte 类将基本类型为 byte 的值包装在一个对象中,一个 byte 类型的对象只包含一个类型为 byte 的对象。此外,该类还为 byte 和 String 之间相互转换提供方法,并提供了一些处理 byte 时非常有用的常量。<br>1、构造方法<br>Byte 类提供了两种构造方法的重载形式来创建 BYTE 类对象:<br>a) Byte (byte value) 通过这种方法创建的 byte 对象,可表示指定的 byte值。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Byte b = <span class="keyword">new</span> Byte(<span class="number">45</span>);</div></pre></td></tr></table></figure></p><p>b) Byte(String str) 通过这种方法创建的 byte 对象,可表示 String 参数指定的 byte 值，例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Byte mybyte = <span class="keyword">new</span> Byte(<span class="string">"12"</span>);</div></pre></td></tr></table></figure></p><p>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Byte类.png" alt="fail"><br>3、常用的常量<br>a) MIN_VALUE: 最小值<br>b) MAX_VALUE: 最大值<br>c) SIZE: 二进制<br>d) TYPE: 表示基本类型 byte 的 class 实例  </p><h4 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h4><p>Character 类在对象中包装一个基本类型为 char 的值。一个 Character 对象包含类型为 char 的单个字段。<br>1、构造方法<br>Character 类的构造方法的语法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Character(<span class="keyword">char</span> value)</div></pre></td></tr></table></figure></p><p>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Character类.png" alt="fail"><br>还有isDigit(ch)、isLetter(ch)、isLetterOrDigit(ch)等方法分别返回一个布尔值表示ch是否是数字字符、ch是否是字母、ch是否是字母或者数字。</p><h4 id="Double类"><a href="#Double类" class="headerlink" title="Double类"></a>Double类</h4><p>Double 和 Float 包装类是对 double、float 基本类型的封装,他们都是 Number 类的子类,又都是对小数进行操作,所以常用基本方法相同,Double 类在对象中包装一个基本类型为 double 的值,每个 double 类都包含一个 double 类型的字段。<br>1、 构造方法<br>Double 类提供了两种构造方法来获得 Double 类对象<br>a) Double(double value): 基于 double 参数创建 Double 类对象;<br>b) Double(String str): 构造一个新分配的 Double 对象,表示用字符串表示的 Double 类型的浮点值<br>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Double1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/Double2.png" alt="fail"> </p><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><p>我们在编程的过程中，经常需要对一些数字进行数学操作，如初等指数、对数、平方根和三角函数，其实 java.lang 里的 Math 类包含了用于执行基本数学运算的方法。我们就来学习一下吧！<br>1、构造方法<br>Math类的构造方法是private的，这样设计的意图是不让使用者创建Math类的对象，也就是说，Math类的所有方法都是静态方法。另外Math类是final的，设计为不能被继承。<br>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Math类.png" alt="fail">   </p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><p>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/String构造1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String构造2.png" alt="fail"><br>2、常用方法(方法很多，勤查API)<br><img src="/2018/01/30/Java学习总结之核心API/String1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String3.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String4.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String5.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String6.png" alt="fail">   </p><p><strong>特别关注：</strong><br>1)字符串的替换和分隔<br>replace、replaceFirst、replaceAll、split等方法。<br>2)依照模式匹配、替换和分隔(正则表达式)<br>matches方法配合正则表达式。更多拓展还应学习java.util.regex 包里的Pattern类和Matcher类。<br>3)字符串与字符数组之间的转换<br>字符串转字符数组使用toCharArray()方法，字符数组转字符串使用字符串的构造方法String(char[])或valueOf(char[])。<br>4)字符串与字符和数值之间的转换<br>字符串转字符和数值使用包装类的parseXXX()方法或valueOf(String)方法，字符和数值转字符串可以使用’+’直接连接，也可以使用String类的valueOf方法。<br>5)格式化字符串<br>使用String类的静态format方法，可以格式化字符串。  </p><p>3、等于运算符与equals方法的区别<br>equals比较的是String对象的内容，==比较的是String对象的引用。值得注意的是，String类型变量看似存储了一个字符串，但它仍然属于引用类型变量，所以String类型变量存在于栈中，而实际的字符串对象存在于堆中或常量池中。String类型变量存储的是String对象的引用，String对象存储的才是字符串值。<br>4、String对象的存储<br>我们首先来看看Java中的内存分布。<br><img src="/2018/01/30/Java学习总结之核心API/内存.png" alt="fail"><br>如果我们用<code>String str = &quot;Hello world&quot;</code>的形式创建字符串，会首先在常量池寻找是否存在这样的字符串常量，如果没有，就创建并让字符串变量指向它;如果有，就直接让字符串变量指向它。而如果使用<code>String str = new str(&quot;Hello world&quot;)</code>的形式，就在堆上重新开辟一块内存空间并让字符串变量指向它。<br>示意图如下：<br><img src="/2018/01/30/Java学习总结之核心API/内存2.png" alt="fail"><br>5、String类的不可变性<br>String类是不可变类，即String对象一旦被创建，其内容是不可变的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.string;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo6</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//String的不可变性</span></div><div class="line"><span class="comment">//String对象一旦被创建，则不能修改，是不可变的</span></div><div class="line"><span class="comment">//所谓的修改其实是创建了新的对象，所指向的内存空间不变</span></div><div class="line">String s1=<span class="string">"imooc"</span>;</div><div class="line">        String s2=<span class="string">"hello,"</span>+s1;</div><div class="line">        <span class="comment">//s2指向"hello,imooc"</span></div><div class="line">s1=<span class="string">"hello,"</span>+s1;</div><div class="line"><span class="comment">//s1不再指向imooc所在的内存空间，而是指向了"hello,imooc"</span></div><div class="line">System.out.println(<span class="string">"s1="</span>+s1);<span class="comment">//s1=hello,imooc</span></div><div class="line">System.out.println(<span class="string">"s2="</span>+s2); <span class="comment">//s2=hello,imooc</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2018/01/30/Java学习总结之核心API/change2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/change.png" alt="fail">   </p><h4 id="StringBuilder类-amp-StringBuffer类"><a href="#StringBuilder类-amp-StringBuffer类" class="headerlink" title="StringBuilder类 &amp; StringBuffer类"></a>StringBuilder类 &amp; StringBuffer类</h4><p>由于String类的不可变性，String在操作字符串时可能会产生很多冗余的中间字符串变量。所以，当需要频繁操作字符串时，建议使用StringBuilder类或StringBuffer类，这两个类是可变类。<br>StringBuilder类和StirngBuffer类的区别<br>两者除了StringBuffer修改缓冲区的方法是同步的，其他用法基本相同。而由于StringBuffer类是多线程安全的，所以在单线程程序中StringBuilder性能略高。所以建议在单线程情况下使用StringBuilder，多线程情况下使用StringBuffer。  </p><p>由于两者的构造方法和常见方法基本相同，所以我们以StringBuffer为例进行介绍：<br>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/StringBuffer1.png" alt="fail"><br>2、常见方法<br><img src="/2018/01/30/Java学习总结之核心API/StringBuffer2.png" alt="fail">   </p><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>详见<a href="http://habitdiary.cn/2017/10/14/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84/">Java学习总结之反射</a>  </p><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>掌握Object类的九个方法：equals()，hashCode(),getClass(),toString(),clone(),sleep(),wait()(三个重载方法)<br>详见 <a href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">Java学习总结之继承和多态</a>  和 <a href="http://habitdiary.cn/2018/02/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%B9%B6%E5%8F%91/#more">Java学习总结之并发</a></p><h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><p>详见<a href="http://habitdiary.cn/2017/11/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F/#more">Java学习总结之Java IO系统</a></p><h4 id="Enum类"><a href="#Enum类" class="headerlink" title="Enum类"></a>Enum类</h4><p>详见<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>  </p><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>详见<a href="http://habitdiary.cn/2018/02/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%B9%B6%E5%8F%91/#more">Java学习总结之并发</a></p><h3 id="java-math包"><a href="#java-math包" class="headerlink" title="java.math包"></a>java.math包</h3><p>java.math包主要包含BigInteger类和BigDecimal类，主要应用于高精度的运算，BigInteger 支持任意精度的整数，BigDecimal 支持任意精度带小数点的运算。<strong>不要混淆java.math包和java.lang包中的Math类。</strong></p><h4 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h4><p>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/BigInteger构造方法.png" alt="fail"><br>2、常见方法<br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法3.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法4.png" alt="fail"><br>3、常量<br><img src="/2018/01/30/Java学习总结之核心API/BigInteger常量.png" alt="fail">  </p><h4 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类　　"></a>BigDecimal类　　</h4><p>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal构造方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal构造方法2.png" alt="fail"><br>2、常见方法<br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法3.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法4.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法5.png" alt="fail"><br>3、常量<br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal常量.png" alt="fail">  </p><h3 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h3><p><img src="/2018/01/30/Java学习总结之核心API/general2.png" alt="fail"></p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间。<br>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/Date构造方法.png" alt="fail"><br>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Date方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/Date方法2.png" alt="fail"></p><h4 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4><p>Java 实用工具类库中的类 java.util.Random 提供了产生各种类型随机数的方法。它可以产生 int、long、float、double 以及 Gaussian 等类型的随机数。这也是它与 java.lang.Math 中的方法 Random() 最大的不同之处，后者只产生 double 型的随机数。<br>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/Random构造方法.png" alt="fail"><br>2、常见方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该方法是设定基值seed</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个整型随机数 </span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个long型随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个Float型随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">nextFloat</span><span class="params">()</span></span></div><div class="line"><span class="function">　</span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个Double型随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个double型的Gaussian随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">nextGaussian</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">/*synchronized 是 Java 语言的关键字，当它用来修饰</span></span></div><div class="line"><span class="function"><span class="comment">一个方法或者一个代码块的时候，能够保证在同一时刻最</span></span></div><div class="line"><span class="function"><span class="comment">多只有一个线程执行该段代码*/</span></span></div></pre></td></tr></table></figure></p><h4 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h4><p>详见<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>  </p><h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>详见<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>  </p><h4 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h4><p>详见<a href="http://habitdiary.cn/2017/10/23/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88/">Java学习总结之集合</a>  </p><h3 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h3><p>详见<a href="http://habitdiary.cn/2017/11/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F/">Java学习总结之Java IO系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Java 的核心 API 是非常庞大的，这给开发者来说带来了很大的方便。所谓的 API 就是一些已经写好、可直接调用的类库。Java 里有非
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之设计模式</title>
    <link href="http://habitdiary.cn/2018/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://habitdiary.cn/2018/01/30/Java学习总结之设计模式/</id>
    <published>2018-01-30T03:01:50.000Z</published>
    <updated>2018-02-14T14:15:26.459Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<br>设计模式是<strong>一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</strong>  </p><h3 id="使用设计模式的目的"><a href="#使用设计模式的目的" class="headerlink" title="使用设计模式的目的"></a>使用设计模式的目的</h3><p>为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。  </p><h3 id="提出者"><a href="#提出者" class="headerlink" title="提出者"></a>提出者</h3><p>设计模式是由GOF(四人帮，Gang of Four)提出的。<br>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则：</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承。    </li></ul><h3 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h3><p>设计模式在软件开发中的两个主要用途。  </p><h4 id="开发人员的共同平台"><a href="#开发人员的共同平台" class="headerlink" title="开发人员的共同平台"></a>开发人员的共同平台</h4><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。  </p><h4 id="最佳的实践"><a href="#最佳的实践" class="headerlink" title="最佳的实践"></a>最佳的实践</h4><p>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。  </p><h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><p>根据设计模式的参考书<strong> Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 中所提到的，总共有<strong> 23 种</strong>设计模式。这些模式可以分为三大类：<strong>创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）</strong>。当然，我们还会讨论另一类设计模式：<strong>J2EE 设计模式。</strong><br><img src="/2018/01/30/Java学习总结之设计模式/general1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之设计模式/general2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之设计模式/general3.png" alt="fail">  </p><p> 下面用一个图片来整体描述一下设计模式之间的关系：  </p><p><img src="/2018/01/30/Java学习总结之设计模式/设计模式之间的关系.png" alt="fail" title="设计模式之间的关系">   </p><h3 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h3><h4 id="1、单一职责原则（SRP：Single-Responsibility-Principle）"><a href="#1、单一职责原则（SRP：Single-Responsibility-Principle）" class="headerlink" title="1、单一职责原则（SRP：Single Responsibility Principle）"></a>1、单一职责原则（SRP：Single Responsibility Principle）</h4><p>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。  </p><h4 id="2、开闭原则（OCP：Open-Close-Principle）"><a href="#2、开闭原则（OCP：Open-Close-Principle）" class="headerlink" title="2、开闭原则（OCP：Open Close Principle）"></a>2、开闭原则（OCP：Open Close Principle）</h4><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </p><h4 id="3、里氏代换原则（LSP：Liskov-Substitution-Principle）"><a href="#3、里氏代换原则（LSP：Liskov-Substitution-Principle）" class="headerlink" title="3、里氏代换原则（LSP：Liskov Substitution Principle）"></a>3、里氏代换原则（LSP：Liskov Substitution Principle）</h4><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </p><h4 id="4、依赖倒转原则（DIP：Dependence-Inversion-Principle）"><a href="#4、依赖倒转原则（DIP：Dependence-Inversion-Principle）" class="headerlink" title="4、依赖倒转原则（DIP：Dependence Inversion Principle）"></a>4、依赖倒转原则（DIP：Dependence Inversion Principle）</h4><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </p><h4 id="5、接口隔离原则（ISP：Interface-Segregation-Principle）"><a href="#5、接口隔离原则（ISP：Interface-Segregation-Principle）" class="headerlink" title="5、接口隔离原则（ISP：Interface Segregation Principle）"></a>5、接口隔离原则（ISP：Interface Segregation Principle）</h4><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </p><h4 id="6、迪米特法则，又称最少知道原则（DP：Demeter-Principle）"><a href="#6、迪米特法则，又称最少知道原则（DP：Demeter-Principle）" class="headerlink" title="6、迪米特法则，又称最少知道原则（DP：Demeter Principle）"></a>6、迪米特法则，又称最少知道原则（DP：Demeter Principle）</h4><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。  </p><h4 id="7、合成复用原则（CRP：Composite-Reuse-Principle）"><a href="#7、合成复用原则（CRP：Composite-Reuse-Principle）" class="headerlink" title="7、合成复用原则（CRP：Composite Reuse Principle）"></a>7、合成复用原则（CRP：Composite Reuse Principle）</h4><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。  </p><h4 id="下面我们将通过Java实例来总结常用的设计模式。"><a href="#下面我们将通过Java实例来总结常用的设计模式。" class="headerlink" title="下面我们将通过Java实例来总结常用的设计模式。"></a>下面我们将通过Java实例来总结常用的设计模式。</h4><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h3 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。  </p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。  </p><p><strong>主要解决：</strong>主要解决接口选择的问题。  </p><p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。  </p><p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。  </p><p><strong>关键代码：</strong>创建过程在其子类执行。  </p><p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。  </p><p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。  </p><p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。  </p><p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 </p><p><img src="/2018/01/30/Java学习总结之设计模式/工厂模式.jpg" alt="fail"></p><p><strong>步骤 1</strong><br>创建一个接口。<br>Shape.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建实现接口的实体类。<br>Rectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>创建一个工厂，生成基于给定信息的实体类的对象。<br>ShapeFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></div><div class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;        </div><div class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>使用该工厂，通过传递类型信息来获取实体类的对象。<br>FactoryPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</div><div class="line"></div><div class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></div><div class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</div><div class="line"></div><div class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></div><div class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</div><div class="line"></div><div class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></div><div class="line">      shape2.draw();</div><div class="line"></div><div class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></div><div class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</div><div class="line"></div><div class="line">      <span class="comment">//调用 Square 的 draw 方法</span></div><div class="line">      shape3.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>验证输出。<br>Inside Circle::draw() method.<br>Inside Rectangle::draw() method.<br>Inside Square::draw() method.  </p><p>使用<strong>反射机制</strong>可以解决每次增加一个产品时，都需要增加一个对象实现工厂接口的缺点。注意要使用完整包名，也可以使用Properties文件做映射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShapeByClassName</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">   Shape obj = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">obj = (Shape)Class.forName(clazz.getName()).newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>工厂模式的实际应用</strong>  </p><p><img src="/2018/01/30/Java学习总结之设计模式/JDBC.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之设计模式/Bean.png" alt="fail"></p><h3 id="2、抽象工厂模式"><a href="#2、抽象工厂模式" class="headerlink" title="2、抽象工厂模式"></a>2、抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  </p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。    </p><p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。  </p><p>为了方便引进抽象工厂模式，引进一个新概念：产品族（Product Family）。所谓产品族，是指位于不同产品等级结构，功能相关联的产品组成的家族。如图：<br><img src="/2018/01/30/Java学习总结之设计模式/产品族1.gif" alt="fail"><br>图中一共有四个产品族，分布于三个不同的产品等级结构中。同一个产品族是同一个工厂生产的，而不同等级结构来自不同的工厂。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。<br>所谓的抽象工厂是指一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。如果用图来描述的话，如下图：<br><img src="/2018/01/30/Java学习总结之设计模式/产品族2.gif" alt="fail"> </p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p><p><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/抽象工厂模式.gif" alt="fail">   </p><p>上图的描述用产品族描述如下：<br><img src="/2018/01/30/Java学习总结之设计模式/产品族3.gif" alt="fail">   </p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>我们来举这样一个例子，QQ秀有不同的装扮，分为男孩和女孩，而男孩又分为圣诞男孩和新年男孩，女孩分为圣诞女孩和新年女孩。那么就可以有一个抽象工厂生产男孩和女孩。两个具体的工厂分别生产圣诞系列的男孩和女孩、新年系列的男孩和女孩。同一系列的男孩和女孩是一个产品族，而不同系列构成不同的产品等级。  </p><p><strong>步骤 1</strong><br>为男孩创建一个接口。<br>Boy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Boy</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMan</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建实现接口的实体类。<br>MCBoy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCBoy</span> <span class="keyword">implements</span> <span class="title">Boy</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMan</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"-----------------圣诞系列的男孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HNBoy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNBoy</span> <span class="keyword">implements</span> <span class="title">Boy</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMan</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"-----------------新年系列的男孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>为女孩创建一个接口<br>Girl.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Girl</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWomen</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>创建实现接口的实体类。<br>MCGirl.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCGirl</span> <span class="keyword">implements</span> <span class="title">Girl</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWomen</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"-----------------圣诞系列的女孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HNGirl.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNGirl</span> <span class="keyword">implements</span> <span class="title">Girl</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWomen</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line">System.out.println(<span class="string">"-----------------新年系列的女孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>创建生产男孩女孩的抽象工厂接口<br>PersonFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span> </span>&#123;</div><div class="line"><span class="comment">//男孩接口</span></div><div class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getBoy</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//女孩接口</span></div><div class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 6</strong><br>创建生产圣诞和新年系列的具体工厂<br>MCFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCFctory</span> <span class="keyword">implements</span> <span class="title">PersonFactory</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getBoy</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MCBoy();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MCGirl();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HNFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNFactory</span> <span class="keyword">implements</span> <span class="title">PersonFactory</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getBoy</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> HNBoy();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> HNGirl();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 7</strong><br>使用工厂生产<br>AbstractFactoryPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    MCFactory mcFactory = <span class="keyword">new</span> MCFactory();</div><div class="line">        HNFactory hnFactory = <span class="keyword">new</span> HNFactory();</div><div class="line">        Boy mcBoy = mcFactory.getBoy();</div><div class="line">        Girl mcGirl = mcFactory.getGirl();</div><div class="line">        Boy hnBoy = hnFactory.getBoy();</div><div class="line">        Girl hnGirl = hnFactory.getGirl();</div><div class="line">        mcBoy.drawMan();</div><div class="line">        mcGirl.drawWomen();</div><div class="line">        hnBoy.drawMan();</div><div class="line">        hnGirl.drawWomen();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 8</strong><br>验证输出<br>—————–圣诞系列的男孩子——————–<br>—————–圣诞系列的女孩子——————–<br>—————–新年系列的男孩子——————–<br>—————–新年系列的女孩子——————–  </p><p><img src="/2018/01/30/Java学习总结之设计模式/对比.png" alt="fail"></p><h3 id="3、单例模式"><a href="#3、单例模式" class="headerlink" title="3、单例模式"></a>3、单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个<strong>单一的类</strong>，该类负责<strong>创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，<strong>可以直接访问，不需要实例化该类的对象</strong>。<br><strong>注意：</strong><br>1、单例类只能有<strong>一个实例</strong>。<br>2、单例类必须<strong>自己创建自己的唯一实例</strong>，而不是在外部随意地new对象。<br>3、单例类必须给所有其他对象<strong>提供</strong>这一实例。  </p><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>应用实例：</strong> 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。<br><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销。2、避免频繁的创建和销毁实例，提高性能（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong>1、扩展比较困难，没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。2、如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失。<br><strong>使用场景：</strong> 1、当多个实例存在可能引起程序逻辑错误，如要求生产唯一序列号。 2、对系统内资源要求统一读写，如读写配置信息，又如WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，但同时又需要用到该对象，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。  </p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img src="/2018/01/30/Java学习总结之设计模式/单例模式.jpg" alt="fail"><br><strong>步骤 1</strong><br>创建一个 Singleton 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">SingleObject.java</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//创建 SingleObject 的一个对象</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</div><div class="line"></div><div class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">   <span class="comment">//获取唯一可用的对象</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"Hello World!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>从 singleton 类获取唯一的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">SingletonPatternDemo.java</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//不合法的构造函数</span></div><div class="line">      <span class="comment">//编译时错误：构造函数 SingleObject() 是不可见的</span></div><div class="line">      <span class="comment">//SingleObject object = new SingleObject();</span></div><div class="line"></div><div class="line">      <span class="comment">//获取唯一可用的对象</span></div><div class="line">      SingleObject object = SingleObject.getInstance();</div><div class="line"></div><div class="line">      <span class="comment">//显示消息</span></div><div class="line">      object.showMessage();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>验证输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure></p><h4 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h4><p>单例模式的实现有多种方式，如下所示：<br><strong>1、懒汉式，线程不安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。假设开始线程1进入，判断instance为空，在将要创建实例时，时间片切换，线程2又进来了，同样判断instance为空，创建了实例，这是CPU调度回到线程1，继续创建实例。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  <span class="comment">/*懒汉式标志：Lazy 初始化,</span></div><div class="line"><span class="comment">    在外部第一次请求使用该类对象时才实例化，是时间换空间的模式*/</span></div><div class="line">        instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong><br><strong>2、懒汉式，线程安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="comment">//加同步锁</span></div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;   </div><div class="line">        instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>3、饿汉式</strong><br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">                           <span class="comment">/*饿汉式标志：在类加载时直接初始化，</span></div><div class="line"><span class="comment">                           是空间换时间的模式*/</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>4、双检锁/双重校验锁（DCL，即 double-checked locking）</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。这种方法既能保证线程安全又能提高了效率。<br>假设线程1进入方法，instance为空，进入同步代码块，时间片切换，线程2进来，instance为空，在同步代码块外被阻塞，因为此时线程1正在里面。cup切换，线程1执行创建实例，当2再进入代码块后，此时instace不为空，直接返回instance。当再有线程进来，instance不为空，不用执行同步代码块，提高了效率。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">            singleton = <span class="keyword">new</span> Singleton();  </div><div class="line">        &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> singleton;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>5、登记式/静态内部类</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>6、枚举</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。  </p><h3 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h3><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h3 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6.适配器模式"></a>6.适配器模式</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。  </p><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决：</strong>继承或依赖（推荐）。</p><p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p><p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/适配器模式.png" alt="fail"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>我们来看这样一个例子，笔记本(Laptop)需要三相插座(ThreePlugIf)充电，但是只有一个国标二相插座(GBTwoPlug),我们可以使用一个适配器来使用二相插座给笔记本充电。</p><p>(1)使用<strong>组合</strong>方式实现<strong>对象</strong>适配器<br>把“被适配者”作为一个对象组合到适配器类中，以修改目标接口包装“被适配者”。<br>ThreePlugIf.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 三相插座接口</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreePlugIf</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//使用三相电流供电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithThree</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>GBTwoPlug.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GBTwoPlug</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//使用二相电流供电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithTwo</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"使用二相电流供电"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>TwoPlugAdapter.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 二相转三相的插座适配器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPlugAdapter</span> <span class="keyword">implements</span> <span class="title">ThreePlugIf</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> GBTwoPlug plug;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TwoPlugAdapter</span><span class="params">(GBTwoPlug plug)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.plug = plug;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithThree</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"通过转化"</span>);</div><div class="line">plug.powerWithTwo();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Laptop.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> ThreePlugIf  plug;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(ThreePlugIf plug)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.plug = plug;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用插座充电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>&#123;</div><div class="line">plug.powerWithThree();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">GBTwoPlug two =  <span class="keyword">new</span> GBTwoPlug();</div><div class="line">ThreePlugIf three = <span class="keyword">new</span> TwoPlugAdapter(two);</div><div class="line">Laptop lp = <span class="keyword">new</span> Laptop(three);</div><div class="line">lp.charge();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>验证输出：<br>通过转化<br>使用二相电流供电  </p><p>分析：Laptop需要一个实现ThreePlugIf接口的对象来使用三相电流供电，我们就传入一个实现了该接口的适配器，看似调用了powerWithThree()方法，实际上是调用了组合在适配器里的GBTwoPlug的powerWithTwo()方法。</p><p>(2)使用<strong>继承</strong>方式实现<strong>类</strong>适配器<br>继承“被适配者”并实现目标接口。<br>TwoPlugAdapterExtends.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 采用继承方式的插座适配器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPlugAdapterExtends</span> <span class="keyword">extends</span> <span class="title">GBTwoPlug</span> <span class="keyword">implements</span> <span class="title">ThreePlugIf</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithThree</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"借助继承适配器"</span>);</div><div class="line"><span class="keyword">this</span>.powerWithTwo();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Laptop.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> ThreePlugIf  plug;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(ThreePlugIf plug)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.plug = plug;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用插座充电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>&#123;</div><div class="line">plug.powerWithThree();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">three = <span class="keyword">new</span> TwoPlugAdapterExtends();</div><div class="line">lp = <span class="keyword">new</span> Laptop(three);</div><div class="line">lp.charge();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>验证输出：<br>借助继承适配器<br>使用二相电流供电</p><p>两种方法比较，组合适配可以适配”被适配者”的任何子类(根据多态机制可以给适配器中的GBTwoPlug赋予GBTwoPlug的任何子类的引用)，但继承适配是为单一的类服务的(已经继承了GBTwoPlug，不能再继承它的子类)，只能适配”被适配者”。</p><h3 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7.桥接模式"></a>7.桥接模式</h3><h3 id="8-过滤器模式"><a href="#8-过滤器模式" class="headerlink" title="8.过滤器模式"></a>8.过滤器模式</h3><h3 id="9-组合模式"><a href="#9-组合模式" class="headerlink" title="9.组合模式"></a>9.组合模式</h3><h3 id="10-装饰器模式"><a href="#10-装饰器模式" class="headerlink" title="10.装饰器模式"></a>10.装饰器模式</h3><h3 id="11-外观模式"><a href="#11-外观模式" class="headerlink" title="11.外观模式"></a>11.外观模式</h3><h3 id="12-享元模式"><a href="#12-享元模式" class="headerlink" title="12.享元模式"></a>12.享元模式</h3><h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a>13.代理模式</h3><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><h3 id="14-责任链模式"><a href="#14-责任链模式" class="headerlink" title="14.责任链模式"></a>14.责任链模式</h3><h3 id="15-命令模式"><a href="#15-命令模式" class="headerlink" title="15.命令模式"></a>15.命令模式</h3><h3 id="16-解释器模式"><a href="#16-解释器模式" class="headerlink" title="16.解释器模式"></a>16.解释器模式</h3><h3 id="17-迭代器模式"><a href="#17-迭代器模式" class="headerlink" title="17.迭代器模式"></a>17.迭代器模式</h3><h3 id="18-中介者模式"><a href="#18-中介者模式" class="headerlink" title="18.中介者模式"></a>18.中介者模式</h3><h3 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19.备忘录模式"></a>19.备忘录模式</h3><h3 id="20-观察者模式"><a href="#20-观察者模式" class="headerlink" title="20.观察者模式"></a>20.观察者模式</h3><h3 id="21-状态模式"><a href="#21-状态模式" class="headerlink" title="21.状态模式"></a>21.状态模式</h3><h3 id="22-空对象模式"><a href="#22-空对象模式" class="headerlink" title="22.空对象模式"></a>22.空对象模式</h3><h3 id="23-策略模式"><a href="#23-策略模式" class="headerlink" title="23.策略模式"></a>23.策略模式</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。  </p><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码：</strong>抽象出行为的共性作为一个策略接口，各种策略类实现这个接口。在调用这个行为的类中通过组合持有这个接口的对象，通过这个策略接口对象代理具体的行为。</p><p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p><p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。   </p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="/2018/01/30/Java学习总结之设计模式/策略模式.jpg" alt="fail">  </p><p><strong>步骤 1</strong><br>创建一个接口。<br>Strategy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建实现接口的实体类。<br>OperationAdd.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> num1 + num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OperationSubstract.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> num1 - num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OperationMultiply.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> num1 * num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>创建 Context 类。<br>Context.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> Strategy strategy;<span class="comment">//组合一个策略接口对象</span></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</div><div class="line">      <span class="keyword">this</span>.strategy = strategy;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</div><div class="line">      <span class="comment">//用策略接口对象代理具体实现</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>使用 Context 来查看当它改变策略 Strategy 时的行为变化。<br>StrategyPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());        </div><div class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</div><div class="line"></div><div class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());        </div><div class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</div><div class="line"></div><div class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());        </div><div class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>验证输出。<br>10 + 5 = 15<br>10 - 5 = 5<br>10 * 5 = 50</p><h3 id="24-模板模式"><a href="#24-模板模式" class="headerlink" title="24.模板模式"></a>24.模板模式</h3><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。  </p><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p><p><strong>何时使用：</strong>有一些通用的方法。</p><p><strong>如何解决：</strong>将这些通用算法抽象出来。</p><p><strong>关键代码：</strong>准备一个抽象类，将部分逻辑以具体方法的形式实现，然后声明一些抽象方法交由子类实现剩余逻辑，用钩子方法给予子类更大的灵活性。最后将方法汇总为一个final的模板方法。</p><p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p><p><strong>优点：</strong> 1、封装性好，封装不变部分，扩展可变部分。 2、复用性好，提取公共代码，便于维护。 3、屏蔽细节，行为由父类控制，子类实现。</p><p><strong>缺点：</strong>1、每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。2、Java的单继承使得继承了其他父类子类难以实现对模板基类的继承。</p><p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。在模板方法内的步骤中，通用的方法在抽象基类里提供实现，特定的方法定义为抽象方法，延迟到子类中实现。</p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。<br>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/模板模式.jpg" alt="fail">  </p><p><strong>步骤 1</strong><br>创建一个抽象类，它的模板方法被设置为 final。<br>Game.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</div><div class="line">   <span class="comment">//如果子类通用，可以在抽象基类实现，不必定义为抽象方法</span></div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">//模板,定义为final，防止被子类重写</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//初始化游戏</span></div><div class="line">      initialize();</div><div class="line"></div><div class="line">      <span class="comment">//开始游戏</span></div><div class="line">      startPlay();</div><div class="line"></div><div class="line">      <span class="comment">//结束游戏</span></div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建扩展了上述类的实体类。<br>Cricket.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Football.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>使用 Game 的模板方法 play() 来演示游戏的定义方式。<br>TemplatePatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">      Game game = <span class="keyword">new</span> Cricket();</div><div class="line">      game.play();</div><div class="line">      System.out.println();</div><div class="line">      game = <span class="keyword">new</span> Football();</div><div class="line">      game.play();        </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>验证输出。<br>Cricket Game Initialized! Start playing.<br>Cricket Game Started. Enjoy the game!<br>Cricket Game Finished!<br>Football Game Initialized! Start playing.<br>Football Game Started. Enjoy the game!<br>Football Game Finished!  </p><p>如果想要灵活选择模板中的某一步骤是否出现，可以添加一个钩子方法：比如在泡饮品的模板方法中，烧水——倒入饮品冲剂——加水——加调料。如果有的饮品不想要调料，可以在模板方法中把加调料放在if语句中，if的条件是一个返回值为boolean类型的方法，比如isCustomerWantsCondiments(),提供一个空的或者默认返回true的实现，称为钩子方法。子类可以根据需要重写该钩子方法选择要不要加调料。</p><h3 id="25-访问者模式"><a href="#25-访问者模式" class="headerlink" title="25.访问者模式"></a>25.访问者模式</h3><h3 id="J2EE模式"><a href="#J2EE模式" class="headerlink" title="J2EE模式"></a>J2EE模式</h3><h3 id="26-MVC-模式"><a href="#26-MVC-模式" class="headerlink" title="26.MVC 模式"></a>26.MVC 模式</h3><h3 id="27-业务代表模式"><a href="#27-业务代表模式" class="headerlink" title="27.业务代表模式"></a>27.业务代表模式</h3><h3 id="28-组合实体模式"><a href="#28-组合实体模式" class="headerlink" title="28.组合实体模式"></a>28.组合实体模式</h3><h3 id="29-数据访问对象模式"><a href="#29-数据访问对象模式" class="headerlink" title="29.数据访问对象模式"></a>29.数据访问对象模式</h3><h3 id="30-前端控制器模式"><a href="#30-前端控制器模式" class="headerlink" title="30.前端控制器模式"></a>30.前端控制器模式</h3><h3 id="31-拦截过滤器模式"><a href="#31-拦截过滤器模式" class="headerlink" title="31.拦截过滤器模式"></a>31.拦截过滤器模式</h3><h3 id="32-服务定位器模式"><a href="#32-服务定位器模式" class="headerlink" title="32.服务定位器模式"></a>32.服务定位器模式</h3><h3 id="33-传输对象模式"><a href="#33-传输对象模式" class="headerlink" title="33.传输对象模式"></a>33.传输对象模式</h3><p>参考资料：菜鸟教程之设计模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式概述&quot;&gt;&lt;a href=&quot;#设计模式概述&quot; class=&quot;headerlink&quot; title=&quot;设计模式概述&quot;&gt;&lt;/a&gt;设计模式概述&lt;/h3&gt;&lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模
      
    
    </summary>
    
    
      <category term="Java,软件工程" scheme="http://habitdiary.cn/tags/Java-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell脚本对拍</title>
    <link href="http://habitdiary.cn/2017/12/02/Linux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E5%AF%B9%E6%8B%8D/"/>
    <id>http://habitdiary.cn/2017/12/02/Linux下shell脚本对拍/</id>
    <published>2017-12-01T16:14:43.000Z</published>
    <updated>2017-12-01T16:47:50.024Z</updated>
    
    <content type="html"><![CDATA[<p>在算法竞赛中，我们常常会遇到一道题一直WA的情况，这时我们不得不自己造样例，这会耗费大量时间，而且还不一定能快速确定样例的答案。所以，如果时间充足，可以写一个对拍程序。<br>对拍程序需要四个文件：<br>1.我们已经写好但WA的待测试文件，记为code.cpp<br>2.一个纯暴力程序(复杂度高但能保证答案一定正确)，记为std.cpp<br>3.一个数据生成器(用srand函数和rand函数产生随机数即可)，记为data.cpp<br>4.一个用于比较输出的shell脚本,记为duipai.sh<br>对拍程序，顾名思义，就是随机生成数据给两个程序分别跑一遍，看看对不对的上。  </p><p>我们以一个计算1到n的和的程序为例，我们都知道计算1到n的暴力方法是用循环加和，简便方法则是使用等差数列求和公式。  </p><p>下面是待测试程序code.cpp(等比数列求和,当然这里没有WA)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> n;</div><div class="line">  <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;n * (n + <span class="number">1</span>) / <span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是暴力求和程序std.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> n;</div><div class="line">  <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</div><div class="line">   ans += i;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后是随机数据生成器data.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  srand(time(<span class="number">0</span>));</div><div class="line">  <span class="keyword">int</span> n = <span class="number">100</span>;</div><div class="line">  <span class="keyword">while</span>(n--)&#123;</div><div class="line">  <span class="keyword">int</span> k = rand() % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">//生成100个[1,10]的随机数</span></div><div class="line">  <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>rand函数和srand函数的用法有点忘了，参见：<a href="https://www.cnblogs.com/guihailiuli/p/4154416.html" target="_blank" rel="external">有关rand()，srand()产生随机数学习总结</a> </p><p>最后是duipai.sh<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></div><div class="line">    ./data &gt; data.in</div><div class="line">    ./std &lt;data.in &gt;std.out</div><div class="line">    ./code &lt;data.in &gt;code.out</div><div class="line">    <span class="keyword">if</span> diff std.out code.out; <span class="keyword">then</span></div><div class="line">        <span class="built_in">printf</span> <span class="string">"AC\n"</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span> <span class="string">"Wa\n"</span></div><div class="line">        <span class="built_in">exit</span> 0</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p><p>这个程序的意思是运行三个可执行文件，比较std.out code.out是否相同，相同输出”AC”，不相同输出错误信息，并输出”WA”且退出。  </p><p>下面开始跑对拍，先用g++编译三个cpp文件，<code>g++ code.cpp -o code</code>,<code>g++ std.cpp -o std</code>,<code>g++ data.cpp -o data</code>。<code>g++ code.cpp -o code</code>表示将code.cpp编译并连接生成一个名为code的可执行文件，如果不加 -o 选项，所有cpp文件都默认生成一个名为a.out的可执行文件。通过<code>./a.out</code>可以运行这个可执行文件,<code>./</code>表示当前目录。如果加上 -c 选项，如<code>g++ -c code.cpp -o code</code>则只编译不连接，会产生一个obj文件而不是exe文件。  </p><p>编译完成后，输入<code>sh duipai.sh</code>即得结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在算法竞赛中，我们常常会遇到一道题一直WA的情况，这时我们不得不自己造样例，这会耗费大量时间，而且还不一定能快速确定样例的答案。所以，如果时间充足，可以写一个对拍程序。&lt;br&gt;对拍程序需要四个文件：&lt;br&gt;1.我们已经写好但WA的待测试文件，记为code.cpp&lt;br&gt;2.
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用jsoup简易爬取POJ题面</title>
    <link href="http://habitdiary.cn/2017/12/01/%E4%BD%BF%E7%94%A8jsoup%E7%AE%80%E6%98%93%E7%88%AC%E5%8F%96POJ%E9%A2%98%E9%9D%A2/"/>
    <id>http://habitdiary.cn/2017/12/01/使用jsoup简易爬取POJ题面/</id>
    <published>2017-12-01T15:16:14.000Z</published>
    <updated>2017-12-03T13:43:35.630Z</updated>
    
    <content type="html"><![CDATA[<p>最近校创的项目终于立项啦！一直在等答辩通知，结果无需答辩直接立项2333。马上和队友开始着手项目，目标是做一个基于习题推荐的算法分类学习平台，简单来说就是一个根据用户历史做题情况自动推荐相应难度或类型题目的Online Judge。作为ACM校队的弱菜，正好造福一下学弟学妹ORZ<br>当然，作为一个新兴的OJ，肯定是没有题目来源的，所以我们把罪恶的双手(嘘~)伸向了一些目前主流的OJ。我们需要用爬虫技术爬取这些OJ的题面，并提取总提交数和通过数来计算AC率，从而把AC率作为题目难度的一个指标，以便后续实现题目推荐。<br>之前没有写过爬虫，队友告诉我Java可以用jsoup库很方便地解析html网页的元素。于是粗略学习了jsoup,再配合一点CSS选择器的知识，这对于一般的html网页的爬取就够用了，下面是几个学习的网站：<br><a href="http://www.open-open.com/jsoup/" target="_blank" rel="external">jsoup Cookbook(中文版)</a><br><a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="external">CSS 选择器</a></p><p>我分到的是<a href="http://poj.org/" target="_blank" rel="external">POJ</a>，打开Problems，选择第一道题，即<a href="http://poj.org/problem?id=1000" target="_blank" rel="external">A+B Problem</a>。查看网页的源代码发现TABLE标签之后的table标签恰好包括了所有我需要的信息(POJ真友好啊)，将爬到的内容重定向到一个html文件，我们就得到了题面。核心代码只有几行，不多说上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Node;</div><div class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Crawler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pid = <span class="number">1000</span>;pid &lt;= <span class="number">1100</span>;pid++) &#123;</div><div class="line">Document doc = Jsoup.connect(<span class="string">"http://poj.org/"</span></div><div class="line">                    +<span class="string">"problem?id="</span> + pid).get();</div><div class="line">        Elements text = doc.select(<span class="string">"TABLE+table"</span>);</div><div class="line">        <span class="comment">//选择TABLE标签之后的table标签</span></div><div class="line">    text.select(<span class="string">".ptt"</span>).attr(<span class="string">"align"</span>, <span class="string">"center"</span>);</div><div class="line">        <span class="comment">//题目没有居中，添加居中属性</span></div><div class="line">        Elements image = text.select(<span class="string">"img"</span>);</div><div class="line"><span class="keyword">for</span>(Element e:image) &#123;</div><div class="line">String href = e.attr(<span class="string">"src"</span>);</div><div class="line">e.attr(<span class="string">"src"</span>,<span class="string">"http://poj.org/"</span>+href);</div><div class="line">        &#125;</div><div class="line">       <span class="comment">/*图片在poj服务器上，必须修改图片路径为</span></div><div class="line"><span class="comment">         绝对路径，否则无法显示*/</span></div><div class="line">        System.setOut(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> </div><div class="line">                      FileOutputStream(<span class="string">"problem"</span>+pid+<span class="string">".html"</span>)));</div><div class="line">        System.out.println(text);</div><div class="line">      <span class="comment">//重定向输出到html文件</span></div><div class="line">            &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>耐心等待爬取题目编号为1000到1100的题目,显示如下：<br><img src="/2017/12/01/使用jsoup简易爬取POJ题面/1.png" alt="fail"><br>用浏览器打开problem1000.html，效果如下：<br><img src="/2017/12/01/使用jsoup简易爬取POJ题面/2.png" alt="fail"><br>大功告成！！！  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近校创的项目终于立项啦！一直在等答辩通知，结果无需答辩直接立项2333。马上和队友开始着手项目，目标是做一个基于习题推荐的算法分类学习平台，简单来说就是一个根据用户历史做题情况自动推荐相应难度或类型题目的Online Judge。作为ACM校队的弱菜，正好造福一下学弟学妹
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
      <category term="爬虫" scheme="http://habitdiary.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之Java IO系统</title>
    <link href="http://habitdiary.cn/2017/11/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F/"/>
    <id>http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/</id>
    <published>2017-11-28T14:07:13.000Z</published>
    <updated>2018-02-21T12:18:58.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。  </p><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>JAVA中IO操作有相应步骤，以文件操作为例，主要操作流程如下：<br>1.使用File类打开一个文件<br>2.通过字节流或字符流的子类，指定输出的位置<br>3.进行读/写操作<br>4.关闭输入/输出  </p><p>那么我们先来介绍一下File类<br>Java文件类在Java.io包中，它以<strong>抽象</strong>的方式代表文件名和目录路径名。该类主要用于获取文件和目录的<strong>属性</strong>，文件和目录的<strong>创建、查找、删除、重命名</strong>等,但<strong>不能</strong>进行文件的<strong>读写操作</strong>。<br>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。  </p><p>通过给定的<strong>父抽象路径名</strong>和<strong>子路径名字符串</strong>创建一个新的File实例。<br><code>File(File parent, String child)</code>  </p><p>通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。<br><code>File(String pathname)</code>  </p><p>根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。<br><code>File(String parent, String child)</code>  </p><p>通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。<br><code>File(URI uri)</code>  </p><p><strong>注意：</strong><br>1.在各个操作系统中，路径的分隔符是不一样的，例如：Windows中使用反斜杠：”<code>\</code>“，Linux|Unix中使用正斜杠：”<code>/</code>“。在使用反斜杠时要写成”<code>\\</code>“的形式，因为反斜杠要进行转义。如果要让Java保持可移植性，应该使用File类的静态常量File.pathSeparator。<br>2.<strong>构建一个File实例并不会在机器上创建一个文件。</strong>不管文件是否存在，都可以创建任意文件名的File实例。可以调用File实例上的exists()方法来判断这个文件是否存在。通过后续的学习我们会知道，当把一个输出流绑定到一个不存在的File实例上时，会自动在机器上创建该文件，如果文件已经存在，把输出流绑定到该文件上则会覆盖该文件，但这些都不是在创建File实例时进行的。</p><p>创建File对象成功后，可以使用以下列表中的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/File1.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File2.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File3.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File4.png" alt="fail">  </p><p>下面给出一个使用File类的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      String dirname = <span class="string">"/java"</span>;</div><div class="line">      File f1 = <span class="keyword">new</span> File(dirname);</div><div class="line">      <span class="keyword">if</span> (f1.isDirectory()) &#123;</div><div class="line">         System.out.println( <span class="string">"Directory of "</span> + dirname);</div><div class="line">         String s[] = f1.list();</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">            File f = <span class="keyword">new</span> File(dirname + <span class="string">"/"</span> + s[i]);</div><div class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</div><div class="line">               System.out.println(s[i] + <span class="string">" is a directory"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               System.out.println(s[i] + <span class="string">" is a file"</span>);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         System.out.println(dirname + <span class="string">" is not a directory"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>小贴士：</strong>lastModified()方法返回的是从时间戳(1970年1月1日0时0分0秒)到当前的毫秒数，返回值类型是long，可以用Date类对它进行包装使其更易读。</p><h3 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h3><p><strong>创建目录：</strong><br>File类中有两个方法可以用来创建文件夹：</p><ul><li>mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li><li>mkdirs()方法创建一个文件夹和它的所有父文件夹。<br>下面的例子创建 “/tmp/user/java/bin”文件夹：  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDir</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    String dirname = <span class="string">"/tmp/user/java/bin"</span>;</div><div class="line">    File d = <span class="keyword">new</span> File(dirname);</div><div class="line">    <span class="comment">// 现在创建目录</span></div><div class="line">    d.mkdirs();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>mkdirs是递归创建文件夹，允许在创建某文件夹时其父文件夹不存在,从而一同创建;mkdir必须满足路径上的父文件夹全都存在</strong><br><strong>注意：</strong> Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。<br><strong>读取目录：</strong><br>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。<br>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。<br>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。<br>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    String dirname = <span class="string">"/tmp"</span>;</div><div class="line">    File f1 = <span class="keyword">new</span> File(dirname);</div><div class="line">    <span class="keyword">if</span> (f1.isDirectory()) &#123;</div><div class="line">      System.out.println( <span class="string">"目录 "</span> + dirname);</div><div class="line">      String s[] = f1.list();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">        File f = <span class="keyword">new</span> File(dirname + <span class="string">"/"</span> + s[i]);</div><div class="line">        <span class="keyword">if</span> (f.isDirectory()) &#123;</div><div class="line">          System.out.println(s[i] + <span class="string">" 是一个目录"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          System.out.println(s[i] + <span class="string">" 是一个文件"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      System.out.println(dirname + <span class="string">" 不是一个目录"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>删除目录或文件：</strong><br>删除文件可以使用 java.io.File.delete() 方法。<br>以下代码会删除目录/tmp/java/，即便目录不为空。<br>测试目录结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/tmp/java/</div><div class="line">|-- <span class="number">1</span>.log</div><div class="line">|-- test</div></pre></td></tr></table></figure></p><p>deleteFolder是一个递归函数，类似于DFS思想<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteFileDemo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      <span class="comment">// 这里修改为自己的测试目录</span></div><div class="line">    File folder = <span class="keyword">new</span> File(<span class="string">"/tmp/java/"</span>);</div><div class="line">    deleteFolder(folder);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//删除文件及目录</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(File folder)</span> </span>&#123;</div><div class="line">    File[] files = folder.listFiles();</div><div class="line">        <span class="keyword">if</span>(files!=<span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">for</span>(File f: files) &#123;</div><div class="line">                <span class="keyword">if</span>(f.isDirectory()) &#123;</div><div class="line">                    deleteFolder(f);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    f.delete();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        folder.delete();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>RandomAccessFile不同于File，它提供了对文件内容的访问，可以<strong>读写文件且支持随机访问文件的任意位置</strong>。<br>RandomAccessFile读写用到文件指针，它的初始位置为0,可以用getFilePointer()方法获取文件指针的位置。下面是RandomAccessFile常用的方法。  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/RandomAccessFile.png" alt="fail"><br>public int read(int x) throws IOException 方法只读取一个字节，也就是x的低八位。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.RandomAccessFile ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo01</span></span>&#123;</div><div class="line"><span class="comment">// 所有的异常直接抛出，程序中不再进行处理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;<span class="comment">// 指定要操作的文件</span></div><div class="line">RandomAccessFile rdf = <span class="keyword">null</span> ;<span class="comment">// 声明RandomAccessFile类的对象</span></div><div class="line">rdf = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"rw"</span>) ;<span class="comment">// 读写模式，如果文件不存在，会自动创建</span></div><div class="line">String name = <span class="keyword">null</span> ;</div><div class="line"><span class="keyword">int</span> age = <span class="number">0</span> ;</div><div class="line">name = <span class="string">"zhangsan"</span> ;<span class="comment">// 字符串长度为8</span></div><div class="line">age = <span class="number">30</span> ;<span class="comment">// 数字的长度为4</span></div><div class="line">rdf.writeBytes(name) ;<span class="comment">// 将姓名写入文件之中</span></div><div class="line">rdf.writeInt(age) ;<span class="comment">// 将年龄写入文件之中</span></div><div class="line">name = <span class="string">"lisi    "</span> ;<span class="comment">// 字符串长度为8</span></div><div class="line">age = <span class="number">31</span> ;<span class="comment">// 数字的长度为4</span></div><div class="line">rdf.writeBytes(name) ;<span class="comment">// 将姓名写入文件之中</span></div><div class="line">rdf.writeInt(age) ;<span class="comment">// 将年龄写入文件之中</span></div><div class="line">name = <span class="string">"wangwu  "</span> ;<span class="comment">// 字符串长度为8</span></div><div class="line">age = <span class="number">32</span> ;<span class="comment">// 数字的长度为4</span></div><div class="line">rdf.writeBytes(name) ;<span class="comment">// 将姓名写入文件之中</span></div><div class="line">rdf.writeInt(age) ;<span class="comment">// 将年龄写入文件之中</span></div><div class="line">rdf.close() ;<span class="comment">// 关闭</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>写完之后，开始读取数据。写的时候可以将一个字符串写入，读的时候需要一个个的以字节的形式读取出来。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.RandomAccessFile ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo02</span></span>&#123;</div><div class="line"><span class="comment">// 所有的异常直接抛出，程序中不再进行处理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;<span class="comment">// 指定要操作的文件</span></div><div class="line">RandomAccessFile rdf = <span class="keyword">null</span> ;<span class="comment">// 声明RandomAccessFile类的对象</span></div><div class="line">rdf = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"r"</span>) ;<span class="comment">// 以只读的方式打开文件</span></div><div class="line">String name = <span class="keyword">null</span> ;</div><div class="line"><span class="keyword">int</span> age = <span class="number">0</span> ;</div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>] ;<span class="comment">// 开辟byte数组</span></div><div class="line"><span class="comment">// 读取第二个人的信息，意味着要空出第一个人的信息</span></div><div class="line">rdf.skipBytes(<span class="number">12</span>) ;<span class="comment">// 跳过第一个人的信息</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">b[i] = rdf.readByte() ;<span class="comment">// 读取一个字节</span></div><div class="line">&#125;</div><div class="line">name = <span class="keyword">new</span> String(b) ;<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">age = rdf.readInt() ;<span class="comment">// 读取数字</span></div><div class="line">System.out.println(<span class="string">"第二个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line"><span class="comment">// 读取第一个人的信息</span></div><div class="line">rdf.seek(<span class="number">0</span>) ;<span class="comment">// 指针回到文件的开头</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">b[i] = rdf.readByte() ;<span class="comment">// 读取一个字节</span></div><div class="line">&#125;</div><div class="line">name = <span class="keyword">new</span> String(b) ;<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">age = rdf.readInt() ;<span class="comment">// 读取数字</span></div><div class="line">System.out.println(<span class="string">"第一个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line">rdf.skipBytes(<span class="number">12</span>) ;<span class="comment">// 跳过第二个人的信息</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">b[i] = rdf.readByte() ;<span class="comment">// 读取一个字节</span></div><div class="line">&#125;</div><div class="line">name = <span class="keyword">new</span> String(b) ;<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">age = rdf.readInt() ;<span class="comment">// 读取数字</span></div><div class="line">System.out.println(<span class="string">"第三个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line">rdf.close() ;<span class="comment">// 关闭</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>结果如下：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/result.png" alt="fail"> </p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>在Java程序中所有的数据都是以<strong>流</strong>的方式进行<strong>传输或保存</strong>的，程序需要数据的时候要使用<strong>输入流</strong>读取数据，而当程序需要将一些数据保存起来的时候，就要使用<strong>输出流</strong>完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是<strong>字节文件</strong>。流涉及的领域很广：标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Stream.png" alt="fail"><br>流具有<strong>方向性</strong>，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。<br>可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Information.jpg" alt="fail"><br>先上一个<strong>Java IO流类层次图</strong>，如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/JavaIO流类层次图.png" alt="fail" title="Java IO流类层次图"><br>是不是被吓到了？没关系，我们将通过一个个例子来学习这些功能。  </p><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><h4 id="1-按操作数据类型分：字符流和字节流"><a href="#1-按操作数据类型分：字符流和字节流" class="headerlink" title="1.按操作数据类型分：字符流和字节流"></a>1.按操作数据类型分：字符流和字节流</h4><p><strong>字符流：</strong>Java中的字符流处理的最基本的单元是<strong>2字节的Unicode码元(char)</strong>，它通常用来处理文本数据，如字符、字符数组或字符串等。所谓Unicode码元，也就是一个Unicode代码单元，范围是0x0000~0xFFFF。在以上范围内的每个数字都与一个字符相对应，Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。然而与存储在内存中不同，存储在磁盘上的数据通常有着各种各样的编码方式。使用不同的编码方式，相同的字符会有不同的二进制表示。实际上字符流是这样工作的：  </p><ul><li>输出字符流：把要写入文件的字符序列(实际上是Unicode码元序列)转为指定编码方式下的字节序列，然后再写入到文件中。</li><li>输入字符流：把要读取的字节序列按指定编码方式解码为相应字符序列(实际上是Unicode码元序列从)从而可以存在内存中。 </li></ul><p>也就是说，所有的文件在<strong>硬盘</strong>或在<strong>传输</strong>时都是以<strong>字节</strong>的方式进行的，包括图片等都是<strong>按字节的方式存储</strong>的，而字符是只有在<strong>内存</strong>中才会形成。 </p><p><strong>字节流：</strong>Java中的字节流处理的最基本单位为<strong>单个字节(byte)</strong>，它通常用来处理二进制数据,如果要得到字节对应的字符需要强制类型转换。  </p><p><strong>两者比较：</strong><br>1.字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性较好，如果要操作中文数据等，用字符流。<br>2.字符流只用来处理文本数据，字节流还可以用来处理媒体数据，如视频、音频、图片等。<br>3.字符流的两个<strong>抽象基类</strong>为Reader和Writer，字节流的两个<strong>抽象基类</strong>为InputStream和OutputStream。它们的具体子类名以基类名为后缀进行扩展。<br>4.字节流在操作的时候不会用到缓冲区(内存)，是直接对文件本身操作的，而字符流在操作的时候使用缓冲区。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Compare.jpg" alt="fail"></p><p>以向一个文件输出”Hello world!”为例，我们分别使用字节流和字符流进行输出，且在使用完之后都不关闭流。</p><p>使用字节流不关闭执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOPractice</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="comment">// 第1步：使用File类找到一个文件    </span></div><div class="line">     File f = <span class="keyword">new</span> File(<span class="string">"/home/xiejunyu/"</span>+</div><div class="line">             <span class="string">"桌面/text.txt"</span>);   </div><div class="line"><span class="comment">// 第2步：通过子类实例化父类对象     </span></div><div class="line">         OutputStream out = <span class="keyword">new</span> FileOutputStream(f); </div><div class="line"><span class="comment">// 通过对象多态性进行实例化    </span></div><div class="line"><span class="comment">// 第3步：进行写操作    </span></div><div class="line">     String str = <span class="string">"Hello World!"</span>;      </div><div class="line"><span class="comment">// 准备一个字符串    </span></div><div class="line">     <span class="keyword">byte</span> b[] = str.getBytes();          </div><div class="line"><span class="comment">// 字符串转byte数组    </span></div><div class="line">     out.write(b);                      </div><div class="line"><span class="comment">// 将内容输出    </span></div><div class="line"> <span class="comment">// 第4步：关闭输出流    </span></div><div class="line">    <span class="comment">// out.close();                  </span></div><div class="line"><span class="comment">// 此时没有关闭    </span></div><div class="line">        &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/1.png" alt="fail"><br>此时没有关闭字节流操作，但是文件中也依然存在了输出的内容，证明字节流是直接操作文件本身的。  </p><p>使用字符流不关闭执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileWriter;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.Writer;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOPractice</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"> <span class="comment">// 第1步：使用File类找到一个文件    </span></div><div class="line">        File f = <span class="keyword">new</span> File(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">        <span class="comment">// 第2步：通过子类实例化父类对象            </span></div><div class="line">        Writer  out = <span class="keyword">new</span> FileWriter(f);            </div><div class="line">        <span class="comment">// 第3步：进行写操作    </span></div><div class="line">        String str = <span class="string">"Hello World!"</span>;      </div><div class="line">        <span class="comment">// 准备一个字符串    </span></div><div class="line">        out.write(str);                    </div><div class="line">        <span class="comment">// 将内容输出    </span></div><div class="line">        <span class="comment">// 第4步：关闭输出流    </span></div><div class="line">        <span class="comment">// out.close();</span></div><div class="line">        <span class="comment">// 此时没有关闭    </span></div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/2.png" alt="fail"></p><p>程序运行后会发现文件中没有任何内容，这是因为字符流操作时使用了缓冲区，而在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果程序没有关闭字符流，缓冲区中的内容是无法输出的，所以得出结论：<strong>字符流使用了缓冲区，而字节流没有使用缓冲区。</strong>如果想让缓冲区中的内容输出，要么关闭流强制刷新缓冲区，要么调用flush方法冲刷缓冲区。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源(如文件或数据库)，则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。<br>在字符流的操作中，所有的字符都是在内存中形成的，在输出前会将所有的内容暂时保存在内存之中，所以使用了缓冲区暂存数据。  </p><p><strong>建议：</strong><br>1.虽然不关闭字节流不影响数据的输出，且后续JVM会自动回收这部分内存，但还是建议在使用完任何流对象之后关闭流。<br>2.使用流对象都要声明或抛出IOException<br>3.在创建一个文件时，如果目录下有同名文件将被覆盖<br>4.在写文件时，如果文件不存在，会在创建输出流对象并绑定文件时自动创建文件，不必使用File的exists方法提前检测<br>4.在读取文件时，必须使用File的exists方法提前检测来保证该文件已存在，否则抛出FileNotFoundException</p><h4 id="2-按流向分：输入流和输出流"><a href="#2-按流向分：输入流和输出流" class="headerlink" title="2.按流向分：输入流和输出流"></a>2.按流向分：输入流和输出流</h4><p>输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络等)，即是将数据源读入到程序的通信通道。输入流主要包括两个抽象基类：InputStream(字节输入流)和Reader(字符输入流)及其扩展的具体子类。<br>输出流：程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道。输出流主要包括两个抽象基类：OutputStream(字节输出流)和Writer(字符输出流)及其扩展的具体子类。 </p><h4 id="3-按功能分：节点流和处理流"><a href="#3-按功能分：节点流和处理流" class="headerlink" title="3.按功能分：节点流和处理流"></a>3.按功能分：节点流和处理流</h4><p>按照流是否<strong>直接</strong>与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两类。<br>节点流：程序用于直接操作目标设备所对应的类叫节点流。(低级流)<br>处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据，这个间接流类就是处理流。处理流可以看成是对已存在的流进行连接和封装的流。(高级流)  </p><p><strong>注意：在使用到处理流对流进行连接和封装时，读写完毕要关闭所有出现的流，包括节点流和处理流。</strong>  </p><h5 id="1-节点流"><a href="#1-节点流" class="headerlink" title="(1) 节点流"></a>(1) 节点流</h5><p><img src="/2017/11/28/Java学习总结之Java-IO系统/节点流.png" alt="fail">  </p><ul><li>File 文件流。对文件进行读、写操作：FileReader、FileWriter、FileInputStream、FileOutputStream。  </li><li>Memory 流。<br>向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。<br>向内存字符串读写数据：StringReader、StringWriter、StringBufferInputStream。  </li><li>Pipe管道流：实现管道的输入和输出(进程间通信)： PipedReader与PipedWriter、PipedInputStream与PipedOutputStream。    </li></ul><p><img src="/2017/11/28/Java学习总结之Java-IO系统/节点流示意图.png" alt="fail">  </p><h5 id="1-处理流"><a href="#1-处理流" class="headerlink" title="(1) 处理流"></a>(1) 处理流</h5><p><img src="/2017/11/28/Java学习总结之Java-IO系统/处理流.png" alt="fail">  </p><ul><li>Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。   </li><li>Filtering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。  </li><li>Converting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换(Stream到Reader)：InputStreamReader、OutputStreamWriter。   </li><li>Object Serialization 对象流 ：ObjectInputStream、ObjectOutputStream。   </li><li>DataConversion数据流：按基本数据类型读、写(处理的数据是Java的基本类型)：DataInputStream、DataOutputStream 。 </li><li>Counting计数流：在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。 </li><li>Peeking Ahead预读流： 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream。   </li><li>Printing打印流： 包含方便的打印方法 ：PrintWriter、PrintStream。  </li></ul><p><img src="/2017/11/28/Java学习总结之Java-IO系统/处理流示意图.png" alt="fail">  </p><h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>在Java中，从控制台输入有三种方法：  </p><h4 id="1-使用标准输入流对象System-in"><a href="#1-使用标准输入流对象System-in" class="headerlink" title="1.使用标准输入流对象System.in"></a>1.使用标准输入流对象System.in</h4><p>System.in是System中内置的InputStream类对象，它的read方法一次只读入<strong>一个字节</strong>数据，返回0 ~ 255的一个byte值,一般用来读取一个字符，需要强制类型转换为char类型，而我们通常要取得一个字符串或一组数字，故这种方法不常用。下面给出这种方法的一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharTest</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> <span class="keyword">try</span>&#123;   </div><div class="line"> System.out.print(<span class="string">"Enter a Char:"</span>);   </div><div class="line"> <span class="keyword">char</span> i = (<span class="keyword">char</span>)System.in.read();   </div><div class="line"> System.out.println(<span class="string">"Yout Enter Char is:"</span> + i);    &#125;   </div><div class="line"> <span class="keyword">catch</span>(IOException e)&#123;   </div><div class="line">    e.printStackTrace();   </div><div class="line"> &#125;   </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>使用这种方法必须提供try-catch块或者在main方法首部声明IOException异常，因为System.in是一个流对象</strong>  </p><h4 id="2-使用Scanner类"><a href="#2-使用Scanner类" class="headerlink" title="2.使用Scanner类"></a>2.使用Scanner类</h4><p>Scanner类功能十分强大，可以读入字符串、整数、浮点数、布尔类型值等等。下面是例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);   </div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Name:"</span>);   </div><div class="line">    String name = sc.nextLine();  <span class="comment">//读取字符串型输入   </span></div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Age:"</span>);   </div><div class="line">    <span class="keyword">int</span> age = sc.nextInt();    <span class="comment">//读取整型输入   </span></div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Salary:"</span>);   </div><div class="line">    <span class="keyword">float</span> salary = sc.nextFloat(); <span class="comment">//读取float型输入   </span></div><div class="line">    System.out.println(<span class="string">"Your Information is as below:"</span>);   </div><div class="line">    System.out.println(<span class="string">"Name:"</span> + name +<span class="string">"\n"</span> + <span class="string">"Age:"</span>+age </div><div class="line">    + <span class="string">"\n"</span>+<span class="string">"Salary:"</span>+salary);   </div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1.用nextXXX()读入XXX类型的数据，XXX可以是除了char外的所有基本数据类型，还可以是BigInteger或BigDecimal，其中凡是整型类型的数据还可以指定radix(进制)，可以用next()和nextLine()读取一个字符串或一行字符<br>2.next()和nextLine()的区别：<br>next()</p><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>next() 不能得到带有空格的字符串，除非用useDelimeter方法修改分隔符。  </li></ul><p>nextLine()</p><ul><li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul><p>3.可以用循环配合hasNextXXX方法判断输入是否继续<br>4.Scanner类没有直接提供读取一个字符的方法，如果要读取一个字符，有三种方法，一是<strong>读入一个字符串后取字符串的第一个字符</strong>，二是使用<strong>System.in的read方法</strong>，三是使用<strong>字符流</strong>读入</p><p>更多Scanner的用法之前已经在<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>中总结过了，不再赘述。</p><h4 id="3-使用BufferedReader对象"><a href="#3-使用BufferedReader对象" class="headerlink" title="3.使用BufferedReader对象"></a>3.使用BufferedReader对象</h4><p>可以把 System.in 包装在一个 BufferedReader 对象中来创建一个<strong>字符流</strong>。<br>下面是创建 BufferedReader 的基本语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </div><div class="line">                      InputStreamReader(System.in));</div></pre></td></tr></table></figure></p><p>其中，System.in是一个InputStream对象(字节流)，使用InputStreamReader作为桥梁，将字节流转换为字符流，然后再使用BufferedReader进行进一步包装。<br>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符(读入一个用0~65535之间的整数表示的字符，需要强制类型转换为char类型，如果已到达流末尾，则返回 -1)，或者用 readLine() 方法读取一个字符串。下面是例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"><span class="comment">//必须要处理java.io.IOException异常</span></div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader</div><div class="line">  (System.in ));</div><div class="line">  <span class="comment">//java.io.InputStreamReader继承了Reader类</span></div><div class="line">  String read = <span class="keyword">null</span>;</div><div class="line">  System.out.print(<span class="string">"输入数据："</span>);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">   read = br.readLine();</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">   e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">  System.out.println(<span class="string">"输入数据："</span>+read);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRRead</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="comment">// 使用 System.in 创建 BufferedReader </span></div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </div><div class="line">                       InputStreamReader(System.in));</div><div class="line">    System.out.println(<span class="string">"输入字符, 按下 'q' 键退出。"</span>);</div><div class="line">    <span class="comment">// 读取字符</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       c = (<span class="keyword">char</span>) br.read();</div><div class="line">       System.out.println(c);</div><div class="line">    &#125; <span class="keyword">while</span>(c != <span class="string">'q'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面的程序读取和显示字符行直到你输入了单词”end”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符</span></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRReadLines</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="comment">// 使用 System.in 创建 BufferedReader </span></div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></div><div class="line">                            InputStreamReader(System.in));</div><div class="line">    String str;</div><div class="line">    System.out.println(<span class="string">"Enter lines of text."</span>);</div><div class="line">    System.out.println(<span class="string">"Enter 'end' to quit."</span>);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       str = br.readLine();</div><div class="line">       System.out.println(str);</div><div class="line">    &#125; <span class="keyword">while</span>(!str.equals(<span class="string">"end"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>在ACM等算法竞赛中，我们常常也会使用Java，在输入数据时有以下几点注意：</strong><br>1.hasXXX等价于C++中读到文件末尾(EOF)<br>2.使用BufferedReader输入会比Scanner输入快十倍左右!</p><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>控制台的输出由 print() 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类的一个对象。<br>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。<br>PrintStream 定义 write() 的最简单格式如下所示：<br><code>void write(int byteval)</code>该方法将 byteval 的低八位字节写到流中,即System.out的write方法一次只能写一个字节(类比System.in的read方法一次只能读取一个字节)。<br>下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="comment">// 演示 System.out.write().</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> b; </div><div class="line">      b = <span class="string">'A'</span>;<span class="comment">//向上类型转换</span></div><div class="line">      System.out.write(b);</div><div class="line">      System.out.write(<span class="string">'\n'</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。</strong></p><h3 id="字节流-OutputStream、InputStream"><a href="#字节流-OutputStream、InputStream" class="headerlink" title="字节流(OutputStream、InputStream)"></a>字节流(OutputStream、InputStream)</h3><p>字节流主要是操作byte类型的数据，以byte数组为准，主要操作类是OutputStream、InputStream。<br>由于文件读写最为常见，我们先讨论两个重要的字节流 FileInputStream(文件输入流) 和 FileOutputStream(文件输出流)，分别是抽象类InputStream和OutputStream的具体子类：</p><p><strong>FileInputStream</strong><br>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>有多种构造方法可用来创建对象。<br>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/java/hello"</span>);</div></pre></td></tr></table></figure></p><p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(f);</div></pre></td></tr></table></figure></p><p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/InputStream.png" alt="fail" title="InputStream"><br>下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">InputStream f  = <span class="keyword">new</span> FileInputStream</div><div class="line">(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>((c =  f.read()) != -<span class="number">1</span>) </div><div class="line">    <span class="comment">//这里也可以先用available方法得到可读的字节数</span></div><div class="line">System.out.println((<span class="keyword">char</span>)c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们需要创建一个byte[]来保存读取的字节时，如果数组太小，无法完整读入数据，如果太大又会造成内存浪费。<strong>可以使用File类的length方法得到文件的数据字节数，从而有效确定byte数组的大小。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 创建一个FileInputStream对象</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</div><div class="line">fis.read(b,<span class="number">0</span>,<span class="number">5</span>); </div><div class="line">            <span class="comment">/*把字节从文件读入b数组，从b数组的0位置开始存放，</span></div><div class="line"><span class="comment">            读取5个字节*/</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(b));</div><div class="line">fis.close();</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意:</strong> 每调用一次read方法,当前读取在文件中的位置就会向后移动一个字节或者移动byte[]的长度(read的两个重载方法)，已经到文件末尾会返回-1，可以通过read方法返回-1判断是否读到文件末尾，也可以使用available方法返回下一次可以不受阻塞读取的字节数来读取。<strong>FileInputStream不支持mark和reset方法进行重复读取。BufferedInputStream支持此操作。</strong>  </p><p><strong>FileOutputStream</strong><br>该类用来创建一个文件并向文件中写数据。<br><strong>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</strong><br>有两个构造方法可以用来创建 FileOutputStream 对象。<br>使用字符串类型的文件名来创建一个输出流对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/java/hello"</span>)</div></pre></td></tr></table></figure></p><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</div></pre></td></tr></table></figure></p><p>之前的所有操作中，如果重新执行程序，则肯定会覆盖文件中的已有内容，那么此时就可以通过FileOutputStream向文件中追加内容，FileOutputStream的另外一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file,<span class="keyword">boolean</span> append)</span></span></div></pre></td></tr></table></figure></p><p>在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。程序代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f,<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileOutputStream.png" alt="fail" title="FileOutputStream"><br>当有一个字符串时，可以用getBytes方法转为byte数组用于字节流的输出。  </p><p>下面是一个演示 InputStream 和 OutputStream 用法的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      <span class="keyword">byte</span> bWrite[] = <span class="string">"ABC"</span>.getBytes();</div><div class="line">      OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x &lt; bWrite.length ; x++)&#123;</div><div class="line">      os.write(bWrite[x] ); <span class="comment">// writes the bytes</span></div><div class="line">    &#125;</div><div class="line">    os.close();</div><div class="line"> </div><div class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">    <span class="keyword">int</span> size = is.available();</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; size; i++)&#123;</div><div class="line">      System.out.print((<span class="keyword">char</span>)is.read() + <span class="string">"  "</span>);</div><div class="line">    &#125;</div><div class="line">      is.close();</div><div class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">      System.out.print(<span class="string">"Exception"</span>);</div><div class="line">    &#125;  </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。<br>以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileStreamTest2</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    </div><div class="line">    File f = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</div><div class="line">    FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(f);</div><div class="line">    <span class="comment">// 构建FileOutputStream对象,文件不存在会自动新建;如果存在会覆盖原文件</span></div><div class="line">    </div><div class="line">    OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fop, <span class="string">"UTF-8"</span>);</div><div class="line">    <span class="comment">// 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"中文输入"</span>);</div><div class="line">    <span class="comment">// 写入到缓冲区</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"\r\n"</span>);</div><div class="line">    <span class="comment">//换行</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"English"</span>);</div><div class="line">    <span class="comment">// 刷新缓冲区,写入到文件,如果下面已经没有写入的内容了,直接close也会写入</span></div><div class="line">    </div><div class="line">    writer.close();</div><div class="line">    <span class="comment">//关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉</span></div><div class="line">    </div><div class="line">    fop.close();</div><div class="line">    <span class="comment">// 关闭输出流,释放系统资源</span></div><div class="line"> </div><div class="line">    FileInputStream fip = <span class="keyword">new</span> FileInputStream(f);</div><div class="line">    <span class="comment">// 构建FileInputStream对象</span></div><div class="line">    </div><div class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fip, <span class="string">"UTF-8"</span>);</div><div class="line">    <span class="comment">// 构建InputStreamReader对象,编码与写入相同</span></div><div class="line"> </div><div class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">    <span class="keyword">while</span> (reader.ready()) &#123;</div><div class="line">      sb.append((<span class="keyword">char</span>) reader.read());</div><div class="line">      <span class="comment">// 转成char加到StringBuffer对象中</span></div><div class="line">    &#125;</div><div class="line">    System.out.println(sb.toString());</div><div class="line">    reader.close();</div><div class="line">    <span class="comment">// 关闭读取流</span></div><div class="line">    </div><div class="line">    fip.close();</div><div class="line">    <span class="comment">// 关闭输入流,释放系统资源</span></div><div class="line"> </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上例子证明：在对多国语言的支持上，字符流表现更优，此时应使用字符流而不是字节流。  </p><p>还可以用InputStream和OutputStream配合进行文件的复制，即读取原件数据，写入副本文件。<br>复制有两种实现方式：<br>实现一：将源文件中的内容全部读取进来，之后一次性的写入到目标文件<br>实现二：边读边写  </p><p>在实际开发中建议使用边读边写的方式，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 文件拷贝</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">FileInputStream fis=<span class="keyword">new</span> FileInputStream(<span class="string">"happy.gif"</span>);</div><div class="line">FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"happycopy.gif"</span>);</div><div class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">while</span>((n=fis.read(b))!=-<span class="number">1</span>)&#123; </div><div class="line">            <span class="comment">/*循环读取，每次1024个字节，最后一次可能不满1024。</span></div><div class="line"><span class="comment">            后面的字节覆盖前面的字节，不必担心数组溢出。*/</span></div><div class="line">fos.write(b,<span class="number">0</span>,n); <span class="comment">//n是实际读取到的字节数，如果写fos.write(b)，会造成最后一次数组未满的情况也写1024个字节，从而造成副本比原件略大</span></div><div class="line">&#125;</div><div class="line">fis.close();</div><div class="line">fos.close();</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实际上边读边写也分为三种方式：<br>1.批量拷贝(循环读取，每次读入一个byte数组)<br>2.缓冲拷贝(使用缓冲流)<br>3.批量+缓冲拷贝(循环批量读取到字节数组中，然后使用缓冲输出流写入到文件)  </p><p><strong>第三种方式是最快的。</strong>  </p><p><strong>注意：</strong>InputStream的int read()方法读取一个字节，并用这个字节填充整型的低八位并返回，OutputStream的void write(int x)写入x的低八位，如果要写入一个int，需要移位并写4次。读写基本数据类型建议使用DataInputStream和DataOutputStream。</p><h3 id="字符流-Writer、Reader"><a href="#字符流-Writer、Reader" class="headerlink" title="字符流(Writer、Reader)"></a>字符流(Writer、Reader)</h3><p>Java提供了两个操作字符的字符流基类，分别是Writer和Reader。先来了解两个用于读写文件的字符流FileReader(字符输入流)和FileWriter(字符输出流)：  </p><p><strong>FileReader</strong><br>FileReader类从InputStreamReader类继承而来。该类按字符读取流中数据。可以通过以下几种构造方法创建需要的对象。<br>在给定从中读取数据的 File 的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(File file)</div></pre></td></tr></table></figure></p><p>在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(FileDescriptor fd)</div></pre></td></tr></table></figure></p><p>在给定从中读取数据的文件名的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(String fileName)</div></pre></td></tr></table></figure></p><p>创建FIleReader对象成功后，可以参照以下列表里的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileReader.png" alt="fail" title="FileReader">  </p><p><strong>FileWriter</strong><br>FileWriter 类从 OutputStreamWriter 类继承而来。该类按字符向流中写入数据。可以通过以下几种构造方法创建需要的对象。<br>在给出 File 对象的情况下构造一个 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(File file)</div></pre></td></tr></table></figure></p><p>在给出 File 对象的情况下构造一个 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(File file, <span class="keyword">boolean</span> append)</div></pre></td></tr></table></figure></p><p>构造与某个文件描述符相关联的 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(FileDescriptor fd)</div></pre></td></tr></table></figure></p><p>在给出文件名的情况下构造 FileWriter 对象，它具有指示是否挂起写入数据的 boolean 值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(String fileName, <span class="keyword">boolean</span> append)</div></pre></td></tr></table></figure></p><p>创建FileWriter对象成功后，可以参照以下列表里的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileWriter.png" alt="fail" title="FileWriter"><br><strong>字符流的操作比字节流操作方便一点，就是可以直接输出字符串。不在用再像之前那样进行字节转换操作了。使用字符流默认情况下依然是覆盖已有的文件，如果想追加的话，则直接在FileWriter上增加一个可追加的标记即可。</strong></p><p>下面的例子演示了FileReader和FileWriter的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">      File file = <span class="keyword">new</span> File(<span class="string">"Hello1.txt"</span>);</div><div class="line">      <span class="comment">// 创建文件</span></div><div class="line">      file.createNewFile();</div><div class="line">      <span class="comment">// creates a FileWriter Object</span></div><div class="line">      FileWriter writer = <span class="keyword">new</span> FileWriter(file); </div><div class="line">      <span class="comment">// 向文件写入内容</span></div><div class="line">      writer.write(<span class="string">"This\n is\n an\n example\n"</span>); </div><div class="line">      writer.flush();</div><div class="line">      writer.close();</div><div class="line">      <span class="comment">//创建 FileReader 对象</span></div><div class="line">      FileReader fr = <span class="keyword">new</span> FileReader(file); </div><div class="line">      <span class="keyword">char</span> [] a = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</div><div class="line">      fr.read(a); <span class="comment">// 从数组中读取内容</span></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">char</span> c : a)</div><div class="line">          System.out.print(c); <span class="comment">// 一个个打印字符</span></div><div class="line">      fr.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="字节-字符转换流-OutputStreamWriter、InputStreamReader"><a href="#字节-字符转换流-OutputStreamWriter、InputStreamReader" class="headerlink" title="字节-字符转换流(OutputStreamWriter、InputStreamReader)"></a>字节-字符转换流(OutputStreamWriter、InputStreamReader)</h3><p>在整个IO包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流-字符流的转换类。  </p><p><strong>InputStreamReader</strong><br>InputStreamReader是<strong>字节流</strong>通向<strong>字符流</strong>的桥梁，它使用指定的charset读取字节并将其解码为字符。它拥有一个InputStream类型的变量，并继承了Reader，使用了对象的适配器模式，如图所示：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/InputStreamReader.jpg" alt="fail"><br>根据InputStream的实例创建InputStreamReader的方法有4种：<br>1.根据默认字符集创建<br>InputStreamReader(InputStream in)<br>2.使用给定字符集创建<br>InputStreamReader(InputStream in, Charset cs)<br>3.使用给定字符集解码器创建<br>InputStreamReader(InputStream in, CharsetDecoder dec)<br>4.使用指定字符集名字符串创建<br>InputStreamReader(InputStream in, String charsetName)</p><p>后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。<br><strong>注意：</strong>在对文件进行读写操作时，默认使用的是项目的编码，如果要读写其他编码方式的文件，要在构造输入输出流时指定对应的编码。这一般通过字节-字符转换流完成。   </p><p>每次调用InputStreamReader中的一个read()方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。共有3个可用的read()方法：  </p><p>int read(); //读取单个字符<br>int read(char[] cbuf, int offset, int length);<br>//将字符读入数组中的某一部分<br>boolean ready(); //判断此流是否已经准备好用于读取 </p><p>使用字符流的形式读取字节流的文件，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + </div><div class="line">        <span class="string">"test.txt"</span>) ;</div><div class="line">Reader reader = <span class="keyword">new</span> InputStreamReader</div><div class="line">        (<span class="keyword">new</span> FileInputStream(f)) ;</div><div class="line">        <span class="comment">// 将字节流变为字符流</span></div><div class="line"><span class="keyword">char</span> c[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>] ;</div><div class="line"><span class="keyword">int</span> len = reader.read(c) ;<span class="comment">// 读取</span></div><div class="line">reader.close() ;<span class="comment">// 关闭</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(c,<span class="number">0</span>,len)) ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>OutputStreamWriter</strong><br>OutputStreamWriter是<strong>字符流</strong>通向<strong>字节流</strong>的桥梁，可使用指定的charset将要写入流中的字符编码成字节。因此，它拥有一个OutputStream类型的变量，并继承了Writer，使用对象的适配器模式,如图所示：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/OutputStreamWriter.jpg" alt="fail" title="OutputStreamWriter"><br>根据OutputStream的实例创建OutputStreamWriter的方法有4种：  </p><p>1.根据默认字符集创建<br>OutputStreamReader(OutputStream out)  </p><p>2.使用给定字符集创建<br>OutputStreamReader(OutputStream out, Charset cs)       </p><p>3.使用给定字符集解码器创建<br>OutputStreamReader(OutputStream out, CharsetDecoder dec)  </p><p>4.使用指定字符集名字符串创建<br>OutputStreamReader(OutputStream out, Stroutg charsetName)        </p><p>后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。  </p><p>每次调用write()方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给write()方法的字符没有缓冲。共有3个可用的write()方法：<br>void write(char[] cbuf, int off, int len); //写入字符数组的某一部分<br>void write(int c); //写入单个字符<br>void write(String str, int off, int len); //写入字符串的某一部分 </p><p>例如：将字节的文件输出流，以字符的形式输出。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</div><div class="line">Writer out = <span class="keyword">new</span> OutputStreamWriter</div><div class="line">        (<span class="keyword">new</span> FileOutputStream(f)) ;<span class="comment">// 字节流变为字符流</span></div><div class="line">    out.write(<span class="string">"hello world!!"</span>) ;</div><div class="line">           <span class="comment">// 使用字符流输出</span></div><div class="line">out.close() ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>特别说明：</strong>OutputStreamWriter是字符流到字节流的桥梁，这不表示OutputStreamWriter接收一个字符流并将其转换为字节流，恰恰相反，其接收的OutputStream是一个字节流，而它本身是一个字符流。<strong>那为什么说它是字符流到字节流的桥梁呢？</strong><br>我们以文件操作为例，之前已经提到，在内存中数据是以字符形式存在的，而在文件中数据是以字节形式保存的。所以在<strong>内存</strong>中的<strong>字符数据</strong>需要通过OutputStreamWriter变为<strong>字节流</strong>才能保存在文件之中，读取的时候需要将读入的<strong>字节流</strong>通过InputStreamReader变为<strong>字符流</strong>。<br>但OutputStreamWriter和InputStreamReader都是字符流，也就是说，OutputStreamWriter以字符输出流形式操作了字节的输出流，但实际上还是以字节的形式输出。而InputStreamReader，虽然以字符输入流的形式操作，但实际上还是使用的字节流输入，也就是说，传输或者是从文件中读取数据的时候，文件中真正保存的数据永远是字节。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/change.png" alt="fail">  </p><p>输入流和输出流要指定相同的字符集才能避免乱码！</p><p><strong>FileWriter和FileReader的说明</strong><br>从JDK文档中可以知道FileOutputStream是OutputStream的直接子类，FileInputStream也是InputStream的直接子类，但是在字符流文件的两个操作类却有一些特殊，FileWriter并不直接是Writer的子类，而是转换流OutputStreamWriter的子类，而FileReader也不直接是Reader的子类，而是转换流InputStreamReader的子类，那么从这两个类的继承关系就可以清楚的发现，不管是是使用字节流还是字符流实际上最终都是以字节形式操作输出流的。</p><h3 id="缓冲流-BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream"><a href="#缓冲流-BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream" class="headerlink" title="缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)"></a>缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)</h3><p>缓冲流是一系列处理流(包装流)，目的是为了提高I/O效率，它们为I/O提供了内存缓冲区，这是一种常见的性能优化，增加缓冲区的两个目的：<br>(1)允许Java的I/O一次不只操作一个字符，这样提高了整个系统的性能<br>(2)由于有缓冲区，使得在流上执行skip、mark和reset方法都成为可能。<br>如果没有缓冲区，每次调用 read() 或 write()方法都会对文件进行读或写字节，在文件和内存之间发生字节和字符的转换，这是极其低效的。  </p><p><strong>BufferedReader</strong><br>BufferedReader是一个包装类，是为了提高读效率提供的，其可以接收一个Reader,然后用readLine()逐行读入字符流，直到遇到换行符为止（相当于反复调用Reader类对象的read()方法读入多个字符）。<br><strong>因此，建议用 BufferedReader 包装所有其 read() 操作可能开销很高的 Reader（如 FileReader 和 InputStreamReader),如：</strong>   </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/Buffer.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedReader1.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedReader2.png" alt="fail"> </p><p> markSupported 判断该输入流能支持 mark 和 reset 方法。mark 用于标记当前位置，readlimit 制定可以重新读取的最大字节数，如果标记后读取的字节数不超过 readlimit 可以用 reset 回到标志位置重复读取。</p><p><strong>BufferedWriter</strong><br>同理建议用BfferedWriter包装所有其write()操作可能开销很高的Writer(如FileWriter和OutputStreamWriter)<br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedWriter.png" alt="fail" title="BufferedWriter">    </p><p><strong>BufferedInputStream</strong><br>BufferedInputStream用于包装其他较为缓慢的InputStream<br>构造方法摘要  </p><ul><li>BufferedInputStream(InputStream in)<br>创建一个使用默认大小输入缓冲区的缓冲字节输入流</li><li>BufferedInputStream(InputStream in, int size)<br>创建一个使用指定大小输入缓冲区的缓冲字节输入流  </li></ul><p>方法摘要  </p><ul><li>public int read();<br>从该输入流中读取一个字节</li><li>public int read(byte[] b,int off,int len);<br>从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。  </li></ul><p><strong>BufferedOutputStream</strong><br>BufferedOutputStream用于包装其他较为缓慢的OutputStream<br>构造方法摘要  </p><ul><li>BufferedOutputStream(OutputStream out);<br>创建一个使用默认大小输入缓冲区的缓冲字节输出流</li><li>BufferedOutputStream(OutputStream out,int size);<br>创建一个使用默认大小输入缓冲区的缓冲字节输出流  </li></ul><p>方法摘要  </p><ul><li>public void write(int b);<br>向输出流中输出一个字节  </li><li>public void write(byte[] b,int off,int len);<br>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。  </li><li>public void flush();<br>刷新此缓冲的输出流。这迫使所有缓冲的输出字节被写出到底层输出流中。  </li></ul><p><strong>其他</strong><br>（1）缓冲输入流BufferedInputSTream除了支持read和skip方法意外，还支持其父类的mark和reset方法;<br>（2）BufferedReader提供了一种新的ReadLine方法用于读取一行字符串（以\r或\n分隔）;<br>（3）BufferedWriter提供了一种新的newLine方法用于写入一个行分隔符;<br>（4）<strong>对于输出的缓冲流，BufferedWriter和BufferedOutputStream，写出的数据会先在缓冲区(由缓冲流提供的一个字节数组，是不可见的)中缓存，直到缓冲区满了会自动写数据到输出流，如果缓冲区未满，可以使用flush方法将会使缓冲区的数据强制写出。关闭输出流也会造成缓冲区中残留的数据被写出。注意BufferedReader和BufferedInputStream没有flush方法，因为flush只用于输出到文件时。</strong>  </p><h3 id="打印流-PrintStream、PrintWriter"><a href="#打印流-PrintStream、PrintWriter" class="headerlink" title="打印流(PrintStream、PrintWriter)"></a>打印流(PrintStream、PrintWriter)</h3><p>在整个IO包中，打印流是<strong>输出信息最方便</strong>的类，主要包含字节打印流(PrintStream)和字符打印流(PrintWriter)。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等。<br>相较OutputStream在输出时的各种麻烦(比如要将String转为byte[]才能输出)打印流中可以方便地进行输出。  </p><p><strong>PrintStream</strong><br>1、public PrintStream(File file) throws FileNotFoundException<br>//构造方法 通过一个File对象实例化PrintStream类  </p><p>2、public PrintStream(OutputStream out)<br>//构造方法 接收OutputStream对象，实例化PrintStream类  </p><p>3、public PrintStream printf(Locale l, String format, Object …arg)<br>//普通方法 根据指定的Locale进行格式化输出</p><p>4、public PrintStream printf(String format,Object … arg)<br>//普通方法 根据本地环境进行格式化输出</p><p>5、public void print(boolean b)<br>//普通方法 此方法被重载很多次，输出任意数据</p><p>6、public void println(boolean b)<br>//普通方法 此方法被重载很多次，输出任意数据后换行  </p><p><strong>打印流的好处：</strong>在PrintStream中定义的构造方法中可以清楚的发现有一个构造方法可以直接接收OutputStream类的实例，这是因为与OutputStream相比起来，PrintStream可以更加方便的输出数据，这就好比将OutputStream重新包装了一下，使之输出更加方便。  </p><p><strong>PrintWriter</strong><br><strong>构造方法</strong>  </p><p>//使用指定文件创建不具有自动行刷新的新 PrintWriter<br>public PrintWriter(File file);</p><p>//创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter<br>public PrintWriter(File file,String csn);</p><p>//根据现有的 OutputStream 创建不带自动行刷新的新PrintWriter<br>public PrintWriter(OutputStream out);</p><p>//通过现有的 OutputStream 创建新的 PrintWriter(具有自动行刷新)<br>public PrintWriter(OutputStream out,boolean autoFlush);</p><p>//创建具有指定文件名称且不带自动行刷新的新PrintWriter<br>public PrintWriter(String fileName);</p><p>//创建具有指定文件名称和字符集且不带自动行刷新的PrintWriter<br>public PrintWriter(String fileName,String csn);</p><p>//创建新 PrintWriter(具有自动行刷新)<br>public PrintWriter(Writer out,boolean autoFlush)   </p><p><strong>常用方法</strong><br>//打印boolean值<br>public void print(boolean b)<br>//打印 boolean 值，然后终止该行<br>public void println(boolean x)</p><p>//打印字符<br>public void print(char c)<br>//打印字符，然后终止该行<br>public void println(char x)</p><p>//打印字符数组<br>public void print(char[] s)<br>//打印字符数组，然后终止该行<br>public void println(char[] x)</p><p>//打印 double 精度浮点数<br>public void print(double d)<br>//打印 double 精度浮点数,然后终止该行<br>public void println(double x)</p><p>//打印一个浮点数<br>public void print(float f)<br>//打印浮点数，然后终止该行<br>public void println(float x)  </p><p>//打印整数<br>public void print(int i)<br>//打印整数，然后终止该行<br>public void println(int x)</p><p>//打印 long 整数<br>public void print(long l)<br>//打印 long 整数，然后终止该行<br>public void println(long x)</p><p>//打印对象<br>public void print(Object obj)<br>//打印 Object，然后终止该行<br>public void println(Object x)  </p><p>//打印字符串。如果参数为 null，则打印字符串 “null”<br>public void print(String s)<br>//打印 String，然后终止该行<br>public void println(String x)</p><p>//通过写入行分隔符字符串终止当前行<br>public void println()</p><p>//使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区<br>public PrintWriter format(Locale l,String format,Object… args)  </p><p>//使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区<br>public PrintWriter format(String format,Object… args)  </p><p>//将指定字符添加到此 writer<br>public PrintWriter append(char c)<br>//将指定的字符序列添加到此 writer<br>public PrintWriter append(CharSequence csq)<br>//将指定字符序列的子序列添加到此 writer<br>public PrintWriter append(CharSequence csq,int start,int end)</p><p>//写入字符数组<br>public void write(char[] buf)<br>//写入字符数组的某一部分<br>public void write(char[] buf,int off,int len)<br>//写入单个字符<br>public void write(int c)<br>//写入字符串<br>public void write(String s)<br>//写入字符串的某一部分<br>public void write(String s,int off,int len)</p><p><strong>提示：</strong>由于BufferedWriter没有PrintWriter使用灵活，所以在实际的操作中，我们往往会使用<strong>PrinterWriter/BufferedReader</strong>这种组合。  </p><h3 id="内存操作流"><a href="#内存操作流" class="headerlink" title="内存操作流"></a>内存操作流</h3><p>之前的程序中，输出输入都是在内存和文件之间进行的，当然，输入输出也可以不访问文件，只在内存中进行。也就是把数据的输入源和输出目的地从文件改成了byte数组、char数组或字符串。  </p><h4 id="字节数组流-ByteArrayInputStream、ByteArrayOutputStream"><a href="#字节数组流-ByteArrayInputStream、ByteArrayOutputStream" class="headerlink" title="字节数组流(ByteArrayInputStream、ByteArrayOutputStream)"></a>字节数组流(ByteArrayInputStream、ByteArrayOutputStream)</h4><p>ByteArrayInputStream的主要功能是完成将byte数组的内容写入到内存之中，而ByteArrayOutputStream的主要功能是将内存中的数据输出到byte数组。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/test.png" alt="fail">  </p><p><strong>ByteArrayInputStream</strong><br>字节数组输入流从内存中的一个字节数组读取字节到内存，这个字节数组就是数据的输入源。创建字节数组输入流对象有以下几种方式。<br>接收字节数组作为参数创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayInputStream bArray = </div><div class="line"><span class="keyword">new</span> ByteArrayInputStream(<span class="keyword">byte</span> [] b);</div></pre></td></tr></table></figure></p><p>另一种创建方式是接收一个字节数组，和两个整型变量 off、len，off表示第一个读取的字节，len表示读取字节的长度,<strong>即将字节数组中从off开始的len个字节读入该输入流</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayInputStream bArray = <span class="keyword">new</span></div><div class="line">ByteArrayInputStream(<span class="keyword">byte</span> []b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</div></pre></td></tr></table></figure></p><p>成功创建字节数组输入流对象后，可以参见以下列表中的方法，对流进行读操作或其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/ByteArrayInputStream.png" alt="fail" title="ByteArrayInputStream">  </p><p><strong>ByteArrayOutputStream</strong><br>字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中，可以用toByteArray()得到该字节数组，也可以用toString()得到缓冲区内容转换得到的字符串。创建字节数组输出流对象有以下几种方式。<br>下面的构造方法创建一个32字节（默认大小）的缓冲区。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream();</div></pre></td></tr></table></figure></p><p>另一个构造方法创建一个大小为n字节的缓冲区。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream(<span class="keyword">int</span> n)</div></pre></td></tr></table></figure></p><p>成功创建字节数组输出流对象后，可以参见以下列表中的方法，对流进行写操作或其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/ByteArrayOutputStream.png" alt="fail" title="ByteArrayOutputStream"><br>下面的例子演示了ByteArrayInputStream 和 ByteArrayOutputStream的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"HELLOWORLD"</span> ;<span class="comment">// 定义一个字符串，全部由大写字母组成</span></div><div class="line">ByteArrayInputStream bis = <span class="keyword">null</span> ;<span class="comment">// 内存输入流</span></div><div class="line">ByteArrayOutputStream bos = <span class="keyword">null</span> ;<span class="comment">// 内存输出流</span></div><div class="line">bis = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()) ;<span class="comment">// 向内存中输入内容</span></div><div class="line">bos = <span class="keyword">new</span> ByteArrayOutputStream() ;<span class="comment">// 准备从内存ByteArrayInputStream中读取内容</span></div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;</div><div class="line"><span class="keyword">while</span>((temp=bis.read())!=-<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) temp ;<span class="comment">// 读取的数字变为字符</span></div><div class="line">bos.write(Character.toLowerCase(c)) ;<span class="comment">// 将字符变为小写</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 所有的数据就全部都在ByteArrayOutputStream中</span></div><div class="line">String newStr = bos.toString() ;<span class="comment">// 取出内容</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">bis.close() ;</div><div class="line">bos.close() ;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">System.out.println(newStr) ;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="字符数据流-CharArrayReader、CharArrayWriter"><a href="#字符数据流-CharArrayReader、CharArrayWriter" class="headerlink" title="字符数据流(CharArrayReader、CharArrayWriter)"></a>字符数据流(CharArrayReader、CharArrayWriter)</h4><p>CharArrayReader、CharArrayWriter和ByteArrayInputStream、ByteArrayOutputStream类似，只不过后者是字节数组输入流，而前者是字符数组输入流。<br><strong>CharArrayReader</strong><br>构造方法摘要  </p><ul><li>CharArrayReader(char buf[]);<br>使用传入的buf构造CharArrayReader </li><li>CharArrayReader(char buf[], int offset, int length);<br>使用传入的buf的一部分构造CharArrayReader    </li></ul><p>方法摘要  </p><ul><li>void close(); 关闭此流  </li><li>void mark(int readAheadLimit); 标记当前流读取的位置  </li><li>void markSupport(); 检测此流是否支持标记  </li><li>int read(); 读取一个字符、并以整数形式返回  </li><li>int read(char[] b, int off, int len); 将buf中len个字符读取到下标从off开始的b中、返回读取的字符个数  </li><li>boolean ready(); 查看CharArrayReader是否可读。  </li><li>void reset(); 将此流开始位置重置到最后一次调用mark是流的读取位置  </li><li>long skip(long n); 丢弃buf中n个字符、返回实际丢弃的字符个数  </li></ul><p><strong>CharArrayWriter</strong><br>构造方法摘要    </p><ul><li>public CharArrayWriter()<br>使用默认的buf大小创建CharArrayWriter。   </li><li>public CharArrayWriter(int initialSize)<br>使用指定的buf大小创建CharArrayWriter。  </li></ul><p>方法摘要  </p><ul><li>CharArrayWriter append(CharSequence csq)<br>将一串有序字符序列写入buf中  </li><li>CharArrayWriter append(CharSequence csq, int start, int end)<br>将一串有序字符序列的一部分写入buf中  </li><li>CharArrayWriter append(char c) 将一个字符写入buf中</li><li>void close() 关闭此流（没有效果，因为不访问文件）</li><li>void flush() flush此流（没有效果，因为不访问文件）</li><li>void reset() 清空buf、重头开始</li><li>int size() 查看当前buf中字符总数</li><li>char[] toCharArray() 将buf中内容转换成char[]</li><li>String toString() 将buf中字符转换成String返回</li><li>void write(int c) 写入一个字符。</li><li>void write(char c[], int off, int len)<br>将一个char[]的一部分写入buf中、若buf满、扩容。</li><li>void write(String str, int off, int len)<br>将一个字符串写入buf中、满自动扩容</li><li>void writeTo(Writer out)<br>将buf中现有的字节写入到另一个输出字符流out中</li></ul><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">       String str = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line">       <span class="comment">// 构建字符输入流</span></div><div class="line">       CharArrayReader reader = <span class="keyword">new</span> CharArrayReader(str.toCharArray());</div><div class="line"></div><div class="line">       <span class="comment">// 从字符输入流读取字符</span></div><div class="line">       <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">       <span class="keyword">int</span> len = reader.read(chars);</div><div class="line">       System.out.println(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//构建字符输出流</span></div><div class="line">   CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter(<span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line"></div><div class="line">       <span class="comment">// 将字符串写入到CharArrayWriter</span></div><div class="line">       String msg = <span class="string">"hello world！！！22121"</span>;</div><div class="line">       writer.write(msg.toCharArray());</div><div class="line"></div><div class="line">       System.out.println(writer.toString());</div><div class="line"></div><div class="line">       writer.close();</div></pre></td></tr></table></figure></p><h4 id="字符串流-StringReader、StringWriter"><a href="#字符串流-StringReader、StringWriter" class="headerlink" title="字符串流(StringReader、StringWriter)"></a>字符串流(StringReader、StringWriter)</h4><p>字符串流和字符数据流基本一样，只是把char[]数组换成了String，在此不赘述。  </p><h3 id="合并流-SequenceInputStream、SequenceOutputStream"><a href="#合并流-SequenceInputStream、SequenceOutputStream" class="headerlink" title="合并流(SequenceInputStream、SequenceOutputStream)"></a>合并流(SequenceInputStream、SequenceOutputStream)</h3><p><strong>SequenceInputStream</strong><br>有些情况下，当我们需要从多个输入流中向程序读入数据。此时，可以使用合并流，将多个输入流合并成一个SequenceInputStream流对象。<br>SequenceInputStream会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。 合并流的作用是将多个源合并合一个源。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/合并流.png" alt="fail">  </p><p>构造方法<br>public SequenceInputStream(InputStream s1,InputStream s2)<br>使用两个输入流对象实例化本类对象。  </p><p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.SequenceInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 所有异常抛出</span></div><div class="line">InputStream is1 = <span class="keyword">null</span> ;<span class="comment">// 输入流1</span></div><div class="line">InputStream is2 = <span class="keyword">null</span> ;<span class="comment">// 输入流1</span></div><div class="line">OutputStream os = <span class="keyword">null</span> ;<span class="comment">// 输出流</span></div><div class="line">SequenceInputStream sis = <span class="keyword">null</span> ;<span class="comment">// 合并流</span></div><div class="line">is1 = <span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"a.txt"</span>);</div><div class="line">is2 = <span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"b.txt"</span>);</div><div class="line">os = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"ab.txt"</span>);</div><div class="line">sis = <span class="keyword">new</span> SequenceInputStream(is1,is2) ;</div><div class="line">        <span class="comment">// 实例化合并流</span></div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;<span class="comment">// 接收内容</span></div><div class="line"><span class="keyword">while</span>((temp=sis.read())!=-<span class="number">1</span>)&#123;<span class="comment">// 循环输出</span></div><div class="line">os.write(temp) ;<span class="comment">// 保存内容</span></div><div class="line">&#125;</div><div class="line">sis.close() ;<span class="comment">// 关闭合并流</span></div><div class="line">is1.close() ;<span class="comment">// 关闭输入流1`</span></div><div class="line">is2.close() ;<span class="comment">// 关闭输入流2</span></div><div class="line">os.close() ;<span class="comment">// 关闭输出流</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>SequenceOutputStream</strong><br>同SequenceInputStream,区别在于合并的是两个OutputStream，在此不赘述。</p><h3 id="数据操作流-DataInputStream、DataOutputStream"><a href="#数据操作流-DataInputStream、DataOutputStream" class="headerlink" title="数据操作流(DataInputStream、DataOutputStream)"></a>数据操作流(DataInputStream、DataOutputStream)</h3><p><strong>DataInputStream</strong><br>数据输入流允许应用程序以与机器无关方式从底层输入流中读取<strong>Java 8种基本数据类型</strong>，方法命名为readXxx。<br>下面的构造方法用来创建数据输入流对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(InputStream in);</div></pre></td></tr></table></figure></p><p>另一种创建方式是接收一个字节数组，和两个整形变量 off、len，off表示第一个读取的字节，len表示读取字节的长度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">byte</span>[] a,<span class="keyword">int</span> off,<span class="keyword">int</span> len);</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/DataInputStream.png" alt="fail" title="DataInputStream"><br><strong>DataOutputStream</strong><br>数据输出流允许应用程序以与机器无关方式将<strong>Java 8种基本数据类型</strong>写到底层输出流,方法命名为writeXxx。<br>下面的构造方法用来创建数据输出流对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(OutputStream  out);</div></pre></td></tr></table></figure></p><p>创建对象成功后，可以参照以下列表给出的方法，对流进行写操作或者其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/DataOutputStream.png" alt="fail" title="DataOutputStream"><br>下面的例子演示了DataInputStream和DataOutputStream的使用，该例从文本文件test.txt中读取5行，并转换成大写字母，最后保存在另一个文件test1.txt中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"></div><div class="line">      DataInputStream d = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span></div><div class="line">                               FileInputStream(<span class="string">"test.txt"</span>));</div><div class="line"></div><div class="line">      DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span></div><div class="line">                               FileOutputStream(<span class="string">"test1.txt"</span>));</div><div class="line"></div><div class="line">      String count;</div><div class="line">      <span class="keyword">while</span>((count = d.readLine()) != <span class="keyword">null</span>)&#123;</div><div class="line">          String u = count.toUpperCase();</div><div class="line">          System.out.println(u);</div><div class="line">          out.writeBytes(u + <span class="string">"  ,"</span>);</div><div class="line">      &#125;</div><div class="line">      d.close();</div><div class="line">      out.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="对象流-ObjectInputStream、ObjectOutputStream"><a href="#对象流-ObjectInputStream、ObjectOutputStream" class="headerlink" title="对象流(ObjectInputStream、ObjectOutputStream)"></a>对象流(ObjectInputStream、ObjectOutputStream)</h3><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>对象序列化，就是把一个对象变为二进制的数据流的一种方法，通过对象序列化可以方便的实现对象的传输或存储。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/对象序列化.png" alt="fail" title="对象序列化">    </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/对象序列化步骤.png" alt="fail" title="对象序列化"><br><strong>注意：</strong>Serializable接口和Cloneable接口一样是一个标记接口，即没有任何方法的接口。但只有一个类实现了Serializable接口，它才能被序列化为二进制流进行传输，否则会抛出NotSerializableException异常。一个类如果实现了Serializable接口，其子类也都可以序列化。  </p><p>定义一个可被序列化的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> String name ; </div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> age ;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name ;</div><div class="line"><span class="keyword">this</span>.age = age ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"；年龄："</span> + <span class="keyword">this</span>.age ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>以后此类的对象就可以被序列化了。变为二进制byte流。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/序列化和反序列化.png" alt="fail" title="序列化和反序列化">   </p><h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>在对象进行序列化或反序列化操作的时候，要考虑JDK版本的问题，如果序列化的JDK版本和反序列化的JDK版本不统一则就有可能造成异常。所以在序列化操作中引入了一个serialVersionUID的常量，可以通过此常量来验证版本的一致性，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现版本不一致的异常。</p><p>在上述的Person类中添加<code>private static final long serialVersionUID = 1L;</code>即可</p><h4 id="对象的序列化和反序列化"><a href="#对象的序列化和反序列化" class="headerlink" title="对象的序列化和反序列化"></a>对象的序列化和反序列化</h4><p>要想完成对象的输入或输出，还必须依靠对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）,<br><strong>使用对象输出流输出序列化对象的过程，即把Java对象转换为字节序列的过程</strong>，也称为<strong>序列化</strong>，而<strong>使用对象输入流读入的过程，即把字节序列恢复为Java对象的过程</strong>，也称为<strong>反序列化</strong>。  </p><h4 id="ObjectOutputStream-序列化"><a href="#ObjectOutputStream-序列化" class="headerlink" title="ObjectOutputStream(序列化)"></a>ObjectOutputStream(序列化)</h4><p>常用构造方法：<br>public ObjectOutputStream(OutputStream out)  //接收一个字节输出流对象  </p><p>常用方法：<br>public final void writeObject(Object obj) //把一个对象写入输出流 </p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo01</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"test.txt"</span>) ; <span class="comment">// 定义保存路径  </span></div><div class="line">        ObjectOutputStream oos = <span class="keyword">null</span> ; <span class="comment">// 声明对象输出流  </span></div><div class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f) ;    <span class="comment">// 文件输出流  </span></div><div class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(out) ;  </div><div class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">30</span>)) ;  <span class="comment">// 保存对象  </span></div><div class="line">        oos.close() ;   <span class="comment">// 关闭  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>对象序列化的真正内容：由于堆中只保存对象的非静态属性，方法和静态属性保存在静态区。所以序列化的实际是对象的非静态属性。  </p><h4 id="ObjectInputStream-反序列化"><a href="#ObjectInputStream-反序列化" class="headerlink" title="ObjectInputStream(反序列化)"></a>ObjectInputStream(反序列化)</h4><p>常用构造方法：<br>public ObjectInputStream(InputStream in)  //接收一个字节输入流对象<br>常用方法：<br>public final Object readObject()  //把输入流读出对象</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"test.txt"</span>) ;</div><div class="line">ObjectInputStream ois = <span class="keyword">null</span> ;</div><div class="line">InputStream in = <span class="keyword">new</span> FileOutputStream(f);</div><div class="line">ois = <span class="keyword">new</span> ObjectInStream(in) ;</div><div class="line">Person person = (Person)ois.readObject();</div><div class="line">oos.close() ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><p>当使用Serializable接口实现序列化操作时，如果一个对象中的某个属性不希望被JVM默认序列化的话，则可以使用transient关键字进行声明。如果用transient声明一个实例变量，当对象存储时，它的值不需要维持，而会保持默认值。换句话来说就是，用transient关键字标记的成员变量不参与JVM的默认序列化过程。  </p><p>更多序列化知识见：<br><a href="https://www.jianshu.com/p/0221518ad38f" target="_blank" rel="external">Java序列化心得（一）：序列化设计和默认序列化格式的问题</a><br><a href="https://www.jianshu.com/p/352fa61e0512" target="_blank" rel="external">Java序列化心得（二）：自定义序列化</a><br><a href="http://blog.csdn.net/u013087513/article/details/52174690" target="_blank" rel="external">Java IO操作——对象序列化（Serializable接口、ObjectOutputStream、以及与Externalizable接口的用法和区别）</a></p><p>拓展：ArrayList源码中对序列化的实现就是默认序列化和自定义序列化混合，只对底层数组的有效元素进行序列化，多余空间不必序列化，从而提高了性能。  </p><p>在对子类进行反序列化的操作时，没有实现Serializable接口的父类的构造方法会被自顶向下调用。</p><h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>在日常的使用中经常会使用到像WinRAR或WinZIP这样的压缩文件，通过这些软件可以把一个很大的文件进行压缩以方便传输。<br>在JAVA中 为了减少传输时的数据量也提供了专门的压缩流，可以将文件或文件夹压缩成ZIP、JAR、GZIP等文件的格式。<br>具体见大牛博客：<br><a href="http://blog.csdn.net/u013087513/article/details/52151227" target="_blank" rel="external">http://blog.csdn.net/u013087513/article/details/52151227</a>  </p><h3 id="管道流-PipedOutputStream、PipedInputStream"><a href="#管道流-PipedOutputStream、PipedInputStream" class="headerlink" title="管道流(PipedOutputStream、PipedInputStream)"></a>管道流(PipedOutputStream、PipedInputStream)</h3><p>管道流的作用是可以进行两个线程间的通讯，分为管道输出流(PipedOutputStream)、管道输入流(PipedInputStream)如果要想进行管道输出，则必须把输出流连在输入流之上，在PipedOutputStream中有一个方法用于连接管道：<br><strong>public void connect(PipedInputStream snk) throws IOException</strong>  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/管道流.png" alt="fail">  </p><p>例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;<span class="comment">// 线程类</span></div><div class="line"><span class="keyword">private</span> PipedOutputStream pos = <span class="keyword">null</span> ;<span class="comment">// 管道输出流</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.pos = <span class="keyword">new</span> PipedOutputStream() ;<span class="comment">// 实例化输出流</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">String str = <span class="string">"Hello World!!!"</span> ;<span class="comment">// 要输出的内容</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">this</span>.pos.write(str.getBytes()) ;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">this</span>.pos.close() ;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getPos</span><span class="params">()</span></span>&#123;<span class="comment">// 得到此线程的管道输出流</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.pos ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> PipedInputStream pis = <span class="keyword">null</span> ;<span class="comment">// 管道输入流</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Receive</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.pis = <span class="keyword">new</span> PipedInputStream() ;<span class="comment">// 实例化输入流</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>] ;<span class="comment">// 接收内容</span></div><div class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">len = <span class="keyword">this</span>.pis.read(b) ;<span class="comment">// 读取内容</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">this</span>.pis.close() ;<span class="comment">// 关闭</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"接收的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getPis</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.pis ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">Send s = <span class="keyword">new</span> Send() ;</div><div class="line">Receive r = <span class="keyword">new</span> Receive() ;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">s.getPos().connect(r.getPis()) ;<span class="comment">// 连接管道</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Thread(s).start() ;<span class="comment">// 启动线程</span></div><div class="line"><span class="keyword">new</span> Thread(r).start() ;<span class="comment">// 启动线程</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="回退流-PushbackInputStream和PushbackReader"><a href="#回退流-PushbackInputStream和PushbackReader" class="headerlink" title="回退流(PushbackInputStream和PushbackReader)"></a>回退流(PushbackInputStream和PushbackReader)</h3><p>在Java IO中所有的数据都是采用顺序的读取方式，即对于一个输入流来讲都是采用从头到尾的顺序读取的，如果在输入流中某个不需要的内容被读取进来，则只能通过程序将这些不需要的内容处理掉，为了解决这样的处理问题，在Java中提供了一种回退输入流(PushbackInputStream、PushbackReader),可以把读取进来的某些数据重新回退到输入流的缓冲区之中。</p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/回退流.png" alt="fail" title="回退流的工作原理">  </p><p>回退流分为字节回退流和字符回退流，我们以字节回退流PushbackInputStream为例。  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/PushbackInputStream.png" alt="fail">   </p><p>对于回退操作来说，提供了三个unread()的操作方法，这三个操作方法与InputStream类中的read()方法是一一对应的。</p><p> 例子如下，内存中使用ByteArrayInputStream，把内容设置到内存之中：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PushbackInputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushInputStreamDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">String str = <span class="string">"www.baidu.com"</span> ;<span class="comment">// 定义字符串</span></div><div class="line">PushbackInputStream push = <span class="keyword">null</span> ;<span class="comment">// 定义回退流对象</span></div><div class="line">ByteArrayInputStream bai = <span class="keyword">null</span> ;<span class="comment">// 定义内存输入流</span></div><div class="line">bai = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()) ;<span class="comment">// 实例化内存输入流</span></div><div class="line">push = <span class="keyword">new</span> PushbackInputStream(bai) ;<span class="comment">// 从内存中读取数据</span></div><div class="line">System.out.print(<span class="string">"读取之后的数据为："</span>) ;</div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ; </div><div class="line"><span class="keyword">while</span>((temp=push.read())!=-<span class="number">1</span>)&#123;<span class="comment">// 读取内容</span></div><div class="line"><span class="keyword">if</span>(temp==<span class="string">'.'</span>)&#123;<span class="comment">// 判断是否读取到了“.”</span></div><div class="line">push.unread(temp) ;<span class="comment">// 放回到缓冲区之中</span></div><div class="line">temp = push.read() ;<span class="comment">// 再读一遍</span></div><div class="line">System.out.print(<span class="string">"（退回"</span>+(<span class="keyword">char</span>)temp+<span class="string">"）"</span>) ;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">System.out.print((<span class="keyword">char</span>)temp) ;<span class="comment">// 输出内容</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="选择合适的IO流"><a href="#选择合适的IO流" class="headerlink" title="选择合适的IO流"></a>选择合适的IO流</h3><p>1.首先，明确IO流中有两个主要的体系，即  InputStream、OutputStream和Reader、Writer。其次，明确数据的来源和数据将要到达的目的地。  </p><p>2.明确将要操作的数据是否是纯文本数据。如果数据源是纯文本数据选Reader;数据源不是纯文本数据选择InputStream。如果数据目的地是纯文本数据就选择Writer;如果不是则选择OutputStream。  </p><p>3.明确具体的设备。即数据源是从哪个设备来的：是硬盘就加File;是键盘用System.in(是一个InputStream对象);是内存用数组;是网络用Socket流。同样目的是哪个设备：是硬盘就加File;是键盘用System.out(是一个PrintStream对象);是内存用数组;是网络用Socket流。    </p><p>4.明确是否还需要其他额外功能呢，例如：<br>①是否需要较高的效率，即是否需要使用缓冲区，是就加上Buffered;<br>②是否需要转换，是就使用转换流，InputStreamReader 和OutputStreamWriter。  </p><p>例子：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/1.jpg" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/2.jpg" alt="fail">   </p><h3 id="System类对IO的支持-out、err、in"><a href="#System类对IO的支持-out、err、in" class="headerlink" title="System类对IO的支持(out、err、in)"></a>System类对IO的支持(out、err、in)</h3><p>System类的常量<br>System表示系统类，实际上在Java中也对IO给予了一定的支持<br>1、public static final PrintStream out<br>//常量  对应系统标准输出，一般是显示器<br>2、public static final PrintStream err<br>//常量 错误信息输出<br>3、public static final InputStream in<br>//常量 对应标准输出，一般是键盘</p><p>使用static final关键字声明的变量是全局常量，只要是常量，则所有的单词字母必须全部大写，按照现在的标准：<br>System.OUT —&gt; System.out  </p><h4 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h4><p>使用System.out输出的时候就是将输出的位置定义在了显示器之中。FileOutputStream是定位在文件里，而System.out是定位在屏幕上输出。PrintStream就是OutputStream的子类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.OutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.IOException ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">OutputStream out = System.out ;<span class="comment">// 此时的输出流是向屏幕上输出</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">out.write(<span class="string">"hello world!!!"</span>.getBytes()) ;<span class="comment">// 向屏幕上输出</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;<span class="comment">// 打印异常</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">out.close() ;<span class="comment">// 关闭输出流</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System1.png" alt="fail">   </p><h4 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h4><p>System.err 表示的是错误的标准输出，如果程序中出现了错误的话，则直接使用System.err进行输出即可。程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo02</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"hello"</span> ;<span class="comment">// 声明一个非数字的字符串</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(Integer.parseInt(str)) ;<span class="comment">// 转型</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">System.err.println(e) ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System2.png" alt="fail"><br>使用System.out输出错误如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo03</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"hello"</span> ;<span class="comment">// 声明一个非数字的字符串</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(Integer.parseInt(str)) ;<span class="comment">// 转型</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">System.out.println(e) ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System3.png" alt="fail">  </p><p><strong>System.out 和System.err 的区别：</strong>System.out和System.err都是PrintStream的实例化对象，而且通过代码可以发现，两者都可以输出错误信息，但是一般来讲System.out是将信息显示给用户看，是正常的信息显示，而System.err的正好相反是不希望用户看到的，会直接在后台打印，是专门显示错误的。<br>一般来讲，如果要输出错误信息的时候最好不要使用System.out而是直接使用System.err 这一点只能从其概念上划分。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/System4.png" alt="fail">  </p><h4 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h4><p>System.in实际上是一个键盘的输入流，其本身是InputStream类型的对象。那么，此时就可以利用此方式完成从键盘读取数据的功能。<br>InputStream对应的是输入流，输入流的话肯定是从指定位置读取的，之前使用的是FileInputStream，是从文件中读取的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo04</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">InputStream input = System.in ;<span class="comment">// 从键盘接收数据</span></div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>] ;<span class="comment">// 开辟空间，接收数据</span></div><div class="line">System.out.print(<span class="string">"请输入内容："</span>) ;<span class="comment">// 提示信息</span></div><div class="line"><span class="keyword">int</span> len = input.read(b) ;<span class="comment">// 接收数据</span></div><div class="line">System.out.println(<span class="string">"输入的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">input.close() ;<span class="comment">// 关闭输入流</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>但是以上的操作存在如下问题：<br>问题一：指定了输入数据的长度，如果现在输入的数据超过了长度范围，只能输入部分的数据。<br>问题二：如果byte数组是奇数的话，则还可能出现中文乱码的情况，因为一个字符是两个字节。  </p><p>可以通过标志位的方式避免指定byte数组大小来解决。实例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo05</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">InputStream input = System.in ;<span class="comment">// 从键盘接收数据</span></div><div class="line">StringBuffer buf = <span class="keyword">new</span> StringBuffer() ;<span class="comment">// 使用StringBuffer接收数据</span></div><div class="line">System.out.print(<span class="string">"请输入内容："</span>) ;<span class="comment">// 提示信息</span></div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;<span class="comment">// 接收内容</span></div><div class="line"><span class="keyword">while</span>((temp=input.read())!=-<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) temp ;<span class="comment">// 将数据变为字符</span></div><div class="line"><span class="keyword">if</span>(c==<span class="string">'\n'</span>)&#123;<span class="comment">// 退出循环，输入回车表示输入完成</span></div><div class="line"><span class="keyword">break</span> ;</div><div class="line">&#125;</div><div class="line">buf.append(c) ;<span class="comment">// 保存内容</span></div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"输入的内容为："</span> + buf) ;</div><div class="line">input.close() ;<span class="comment">// 关闭输入流</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这种方法读取中文还是会乱码，这是因为每读取一个字节就将其转为字符，字母和数字都是占1个字节 可以正常显示。但是如果是中文的话，就相当于每读取到一个字节就是半个字符就进行转化，所以导致乱码的错误。<br>最好的输入方式是将全部输入的数据暂时存放在一块内存之上，之后一次性的从内存中读取数据，这样所有数据就整体只读了一次，则不会造成乱码，而且也不会受到长度的限制。  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System5.png" alt="fail">  </p><p>上述功能可以通过BufferedReader实现。  </p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>从之前的操作中知道System.out、System.err、System.in三个常量的作用，但是通过System类也可以改变System.in的输入流来源，以及System.out和System.err两个输出流的输出位置。<br>1、public static void setOut(PrintStream out)<br>//普通方法 重定向标准输出流<br>2、public static void setErr(PrintStream err)<br>//普通方法 重定向标准错误输出流<br>3、public static void setIn(InputStream in)<br>//普通方法 重定向标准输入流</p><h4 id="为System-out输出重定向"><a href="#为System-out输出重定向" class="headerlink" title="为System.out输出重定向"></a>为System.out输出重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo06</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">System.setOut(</div><div class="line"><span class="keyword">new</span> PrintStream(</div><div class="line"><span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span> + </div><div class="line">File.separator + <span class="string">"red.txt"</span>))) ;<span class="comment">// System.out输出重定向</span></div><div class="line">System.out.print(<span class="string">"hello"</span>) ;<span class="comment">// 输出时，不再向屏幕上输出</span></div><div class="line">System.out.println(<span class="string">",world"</span>) ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>System.out是希望用户看得到信息，一旦有错误，最好保存起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo07</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"hello"</span> ;<span class="comment">// 声明一个非数字的字符串</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(Integer.parseInt(str)) ;<span class="comment">// 转型</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.setOut(</div><div class="line"><span class="keyword">new</span> PrintStream(</div><div class="line"><span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span></div><div class="line">+ File.separator + <span class="string">"err.log"</span>))) ;<span class="comment">// 输出重定向</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">System.out.println(e) ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>通过此操作就可以完成错误的重定向，保存错误日志。</strong>  </p><h4 id="为System-err重定向"><a href="#为System-err重定向" class="headerlink" title="为System.err重定向"></a>为System.err重定向</h4><p>利用System.err向屏幕上输出信息，此时，为了方便起见，使用内存操作流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo08</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">ByteArrayOutputStream bos = <span class="keyword">null</span> ;<span class="comment">// 声明内存输出流</span></div><div class="line">bos = <span class="keyword">new</span> ByteArrayOutputStream() ;<span class="comment">// 实例化</span></div><div class="line">System.setErr(<span class="keyword">new</span> PrintStream(bos)) ;<span class="comment">// 输出重定向</span></div><div class="line">System.err.print(<span class="string">"hello"</span>) ;<span class="comment">// 错误输出，不再向屏幕上输出</span></div><div class="line">System.err.println(<span class="string">"world"</span>) ;<span class="comment">// 向内存中输出</span></div><div class="line">System.out.println(bos) ;<span class="comment">// 输出内存中的数据</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>一般不建议去修改System.err的输出位置，因为这样的信息都不太希望用户可以看见。  </p><h4 id="为System-in重定向"><a href="#为System-in重定向" class="headerlink" title="为System.in重定向"></a>为System.in重定向</h4><p>默认情况下System.in是指键盘输入，也可以通过setIn()方法，将其输入流的位置改变，例如，现在从文件中读取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo09</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">System.setIn(<span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span></div><div class="line">+ File.separator + <span class="string">"demo.txt"</span>)) ;<span class="comment">// 设置输入重定向</span></div><div class="line">InputStream input = System.in ;<span class="comment">// 从文件中接收数据</span></div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">// 开辟空间，接收数据</span></div><div class="line"><span class="keyword">int</span> len = input.read(b) ;<span class="comment">//接收</span></div><div class="line">System.out.println(<span class="string">"输入的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">input.close() ;<span class="comment">// 关闭输入流</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个常量的使用：  </p><ul><li>System.out是希望用户可以看见的信息。用IDE(Eclipse)的话错误信息使用黑颜色显示的。  </li><li>System.err 是不希望用户可以看见的信息。则在IDE中将以红色的文字显示错误信息。  </li><li>System.in 对应键盘输入。  </li><li>以上三个常量的输入、输出都可以重定向，但是一般建议只修改setOut的重定向。  </li><li>System.in读取的时候会出现中文乱码的问题，则可以通过BufferedReader完成读取功能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用telnet发送HTTP请求报文</title>
    <link href="http://habitdiary.cn/2017/11/19/%E4%BD%BF%E7%94%A8telnet%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/"/>
    <id>http://habitdiary.cn/2017/11/19/使用telnet发送HTTP请求报文/</id>
    <published>2017-11-19T15:30:25.000Z</published>
    <updated>2017-11-29T13:32:18.128Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以使用telnet给特定的Web服务器发送HTTP请求报文，得到服务器的HTTP相应报文。</p><p>比如，打开终端输入下面命令：  </p><p>telnet www.baidu.com 80  //Web服务器ip或域名、端口<br>GET <a href="https://www.baidu.com/" target="_blank" rel="external">https://www.baidu.com/</a>  HTTP/1.1<br>//请求行：方法字段、URL字段、HTTP版本字段<br>Host: www.baidu.com //首部行</p><p>在输入最后一个首部行之后连续按两次回车，这就打开一个到主机 www.baidu.com 的80端口的TCP连接，并发送一个HTTP请求报文。你将会看到一个携带包括百度主页的HTML基本文件的相应报文(HTML文件，即对象被封装在相应报文的实体体中)。如果只是想看一下HTTP协议的报文行，而不是获取对象本身的话，可以用HEAD代替GET。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以使用telnet给特定的Web服务器发送HTTP请求报文，得到服务器的HTTP相应报文。&lt;/p&gt;
&lt;p&gt;比如，打开终端输入下面命令：  &lt;/p&gt;
&lt;p&gt;telnet www.baidu.com 80  //Web服务器ip或域名、端口&lt;br&gt;GET &lt;a href=
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://habitdiary.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用telnet登录SMTP服务发送邮件</title>
    <link href="http://habitdiary.cn/2017/11/19/%E4%BD%BF%E7%94%A8telnet%E7%99%BB%E5%BD%95SMTP%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>http://habitdiary.cn/2017/11/19/使用telnet登录SMTP服务发送邮件/</id>
    <published>2017-11-19T13:59:48.000Z</published>
    <updated>2017-11-19T15:28:43.717Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《计算机网络自顶向下方法》，初步了解了SMTP协议。尝试用telnet登录SMTP服务给自己的qq邮箱发送了一封邮件，中间踩了很多坑，现在把具体步骤总结如下：  </p><p><strong>1.打开终端，输入<code>telnet</code>,回车</strong>  </p><p><strong>2.输入<code>o smtp.139.com 25</code>,此处o是open的缩写,以139邮箱为例,25表示SMTP服务器时刻监听的端口号,登录SMTP服务器。服务器返回<code>220 localhost richmail system v10(2eff5a1190ba8e2-ea850)</code>表示成功</strong>  </p><p><strong>3.输入<code>HELO xxx</code>,和服务器打招呼,xxx可以是任意内容,确认服务器应答,服务器返回<code>250 localhost richmail system v10(2eff5a1190ba8e2-ea850)</code>表示成功</strong>  </p><p><strong>4.输入<code>auth login</code>,请求登录,服务器返回<code>334 dXNlcm5hbWU6</code>,334是成功的状态码,后面是 username: 的base64码,可以在网上找到编码和解码工具</strong>  </p><p><strong>5.输入转换为base64码后的发送邮箱的用户名,不用带邮件域名，服务器返回<code>334 UGFzc3dvcmQ6</code>，334是成功的状态码，后面是 password: 的base64码</strong>  </p><p><strong>6.输入转换为base64码后的发送邮箱的密码,服务器返回<code>235 Authentication successful</code>表示登录成功</strong>  </p><p><strong>7.输入<code>MAIL FROM:&lt;发件人邮箱地址&gt;</code>，告诉服务器发信人的地址,服务器返回<code>250 Mail OK</code>表示成功</strong>  </p><p><strong>8.输入<code>RCPT TO:&lt;收件人邮箱地址&gt;</code>，告诉服务器收信人的地址,服务器返回<code>250 Mail OK</code>表示成功</strong>  </p><p><strong>9.输入<code>DATA</code>,开始写邮件,服务器返回<code>354 End data with .</code>提示邮件以一个单独占有一行的<code>.</code>结束</strong>  </p><p><strong>10.邮件格式如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">To:收件人邮箱地址</div><div class="line">From:发件人邮箱地址</div><div class="line">Subject:邮件主题 //前三行是首部行</div><div class="line">//首部行和报文体之间要有一个空行</div><div class="line">邮件正文//报文体</div><div class="line">． //结束邮件的标志</div></pre></td></tr></table></figure></p><p><strong>服务器返回<code>250 ok</code>表示发送成功，如果要继续发送，则返回步骤7重复即可。</strong>  </p><p><strong>11.发送完所有邮件之后输入<code>QUIT</code>,关闭TCP连接</strong> </p><p><strong>下面是成功接收的邮件</strong></p><p><img src="/2017/11/19/使用telnet登录SMTP服务发送邮件/test.png" alt="fail">  </p><p><strong>注意几个坑：<br>1.发件方使用的是139邮箱，尝试qq邮箱和163邮箱开启了SMTP服务也不成功，可能是基于安全性考虑进行了限制<br>2.收件方邮箱如果有反垃圾机制，应该事先关闭，否则会拒绝接收邮件</strong>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看《计算机网络自顶向下方法》，初步了解了SMTP协议。尝试用telnet登录SMTP服务给自己的qq邮箱发送了一封邮件，中间踩了很多坑，现在把具体步骤总结如下：  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.打开终端，输入&lt;code&gt;telnet&lt;/code&gt;,回车&lt;/str
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://habitdiary.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之异常处理</title>
    <link href="http://habitdiary.cn/2017/11/08/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://habitdiary.cn/2017/11/08/Java学习总结之异常处理/</id>
    <published>2017-11-08T13:42:16.000Z</published>
    <updated>2018-02-01T12:44:29.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在程序运行过程中<strong>(注意是运行阶段，程序可以通过编译)</strong>，如果JVM检测出一个不可能执行的操作，就会出现<strong>运行时错误</strong>。例如，使用一个越界的下标访问数组，程序就会产生一个ArrayIndexOutOfBoundsException的运行时错误。如果程序需要输入一个整数的时候用户输入了一个double值，会得到一个InputMismatchException的运行时错误。<br>在Java中，运行时错误会作为<strong>异常</strong>抛出。<strong>异常</strong>就是一种对象，表示阻止正常进行程序执行的错误或者情况。如果异常没有被处理，那么程序就会非正常终止。<br>人们在遇到错误时会感觉不爽。如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序了，为了避免这类事<br>情的发生，至少应该做到以下几点：  </p><ul><li>向用户通告错误</li><li>保存所有的工作结果</li><li>允许用户以妥善的形式退出程序  </li></ul><p>Java使用一种称为<strong>异常处理</strong>的错误捕获机制处理，从而使程序继续运行或优雅终止。  </p><h3 id="异常处理概述"><a href="#异常处理概述" class="headerlink" title="异常处理概述"></a>异常处理概述</h3><p>异常处理使得程序可以处理非预期的情景，并且继续正常的处理。<br>我们来看一个读取两个整数并显示它们商的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quotient</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">        <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">        <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">        + <span class="string">" is "</span> + (number1 / number2));</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果number2为0,就会产生一个运行时错误，因为不能用一个整数除以0(注意，一个浮点数除以0不会产生异常)。<br>我们可以添加一个if语句来测试第二个数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quotient</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">        <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">        <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">        <span class="keyword">if</span>(number2 != <span class="number">0</span>)</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">        + <span class="string">" is "</span> + (number1 / number2));</div><div class="line">        <span class="keyword">else</span></div><div class="line">        System.out.println(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了介绍异常处理，我们使用一个<strong>方法</strong>来实现两个整数求商的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuotientWithMethod</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(number2 == <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> number1 / number2;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">    <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> result = quotient(number1,number2);</div><div class="line">    System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">    + <span class="string">" is "</span> + result);</div></pre></td></tr></table></figure></p><p>但上述代码有一个问题：当number2为0时，程序在quotient方法内终止。但不应该让一个方法来终止程序 —— <strong>应该由方法的调用者决定是否终止程序，即方法只需要通知其调用者有运行时错误产生，而不应该自己做决定。</strong><br>下面使用异常处理的方法，让quotient方法抛出一个异常，使其被调用这捕获和处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuotientWithException</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (number2 == <span class="number">0</span>) </div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">        <span class="keyword">return</span> number1 / number2;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">    <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span> result = quotient(number1,number2);</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 + <span class="string">" is "</span></div><div class="line">        + result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(ArithmeticException ex) &#123;</div><div class="line">System.out.println(<span class="string">"Exception: an integer "</span> + </div><div class="line">        <span class="string">"cannot be divided by zero"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"Execution continues ..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以看到，上面的代码能使方法抛出一个异常给调用者，并由调用者处理该异常。如果不这么做，被调用的方法本身必须处理异常或者终止程序。但是库方法在设计时通常无法确定在出错时要进行什么操作，最好的做法就是将检测出的错误作为异常抛出给调用者处理，查阅API我们也会发现库方法会对其可能抛出的异常进行说明。异常处理的最根本优势就是<strong>将检测错误(由被调用的方法完成)从处理错误(由调用方法完成)中分离出来。</strong><br>当然，如果运行时错误发生在main方法中，就不必抛出异常了，可以考虑提供一个异常处理器对异常进行捕获和处理。  </p><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>异常是对象，而对象都采用类来定义。在 Java 程序设计语言中， 异常对象都是派生于 Throwable 类的一个实例。稍后还可以看到，如果 Java 中内置的异常类不能够满足需求，用户可以创建自己的异常类。  </p><p>下面是Java中的异常层次结构：  </p><p><img src="/2017/11/08/Java学习总结之异常处理/Java异常层次结构.jpg" alt="fail" title="Java异常层次结构"><br>可以看到，Throwable是所有异常类的根类，所有异常类都直接或间接继承自 Throwable。但在下一层立即分解为两个分支：Error 和 Exception。<br><strong>Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。</strong>应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。这种情况很少出现。<br>在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：<br>一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像 I/O 错误这类<br>问题导致的异常属于其他异常。<br>有一条相当有道理的规则：<strong>如果出现 RuntimeException，那么就一定是你的问题</strong>。<br>也就是说，RuntimeException是可以在编程时避免的。比如，可以通过检测数组下标是否越界来避免IndexOutOfBoundsException，可以通过在使用变量前检测是否为null杜绝NullPointerException。  </p><p><strong>免检异常：</strong>又称非受查异常(Unchecked Exception)，RuntimeException、Error以及它们的子类都称为免检异常。意思是编译器不会强制检查程序是否处理或声明了异常。如果想让使用某方法的程序员注意到方法可能抛出的免检异常，可以给该方法加上文档注释。<br><strong>必检异常：</strong>又称受查异常(Checked Exception)，除了免检异常的其他异常都是必检异常，意思是编译器会强制程序员检查并通过try-catch语句处理它们，或者在方法头进行声明，否则无法通过编译。  </p><h3 id="关于异常处理的更多知识"><a href="#关于异常处理的更多知识" class="headerlink" title="关于异常处理的更多知识"></a>关于异常处理的更多知识</h3><p><strong>异常处理器是通过从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到的。</strong>即如果某方法的异常没有在该方法内被捕获和处理，就会被抛出给它的调用者，并在调用者中搜寻相应的异常处理器，如果还没有找到就继续上抛，如果在整个方法调用链中异常都没有被捕获处理，该异常会被抛给JVM，JVM会终止程序并打印错误信息。<br>Java的异常处理模型基于三种操作：  </p><ul><li>声明异常  </li><li>抛出异常  </li><li>捕获异常  </li></ul><h3 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h3><p>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如，一段读取文件的代码知道有可能读取的文件不存在， 或者内容为空，因此， 试图处理文件信息的代码就需要通知编译器可能会抛出 IOException 类的异常。<br>方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出异常。<br>每个方法只需声明所有它可能抛出的<strong>必检异常类型</strong>，这称为<strong>声明异常</strong>。无需声明免检异常，因为免检异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)。<br>可以声明多个异常，用逗号隔开即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception1, Exception2,...</span></div></pre></td></tr></table></figure></p><p>当然，从前面的示例中可以知道：除了声明异常之外， 还可以捕获异常。这样会使异常不被抛到方法之外，也不需要 throws 规范。稍后，将会讨论如何决定一个异常是被捕获，还是被抛出让其他的处理器进行处理。<br>下面有一些规则：  </p><ul><li>在方法定义处声明的异常类型可以是方法内抛出异常的类型及其父类型。</li><li>如果在子类中重写了父类的一个方法，子类方法中声明的受查异常必须是父类所声明异常的同类或子类(也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常)  </li><li>如果在超类方法中没有声明/抛出异常，子类也不能声明/抛出异常  </li></ul><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>检测到错误的程序可以创建一个合适的异常类型的实例并抛出它，这就称为<strong>抛出异常</strong>。下面有一个例子，方法的参数必须是非负的，如果传入一个负参数，程序就创建一个IllegalArgumentException实例并抛出它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IllegalArgumentException ex = </div><div class="line"><span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong Argument"</span>);</div><div class="line"><span class="keyword">throw</span> ex;</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong Argument"</span>);</div></pre></td></tr></table></figure></p><p>第一种写法创建了一个异常对象并赋给一个异常类引用变量，并抛出它;第二种写法则直接抛出一个匿名异常对象。<br>Java库中每个异常类一般至少有两个构造方法：一个无参构造方法和一个带可描述这个异常的String参数的构造方法。如上述就使用了带参数的构造方法并传入了”Wrong Argument”的异常描述。可以通过在异常对象上调用getMessage()获取异常描述字符串。<br>抛出异常的三个步骤：  </p><ol><li>找到一个合适的异常类  </li><li>创建这个类的一个对象 </li><li>将对象抛出  </li></ol><p><strong>注意：</strong>这里所说抛出异常是指我们在编写程序时用throw关键字显式抛出异常，但是在很多情况下，异常是由库方法抛出的，throw关键字被封装在库方法中，对用户是不可见的，此时用户程序中是没有显式的throw关键字的。  </p><p>我们使用throw关键字手动抛出异常有两种基本方案：<br>1、在throw语句外加上对应异常的try-catch块，即自己抛出的异常自己捕获处理。<br>2、在含有throw语句的方法声明处通过throws关键字声明对应的异常，由方法的调用者来处理这个异常。<br><img src="/2017/11/08/Java学习总结之异常处理/throw.png" alt="fail"></p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>当抛出一个异常时，可以提供try-catch语句来捕获和处理它，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   statements; <span class="comment">// Statements that may throw exceptions</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception exVar1) &#123;</div><div class="line">    handler <span class="keyword">for</span> exception1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception exVar2) &#123;</div><div class="line">    handler <span class="keyword">for</span> exception2;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="keyword">catch</span>(Exception exVarN) &#123;</div><div class="line">    handler <span class="keyword">for</span> exceptionN;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>可以为一个try块提供多个catch语句，因为一个try块可能抛出多种不同类型的异常。<br>如果在执行try块的过程中没有出现异常，则跳过catch子句。<br>如果try块中的某条语句抛出一个异常，Java就会跳过try块中剩余的语句，然后开始查找合适的处理异常的代码，即<strong>异常处理器</strong>。可以从当前的方法开始，沿着方法调用链，按照异常的<strong>反向传播</strong>方向找到这个处理器。从第一个到最后一个逐个检查catch块，判断在catch块中的异常类变量是否是该异常对象的类型。如果是，就将该异常对象赋值给所声明的变量，然后执行catch块中的代码。如果没有发现异常处理器，Java会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来查找处理器。如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息。<strong>寻找处理器的过程称为捕获异常。</strong><br><strong>注意：</strong>如果一个catch块可以捕获一个父类的异常对象，它就能捕获那个父类的所有子类的异常对象。在catch块中异常被指定的顺序是非常重要的，如果父类异常的catch块在子类异常的catch块之前，就会导致编译错误。道理很简单，如果将父类异常的catch块放在子类异常的catch块之前，则子类异常对象一定会被父类异常的catch块捕获，子类异常的catch块就失去了意义。<strong>因为我们无法保证所编写的catch块涵盖了try块中可能出现的所有异常类型，所以建议在多重catch块的最后添加所有异常的父类Exception的异常处理器来保证try块中出现的任何异常被捕获。</strong><br>对于使用同样的处理代码处理多个异常的情况，可以使用<strong>多捕获</strong>特征简化异常的代码编写，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">catch</span>(Exception1 | Exception2 | ... | ExceptionN ex) &#123;</div><div class="line"><span class="comment">// Same code for handling these exceptions</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>小提示：对于InputMismatchedException，要在catch块中吸收错误输入，否则该错误输入将被下一条读取语句读取。</strong></p><h3 id="创建自定义异常类"><a href="#创建自定义异常类" class="headerlink" title="创建自定义异常类"></a>创建自定义异常类</h3><p>在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。在这种情况下，我们可以通过派生Exception类或其子类来创建自定义的异常类。<br>下面给出一个例子，当半径为负时，setRadius方法会抛出一个异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidRadiusException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidRadiusException</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(<span class="string">"Invalid radius "</span> + radius);</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> radius;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>可见异常类里可定义数据域和访问器，使外界能访问到导致异常的非法参数。<br><strong>注意：</strong>建议不要让自定义的异常类继承RuntimeException及其子类，这样会使自定义的异常类称为免检异常，最好使自定义的异常类必检，这样编译器就可以在程序中强制捕获或声明这些异常。</p><h3 id="从异常中获取信息"><a href="#从异常中获取信息" class="headerlink" title="从异常中获取信息"></a>从异常中获取信息</h3><p>异常对象中包含了关于异常的有价值的信息，可以利用Throwable类中的实例方法获取有关的信息，如下所示：<br><img src="/2017/11/08/Java学习总结之异常处理/Throwable1.png" alt="fail"><br><img src="/2017/11/08/Java学习总结之异常处理/Throwable2.png" alt="fail"></p><ul><li>Throwable() 无参构造器  </li><li>Throwable(String message) 带描述异常信息字符串的构造器 </li><li>String getMessage() 返回一个描述该异常对象信息的字符串 </li><li>String toString() 返回三个字符串的连接：1) 异常类的全名; 2) “: “ 一个冒号和一个空格 3) getMessage(方法)  </li><li>void printStackTrace() 在控制台上打印 Throwable对象和它的调用堆栈信息  </li></ul><p>同样Exception和RuntimeException也有类似的方法<br><img src="/2017/11/08/Java学习总结之异常处理/Exception.png" alt="fail"><br><img src="/2017/11/08/Java学习总结之异常处理/RuntimeException.png" alt="fail"><br>堆栈轨迹(stack trace)是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。类似于数据结构中的栈，一个方法被调用就会入栈，即最先被调用的方法(main方法)在栈底，后被调用的方法在栈顶。当一个方法调用结束，就会出栈，也是栈顶方法先出栈，最后main方法也调用完毕，整个方法栈被销毁，程序结束。<br>Throwable的printStackTrace方法就是这样从上到下打印了方法栈，栈顶是产生异常的方法，栈底是main方法。比如下面的代码访问了数组的-1下标，抛出一个ArrayIndexOutOfBoundsException：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">    printArrayElement(array,-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArrayElement</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">System.out.println(a[index]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>打印的堆栈轨迹是：<br><img src="/2017/11/08/Java学习总结之异常处理/stack trace.png" alt="fail"><br>一种更灵活的方法是getStackTrace()，它会得到一个StackTraceElement对象的一个数组，每个元素都是方法堆栈中的一个方法，其API如下：<br><img src="/2017/11/08/Java学习总结之异常处理/getStackTrace.png" alt="fail">  </p><h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>当异常被捕获之后，可以在catch子句中重新抛出异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用的子系统，那么，用于表示子系统的异常类型可能会产生多种解释。ServletException就是这样一个异常类型的例子。执行servlet的代码可能不想知道发生错误的细节原因，但希望明确地知道servlet是否有问题。<br>同原始异常一起抛出一个新异常(带有附加信息)，这称为<strong>异常链</strong>。<br>下面给出了抛出异常链的基本方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">access the database</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SQLException e)</div><div class="line">&#123;</div><div class="line">Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error: "</span> </div><div class="line">    + e.getMessage());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不过，我们发现原始异常被改变了。有一种更好的处理方法，可以将原始异常设置为新异常的”原因”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">access the database</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SQLException e)</div><div class="line">&#123;</div><div class="line">Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</div><div class="line">se.initCause(e);</div><div class="line"><span class="keyword">throw</span> se;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当捕获到异常时，就可以使用下面的这条语句重新得到原始异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Throwable e = se.getCause();</div></pre></td></tr></table></figure></p><p>强烈建议使用这种包装技术，这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。也可以使用带有包装功能的构造方法来封装原始异常并抛出该新异常。  </p><h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有的异常。但是，这种解决方案比较乏味，这是因为需要在两个地方清除所分配的资源。一个在正常的代码中；另一个在异常代码中。<br>Java 有一种更好的解决方案，这就是 finally 子句。无论异常是否产生，finally子句总是会被执行,即使在到达finally子句之前有一个return语句，finally块还是会执行。唯一使finally子句不执行的方法是在finally子句前使用<code>System.exit(1)</code>方法，这个方法的作用是终止正在运行的JVM，参数为0表示程序正常终止，非0表示异常终止。在try块(或try-catch块)和finally块之间不能有其他任何代码。finally子句常用于在抛出异常时关闭资源，比如关闭文件和关闭与数据库的连接。<br>比如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(. . .);</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//1</span></div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line"><span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// 3</span></div><div class="line">show error message</div><div class="line"><span class="comment">// 4</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line"><span class="comment">// 5</span></div><div class="line">in.close();</div><div class="line">&#125;</div><div class="line"><span class="comment">//6</span></div></pre></td></tr></table></figure></p><p>在上面的代码中，有下列3种情况会执行finally子句：<br>1) 代码没有抛出异常。在这种情况下，程序首先执行 try 语句块中的全部代码，然后执行 finally 子句中的代码。随后，继续执行 try 语句块之后的下一条语句。也就是说，执行标<br>注的1、2、5、6处<br>2) 抛出一个在 catch 子句中捕获的异常。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try语句块中的所有代码，直到发生异常为止。此时，将跳过 try语句块中的剩余代码，转去执行与该异常匹配的 catch 子句中的代码， 最后执行 finally 子句中的代码。<br> 如果 catch 子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6 处的语句。<br> 如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。在这里， 执行标注<br>1、 3、 5 处的语句。<br>3) 代码抛出了一个异常，但这个异常不是由 catch 子句捕    获的。在这种情况下，程序将执行 try 语句块中的所有语句，直到有异常被抛出为止。此时，将跳过 try 语句块中的剩余代<br>码，然后执行 finally 子句中的语句，并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。<br>try 语句可以只有 finally 子句，而没有 catch 子句。例如，下面这条 try 语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   InputStream in = . .</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>无论在 try 语句块中是否遇到异常，finally 子句中的 in.close()语句都会被执行。当然,<br>如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 catch 子句捕获。<br>强烈建议解耦合 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">InputStream in = . . .;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line">show error message</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>内层的 try 语句块只有一个职责，就是确保关闭输入流。外层的 try 语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚， 而且还具有一个功能，就是<strong>将会报告 finally 子句中出现的错误。</strong><br><strong>注意：</strong>当 finally 子句包含 return 语句时，将会出现一种意想不到的结果„ 假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值。请看一个复杂的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> r = n * n;</div><div class="line"><span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句然而，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值4。<br>有时候， finally 子句也会带来麻烦。例如， 清理资源的方法也有可能抛出异常。假设希望能够确保在流处理代码中遇到异常时将流关闭。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">InputStream in = . . .;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在，假设在 try 语句块中的代码抛出了一些非 IOException 的异常，这些异常只有这个方法的调用者才能够给予处理。执行 finally 语句块，并调用 close 方法。而 close 方法本身也<br>有可能抛出 IOException 异常。当出现这种情况时， 原始的异常将会丢失，转而抛出 close 方法的异常。<br>这会有问题， 因为第一个异常很可能更有意思。如果你想做适当的处理，重新抛出原来的异常， 代码会变得极其繁琐。 如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">InputStream in = . . .;</div><div class="line">Exception ex = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">    code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Exception e)</div><div class="line">    &#123;</div><div class="line">    ex = e;</div><div class="line"><span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">in.close()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Exception e)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (ex = <span class="keyword">null</span>) <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码太繁琐，在 Java SE 7中提供了一种更便捷的方法。  </p><h3 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的try语句</h3><p>对于以下代码模式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">open a resource</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">work with the resource</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">close the resource</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。AutoCloseable 接口有一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div></pre></td></tr></table></figure></p><p>另外，还有一个 Closeable 接口。这是 AutoCloseable 的子接口， 也包含一个 close方法。不过，这个方法声明为抛出一个 IOException。<br>带资源的 try 语句（try-with-resources) 的最简形式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (声明和创建资源)&#123;</div><div class="line">使用资源来处理文件;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>try块退出时，会自动调用 res.close()。下面给出一个典型的例子， 这里要读取一个文件中的所有单词：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="number">7</span>usr/share/dict/words<span class="string">")), "</span>UTF-<span class="number">8</span><span class="string">")</span></div><div class="line"><span class="string">&#123;</span></div><div class="line"><span class="string">while (in.hasNext())</span></div><div class="line"><span class="string">System.out.println(in.next());</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></p><p>这个块正常退出时， 或者存在一个异常时， 都会调用 in.close() 方法， 就好像使用了finally块一样。<br>还可以指定多个资源,例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanne(<span class="keyword">new</span> FileInputStream(<span class="string">"7usr/share/dict/words"</span>), <span class="string">"UTF-8"</span>);</div><div class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"out.txt"</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span> (in.hasNext())</div><div class="line">out.println(in.next().toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不论这个块如何退出， in 和 out 都会关闭。如果你用常规方式手动编程，就需要两个嵌套的 try/finally语句。<br>前面已经看到，如果 try 块抛出一个异常， 而且 close 方法也抛出一个异常，这就会带来一个难题。带资源的 try 语句可以很好地处理这种情况。原来的异常会重新抛出，而 close方法抛出的异常会”被抑制”。这些异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。 如果对这些异常感兴趣， 可以调用 getSuppressed 方法，它会得到从 close 方法抛出并被抑制的异常列表。<br>你肯定不想采用这种常规方式编程。只要需要关闭资源， 就要尽可能使用带资源的 try语句。</p><h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><h4 id="1-异常处理不能代替简单的测试"><a href="#1-异常处理不能代替简单的测试" class="headerlink" title="1.异常处理不能代替简单的测试"></a>1.异常处理不能代替简单的测试</h4><p>异常处理需要初始化新的异常对象，需要调用栈返回，而且还需要沿着方法调用链来传播异常以找到它的异常处理器，所以，异常处理通常需要更多的时间和资源。<br>如果能在发生异常的方法中处理异常，就不需要抛出异常。在个别方法中的简单错误最好进行局部处理，无须抛出异常。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(refVar.toString());</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(NullPointerException ex) &#123;</div><div class="line">System.out.println(<span class="string">"refVar is null"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最好用下面的代码代替：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (refVar != <span class="keyword">null</span>)</div><div class="line">System.out.println(refVar.toString());</div><div class="line"><span class="keyword">else</span></div><div class="line">System.out.println(<span class="string">"refVar is null"</span>);</div></pre></td></tr></table></figure></p><p>只有在异常不可预料的情况下才抛出异常，简单的情况不应该使用异常机制。</p><h4 id="1-不要过分细化异常"><a href="#1-不要过分细化异常" class="headerlink" title="1.不要过分细化异常"></a>1.不要过分细化异常</h4><p>很多程序员习惯将每一条语句都分装在一个独立的 try 语句块中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">PrintStream out;</div><div class="line">Stack s;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">n = s.pop();</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (EmptyStackException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// stack was empty</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">out.writelnt(n);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// problem writing to file</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种编程方式将导致代码量的急剧膨胀。首先看一下这段代码所完成的任务。在这里，希望从栈中弹出 100 个数值， 然后将它们存入一个文件中。如果栈是空的， 则不会变成非空状态；如果文件出现错误， 则也很难给予排除。出现上述问题后，这种编程方式无能为力。因此，有必要将整个任务包装在一个 try语句块中，这样，当任何一个操作出现问题时，整个任务都可以取消。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">&#123;</div><div class="line">n = s.pop();</div><div class="line">out.writelnt(n);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// problem writing to file</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (EmptyStackException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// stack was empty</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码看起来清晰多了。这样也满足了异常处理机制的其中一个目标，将正常处理与错误处理分开。</p><h4 id="3-利用异常层次结构"><a href="#3-利用异常层次结构" class="headerlink" title="3.利用异常层次结构"></a>3.利用异常层次结构</h4><p>不要只抛出 RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。<br>不要只捕获 Thowable 异常， 否则，会使程序代码更难读、 更难维护。<br>考虑受查异常与非受查异常的区别。 已检查异常本来就很庞大，不要为逻辑错误抛出这些异常。（例如， 反射库的做法就不正确。 调用者却经常需要捕获那些早已知道不可能发生的异常。）<br>将一种异常转换成另一种更加适合的异常时不要犹豫。例如， 在解析某个文件中的一个整数时，捕获NumberFormatException 异 常，然后将它转换成 IOException 或 MySubsystemException 的子类。  </p><h4 id="4-不要压制异常"><a href="#4-不要压制异常" class="headerlink" title="4.不要压制异常"></a>4.不要压制异常</h4><p>在 Java 中，往往强烈地倾向关闭异常。如果编写了一个调用另一个方法的方法，而这个方法有可能 100 年才抛出一个异常， 那么， 编译器会因为没有将这个异常列在 throws 表中产生抱怨。而没有将这个异常列在 throws 表中主要出于编译器将会对所有调用这个方法的方法进行异常处理的考虑。因此，应该将这个异常关闭：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="comment">// code that threatens to throw checked exceptions</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Exception e)</div><div class="line">&#123;&#125; <span class="comment">// so there</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在，这段代码就可以通过编译了。除非发生异常，否则它将可以正常地运行。即使发生了异常也会被忽略。如果认为异常非常重要，就应该对它们进行处理。  </p><h4 id="5-在检测错误时，”苛刻”要比放任更好"><a href="#5-在检测错误时，”苛刻”要比放任更好" class="headerlink" title="5.在检测错误时，”苛刻”要比放任更好"></a>5.在检测错误时，”苛刻”要比放任更好</h4><p>当检测到错误的时候，有些程序员担心抛出异常。在用无效的参数调用一个方法时，返回一个虚拟的数值， 还是抛出一个异常， 哪种处理方式更好？ 例如， 当栈空时，Stack.pop 是<br>返回一个 null, 还是抛出一个异常？ 我们认为：在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一个 NullPointerException 异常更好。  </p><h4 id="6-不要羞于传递异常"><a href="#6-不要羞于传递异常" class="headerlink" title="6.不要羞于传递异常"></a>6.不要羞于传递异常</h4><p>很多程序员都感觉应该捕获抛出的全部异常。如果调用了一个抛出异常的方法，例如，FilelnputStream 构造器或 readLine 方法，这些方法就会本能地捕获这些可能产生的异常。其实， 传递异常要比捕获这些异常更好：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStuff</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function"><span class="comment">// not a sign of shame!</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">InputStream in = <span class="keyword">new</span> FilelnputStream(filename);</div><div class="line">. . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>让高层次的方法通知用户发生了错误， 或者放弃不成功的命令更加适宜。<br><strong>规则 5、6 可以归纳为”早抛出，晚捕获”</strong></p><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><p>在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此，可以将这些检测删掉，并在其他测试需要时将它们粘贴回来，这是一件很乏味的事。  </p><h4 id="1-断言的概念"><a href="#1-断言的概念" class="headerlink" title="1.断言的概念"></a>1.断言的概念</h4><p>假设确信某个属性符合要求，并且代码的执行依赖于这个属性。例如，需要计算：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> y = Math.sqrt(x);</div></pre></td></tr></table></figure></p><p>我们确信，这里的 X 是一个非负数值。原因是：X 是另外一个计算的结果，而这个结果不可能是负值；或者 X 是一个方法的参数，而这个方法要求它的调用者只能提供一个正整数。<br>然而，还是希望进行检查，以避免让“不是一个数”的数值参与计算操作。当然，也可以抛出一个异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"x &lt; 0"</span>);</div></pre></td></tr></table></figure></p><p>但是这段代码会一直保留在程序中，即使测试完毕也不会自动地删除。如果在程序中含有大量的这种检查，程序运行起来会相当慢。<br>断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。<br>Java 语言引人了关键字 assert。这个关键字有两种形式：<br><code>assert 条件;</code>和<code>assert 条件：表达式;</code><br>这两种形式都会对条件进行检测，如果结果为 false, 则在第一种形式中会抛出一个 AssertionError 异常。在第二种形式中，表达式将被传人 AssertionError 的构造器，并转换成一个消息字符串,在打印异常信息时会随之显示出来。<br><strong>注意：</strong>“表达式”部分的唯一目的是产生一个消息字符串。AssertionError 对象并不存储表达式的值，因此，不可能在以后得到它。正如 JDK 文档所描述的那样：如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。<br>要想断言 x 是一个非负数值，只需要简单地使用下面这条语句：<br><code>assert x &gt;= 0;</code><br>或者将 x 的实际值传递给 AssertionError 对象， 从而可以在后面显示出来：<br><code>assert x &gt;= 0 : x;</code>  </p><h4 id="2-启用和禁用断言"><a href="#2-启用和禁用断言" class="headerlink" title="2.启用和禁用断言"></a>2.启用和禁用断言</h4><p>在默认情况下，断言被禁用。可以在运行程序时用<br><code>-enableassertions</code> 或 <code>-ea</code> 选项启用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -enableassertions MyApp</div></pre></td></tr></table></figure></p><p>需要注意的是，在启用或禁用断言时<strong>不必重新编译程序</strong>。启用或禁用断言是类加载器(class loader) 的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。<br>也可以在某个类或整个包中使用断言，例如：<br><code>java -ea:MyClass -ea:com.mycompany.mylib... MyApp</code>  </p><p>这条命令将开启 MyClass 类以及在 com.mycompany.mylib 包和它的子包中的所有类的断言。选项 -ea 将开启默认包中的所有类的断言。 也可以用选项 <code>-disableassertions</code> 或 <code>-da</code> 禁用某个特定类和包的断言：<br><code>java -ea:... -da:MyClass MyApp</code><br>有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。<br>然而，启用和禁用所有断言的 <code>-ea</code> 和 <code>-da</code> 开关不能应用到那些没有类加载器的”系统类”上。对于这些系统类来说，需要使用 <code>-enablesystemassertions/-esa</code> 开关启用断言。<br>在程序中也可以控制类加载器的断言状态。有关这方面的内容请参看本文末尾的 API 注释。<br>还可以在eclipse里开启断言，只要Run -&gt; Run Configurations -&gt; Arguments页签 -&gt; VM arguments文本框中加上断言开启的标志:<br>-enableassertions 或者-ea 就可以了。  </p><h4 id="3-使用断言完成参数检查"><a href="#3-使用断言完成参数检查" class="headerlink" title="3.使用断言完成参数检查"></a>3.使用断言完成参数检查</h4><p>在 Java 语言中，给出了3种处理系统错误的机制：</p><ul><li>抛出一个异常</li><li>日志</li><li>使用断言</li></ul><p>什么时候应该选择使用断言呢？ 请记住下面几点：</p><ul><li>断言失败是致命的、 不可恢复的错误。</li><li>断言检查只用于开发和测阶段(这种做法有时候被戏称为“ 在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”)。  </li></ul><p>因此，<strong>不应该</strong>使用断言向程序的其他部分通告发生了<strong>可恢复性的错误</strong>，或者，不应该作为程序向用户通告问题的手段。断言只应该用于在测试阶段<strong>确定程序内部的错误位置</strong>。<br>下面看一个十分常见的例子：检查方法的参数。是否应该使用断言来检查非法的下标值或null 引用呢？ 要想回答这个问题， 首先阅读一下这个方法的文档。假设实现一个排序方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Sorts the specified range of the specified array in ascending </span></div><div class="line"><span class="comment">numerical order.</span></div><div class="line"><span class="comment">The range to be sorted extends from fromlndex, inclusive, </span></div><div class="line"><span class="comment">to tolndex, exclusive.</span></div><div class="line"><span class="comment"><span class="doctag">@param</span> a the array to be sorted.</span></div><div class="line"><span class="comment"><span class="doctag">@param</span> fromlndex the index of the first element (inclusive) </span></div><div class="line"><span class="comment">to be sorted.</span></div><div class="line"><span class="comment"><span class="doctag">@param</span> tolndex the index of the last element (exclusive) to be </span></div><div class="line"><span class="comment">sorted.</span></div><div class="line"><span class="comment">©throws IllegalArgumentException if fromlndex &gt; tolndex</span></div><div class="line"><span class="comment">©throws ArraylndexOutOfBoundsException if fromlndex &lt; 0 or </span></div><div class="line"><span class="comment">tolndex &gt; a.length</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromlndex, <span class="keyword">int</span> tolndex)</span></span></div></pre></td></tr></table></figure></p><p>文档指出，如果方法中使用了错误的下标值，那么就会抛出一个异常。这是方法与调用者之间约定的处理行为。如果实现这个方法，那就必须要遵守这个约定，并抛出表示下标值有误的异常。因此，这里使用断言不太适宜。<br>是否应该断言 a 不是 null 呢？ 这也不太适宜。当 a 是 null 时，这个方法的文档没有指出应该采取什么行动。在这种情况下，调用者可以认为这个方法将会成功地返回，而不会抛出<br>一个断言错误。<br>然而，假设对这个方法的约定做一点微小的改动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@param</span> <span class="function">a the array to be <span class="title">sorted</span> <span class="params">(must not be <span class="keyword">null</span>)</span></span></div></pre></td></tr></table></figure></p><p>现在，这个方法的调用者就必须注意：不允许用 null 数组调用这个方法，并在这个方法的开头使用断言：<code>assert a != null;</code><br>计算机科学家将这种约定称为前置条件(Precondition)。最初的方法对参数没有前置条件， 即承诺在任何条件下都能够给予正确的执行。修订后的方法有一个前置条件，即 a 非空。如果调用者在调用这个方法时没有提供满足这个前置条件的参数， 所有的断言都会失败，并且这个方法可以执行它想做的任何操作。事实上，由于可以使用断言，当方法被非法调用时， 将会出现难以预料的结果。有时候会拋出一个断言错误， 有时候会产生一个 null 指针异常， 这完全取决于类加载器的配置。  </p><h4 id="4-为文档假设使用断言"><a href="#4-为文档假设使用断言" class="headerlink" title="4.为文档假设使用断言"></a>4.为文档假设使用断言</h4><p>很多程序员使用注释说明假设条件。看一下下面的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> = <span class="number">1</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span> <span class="comment">// (i % 3 == 2)</span></div><div class="line">. . .</div></pre></td></tr></table></figure></p><p>在这个示例中，使用断言会更好一些。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">assert</span> i % <span class="number">3</span> == <span class="number">2</span>;</div><div class="line">    . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当然，如果再仔细地考虑一下这个问题会发现一个更有意思的内容。i%3 会产生什么结果？如果 i 是正值，那余数肯定是 0、 1 或 2。如果 i 是负值，则余数则可以是 -1 和-2。然而，实际上都认为 i 是非负值， 因此， 最好在 if 语句之前使用下列断言：<code>assert i &gt;= 0;</code><br>无论如何，这个示例说明了程序员如何使用断言来进行自我检查。前面已经知道，断言是一种测试和调试阶段所使用的战术性工具; 而日志记录是一种在程序的整个生命周期都可以使用的策略性工具。  </p><p><img src="/2017/11/08/Java学习总结之异常处理/ClassLoader.png" alt="fail"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在程序运行过程中&lt;strong&gt;(注意是运行阶段，程序可以通过编译)&lt;/strong&gt;，如果JVM检测出一个不可能执行的操作，就会出现&lt;st
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之集合</title>
    <link href="http://habitdiary.cn/2017/10/23/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>http://habitdiary.cn/2017/10/23/Java学习总结之集合/</id>
    <published>2017-10-23T13:40:35.000Z</published>
    <updated>2018-02-01T11:32:40.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><p>Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Java只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、Bitset和Enumeration接口，其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，但要想建立一个全面的集合类库还需要大量的时间和高超的技能。<br>后来，经过艰难的抉择，设计人员设计出了一组功能完善的数据结构，下面我们来进入集合框架的学习。    </p><h4 id="使用集合的场景"><a href="#使用集合的场景" class="headerlink" title="使用集合的场景"></a>使用集合的场景</h4><p><img src="/2017/10/23/Java学习总结之集合/应用场景.png" alt="fail"></p><h4 id="集合接口与具体实现分离"><a href="#集合接口与具体实现分离" class="headerlink" title="集合接口与具体实现分离"></a>集合接口与具体实现分离</h4><p>Java集合类库将接口与实现分离。比如队列接口，其指出可以在队列的尾部添加元素，在队头删除元素，并可以查找队列中元素的个数等。队列接口的最简形式可能类似下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这个接口并没有说明队列的具体实现，实际上，队列的实现主要有两种方式：<strong>一是使用循环数组，二是使用链表。</strong>如果需要一个循环数组队列，可以使用<strong>ArrayDeque类</strong>;如果需要一个链表队列，就直接使用<strong>LinkedList类</strong>。这两个类都实现了Queue接口。<br>当我们使用队列时，一旦创建了集合就不用关心究竟使用了哪种实现，因此，只有在构建集合时，使用具体的类才有意义。<br>用两种具体类实现Queue接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div></pre></td></tr></table></figure></p><p><strong>注意：一般情况下循环数组比链表更高效，但它是一个有界集合，即容量有限，超过一定范围会进行扩容，降低效率。所以如果处理的数据量较小，优先使用循环数组，但如果程序要收集的对象数量没有上限，最好使用链表实现。</strong><br>在研究API时会发现一组名字以Abstract开头的类，例如，AbstractQueue。这些类是为类库设计者设计的，如果想要实现自己的队列类，会发现扩展AbstractQueue类比实现Queue接口中的所有方法轻松得多。  </p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>在Java类库中，集合类的基本接口是Collection接口，其常用API如下：    </p><ul><li>boolean add(E e)<br>将一个元素添加到集合中。如果由于这个调用改变了集合，返回true。   </li><li>boolean addAll(Collection&lt;? extends E&gt; other)<br>将other集合中的所有元素都添加到这个集合。如果由于这个调用改变了集合，返回true。  </li><li>void clear()  移除这个集合中的所有元素。  </li><li>boolean contains(Object obj)<br>如果这个集合包含了一个与obj相等的对象，返回true。  </li><li>boolean    containsAll(Collection&lt;?&gt; other)<br>如果这个集合包含other集合中的所有元素，返回 true。    </li><li>boolean isEmpty() 如果这个集合没有元素，返回 true。</li><li>Iterator<code>&lt;E&gt;</code>    iterator()<br>返回一个用于访问集合中每个元素的迭代器。  </li><li>boolean remove(Object obj)<br>从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true。  </li><li>boolean removeAll(Collection&lt;?&gt; other)<br>从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true。  </li><li>boolean retainAll(Collection&lt;?&gt; other)<br>仅保留这个集合中那些也包含在other集合里的元素  </li><li>int size()  返回这个集合的元素数。</li><li>Object[]    toArray() 返回这个集合的对象数组。</li><li><code>&lt;T&gt;</code> T[] toArray(T[] arrayToFill)<br>返回这个集合的对象数组。如果arrayToFill足够大，就将集合的元素填入这个数组中，剩余空间补null;否则，分配一个新数组，其成员类型和arrayToFill一样，其长度等于集合的大小，并填充集合元素。  </li><li>default boolean removeIf(Predicate&lt;? super E&gt; filter)<br>从这个集合中删除filter返回true的所有元素。如果这个调用改变了集合，返回true </li></ul><p><strong>注意：在使用Object[] toArray()时不能把返回的Object[]数组成强制类型转换其他类型的数组，因为所有数组类型的父类都是Object，甚至Object[]的父类也是Object，所以这种向下类型转换是错误的,会抛出一个ClassCastException</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer[] array = (Integer[])a.toArray();<span class="comment">// Error</span></div><div class="line">Object[] array =  a.toArray();<span class="comment">// Right</span></div></pre></td></tr></table></figure></p><p> 或者使用<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer[] array = a.toArray(<span class="keyword">new</span> Integer[<span class="number">10</span>]);</div></pre></td></tr></table></figure></p><p> removeIf函数的参数是一个函数式接口Predicate，表示布尔值函数，可以传递一个lambda表达式描述要删除的元素的特征。例如下面的代码可以删除列表中的所有偶数：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.removeIf(e -&gt; e %<span class="number">2</span> == <span class="number">0</span>);</div></pre></td></tr></table></figure></p><p> 同队列，Java也给类库设计者提供了一个AbstractCollection类，其提供了一些例行方法，可以让实现者更容易实现自己的集合类。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p> Collection接口的<code>Iterator&lt;E&gt;    iterator()</code>方法可以返回一个迭代器，它是一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。<br> Iterator接口包含4个方法：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</div></pre></td></tr></table></figure></p><p> C++的STL中的迭代器是根据数组索引建模的，即迭代器指向指定位置的元素。但Java中的迭代器应该理解为位于两个元素之间，其起始位置在所有元素之前。调用next方法，迭代器会<strong>越过一个元素并且返回被越过的元素</strong>。通过next方法可以逐个访问集合中的每个元素，但是如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此,需要在每次调用next方法之前调用hasNext方法。如果迭代器还有剩余供访问的元素，这个方法就返回true。如果要想查看一个集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复调用next方法，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Collection&lt;String&gt; c = . . .;</div><div class="line">Iterator&lt;String&gt; iter = c.iterator();</div><div class="line"><span class="keyword">while</span>(iter.hasNext())</div><div class="line">&#123;</div><div class="line">String element = iter.next();</div><div class="line">   <span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> “for-each”循环可以更简练地表示同样的操作：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String element: c)</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 编译器简单地将”for-each”循环翻译为<strong>带有迭代器的循环</strong>，”for-each”循环可以和任何实现了Iterable接口的对象一起工作，这个接口只包含一个抽象方法：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">Interator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> Iterable接口表示实现它的类是可以迭代的(即可以返回一个迭代器对象)，Collection接口扩展了Iterable接口，所以<strong>对于标准类库中的任何集合都可以使用”for-each”循环</strong><br> Java SE 8提供了一种更简便的方式，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式(它会处理一个元素)。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止,例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iter.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</div></pre></td></tr></table></figure></p><p> <strong>元素被访问的顺序取决于集合类型。</strong>如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次索引加1.如果访问HashSet中的元素，每个元素将会以某种随机的次序出现。但这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说没有影响。<br> Iterator接口的remove方法将会删除<strong>上一次调用next方法</strong>时返回的元素，也就是说，如果要删除某个元素，必须先用next方法越过它：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = c.iterator();</div><div class="line">it.next();<span class="comment">// skip over the first element</span></div><div class="line">it.remove(); <span class="comment">// now remove it</span></div></pre></td></tr></table></figure></p><p>如果在调用remove方法之前没有调用next方法会抛出一个IllegalStateException。<br>如果想删除两个相邻的元素，不能直接连续调用两次remove：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.remove();<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>必须先越过要删除的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.next();</div><div class="line">it.remove();<span class="comment">//OK</span></div></pre></td></tr></table></figure></p><p>所以删除元素必须在刚越过该元素时就进行，否则”过了这个村就没这个店了”  </p><h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><p>Java集合框架为不同类型的集合定义了大量接口，如下图所示：  <img src="/2017/10/23/Java学习总结之集合/集合框架的接口.png" alt="fail" title="集合框架的接口"><br>集合有两个基本接口：<strong>Collection</strong>和<strong>Map</strong>。Collection用于保存一个元素序列，Map用于表示键值对之间的映射关系。在Collection中插入元素使用<code>boolean add(E element)</code>,获取元素使用迭代器访问;在Map中插入元素使用<code>V put(K key,V value)</code>,通过key获取value使用<code>V get(K key)</code><br>List是一个有序集合，允许有null值存在。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，使用一个整数索引访问。前者称为顺序访问，后者称为随机访问。<br>List的重要API如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">* <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素  </span></div><div class="line"><span class="function">* ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素，</span></div><div class="line"><span class="function">   初始位置在索引为index元素的前面，索引从0开始  </span></div><div class="line"><span class="function">* <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span> 在给定位置添加一个元素  </span></div><div class="line"><span class="function">* E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> 删除给定位置的元素并返回这个元素  </span></div><div class="line"><span class="function">* E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> 获取给定位置的元素  </span></div><div class="line"><span class="function">* E <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, E element)</span> </span></div><div class="line"><span class="function">   用新元素取代给定位置的元素，并返回原来那个元素  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素  </span></div><div class="line"><span class="function"> 在列表中第一次出现的位置，如果没有这样的元素返回-1  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素</span></div><div class="line"><span class="function"> 在列表中最后一次出现的位置，如果没有这样的元素返回-1</span></div></pre></td></tr></table></figure></p><p>我们发现List接口提供了多个用于随机访问的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span></div></pre></td></tr></table></figure></p><p>当我们给List接口选择具体实现类时，需要考虑顺序访问和随机访问哪种情况更多，如果随机访问占操作的大多数，应该使用数组或动态列表ArrayList实现List接口，否则应该使用链表LinkedList实现List接口。<br>为了避免对链表进行随机访问，Java定义了一个标记接口RandomAccess，这个接口不包含任何方法，但可以用来测试一个特定的集合是否支持高效的随机访问：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(c <span class="keyword">instanceof</span> RandomAccess)</div><div class="line">&#123;</div><div class="line">use random access algorithm</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">use sequential access algorithm</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不建议在LinkedList实现的List列表中使用get、set等随机访问方法，此时应该通过一个ListIterator顺序访问列表。<br>ListIterator接口是Iterator的一个子接口，它是一种更灵活的迭代器，只用于List。下面是ListIterator的重要API：  </p><ul><li>void add(E newElement) 在当前位置前添加一个元素  </li><li>void set(E newElement) 用新元素取代next或previous上次访问的元素。</li><li>boolean hasPrevious() 当反向迭代列表时，还有可供访问的元素，返回true  </li><li>E previous() 返回前一个对象，如果已经到达了列表的头部，就抛出一个NoSuchElementException  </li><li>int nextIndex() 返回下次调用next方法时将返回元素的索引  </li><li>int previous() 返回下次调用previous方法时将返回元素的索引  </li></ul><p><strong>并发修改：</strong>如果在一个迭代器修改集合时，另一个迭代器对它进行遍历，一定会出现混乱。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = . . .;</div><div class="line">ListIterator&lt;String&gt; iter1 = list.ListIterator();</div><div class="line">ListIterator&lt;String&gt; iter2 = list.ListIterator();</div><div class="line">iter1.next();</div><div class="line">iter1.remove();</div><div class="line">iter2.next();<span class="comment">//throws ConcurrentModificationException</span></div></pre></td></tr></table></figure></p><p>上述代码中iter2迭代器在遍历链表时，iter1修改了链表结构，iter2会检测到这种变化，抛出一个ConcurrentModificationException。<br>为了避免出现并发修改异常，请遵循下述简单规则：<strong>可以根据需要给容器附加许多迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读也写的迭代器</strong>。<br>通过调用AbstractCollection类的toString方法可以打印出集合中的所有元素。<br><strong>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集(Set)的add方法不允许增加重复的元素,允许有null值，当然只允许一个null值。要适当定义equals方法：只要两个集包含同样的元素就认为是相等的，而不要求有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。<br>SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集试图的方法。<br>最后，Java SE 6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集和映射的方法，TreeSet和TreeMap实现了这些接口。</strong>  </p><h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p>下面是Java库中的具体集合和集合框架中的类<br><img src="/2017/10/23/Java学习总结之集合/Java库中的具体集合.png" alt="fail" title="Java库中的具体集合"><br><img src="/2017/10/23/Java学习总结之集合/集合框架中的类.png" alt="fail" title="集合框架中的类"></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList是链表类，相较于数组以及动态的ArrayList类，能够更高效地从集合的中间位置插入、删除元素，Java中的LinkedList类是<strong>双向链接</strong>的。<br>除了实现了Collection接口和List接口之外，LinkedList还提供了以下API：  </p><ul><li>LinkedList() 构造一个空链表  </li><li>LinkedList(Collection&lt;? extends E&gt; elements)<br>构造一个链表，并将集合中的所有元素添加到这个链表中  </li><li>void addFirst(E element) 将某个元素添加到列表的头部  </li><li>void addLast(E element) 将某个元素添加到列表的尾部  </li><li>E getFirst 返回列表头部的元素  </li><li>E getLast 返回列表尾部的元素  </li><li>E removeFirst() 删除并返回列表头部的元素 </li><li>E removeLast() 删除并返回列表尾部的元素    </li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList是动态数组列表，适用于常常要随机访问元素的情况。下面给出ArrayList的常用API：  </p><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  </li></ul><p><strong>ArrayList和Vector的区别：</strong>Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vector对象，然而如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。所以建议在不需要同步的时候使用ArrayList，而不要使用Vector</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>链表和数组可以按照人们的意愿排列元素的次序，但如果要查看某个元素，却忘记了它的位置，需要访问所有元素直到找到为止，将会消耗很多时间。<br>HashSet是一种基于<strong>散列表</strong>的集，实现了Set接口，它无法控制元素的次序，但可以快速查找元素。散列表基于散列码，散列码由类的hashCode方法提供，用于将元素插入散列表的特定位置，hashCode和equals方法应该兼容，即使用equals方法返回true的两个对象应该有相同的散列码，<strong>一个自定义类如果重写了equals方法就必须要重写hashCode方法，以便于将该类的对象插入散列表中。否则HashSet无法知道插入的两个对象是否相同，无法保证集合元素的唯一性。这两个方法的重写在eclipse的source菜单里也有快捷添加选项。</strong><br>在Java中，散列表用链表数组实现，每个<strong>散列单元</strong>被称为<strong>桶</strong>。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，如果桶中没有元素，可以直接插入，如果已经有元素，即发生<strong>散列冲突</strong>，则需要将新元素和桶中已有的所有元素进行比较，如果桶中有元素和新元素相等，就不插入，反之插入。<strong>注意：在HashSet的一个桶中可以有多个不同元素，即使用链地址法解决冲突。</strong>如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。这样，当我们在HashSet中查找某元素时，不必像在线性表中一样循环遍历整个表来比较，只需要根据散列规则找到对应的桶，对桶里的元素进行遍历比较即可。<br><strong>所以，从上面的分析我们可以得到equals方法和hashCode方法之间的关系：</strong><br>1、如果重写了equals方法，必须重写hashCode方法，因为两个对象的euqals方法如果返回true,它们的hashCode值一定要相同。<br>2、如果两个对象的hashCode值相同，它们并不一定相同，比如HashSet中同一个桶中的对象就是发生了散列冲突的具有相同hashCode值的对象。它们的equals方法有可能返回false。  </p><p>这就是为什么我们在HashSet使用时要同时重写这两个方法的原因，重写hashCode方法以进行桶间的查找，重写equals方法以进行同一个桶内对象的比较。<br>在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。<br>如果想更多地控制散列表的运行性能，就要指定一个初始桶数。通常将桶数设置为预计元素个数的75% ~ 150%,最好将桶数设置为一个<strong>素数</strong>,以防键的集聚。标准类库使用的桶数是2的幂，默认值为16,<strong>为散列表的大小提供的任何值都被自动转换为2的下一个幂</strong>。<br>如果最初的估计过低，散列表太满，散列表会进行再散列，创建一个桶数更多的表。<strong>装填因子</strong>决定何时再散列，比如装填因子为0.75，当散列表中超过75%的位置已经填入了元素，这个表就会用双倍的桶数自动进行再散列，大多数情况装填因子为0.75是比较合理的。<br>下面是HashSet的常用API：  </p><ul><li>HashSet() 构造一个空散列集  </li><li>HashSet(Collection&lt;? extends E&gt; elements)<br>构造一个散列集，并将集合中的所有元素添加到这个散列集中 </li><li>HashSet(int initialCapacity) 构造一个具有指定容量(桶数)的散列集  </li><li>HashSet(int initialCapacity,float loadFactor) 构造一个具有指定容量和装填因子(一个0.0 ~ 1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集      </li></ul><p><strong>特别要注意,在HashSet中没有get和set方法，因为HashSet是无序集，不存在索引概念，如果要访问HashSet中的元素应该使用迭代器，另外contains方法也被重新定义，可以快速查看某个元素是否出现在集中，此时不用查看集中的所有元素，只用通过散列码定位到一个桶，查看这个桶中的所有元素即可</strong>  </p><p>如果要查找HashSet中符合某条件的对象，可以使用迭代器遍历或者使用foreach循环遍历HashSet。如果要删除符合某条件的对象，如果在for-each循环中边删除边遍历会抛出一个并发修改异常ConcurrentModificationException，此时有两种解决方案：<br>1、如果只删除一个元素，就在remove之后break即可<br>2、如果要删除多个元素，就先把要删除的元素添加到另一个集合中，循环结束后调用removeAll的求差集方法删除目标子集即可。  </p><p><strong>还可以使用迭代器遍历来避免这种情况。</strong></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet和HashSet十分类似，不过当元素以任意顺序插入TreeSet时，TreeSet会保证元素是有序排列的。其底层是由<strong>红黑树</strong>实现的,每次将一个元素添加到树中，都被放置在正确的排序位置上。<br><strong>一个元素添加到树中比添加到散列表中慢</strong>，但是与检查数组或链表中的重复元素相比还是快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。如果对集合中的元素次序没有要求，应该使用HashSet而不是TreeSet，即使排序的花销不大，但也会影响效率。<br><strong>注意：要使用TreeSet，插入的元素必须可排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator</strong><br>从Java SE 6起,TreeSet类实现了Navigable接口，这个接口增加了几个便于定位元素以及反向遍历的方法。  </p><p>下面是TreeSet的常用API：  </p><ul><li>TreeSet() 构造一个空树集  </li><li>TreeSet(Collection&lt;? extends E&gt; elements)<br>构造一个空树集，并将集合中的所有元素添加到这个树集中  </li><li>TreeSet(Comparator&lt;? super E&gt; comparator)  构造一个空树集  </li><li>TreeSet(SortedSet&lt;<code>E</code>&gt; s)<br>构造一个空树集，并将有序集中的所有元素添加到这个树集中，并使用与给定的有序集相同的比较器</li></ul><p>下面是SortedSet的常用API：  </p><ul><li>Comparator&lt;? super E&gt; comparator()<br>返回用于对元素进行排序的比较器。如果元素用Comparable接口的compareTo方法进行比较则返回null  </li><li>E first() 返回有序集中的最小元素  </li><li>E last() 返回有序集中的最大元素   </li></ul><p>下面是NavigableSet的常用API： </p><ul><li>E higher(E value)  </li><li>E lower(E value)<br>返回大于value的最小元素或小于value的最大元素，如果没有这样的元素则返回null  </li><li>E ceiling(E value)  </li><li>E floor(E value)<br>返回大于等于value的最小元素或小于等于value的最大元素，如果没有这样的元素则返回null  </li><li>E poolFirst()  </li><li>E pollLast()<br>删除并返回这个集合中的最大元素或最小元素，这个集合为空时返回null  </li><li>Iterator&lt;<code>E</code>&gt; descendingIterator()<br>返回一个按照递减顺序遍历集中元素的反向迭代器  </li></ul><h4 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h4><p>Deque(双端队列)接口继承自Queue(队列)接口，与之有所不同的是，双端队列可以在队列的头部和尾部添加或删除元素，但也不支持在队列中间添加或删除元素。<br>和普通队列一样，双端队列也可以用ArrayDeque和LinkedList实现。  </p><p>下面是Queue的常用API：  </p><ul><li>boolean add(E element)  </li><li>boolean offer(E element)<br>都是将一个元素入队并返回true，如果队列已满，前者会抛出一个IllegalStateException，后者则返回false  </li><li>E remove()  </li><li>E poll()<br>都是将队头元素出队并返回，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null  </li><li>E element()  </li><li>E peek()<br>都是取队头元素但不删除，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null   </li></ul><p>下面是Deque的常用API：  </p><ul><li>void addFirst(E element)  </li><li>void addLast(E element)  </li><li>boolean offerFirst(E element)  </li><li>boolean offerLast(E element)<br>都是将给定元素添加到双端队列的头部或尾部，如果队列满了，前两个方法会抛出一个IllegalStateException，后两个方法则返回false  </li><li>E removeFirst()  </li><li>E removeLast()  </li><li>E pollFirst()  </li><li>E pollLast()<br>都是删除双端队列的头部或尾部并返回元素，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li><li>E getFirst()  </li><li>E getLast() </li><li>E peekFirst()  </li><li>E peekLast()<br>都是返回双端队列的头部或尾部元素但不删除，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li></ul><p>下面是ArrayDeque的常用API：  </p><ul><li>ArrayDeque() 用默认初始容量16构造一个空队列  </li><li>ArrayDeque(int initialCapacity) 用指定容量构造一个空队列    </li></ul><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先出队。优先队列具有最高级先出(first in, largest out)的行为特征。<br>PriorityQueue的底层是通过堆(小根堆，<strong>将较小的元素设为最高优先级</strong>)实现的，堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。<br>PriorityQueue是一个实现了Queue接口的具体类。<br><strong>和TreeSet一样，要实现排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator。</strong>  </p><p><strong>注意：</strong>方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。原因是PriorityQueue内部是一个堆，堆只能保证根具有最高的优先级，但整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历，也就是只能保证数组的第一个元素具有最高优先级。但如果将元素依次出队，出队顺序可以保证是有序的，这是因为在每一次出队后堆会进行调整，将下一个优先级最高的元素移动到根。</p><p>下面是PriorityQueue的常用API：  </p><ul><li>PriorityQueue() 构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity)<br>用指定容量构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity,Comaparator&lt;? super E&gt; c)<br>用指定容量构造一个空优先队列,并指定比较器对元素进行排序  </li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>集(Set)是一个集合，它可以快速查找现有元素。但是，有时我们知道某些键的信息，并想要查找与之对应的元素。映射(map)数据结构就是为此设计的，map用来存放键值对(Key-value)，key-value以Entry类型的对象实例存在，Entry对象是无序排列的。允许使用null键和null值(当然只允许有一个null键)，提供键(Key)就能快速查找到值(Value)。Key不允许重复，每个Key最多只能映射到一个Value。<br>Java类库为映射提供了两个实现：HashMap和TreeMap，这两个类都实现了Map接口。<br>HashMap(散列映射)对<strong>键</strong>进行散列，键值对是无序的。TreeMap(树映射)用<strong>键</strong>的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。<strong>与集一样，HashMap比TreeMap快一些，如果不需要按照排列顺序访问键，就最好选择散列。</strong>  </p><p>下面是Map接口的常用API：  </p><ul><li>V get(Object key)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回null  </li><li>default V getOrDefault(Object key,V defaultValue)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回defaultValue  </li><li>V put(K key,V value)<br>将键与对应的值关系插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象，并返回键对应的旧值，如果这个键以前没有出现过则返回null。<strong>键可以为null，但值不能为null</strong>  </li><li>V putAll(Map&lt;? extends K,? extends V&gt; entries)<br>将给定映射中的所有条目添加到这个映射中  </li><li>boolean containsKey(Object key)<br>如果在映射中已经有这个键，返回true </li><li>boolean containsValue(Object value)<br>如果在映射中已经有这个值，返回true  </li><li>default void forEach(BiConsumer&lt;? super K,? super V&gt; action)<br>对这个映射中的所有键值对应用这个动作，参数是一个函数式接口类型，可以传入一个lambda表达式,例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scores.forEach((k,v) -&gt; </div><div class="line">System.out.println(<span class="string">"key="</span> + k + <span class="string">", value="</span> + v));</div></pre></td></tr></table></figure></li></ul><p>下面是HashMap的常用API：   </p><ul><li>HashMap()  构造一个空散列映射</li><li>HashMap(int initialCapacity) 用指定容量构造一个空散列映射 </li><li>HashMap(int initialCapacity,float LoadFactor)<br>用指定容量和装填因子构造一个空散列映射，默认的装填因子是0.75  </li></ul><p>下面是TreeMap的常用API：   </p><ul><li>TreeMap() 构造一个空树映射  </li><li>TreeMap(Comparator&lt;? super K&gt; c)<br>构造一个空树映射，并使用一个指定的比较器对键进行排序  </li><li>TreeMap(Map&lt;? extends K,? extends V&gt; entries) 构造一个空树映射，并将某个映射的所有条目添加到树映射中   </li><li>TreeMap(SortedMap&lt;? extends K,? extends V&gt; entries)<br>构造一个空树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器  </li></ul><p>下面是SortedMap的常用API：   </p><ul><li>Comparator&lt;? super K&gt; comparator()<br>返回对键进行排序的比较器。如果键是用Comparable接口的compareTo方法进行比较的，返回null  </li><li>K firstKey()  </li><li>K lastKey()<br>返回映射中最小元素和最大元素  </li></ul><h4 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h4><p>假设我们要统计一个单词在文件中出现的次数，当得到一个单词时，我们将其计数器加1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>但这可能会出错，如果word第一次出现，counts.get(word)会返回null，从而抛出一个NullPointerException。  </p><p>为了避免这种情况，我们可以用<strong>getOrDefault方法</strong>来取代get方法，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.getOrDefault(word,<span class="number">0</span>) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>另一种方法是首先调用<strong>putIfAbsent方法</strong>，这个方法会在映射中不存在word时插入键值对初始化word的值为0：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">counts.putIfAbsent(word,<span class="number">0</span>);</div><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>还可以做得更好,<strong>merge方法</strong>可以简化这个常见操作。如果键原先不存在，则下面的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.merge(word,<span class="number">1</span>,Integer::sum);</div></pre></td></tr></table></figure></p><p>将把word和1关联，如果word存在，则会使用Integer::sum函数组合原值和1(也就是将原值和1求和)  </p><h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><p>集合框架不认为映射本身是一种集合，不过可以得到映射视图 —— 这是实现了Collection接口或某个子接口的对象。<br>有三种视图：键集、值集合<strong>(不是一个集)</strong>、键值对集。<strong>键集</strong>和<strong>键值对集</strong>是集，因为一个映射中的键是唯一的，但值不能构成集，只能是值集合，因为一个映射中可以有多个相同的值。<br>下面的方法可以从映射中返回这三种视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></div><div class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></div><div class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p><p><strong>需要说明的是，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口，所以可以向使用集合一样使用keySet</strong>  </p><p>键值对是Map.Entry<code>&lt;K,V&gt;</code>类型的，可以使用entrySet()方法返回映射的键值对集，再通过循环对于每个键值对对象使用，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Employee&gt; entry: staff.entrySet())</div><div class="line">&#123;</div><div class="line">String k = entry.getKey();</div><div class="line">    Employee v = entry.getValue();</div><div class="line">    <span class="comment">// do something with k,v</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>getKey方法获取该键值对的键，getValue方法获取该键值对的值，setValue方法将键值对的值设置为新值并返回原值。<br>当然查看键值对最高效的方法是使用forEach方法</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">counts.forEach((k,v) -&gt; &#123;</div><div class="line"><span class="keyword">do</span> something with k,v</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p><strong>注意:</strong>可以在键集视图上调用迭代器的remove方法，结果会在映射中删除这个键和与它关联的值，但不能调用add方法，否则会抛出一个UnsupportedOperationException;可以在值集合视图删除元素，所删除的值和相应的键将从映射中删除，也不能增加元素;可以在键值对集合中删除元素，将从映射中删除相应的键值对，但也不能增加元素。<strong>总之，可删不可增。</strong>  </p><h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p>当一个映射中引用某个值的所有键都消亡，即没有任何途径引用这个值时，这个值成为了无用对象。但是垃圾回收器跟踪<strong>活动的对象</strong>，只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收。于是，长期存活的映射中可能会存在一些无用的值，此时需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用WeakHashMap。当对键的唯一应用来自散列条目时，这种数据结构会协助垃圾回收期协同工作一起删除键值对。<br>下面是这种机制的内部运行情况。WeakHashMap使用<strong>弱引用</strong>保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种特定类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。  </p><p><img src="/2017/10/23/Java学习总结之集合/WeakHashMap.png" alt="fail"></p><p>更多细节见：<a href="http://mikewang.blog.51cto.com/3826268/880775/" target="_blank" rel="external">深入理解WeakHashMap</a>  </p><h4 id="LinkedHashSet-amp-LinkedHashMap"><a href="#LinkedHashSet-amp-LinkedHashMap" class="headerlink" title="LinkedHashSet &amp; LinkedHashMap"></a>LinkedHashSet &amp; LinkedHashMap</h4><p>LinkedHashSet和LinkedHashMap会按照<strong>元素插入顺序</strong>存放元素或键值对。当条目插入到表中时，就会并入到双向链表中。<br><img src="/2017/10/23/Java学习总结之集合/双向链表.png" alt="fail"><br>也可以使用<code>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</code>来构造一个按照<strong>元素访问顺序</strong>迭代键值对的LinkedHashMap。每次调用get或put，受到影响的条目将从当前位置删除，并放到条目链表的尾部(只有条目在链表中位置会受影响，而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中)。<br>访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已满时，可以将迭代器加入到表中，并将前几个元素删除掉。这些是近期最少使用的几个元素。<br>甚至可以让这一过程自动化。即构造一个LinkedHashMap的子类，然后覆盖下面的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></div></pre></td></tr></table></figure></p><p>每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。例如，下面的高速缓存可以存放100个元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Map&lt;K, V&gt; cache = <span class="keyword">new</span> </div><div class="line">LinkedHashMap&lt;&gt;(<span class="number">128</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>)</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() &gt; <span class="number">100</span>; </div><div class="line">        <span class="comment">/*当元素个数 &lt;= 100，直接插入元素，</span></div><div class="line"><span class="comment">        否则进行替换，删除“最近最少使用”的元素，</span></div><div class="line"><span class="comment">        插入新元素*/</span></div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p><p>另外，还可以对eldest条目进行评估，以此决定是否应该将它删除。例如，可以检查与这个条目一起存在的时间戳。<br><img src="/2017/10/23/Java学习总结之集合/LinkedHashSet.png" alt="fail"></p><p><img src="/2017/10/23/Java学习总结之集合/LinkedHashMap.png" alt="fail"></p><h4 id="EnumSet-amp-EnumMap"><a href="#EnumSet-amp-EnumMap" class="headerlink" title="EnumSet &amp; EnumMap"></a>EnumSet &amp; EnumMap</h4><p>EnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1.<br>EnumSet没有公共的构造器，可以使用静态工厂方法构造这个集，下面给出得到EnumSet的几个常用方法：<br><img src="/2017/10/23/Java学习总结之集合/枚举集.png" alt="fail"><br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;</div><div class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</div><div class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</div><div class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);</div><div class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY);</div></pre></td></tr></table></figure></p><p>可以使用Set接口的常用方法来修改EnumSet<br>EnumMap是一个<strong>键类型</strong>为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时，需要在构造器中指定键类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EnumMap&lt;Weekday, Employee&gt; personInChange = <span class="keyword">new</span> EnumMap&lt;&gt;(Weekday.class);</div></pre></td></tr></table></figure></p><p>这样就构造了一个键为Weekday类型的空映射。</p><h4 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h4><p>类IdentityHashMap有特殊的作用。在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。而且，在对两个对象进行比较时，IdentityHashMap类使用 == ，而不使用equals<br>也就是说，不同的键对象，即使内容相同，也被视为不同的对象。在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况。<br><img src="/2017/10/23/Java学习总结之集合/IdentityHashMap.png" alt="fail"></p><h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>通过使用<strong>视图</strong>可以获取其他的实现了Collection接口或Map接口的对象，映射类的keySet方法就是这样一个示例。这个方法看似创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。<strong>然而事实并非如此，keySet方法返回一个实现了Set接口的类对象，这个类的方法对原映射进行操作。这样的集合称为视图。</strong>  </p><h4 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h4><p>Arrays类的静态方法asList将返回一个<strong>包装了普通Java数组的List包装器</strong>。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</div><div class="line">   ...</div><div class="line">   List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</div></pre></td></tr></table></figure></p><p>返回的对象不是ArrayList，而是一个视图对象，带有访问底层数组的get和set方法。<br><strong>改变数组大小的所有方法(例如，与迭代器相关的add和remove方法)都会抛出一个UnsupportedOperationException。</strong><br>asList方法可以接收可变数目的参数，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span>,<span class="string">"Bob"</span>,<span class="string">"Carl"</span>);</div></pre></td></tr></table></figure></p><p>这个方法调用<code>Collections.nCopies(n,anObject)</code><br>将返回一个实现了List接口的<strong>不可修改的对象</strong>，并给人一种包含n个元素，每个元素都像是一个anObject的错觉。<br>例如，下面的调用将创建一个包含100个字符串的List，每个串都被设置为”DEFAULT”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; settings = Collections.nCopies(<span class="number">100</span>,<span class="string">"DEFAULT"</span>);</div></pre></td></tr></table></figure></p><p>存储代价很小，可用于不需要修改元素的情况。这是视图技术的一种巧妙的应用。<br><strong>注意：</strong>Collections类包含很多使用的方法，这些方法的参数和返回值都是集合，不要将它和Collection接口混起来。  </p><p>如果调用以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.singleton(anObject);</div></pre></td></tr></table></figure></p><p>将返回一个实现了Set接口的视图对象(与产生List视图的ncopies方法不同)，即一个不可修改的单元素集，而不需要付出建立数据结构的开销。singletonList方法与singletonMap方法类似。<br>类似地，对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等等。特别是，集的类型可以推导得出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; deepThoughts = Collections.emptySet();</div></pre></td></tr></table></figure></p><h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立子范围视图。例如，假设有一个列表staff，想从中取出第10个-第19个元素。可以使用subList方法来获得一个列表的子范围视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List group2 = staff.subList(<span class="number">10</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure></p><p>第一个索引包含在内，第二个索引则不包含在内。可以将<strong>任何操作</strong>应用于子范围，该操作会影响整个列表。例如，可以删除整个子范围：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">group2.clear();</div></pre></td></tr></table></figure></p><p>现在，staff列表中该范围的元素也被删除，并且group2为空。<br>对于SortedSet和SortedMap，可以使用排序顺序而不是元素位置建立子范围。SortedSet接口声明了3个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,E to)</span></span></div><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></span></div><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></span></div></pre></td></tr></table></figure></p><p>这些方法返回大于等于from且小于to的所有元素构成的子集。</p><p>SortedMap也有类似的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K from,K to)</span></span></div><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span></div><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span></div></pre></td></tr></table></figure></p><p>返回映射视图，该映射包含<strong>键</strong>落在指定范围内的所有元素。<br>Java SE 6引入的NavigableSet接口赋予子范围操作更多控制能力。可以指定是否包括边界：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive,E to,<span class="keyword">boolean</span> toInclusive)</span></span></div><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to,<span class="keyword">boolean</span> toInclusive)</span></span></div><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from,<span class="keyword">boolean</span> fromInclusive)</span></span></div></pre></td></tr></table></figure></p><h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p><img src="/2017/10/23/Java学习总结之集合/不可修改的视图1.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/不可修改的视图2.png" alt="fail"></p><h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p><img src="/2017/10/23/Java学习总结之集合/同步视图.png" alt="fail"></p><h4 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h4><p><img src="/2017/10/23/Java学习总结之集合/受查视图.png" alt="fail"></p><h4 id="关于可选操作的说明"><a href="#关于可选操作的说明" class="headerlink" title="关于可选操作的说明"></a>关于可选操作的说明</h4><p><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明2.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明3.png" alt="fail"></p><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>内容较多，见Java核心技术卷一 P388 ~ P396，并查阅相关API</p><h3 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h3><p>见Java核心技术 P396 ~ P402</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h3&gt;&lt;p&gt;Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Jav
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之泛型程序设计</title>
    <link href="http://habitdiary.cn/2017/10/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://habitdiary.cn/2017/10/22/Java学习总结之泛型程序设计/</id>
    <published>2017-10-22T01:09:10.000Z</published>
    <updated>2018-02-01T14:54:17.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h3><p>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，这是一个泛型程序设计的实例。实际上，在Java增加泛型类之前已经有一个ArrayList类，下面来研究泛型程序设计机制是如何演变的。  </p><h3 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h3><p>在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayLists类只维护一个Object引用的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] elementData;</div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; . . . &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123; . . . &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种方法有两个问题，我们以一个保存文件名的files数组列表为例：<br>1) 当获取一个值时必须进行强制类型转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList files = <span class="keyword">new</span> ArrayList();</div><div class="line">. . .</div><div class="line">String filename = (String)files.get(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>2) 当添加一个值时不进行类型检查，可以添加任何类的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">files.add(<span class="keyword">new</span> File(<span class="string">". . ."</span>));</div></pre></td></tr></table></figure></p><p>此调用在编译和运行时都不会出错，但如果将get的结果强制转换为String会产生一个错误  </p><p>为了解决上述问题，引入了类型参数。ArrayList有一个类型参数用来指示元素类型：<code>ArrayList&lt;T&gt; files = new ArrayList&lt;T&gt;();</code>，<strong>注意前后两个T必须一致，不能是子类和父类！</strong>在Java SE 7及以后的版本，构造函数可以省略类型参数，即<code>ArrayList&lt;T&gt; files = new ArrayList&lt;&gt;();</code><br>这种方法有三个好处：<br>1)get得到的值不必进行强制类型转换<br>2)向数组列表中添加对象时会进行类型检查，如果不符合类型，无法通过编译，出现编译错误比类在运行时出现类的强制转换异常要好得多<br>3)程序具有更好的可读性，比如<code>ArrayList&lt;String&gt; files</code>一看就是聚集了String对象的数组列表  </p><h3 id="定义简单的泛型类"><a href="#定义简单的泛型类" class="headerlink" title="定义简单的泛型类"></a>定义简单的泛型类</h3><p>一个泛型类就是具有一个或多个类型变量的类，下面使用一个简单的Pair类作为例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> T first;</div><div class="line">    <span class="keyword">private</span> T second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair类引入了一个类型变量T，用尖括号括起来，并放在类名的后面。<strong>注意这里的T只是指定了一种类型，不代表类只有一个属性成员，而表示接下来类中出现的T都和尖括号里的类型保持一致,即类定义的类型变量指定方法返回类型以及域和局部变量的类型。</strong><br>泛型类可以有多个类型变量，如可以定义两个域类型不同的Pair类<code>public class Pair&lt;T,U&gt; {. . .}</code><br><strong>类型变量命名规则：</strong>E表示集合的元素类型，K和V分别表示表的关键字和值的类型，T(需要时还可以用临近的字母U和S)表示“任意类型”。<br>实际使用中将类定义尖括号里的T替换为具体类型，类中的T也会进行相应的替换，所以，<strong>泛型类可以看作普通类的工厂</strong>  </p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>前面介绍了如何定义一个泛型类，下面我们来定义一个带有类型参数的简单泛型方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1)类型变量放在修饰符(这里是public static)的后面，返回类型的前面<br>2)泛型方法可以定义在普通类中，也可以定义在泛型类中<br>3)当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q."</span>,<span class="string">"Public"</span>);</div></pre></td></tr></table></figure></p><p><strong>我们注意到上面的泛型方法的参数必须是T类型，如果想要传入T类型的子类怎么办呢？我们可以把<code>&lt;T&gt;</code>改为<code>&lt;? extends T&gt;</code>，这样参数就可以接受T类型以及它的子类。类似的<code>&lt;? super T&gt;</code>则表示参数可以为T类型以及它的超类。</strong></p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时，类或方法需要对类型变量加以约束。下面是一个典型的例子，我们要计算数组中的最小元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        T smallest = a[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length;i++)</div><div class="line">        <span class="keyword">if</span>(smallest.compareTo(a[i]) &gt; <span class="number">0</span>)</div><div class="line">            smallest = a[i];</div><div class="line">        <span class="keyword">return</span> smallset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们会发现一个问题，smallest的类型为T，既可以是任何一个类的对象，如何保证T类型有compareTo方法呢？<strong>解决方法是限制T为实现了Comparable接口的类</strong>，即将泛型方法定义改为<code>public static &lt;T extends Comparable&gt; T min(T[] a)</code><br><strong>注意：</strong><br>1)限定类时如果实现的是接口也用extends关键字，如上面的<code>T extends Comparable</code><br>2)只需要在尖括号里限定，之后的T不用再加限定  </p><p>一个类型变量或通配符可以有多个限定，用’&amp;’分隔限定类型，用逗号分隔类型变量，例如：<code>T extends Comparable &amp; Serializable</code> <strong>可以有多个接口限定和至多一个类限定，将标记接口(空接口)放在限定列表的末尾，如果用一个类作为限定，它必须是限定列表中的第一个</strong>  </p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p><strong>对于虚拟机来说没有泛型类型，只有普通类和方法。无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。在编译时泛型类型会被转化为原始类型。</strong>原始类型就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(无限定类型的变量替换为Object)。<br>例如，<code>Pair&lt;T&gt;</code>的原始类型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object first;</div><div class="line">    <span class="keyword">private</span> Object second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first,Object second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>因为T是一个无限定的参数变量，所以直接用Object替换<br>如果是T是一个限定类型的参数变量，用限定列表中的第一个类型替换，比如<code>T extends Comparable &amp; Serializable</code>被替换为<code>Comparable</code>  </p><h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><p>当泛型表达式编译时，编译器会将其编译为原始类型并加入强制类型转换。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Employee&gt; buddies = . . . ;</div><div class="line">Employee buddy = buddies.getFirst();</div></pre></td></tr></table></figure></p><p>编译器会把这个方法调用翻译为两条虚拟机指令：  </p><ul><li>对原始方法Pair.getFirst的调用  </li><li>将返回的Object类型强制转换为Employee类型  </li></ul><p>当存入一个泛型域时编译器也会自动在字节码中插入强制类型转换。  </p><h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><p>类型擦除会发生一些问题，比如一个类subPair继承自类<code>Pair&lt;String&gt;</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">String</span>&gt; //继承一个泛型类</span></div><div class="line"><span class="class"> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;<span class="comment">//重写了父类的方法</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair在编译的时候被类型擦除，Pair的setFirst方法变为了setFirst(Object newValue)，这样SubPair的setFirst(Stirng newValue)方法就无法覆盖父类中的setFirst(Object newValue)方法，因为参数不同，不是同一个方法。<br>SubPair中会出现两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span>&#123;....&#125;</div></pre></td></tr></table></figure></p><p>此时如果有如下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SubPair p = <span class="keyword">new</span> SubPair(. . .);</div><div class="line">Pair&lt;String&gt; pair = p;</div><div class="line">p.setFirst(<span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure></p><p>按理来说，这段测试代码应该不能通过编译，因为要实现多态的话，所调用的方法必须在子类中重写，但是在这里SubPair类并没有重写Pair类中的setFirst方法，只是单纯的继承而已，并且新加了一个参数不同的同名方法。<br>但结果可以运行，因为为了解决这种<strong>类型擦除和多态的冲突</strong>，编译器会在SubPair类中生成一个桥方法，上述两个方法被编译器变成了这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125; <span class="comment">//子类定义的方法不变</span></div><div class="line"></div><div class="line"><span class="comment">//编译器生成的桥方法 </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   setFirst((String) newValue);</div><div class="line">   <span class="comment">//桥内部调用的是子类中定义的setFirst(String newValue)方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看出，这个桥方法实际上就是对超类中setFirst(Object newValue)的重写。这样做的原因是，当程序员在子类中写下setFirst(String newValue)方法时，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免<strong>类型擦除与多态发生冲突。</strong><br>详见博客：<a href="http://www.cnblogs.com/xz816111/p/7643323.html" target="_blank" rel="external">Java中的类型擦除与桥方法</a>  </p><h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><p>在使用Java泛型时需要考虑一些限制。大多数限制都是由类型擦除引起的。  </p><h4 id="1-不能用基本类型实例化类型参数"><a href="#1-不能用基本类型实例化类型参数" class="headerlink" title="1.不能用基本类型实例化类型参数"></a>1.不能用基本类型实例化类型参数</h4><p>类型参数不能为基本类型。比如，没有<code>Pair&lt;double&gt;</code>只有<code>Pair&lt;Double&gt;</code>,其原因是类型擦除，因为擦除之后，Pair类含有Object类型的域，Object不能存储double值。  </p><h4 id="2-运行时类型查询只适用于原始类型"><a href="#2-运行时类型查询只适用于原始类型" class="headerlink" title="2.运行时类型查询只适用于原始类型"></a>2.运行时类型查询只适用于原始类型</h4><p>使用instanceof查询一个对象是否属于某个泛型类会产生编译错误，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;)<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>同样的道理，getClass方法总是返回原始类型。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; stringPair = . . .;</div><div class="line">Pair&lt;Employee&gt; employeePair = . . .;</div><div class="line"><span class="keyword">if</span>(stringPair.getClass() == employeePair.getClass()) <span class="comment">//equal</span></div></pre></td></tr></table></figure></p><p>其比较结果是true，因为两次调用getClass结果都返回Pair.class  </p><h4 id="3-不能创建参数化类型的数组"><a href="#3-不能创建参数化类型的数组" class="headerlink" title="3.不能创建参数化类型的数组"></a>3.不能创建参数化类型的数组</h4><p>不能实例化参数化类型的数组，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt; [<span class="number">10</span>];<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>最安全而有效的方法是使用ArrayList，即<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>  </p><h4 id="4-Varargs警告"><a href="#4-Varargs警告" class="headerlink" title="4.Varargs警告"></a>4.Varargs警告</h4><p>考虑下面的方法，它有可变长的泛型类型参数ts：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll,T...ts)</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(t : ts) coll.add(t);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>现在如果调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Collection&lt;Pair&lt;String&gt;&gt; table = . . .;</div><div class="line">Pair&lt;String&gt; pair1 = . . .;</div><div class="line">Pair&lt;String&gt; pair2 = . . .;</div><div class="line">addAll(table,pair1,pair2);</div></pre></td></tr></table></figure></p><p>JVM会为了可变长参数建立一个Pair<string>数组，这违反了前面的规则。<br><strong>这里特别注意</strong>：Java不支持泛型类型的数组，但如果向参数个数可变的方法传递一个泛型类型的实例(即传递一个泛型类型对象的数组)这种规则有所放松，你只会得到一个警告，而不是错误。可以用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>或用<code>@SafeVarags</code>标注addAll方法来抑制警告。<br>即如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SafeVarargs</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll,T...ts)</span></span></div></pre></td></tr></table></figure></string></p><p>现在就可以提供泛型类型来调用这个方法了。</p><h4 id="5-不能实例化类型变量"><a href="#5-不能实例化类型变量" class="headerlink" title="5.不能实例化类型变量"></a>5.不能实例化类型变量</h4><p>不能使用像new T(…),new T[…]或T.class这样的表达式中的类型变量。例如，下面的Pair<code>&lt;T&gt;</code>构造器是非法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">new</span> T();second = <span class="keyword">new</span> T();&#125;<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>类型擦除将T改变成Object，而且本意肯定不希望调用new Object()。在Java SE 8之后，最好的解决方法是让调用者提供一个构造器表达式。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</div></pre></td></tr></table></figure></p><p>makePair方法接受一个Supplier<code>&lt;T&gt;</code>，这是一个函数式接口，表示一个无参数而且返回类型为T的函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt; (constr.get(),constr.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比较传统的解决方法是通过反射调用Class.newInstance方法来构造泛型对象。<br>遗憾的是，细节有点复杂。不能调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first = T.class.newInstance();<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>表达式T.class是不合法的，因为它会被类型擦除为Object.class。必须像下面这样设计API以便得到一个Class对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt; (c1.newInstance(),c1.newInstance())&#125;;</div><div class="line">    <span class="keyword">catch</span>(Exception ex) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方法可以按照下列方式调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</div></pre></td></tr></table></figure></p><p>注意，Class类本身是泛型。例如,String.class是一个Class<code>&lt;String&gt;</code>的实例(事实上，它是唯一的实例)。因此,makePair方法能够推断除pair的类型。  </p><h4 id="6-不能构造泛型数组"><a href="#6-不能构造泛型数组" class="headerlink" title="6.不能构造泛型数组"></a>6.不能构造泛型数组</h4><p>就像不能实例化一个泛型实例一样，也不能实例化数组。不过原因有所不同，毕竟数组会填充null值，构造时看上去是安全的。不过，数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除。例如，考虑下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];&#125;<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>类型擦除会让这个方法永远构造Comparable[2]数组。<br>如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object[],并且在屈原素时进行类型转换。例如，ArrayList可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] elements;</div><div class="line">    . . .</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (E) elements[i];&#125;<span class="comment">//取元素时强制类型转换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i,E e)</span> </span>&#123; elements[i] = e;&#125;<span class="comment">//改变元素时不必强转</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实际的实现没有那么清晰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> E[] elements;</div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;elements = (E[]) <span class="keyword">new</span> Object[<span class="number">10</span>];&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里的强制类型转换E[]是一个假象，而类型擦除使其无法察觉。<br>由于 minmax 方法返回 T[] 数组，使得这一技术无法施展， 如果掩盖这个类型会有运行时错误结果。假设实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a)</div><div class="line">&#123;</div><div class="line">Object[] mm = <span class="keyword">new</span> Object[<span class="number">2</span>];</div><div class="line">. . .</div><div class="line"><span class="keyword">return</span> (T[]) mm; <span class="comment">// compiles with warning</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用 String[] ss = ArrayAlg.minmax(“Tom”, “Dick”, “Harry”);<br>编译时不会有任何警告。当 Object[] 引用赋给 Comparable[] 变量时，将会发生 ClassCastException异常。<br>在这种情况下， 最好让用户提供一个数组构造器表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] ss = ArrayAlg.minmax (String[]::<span class="keyword">new</span>，<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</div></pre></td></tr></table></figure></p><p>构造器表达式 String::new 指示一个函数，给定所需的长度，会构造一个指定长度的<br>String数组。<br>minmax方法使用这个参数生成一个有正确类型的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmax(IntFunction&lt;T[]&gt; constr, T... a)</div><div class="line">&#123;</div><div class="line">T[] mm = constr.apply(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比较老式的方法是利用反射， 调用 Array.newInstance:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmaxfT... a)</div><div class="line">&#123;</div><div class="line">T[] mm = (T[]) Array.newlnstance (a.getClass().getComponentType() , <span class="number">2</span>);</div><div class="line"> . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ArrayList 类的 toArray 方法就没有这么幸运。它需要生成一个 T[] 数组， 但没有成分类型。因此， 有下面两种不同的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object[] toArray()</div><div class="line">T[] toArray(T[] result)</div></pre></td></tr></table></figure></p><p>第二个方法接收一个数组参数。如果数组足够大,就使用这个数组。否则,用 result 的成分类型构造一个足够大的新数组。  </p><h4 id="7-泛型类的静态上下文中类型变量无效"><a href="#7-泛型类的静态上下文中类型变量无效" class="headerlink" title="7.泛型类的静态上下文中类型变量无效"></a>7.泛型类的静态上下文中类型变量无效</h4><p>不能在静态域或方法中引用类型变量。例如， 下列高招将无法施展：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> T singlelnstance; <span class="comment">// Error</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T getSinglelnstanceO <span class="comment">// Error</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (singleinstance == <span class="keyword">null</span>) <span class="comment">//construct new instance of T</span></div><div class="line"><span class="keyword">return</span> singlelnstance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="8-不能抛出或捕获泛型类的实例"><a href="#8-不能抛出或捕获泛型类的实例" class="headerlink" title="8.不能抛出或捕获泛型类的实例"></a>8.不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类对象。实际上， 甚至泛型类扩展 Throwable 都是不合法的。<br>例如， 以下定义就不能正常编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* . . . */</span> &#125; </div><div class="line"><span class="comment">// Error can't extend Throwable</span></div></pre></td></tr></table></figure></p><p>catch 子句中不能使用类型变量。例如， 以下方法将不能编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (T e) <span class="comment">// Error can 't catch type variable</span></div><div class="line">&#123;</div><div class="line">Logger.global.info(...)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不过，在异常规范中使用类型变量是允许的。以下方法是合法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T <span class="comment">// OK</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Throwable real Cause)</div><div class="line">&#123;</div><div class="line">t.initCause(real Cause);</div><div class="line"><span class="keyword">throw</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="9-可以消除对受查异常的检查"><a href="#9-可以消除对受查异常的检查" class="headerlink" title="9.可以消除对受查异常的检查"></a>9.可以消除对受查异常的检查</h4><p>Java 异常处理的一个基本原则是， 必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。关键在于以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">throw</span> (T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设这个方法包含在类 Block 中，如果调用<code>Block.&lt;RuntimeException&gt;throwAs(t);</code><br>编译器就会认为 t 是一个非受查异常。 以下代码会把所有异常都转换为编译器所认为的非受查异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Throwable t)</div><div class="line">&#123;</div><div class="line">Block.&lt;RuntimeException&gt;throwAs(t) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面把这个代码包装在一个抽象类中。用户可以覆盖 body 方法来提供一个具体的动作。调用 toThread 时， 会得到 Thread 类的一个对象， 它的 run 方法不会介意受查异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">toThrea</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Thread()</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">body();</div><div class="line">            &#125;</div><div class="line"><span class="keyword">catch</span> (Throwable t)</div><div class="line">&#123;</div><div class="line">            Block.&lt;RuntimeException&gt; throwAs(t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">throw</span> (T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>例如， 以下程序运行了一个线程， 它会拋出一个受查异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">new</span> Block()</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"ququx"</span>) ,<span class="string">"UTF-8"</span>);</div><div class="line"><span class="keyword">while</span> (in.hasNext())</div><div class="line">System.out.println(in.next());</div><div class="line">&#125;</div><div class="line"> &#125; </div><div class="line">   .toThread() .start();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行这个程序时， 会得到一个栈轨迹， 其中包含一个FileNotFoundException ( 当然,假设你没有提供一个名为 ququx 的文件)。<br>这有什么意义呢？ 正常情况下， 你必须捕获线程 run 方法中的所有受查异常， 把它们”包装”到非受查异常中， 因为 run 方法声明为不抛出任何受查异常。<br>不过在这里并没有做这种”包装”。我们只是抛出异常， 并”哄骗”编译器， 让它认为这不是一个受查异常。<br>通过使用泛型类、 擦除和 @SuppressWarnings 注解， 就能消除 Java 类型系统的部分基本限制。  </p><h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><p>当泛型类型被擦除时，无法创建引发冲突的条件。下面是一个示例。假定像下面这样将equals 方法添加到 Pair 类中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>考虑一个Pair<code>&lt;String&gt;</code>。从概念上讲，它有两个equals方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span> <span class="comment">// defined in Pair&lt;T&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span> <span class="comment">// inherited from Object</span></span></div></pre></td></tr></table></figure></p><p>但是，直觉把我们引入歧途。方法擦除<code>boolean equals(T)</code>，就是<code>boolean equals(Object)</code><br>与 Object.equals 方法发生冲突。<br>当然，补救的办法是重新命名引发错误的方法。<br>泛型规范说明还提到另外一个原则:”要想支持擦除的转换， 就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。”例如，<br>下述代码是非法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Coinparab1e</span>&lt;<span class="title">Emp1oyee</span>&gt; </span>&#123; . . . &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Hanager</span>&gt; </span></div><div class="line"><span class="class"></span>&#123; . . . &#125; <span class="comment">// Error</span></div></pre></td></tr></table></figure></p><p>Manager 会实现 Comparable<code>&lt;Employee&gt;</code> 和 Comparable<code>&lt;Manager&gt;</code>, 这是同一接口的不同参数化。<br>这一限制与类型擦除的关系并不十分明确。毕竟，下列非泛型版本是合法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123; . . . &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123; . . . &#125;</div></pre></td></tr></table></figure></p><p>其原因非常微妙， 有可能与合成的桥方法产生冲突。实现了 Comparable<code>&lt;X&gt;</code> 的类可以获得一个桥方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123; <span class="keyword">return</span> compareTo((X) other); &#125;</div></pre></td></tr></table></figure></p><p>对于不同类型的 X 不能有两个这样的方法。</p><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;泛型程序设计&quot;&gt;&lt;a href=&quot;#泛型程序设计&quot; class=&quot;headerlink&quot; title=&quot;泛型程序设计&quot;&gt;&lt;/a&gt;泛型程序设计&lt;/h3&gt;&lt;p&gt;泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之线段树</title>
    <link href="http://habitdiary.cn/2017/10/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://habitdiary.cn/2017/10/18/算法学习之线段树/</id>
    <published>2017-10-18T15:11:27.000Z</published>
    <updated>2017-10-18T16:23:57.942Z</updated>
    
    <content type="html"><![CDATA[<p>最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  </p><h3 id="线段树是什么？有什么用？"><a href="#线段树是什么？有什么用？" class="headerlink" title="线段树是什么？有什么用？"></a>线段树是什么？有什么用？</h3><p>线段树类似区间树，它在各个节点保存一条线段(数组中的一段子数组)，主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。<br>你可能会问：查询区间和可以用O(n)的复杂度预处理一个前缀和数组，然后就可以O(1)地查询某段区间和;查询区间最值，也就是RMQ问题，也可以用O(nlogn)的复杂度预处理ST表，然后O(1)地查询区间最值。那么为什么要使用线段树呢？<br>线段树的精髓就在于它能在支持<strong>区间动态修改</strong>的前提下保持每个操作O(logn)的复杂度，这是其他两者做不到的。<br>线段树能进行的操作主要有：1)单点更新，区间查询  2)区间更新，区间查询 3)区间更新，单点查询<br>除了上述操作，线段树还可以解决区间染色和矩形面积交、面积并等问题。  </p><h3 id="线段树基本知识"><a href="#线段树基本知识" class="headerlink" title="线段树基本知识"></a>线段树基本知识</h3><p>线段树的结构：<br><img src="/2017/10/18/算法学习之线段树/1.png" alt="fail">  </p><p>建立一个线段树的示意图(可以维护区间和或最值)：<br><img src="/2017/10/18/算法学习之线段树/2.png" alt="fail">  </p><p>单点修改后重新调整线段树：<br><img src="/2017/10/18/算法学习之线段树/3.png" alt="fail">  </p><p>区间查询区间最值：<br><img src="/2017/10/18/算法学习之线段树/4.png" alt="fail">  </p><p>线段树的结点关系:<br><img src="/2017/10/18/算法学习之线段树/5.png" alt="fail">  </p><h3 id="线段树的代码实现"><a href="#线段树的代码实现" class="headerlink" title="线段树的代码实现"></a>线段树的代码实现</h3><p>下面给出建立线段树和进行各种操作的模板，关键点在代码的注释中有解释：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*node：区间结点号begin：该node的区间左边界end：该node的区间右边界</span></div><div class="line"><span class="comment">  left：查询区间的左边界right：查询区间的右边界pos：查询区间的点*/</span> </div><div class="line">  </div><div class="line"><span class="comment">/*线段树:求和或最值 </span></div><div class="line"><span class="comment">单点更新,区间查询</span></div><div class="line"><span class="comment">区间更新,单点查询(lazy标记表示本节点的信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。lazy初始为0,区间加上k给该区间管理的结点的lazy加k,push_down给子节点加(end-begin+1)*k)</span></div><div class="line"><span class="comment">区间更新,区间查询 </span></div><div class="line"><span class="comment">lson 2*node</span></div><div class="line"><span class="comment">rson 2*node+1</span></div><div class="line"><span class="comment">[begin,end]</span></div><div class="line"><span class="comment">[begin,mid] [mid+1,end] 其中mid为(begin+end)/2 */</span> </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1) </span></div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> lazy[maxn*<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;<span class="comment">//pushUp自底向上更新区间和与最值 </span></div><div class="line">segTree[node]=segTree[lson]+segTree[rson];<span class="comment">//segTree[node]=max(segTree[lson],segTree[rson]) </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//pushDown自顶向下更新lazy数组和给结点加上lazy数组的值 </span></div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;<span class="comment">//lazy[node]为0直接return </span></div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node]; </div><div class="line">lazy[lson]+=lazy[node]; </div><div class="line">lazy[rson]+=lazy[node];<span class="comment">//给左右孩子传递lazy,是+=不是=，因为孩子节点可能被多次延迟标记又没有向下传递 </span></div><div class="line">lazy[node]=<span class="number">0</span>;<span class="comment">//把父节点的lazy置为0 </span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//建树 </span></div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;<span class="comment">//begin==end表示管理的是结点 </span></div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);<span class="comment">//按照顺序输入结点，由于建树类似于树的先根遍历，所以建立的线段树的叶子结点从左到右的值就是输入的顺序 </span></div><div class="line"><span class="comment">//segTree[node]=a[begin] 用于任意顺序输入,先将输入存入a数组,下标从1开始，begin = end = index </span></div><div class="line"><span class="keyword">return</span>;<span class="comment">//输入完成后要return，否则会继续访问左右孩子，可能越界</span></div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//单点更新 </span></div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;<span class="comment">//管理的区间不包含pos,直接return </span></div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125; </div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//区间查询 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查询结点和区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];<span class="comment">//查询区间包含查询结点 </span></div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//int maxx=-1</span></div><div class="line">sum+=query(lson,begin,mid,left,right);<span class="comment">//maxx=max(maxx,query(lson,begin,mid,left,right))</span></div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);<span class="comment">//maxx=max(maxx,query(rson,mid+1,end,left,right))</span></div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//区间更新 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;<span class="comment">//结点和更新区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;<span class="comment">//更新区间包含结点 </span></div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="一、单点更新，区间查询"><a href="#一、单点更新，区间查询" class="headerlink" title="一、单点更新，区间查询"></a>一、单点更新，区间查询</h4><p>HDU1166 敌兵布阵<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1166</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> T,N,a,b;</div><div class="line"><span class="keyword">char</span> command[<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,cas++);</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,command)!=EOF)&#123;</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'E'</span>) <span class="keyword">break</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)</div><div class="line"><span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,<span class="number">1</span>,N,a,b)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'A'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,b);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'S'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,-b);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1754 I Hate It<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1754</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> N,M,A,B;</div><div class="line"><span class="keyword">char</span> C[<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=max(segTree[lson],segTree[rson]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=k;<span class="comment">//直接修改</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line"><span class="keyword">int</span> maxx=<span class="number">0</span>;</div><div class="line">maxx=max(maxx,query(lson,begin,mid,left,right));</div><div class="line">maxx=max(maxx,query(rson,mid+<span class="number">1</span>,end,left,right));</div><div class="line"><span class="keyword">return</span> maxx;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M)!=EOF)&#123;</div><div class="line"> build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"> <span class="keyword">while</span>(M--)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,C,&amp;A,&amp;B);</div><div class="line"><span class="keyword">if</span>(C[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B);</div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="二、区间更新，区间查询"><a href="#二、区间更新，区间查询" class="headerlink" title="二、区间更新，区间查询"></a>二、区间更新，区间查询</h3><p>POJ 3468 A Simple Problem with Integers<br>题目链接:<a href="http://poj.org/problem?id=3468" target="_blank" rel="external">http://poj.org/problem?id=3468</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line">ll segTree[<span class="number">4</span>*maxn];</div><div class="line">ll lazy[<span class="number">4</span>*maxn];</div><div class="line">ll N,Q,A,B,C;</div><div class="line"><span class="keyword">char</span> command[<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(ll node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node];</div><div class="line">lazy[lson]+=lazy[node];</div><div class="line">lazy[rson]+=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll node,ll begin,ll end,ll left,ll right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line">ll sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll node,ll begin,ll end,ll left,ll right,ll k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,command);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;A,&amp;B,&amp;C);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B,C);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1698 Just A Hook<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1698" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1698</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> lazy[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> T,N,Q,X,Y,Z;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=<span class="number">1</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]=(mid-begin+<span class="number">1</span>)*lazy[node];<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">segTree[rson]=(end-mid)*lazy[node];</div><div class="line">lazy[lson]=lazy[node];</div><div class="line">lazy[rson]=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]=(end-begin+<span class="number">1</span>)*k;<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">lazy[node]=k;<span class="comment">//+=改成=,因为此时lazy即使没有下传也不叠加</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;X,&amp;Y,&amp;Z);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,X,Y,Z);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: The total value of the hook is %d.\n"</span>,cas++,query(<span class="number">1</span>,<span class="number">1</span>,N,<span class="number">1</span>,N));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、区间染色问题"><a href="#三、区间染色问题" class="headerlink" title="三、区间染色问题"></a>三、区间染色问题</h3><p>ZOJ 1610 Count the Colors<br>题目链接:<a href="https://vjudge.net/problem/11553/origin" target="_blank" rel="external">https://vjudge.net/problem/11553/origin</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 8005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> col[maxn*<span class="number">4</span>];<span class="comment">//col[node]表示node管辖的区间的颜色 </span></div><div class="line"><span class="keyword">int</span> sum[maxn];<span class="comment">//表示某点的颜色 </span></div><div class="line"><span class="keyword">int</span> res[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">col[lson]=col[rson]=col[node];</div><div class="line">col[node]=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">col[node]=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(col[node]!=<span class="number">-1</span>) pushDown(node);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"><span class="comment">//不用建树,直接在query里存储颜色即可，因为染色不用求区间和或者最值 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">sum[begin]=col[node];<span class="comment">//存储每个点的颜色 </span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid,left,right);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> n,x1,x2,c;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</div><div class="line"><span class="built_in">memset</span>(col,<span class="number">-1</span>,<span class="keyword">sizeof</span>(col));</div><div class="line"><span class="built_in">memset</span>(sum,<span class="number">-1</span>,<span class="keyword">sizeof</span>(sum));</div><div class="line"><span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x1,&amp;x2,&amp;c);</div><div class="line"><span class="keyword">if</span>(x1==x2) <span class="keyword">continue</span>;<span class="comment">//为了保证R-1&gt;=L </span></div><div class="line">update(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,x1,x2<span class="number">-1</span>,c);<span class="comment">//为防止重叠,更新区间[L,R-1]</span></div><div class="line"><span class="comment">/*注意begin=0 end=maxn-1 而不是begin=1 end=n 因为只是涂n次,不一定在1-n范围内涂 */</span> </div><div class="line">&#125;</div><div class="line">query(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++) &#123;</div><div class="line">            <span class="keyword">while</span>(i!=<span class="number">0</span>&amp;&amp;sum[i]!=<span class="number">-1</span>&amp;&amp;sum[i]==sum[i<span class="number">-1</span>])<span class="comment">//涂过同一颜色也加1 </span></div><div class="line">            i++;</div><div class="line">            res[sum[i]]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</div><div class="line"><span class="keyword">if</span>(res[i])</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,res[i]);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>POJ 2528 Mayor’s posters<br>题目链接:<a href="http://poj.org/problem?id=2528" target="_blank" rel="external">http://poj.org/problem?id=2528</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*解法：离散化，如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的</span></div><div class="line"><span class="comment">      1   2   3   4  6   7   8   10</span></div><div class="line"><span class="comment">      —   —   —   —  —   —   —   —</span></div><div class="line"><span class="comment">      1   2   3   4  5   6   7   8</span></div><div class="line"><span class="comment">离散化  X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10</span></div><div class="line"><span class="comment">于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。</span></div><div class="line"><span class="comment">但是只是这样简单的离散化是错误的，</span></div><div class="line"><span class="comment">如三张海报为：1~10 1~4 6~10</span></div><div class="line"><span class="comment">离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10</span></div><div class="line"><span class="comment">第一张海报时：墙的1~4被染为1；</span></div><div class="line"><span class="comment">第二张海报时：墙的1~2被染为2，3~4仍为1；</span></div><div class="line"><span class="comment">第三张海报时：墙的3~4被染为3，1~2仍为2。</span></div><div class="line"><span class="comment">最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。</span></div><div class="line"><span class="comment">新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）</span></div><div class="line"><span class="comment">X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10</span></div><div class="line"><span class="comment">这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3</span></div><div class="line"><span class="comment">最终，1~2为2，3为1，4~5为3，于是输出正确结果3。*/</span> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></div><div class="line"><span class="comment">//不用建树,直接在query里记录hash即可，因为染色不用求区间和或者最值，也不用pushUp </span></div><div class="line"><span class="keyword">int</span> m, li[maxn], ri[maxn];</div><div class="line"><span class="keyword">int</span> poster[maxn&lt;&lt;<span class="number">3</span>], col[maxn&lt;&lt;<span class="number">4</span>], ans; <span class="comment">//col记录当前该位置最上面一层的海报种类,即染色问题的颜色 </span></div><div class="line"><span class="comment">//poster记录海报位置 </span></div><div class="line"><span class="keyword">bool</span> hash[maxn];<span class="comment">//hash用于标记某种种类的海报是否计算过,若已计算过标记为true,不再重复计算 </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">     col[lson] = col[rson] = col[node];<span class="comment">//类似lazy标记，向下传递后清空</span></div><div class="line">     col[node] = <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin, <span class="keyword">int</span> end,<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (begin &gt;= left &amp;&amp; end &lt;= right) &#123;</div><div class="line">         col[node] = k;</div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">    <span class="keyword">if</span>(col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    update(lson,begin,mid,left,right,k);</div><div class="line">    update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (begin == end) &#123;</div><div class="line">        <span class="keyword">if</span> (!hash[col[node]]) &#123;</div><div class="line">        ans++;</div><div class="line">        hash[col[node]] = <span class="literal">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> hh, <span class="keyword">int</span> xx)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mm;</div><div class="line">    <span class="keyword">while</span> (ll &lt;= hh) &#123;</div><div class="line">        mm = (ll + hh) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (poster[mm] == xx) <span class="keyword">return</span> mm;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (poster[mm] &gt; xx)  hh = mm - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> ll = mm + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> t, n, i;</div><div class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;t);</div><div class="line">    <span class="keyword">while</span> (t--) &#123;</div><div class="line">        <span class="built_in">memset</span>(col, <span class="number">-1</span>, <span class="keyword">sizeof</span> (col));<span class="comment">//-1表示没有染色</span></div><div class="line">        <span class="built_in">memset</span> (hash, <span class="literal">false</span>, <span class="keyword">sizeof</span> (hash));<span class="comment">/*因为本题墙的长度为10000000,</span></div><div class="line"><span class="comment">直接做会超时,而实际海报数量只有10000,考虑把每张海报左右两端的两段映射到小范围计算，</span></div><div class="line"><span class="comment">所以考虑离散化,但传统离散化会出错,要如果有两个位置相邻的数字数值不相邻,考虑在中间</span></div><div class="line"><span class="comment">插入一个比大的数小1的数*/</span></div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;n);</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">             <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;li[i], &amp;ri[i]);</div><div class="line">             poster[++cnt] = li[i];</div><div class="line">             poster[++cnt] = ri[i];</div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+cnt+<span class="number">1</span>);</div><div class="line">        m = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</div><div class="line">             <span class="keyword">if</span> (poster[i] != poster[i<span class="number">-1</span>]) poster[++m] = poster[i];<span class="comment">//去重 </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i = m; i &gt; <span class="number">1</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (poster[i] - poster[i<span class="number">-1</span>] &gt; <span class="number">1</span>) poster[++m] = poster[i] - <span class="number">1</span>;<span class="comment">//在末尾加入要增加的点 </span></div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+m+<span class="number">1</span>);<span class="comment">//重新排序 </span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            <span class="keyword">int</span> l = binarySearch(<span class="number">1</span>, m, li[i]);<span class="comment">//在离散化后的poster数组里二分查找每一组的左右端点</span></div><div class="line">            <span class="keyword">int</span> r = binarySearch(<span class="number">1</span>, m, ri[i]);</div><div class="line">            update(<span class="number">1</span>,<span class="number">1</span>,m,l,r,i);</div><div class="line">        &#125;</div><div class="line">        ans = <span class="number">0</span>;</div><div class="line">        query(<span class="number">1</span>, <span class="number">1</span>, m);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、矩形面积交-面积并"><a href="#四、矩形面积交-面积并" class="headerlink" title="四、矩形面积交/面积并"></a>四、矩形面积交/面积并</h3><p>HDU 1542 Atlantis(矩形面积并)<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1542" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1542</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"><span class="comment">//沿x轴扫描,沿y轴建树,线段树的结点是纵向的线段,最下面一层结点以排序后相邻的y1,y2为边界 </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>     //  存储线段信息；</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> x;   <span class="comment">//  该线段的x坐标；</span></div><div class="line">    <span class="keyword">double</span> y_up,y_down;     <span class="comment">//  竖向线段的上下端点；</span></div><div class="line">    <span class="keyword">int</span> flag;<span class="comment">//矩形的左边界为1,右边界为-1 </span></div><div class="line">&#125;line[maxn];</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>//线段树的结点,不再是单个点,是一个区间 </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> l,r;<span class="comment">//区间的左右边界,即某段扫描线的上下端点 </span></div><div class="line">    <span class="keyword">double</span> x;       <span class="comment">//  记录上一个横坐标位置，用于求面积；</span></div><div class="line">    <span class="keyword">int</span> cover;      <span class="comment">//  记录覆盖的线段数;即同一方向的线段数;由flag累加 </span></div><div class="line">    <span class="keyword">bool</span> flag;      <span class="comment">//  标记只有一个区间的节点,即在线段树最底层的结点,我们将一个个连续的区间离散化成一个结点；</span></div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>      <span class="comment">//  建树；</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    node[rt].l=y[l];    <span class="comment">//  维护区间；</span></div><div class="line">    node[rt].r=y[r];</div><div class="line">    node[rt].x=<span class="number">-1</span>;</div><div class="line">    node[rt].flag=<span class="literal">false</span>;</div><div class="line">    node[rt].cover=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;             <span class="comment">//  区间是连续的;</span></div><div class="line">        node[rt].flag=<span class="literal">true</span>; <span class="comment">//  标记为结点; </span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    build(lson,l,mid);</div><div class="line">    build(rson,mid,r);   <span class="comment">//  因为将一个个连续区间离散成点，所以此处mid不需要+1；</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span> </span></div><div class="line"><span class="function"><span class="comment">/*查询+更新x处（l,r）区间面积，l和r代表的是区间查询区间的边界，node[rt].l和node[rt].r代表的是结点边界*/</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//  该方向结点不包含所要查询的区间；</span></div><div class="line">    <span class="keyword">if</span>(node[rt].flag)&#123;  <span class="comment">//  找到只有一个区间的叶子结点；</span></div><div class="line">        <span class="keyword">if</span>(node[rt].cover&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">double</span> pre=node[rt].x;</div><div class="line">            <span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l); <span class="comment">//  计算面积；</span></div><div class="line">            node[rt].x=x;       <span class="comment">//  更新定位x位置，便于下次计算面积；</span></div><div class="line">            node[rt].cover+=flag;   <span class="comment">//  更新覆盖的线段数；</span></div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">            node[rt].x=x;</div><div class="line">            node[rt].cover+=flag;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没有产生面积并也要return 0 </span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> ans1,ans2;</div><div class="line">    ans1=Insert_query(lson,x,l,r,flag);    </div><div class="line">    ans2=Insert_query(rson,x,l,r,flag); </div><div class="line">    <span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> x1,x2,y1,y2;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</div><div class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">            y[cnt]=y1;</div><div class="line">            line[cnt].x=x1;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">1</span>;   <span class="comment">//  表示左边线段；</span></div><div class="line">            y[cnt]=y2;</div><div class="line">            line[cnt].x=x2;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">-1</span>;  <span class="comment">//  表示右边线段；</span></div><div class="line">        &#125;</div><div class="line">        sort(y,y+cnt);        <span class="comment">//  将所有高度由小到大排序，将区间建树表示</span></div><div class="line">        sort(line,line+cnt,cmp);      <span class="comment">//  因为扫描线从左到右扫描，所以按照横坐标从小到大排序后逐一插入线段树</span></div><div class="line">        build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line">        <span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">            area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2lf\n\n"</span>,++Case,area);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1255 覆盖的面积(矩形面积交)<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1255" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1255</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> T,N;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>&#123;</span></div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">double</span> y_up,y_down;</div><div class="line"><span class="keyword">int</span> flag;</div><div class="line">&#125;line[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></div><div class="line"><span class="keyword">double</span> l,r;</div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">int</span> cover;</div><div class="line"><span class="keyword">bool</span> flag;</div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</div><div class="line">node[rt].l=y[l];</div><div class="line">node[rt].r=y[r];</div><div class="line">node[rt].x=<span class="number">-1</span>;</div><div class="line">node[rt].flag=<span class="literal">false</span>;</div><div class="line">node[rt].cover=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;</div><div class="line">node[rt].flag=<span class="literal">true</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,l,mid);</div><div class="line">build(rson,mid,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(node[rt].flag)&#123;</div><div class="line"><span class="keyword">if</span>(node[rt].cover&gt;<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">double</span> pre=node[rt].x;</div><div class="line"><span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l);</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">double</span> ans1,ans2;</div><div class="line">ans1=Insert_query(lson,x,l,r,flag);</div><div class="line">ans2=Insert_query(rson,x,l,r,flag);</div><div class="line"><span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line"><span class="keyword">while</span>(N--)&#123;</div><div class="line"><span class="keyword">double</span> x1,y1,x2,y2;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">y[cnt]=y1;</div><div class="line">line[cnt].x=x1;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">1</span>;</div><div class="line">y[cnt]=y2;</div><div class="line">line[cnt].x=x2;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">sort(y,y+cnt);</div><div class="line">sort(line,line+cnt,cmp);</div><div class="line">build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line"><span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,area);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  &lt;/p&gt;
&lt;h3 id=&quot;线段树是什么？有什么用？&quot;&gt;&lt;a href=&quot;#线段树是什么？有什么用？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="算法" scheme="http://habitdiary.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之抽象类、接口、lambda表达式与内部类</title>
    <link href="http://habitdiary.cn/2017/10/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://habitdiary.cn/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/</id>
    <published>2017-10-16T00:52:06.000Z</published>
    <updated>2018-02-14T07:50:49.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它子类的共同特征。<strong>如果一个父类设计得非常抽象，以至于它没有任何具体的实例，这样的类称为抽象类，使用abstract关键字修饰。抽象类定义了相关子类的共同行为。</strong>  </p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果一个方法非常抽象，只定义了方法，没有提供方法的具体实现，那么我们把它定义为一个抽象方法，它的具体实现由子类提供，即子类覆盖抽象方法提供方法体。<br>抽象方法由abstract关键字修饰，只有方法头，没有花括号和方法体，以分号结尾。比如一个GeometricObject类定义了一个名为getArea的抽象方法，即<code>public abstract double getArea();</code> </p><h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><p>1.抽象方法应该定义为public，以便子类进行重写。<br>2.抽象类的构造器应该定义为protected，因为抽象类不能通过new直接创建实例，其构造器只被子类调用。创建一个具体子类的实例时，它的父类的构造器被调用以初始化父类中定义的数据域。<br>3.一个包含抽象方法的类必须定义为抽象类，一个不包含抽象方法的类也可以定义为抽象类(如果不想让某类创建实例，可以把它定义为抽象类)<br>4.如果子类继承抽象类时没有覆盖其所有的抽象方法，即子类中仍有抽象方法，子类也应该定义为抽象的<br>5.抽象方法是非静态的<br>6.子类可以覆盖父类的方法并将它定义为abstract,这种情况很少见，但它在当父类方法实现在子类中变得无效时是很有用的，在这种情况下，子类必须定义为abstract<br>7.即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object是具体的，但它的子类GeometricObject是抽象的。<br>8.不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。下面的语句创建一个GeometricObject类型的数组是正确的：<code>GeometricObject[] objects = new GeometricObject[10];</code>然后可以创建一个具体子类的实例并把它的引用赋给数组，如：<code>Objects[0] = new Circle();</code></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在很多方面都与抽象类很相似，但它的目的是指明<strong>相关或者不相关类</strong>的多个对象的共同行为，属性成员都是<strong>公共静态常量</strong>，成员方法都是<strong>公共抽象方法</strong>。例如，使用正确的接口，可以指明这些对象是可比较的、可克隆的。为了区分接口和类，Java采用Interface关键字定义接口。在一个java文件内，只能有一个public类或一个public接口，即public类和public接口不能同文件共存。接口没有构造器，没有实例域，也不能使用new操作符创建实例。接口没有构造器的原因有三点：<br>1.构造器用于初始化成员变量，接口没有成员变量，不需要构造器<br>2.类可以实现多个接口，如果多个接口都有构造方法，不好确定构造方法链的调用次序<br>3.作为高度抽象的概念，接口不能实例化对象，也就不需要构造器  </p><p>像常规类一样，每个接口都被编译为独立的字节码文件，可以作为引用变量的数据类型和类型转换的结果，可以使用instanceof关键字等。<br>类实现接口用implements关键字，一个类可以实现多个接口，用逗号隔开即可，<strong>一个类必须实现它实现接口的所有方法，否则要定义为抽象类。</strong>一个接口可以继承多个接口，用extends关键字，此时实现类需要重写接口继承链上所有接口的所有抽象方法。<strong>如果接口在继承在多个父接口时，父接口中出现了重名的默认方法冲突，就要在该接口中提供一个同名默认方法来解决冲突。</strong><br>在定义接口中的数据域和方法时可以简写，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>可简写成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要注意接口中所有的数据域都是public static final，所有的方法都是public abstract，在定义接口中允许省略修饰符，但在子类重写方法时不可缺省public修饰符，否则方法的可见性会缩小为包内可见。<br><strong>接口只能使用public修饰符或缺省访问控制修饰符。</strong><br><strong>如果在具体实现类中定义了和接口中常量同名的常量，那么用接口变量指向实现类引用时变量调用的常量仍然是接口中定义的常量。</strong></p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>从Java SE 8开始，允许在接口中增加静态方法，并给静态方法提供方法体实现，该静态方法只能通过<code>接口名.静态方法</code>来调用。实现语法只要在方法前面加static关键字即可，这理论上讲是可以的，但这有违于接口作为抽象规范的初衷。<strong>静态方法只能被具体实现类继承，不能在实现类中重写。</strong>  </p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>可以为接口方法提供一个默认方法体实现，在方法前加default修饰符即可，这样子类无需重写这个方法也能得到一个接口的默认实现。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样实现Collection的程序员就不用操心实现isEmpty方法了。<br><strong>当然，默认方法也可以被具体实现类重写。在实现类中调用默认方法要使用接口名.super.默认方法来调用。</strong><br>默认方法的一个重要用法是<strong>“接口演化”</strong>。以Collection接口为例，这个接口作为Java的一部分已经很多年了，假设很久以前定义了一个实现Collection接口的类Bag。后来在Collection接口中增加了一个stream方法，假设stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。如果不重新编译这个类，而是使用原先包含这个类的JAR文件，这个类仍能正常加载，正常构造实例，但如果在一个Bag实例上调用stream方法，会出现一个AbstractMethodError。<strong>但如果把stream方法定义为默认方法就可以解决这个问题，既可以重新编译也可以使用JAR文件加载类并调用stream方法。</strong>  </p><h3 id="解决默认方法的冲突"><a href="#解决默认方法的冲突" class="headerlink" title="解决默认方法的冲突"></a>解决默认方法的冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生冲突。解决冲突规则如下：<br>1) 超类和接口冲突。如果超类提供了一个具体方法，那么根据超类优先原则，同名而且有相同参数类型的默认方法会被忽略。<br>2) 多接口之间冲突。如果一个实现类实现了多个接口，一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，此时就发生了接口冲突，必须在实现类中重写这个方法来解决冲突。  </p><h3 id="解决重名常量的冲突"><a href="#解决重名常量的冲突" class="headerlink" title="解决重名常量的冲突"></a>解决重名常量的冲突</h3><p>1）超类和接口冲突。如果一个类继承了一个超类和实现了若干接口，此时不像默认方法冲突一样有超类优先原则。只能通过在实现类中覆盖该常量来解决冲突。<br>2）多接口之间冲突。如果一个类实现了多个接口，而这些接口又有重名常量，此时会发生冲突。必须用<code>接口名.常量</code>的方式来精确指明要使用的常量。</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable接口定义了compareTo方法，用于比较对象。当想使用Arrays类的sort方法对对象数组进行排序时，对象所属的类必须实现了Comparable接口。<br>Comparable接口是一个带泛型的接口，定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> compareTo应该与equals保持一致，即当且仅当o1.equals(o2)为true时，o1.compareTo(o2) == 0成立。以下是compareTo方法的实现：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> Double.compare(salary,other.salary);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> <strong>在比较浮点数时可以使用Double的静态方法compare,这样就不必担心溢出或精度损失，类似的还有Integer.compare方法等</strong><br> <strong>继承过程中的compareTo，如果由子类决定相等的概念，每个compare方法都应该在开始时检测：<code>if(getClass() != other.getClass()) throw new ClassCastException()</code></strong>：<strong>如果父类决定相等的概念，应该在超类中提供一个compareTo方法，并将这个方法声明为final。</strong>  </p><h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p> Comparator接口意为”比较器”接口，是一个泛型接口，可用于自定义排序规则和大小比较等。要进行自定义排序，Arrays.sort方法有一个重载版本，需要提供一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。接口定义为：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first,T second)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 如果要按长度比较字符串，由于String是按字典序比较字符串，肯定不能让String类用两种方法实现compareTo方法 —— 况且String类也不由我们修改。此时可以定义如下实现Comparator<string>的类：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">lengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first,String second)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> first.length() - second.length();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p><p> 因为要调用compare方法，所以具体比较大小和排序时都要创建一个lengthComparator的实例：<br> <strong>大小比较</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> LengthComparator();</div><div class="line"><span class="keyword">if</span>(comp.compare(words[i],words[j]) &gt; <span class="number">0</span>) ...</div></pre></td></tr></table></figure></p><p> <strong>自定义排序</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] friends = &#123;<span class="string">"Peter"</span>,<span class="string">"Paul"</span>,<span class="string">"Mary"</span>&#125;;</div><div class="line">Arrays.sort(friends,<span class="keyword">new</span> LengthComparator());</div></pre></td></tr></table></figure></p><p> <strong>Comparable接口和Comparator接口都可以用于自定义排序。但前者只能在定义要比较的类的同时实现，比如自定义的类，使用sort的不带比较器的方法排序。后者则可用于类的定义时或类已经设计完成但还想进行排序，因为它的实现是在要比较的类之外的，比如对Java类库中的类进行排序，无法修改类的定义，只好在外部定义一个实现了Comparator的比较器，并使用sort带比较器的方法排序。</strong><br>下面对于一个学生类的两个关键字进行排序，先按分数从高到低排序，分数相同按年龄从小到大排序。<br><strong>方法一：实现Comparable接口</strong><br>重写的compareTo方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student stu)</span></span>&#123;    </div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.score&gt;stu.score)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.score &lt; stu.score)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.age&gt;stu.age)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.age &lt; stu.age)&#123;</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p><strong>方法二：实现Comparator接口</strong><br>重写的compare方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student stu1,Student stu2)</span></span>&#123;    </div><div class="line">       <span class="keyword">if</span>(stu1.score&gt;stu2.score)&#123;</div><div class="line">           <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stu1.score&lt;stu2.score)&#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">       &#125;<span class="keyword">else</span>&#123;</div><div class="line">           <span class="keyword">if</span>(stu1.age&gt;stu2.age)&#123;</div><div class="line">               <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stu1.age&lt;stu2.age)&#123;</div><div class="line">               <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">           &#125;</div><div class="line">       &#125;    </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p><strong>自定义排序总结：</strong>无论是重写compare方法还是compareTo方法，对大于、小于、等于三种情况都要有返回值，否则无法通过编译。在compareTo方法中，规定this.xxx &gt; o.xxx 返回 1,this.xxx == o.xxx 返回0,this.xxx &lt; o.xxx 返回-1是升序排列，反之就是降序排列。在compare方法中,规定o1.xxx &gt; o2.xxx返回1,o1.xxx == o2.xxx返回0,o1.xxx &lt; o2.xxx返回 -1是升序排列，反之就是降序排列。<br>技巧：如果要比较的属性也实现了Comparable接口，就可以调用它的compareTo方法。如果要降序排列，就交换compareTo的参数顺序即可。如果要比较的类是基本数据类型，可以返回差值，如果差值不是int类型，就转换为int类型。</p><h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h3><p> 首先，我们考虑为一个包含对象引用的变量建立副本会发生什么，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Employee original = <span class="keyword">new</span> Employee(<span class="string">"John Public"</span>,<span class="number">50000</span>);</div><div class="line">Employee copy = original;</div><div class="line">copy.ratseSalary(<span class="number">10</span>); <span class="comment">//original的salary也被改变</span></div></pre></td></tr></table></figure></p><p> 原变量和副本都会指向同一个对象，这说明，任何一个变量的改变都会影响到另一个变量。如果有一个对象original，希望创建一个对象copy使得其初始状态与original相同，但是之后它们各自回有自己不同的状态，这种情况下就可以使用克隆，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee copy = original.clone();</div><div class="line">copy.raiseSalary(<span class="number">10</span>); <span class="comment">//original的salary不会被改变</span></div></pre></td></tr></table></figure></p><p>Object类中的clone方法将原始对象的每个数据域复制给目标对象，如果一个数据域是基本数据类型，复制的就是它的值，如果是引用类型，复制的就是它的引用，这种克隆称为<strong>浅复制</strong>,即original != copy,但original.hireDay == copy.hireDay。这有时是不符合我们要求的，我们不希望在改变某个对象的引用类型的数据域时影响到另一个对象，这时我们需要<strong>深复制</strong>,即如果数据域是引用类型，复制的是对象的内容而不是引用。<br>无论是<strong>浅复制</strong>还是<strong>深复制</strong>，我们都需要先实现Cloneable接口，否则会产生一个必检异常。Cloneable接口的定义是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们发现这个接口是空的，一个带空体的接口称为标记接口。一个标记接口既不包括常量也不包括方法，它用来表示一个类拥有的某些特定的属性，其惟一的作用是允许在类型查询中使用instanceof关键字。但如果一个请求克隆的对象不实现这个接口，会产生CloneNotSupportedException，即使clone的默认(浅拷贝)实现能够满足要求，还是要实现这一接口。在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone方法，这个方法是从Object类继承的，这个接口只是作为一个标记。  </p><p>Object类中提供的原始clone方法的方法头是<code>protected native Object clone() throws CloneNotSupportedException</code>,关键字native表明这个方法不是用Java写的，但它是JVM针对自身平台实现的。关键字protected限定方法只能在同一个包内或在其子类中访问。由于这个原因：<strong>必须在要实现克隆的子类中覆盖这个方法并把可见性修饰父改为public</strong>。<br>下面给出一个浅复制的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> (Employee) <span class="keyword">super</span>.clone();</div><div class="line">    &#125;</div><div class="line">    . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出一个深复制的例子：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">     . . .</div><div class="line">     Employee cloned = (Employee) <span class="keyword">super</span>.clone;</div><div class="line">     cloned.hireDay = (Date)hireDay.clone();</div><div class="line">     <span class="keyword">return</span> cloned;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们注意到Object类的clone方法的返回值类型是Object，而Employee类的clone方法返回值类型是Employee，这叫做协变返回类型，即<strong>子类在重写父类方法时可以返回父类返回值类型的子类型</strong>。clone方法声明异常也可以改成捕获异常，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">Employee cloned = (Employee) <span class="keyword">super</span>.clone();</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(CloneNotSupportedException e)&#123; <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="复制数组的四种方法"><a href="#复制数组的四种方法" class="headerlink" title="复制数组的四种方法"></a>复制数组的四种方法</h3><p>1.申请一个新数组，遍历原数组逐一复制元素<br>2.使用System类的静态方法arraycopy<br>3.使用<code>数组对象.clone</code>返回一个数组克隆的引用<br>4.使用Arrays类的copyOf方法  </p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>区别：<br>1.接口所有的变量必须是public static final;抽象类的变量无限制<br>2.接口没有构造方法，不能用new操作符实例化;抽象类有构造方法，由子类通过构造方法链调用，不能用new操作符实例化<br>3.接口所有方法必须是公共抽象实例方法(Java SE 8开始允许定义静态方法)，抽象类无限制<br>4.一个类只可以继承一个父类，但可以实现多个接口<br>5.所有的类有一个共同的根Object类，接口没有共同的根<br>6.抽象类和子类的关系应该是强的“是一种”关系(strong is-a relationship),而接口和子类的关系是弱的”是一种”关系(weak is-a relationship)。接口比抽象类更灵活，因为实现接口的子类只需要具有统一的行为即可，不需要都属于同一个类型的类。</p><h3 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h3><p> 回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下按钮或选择某个菜单项时应该采取什么行动。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p> 内部类，或者称为嵌套类，是一个定义在另一个类范围中的类。一个内部类可以如常规类一样使用。通常，在一个类只被它的外部类所使用的时候，才将它定义为内部类，内部类机制主要用于设计具有互相协作关系的类集合。比如：  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//OuterClass.java: inner class demo</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line">   <span class="comment">/** A method in the outer class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="comment">//Do something</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// An inner class</span></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">   <span class="comment">/** A method in the inner class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mi</span><span class="params">()</span></span>&#123;</div><div class="line">   data++;</div><div class="line">       m();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 为什么要使用内部类，主要原因有三：<br> 1.内部类可以访问包含它的外部类的所有数据域(包括私有数据域)和方法，没有必要将外部类对象的引用传递给内部类的构造方法,内部类有一个指向外部类对象的隐式引用，如果显式写出，外部类的引用是OuterClass.this<br> 2.内部类可以对同一个包中的其他类隐藏起来<br> 3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷  </p><p> 内部类具有一下特征：<br> 1) 一个成员内部类被编译成一个名为<code>OuterClassName$InnerClassName</code>的类。例如，一个定义在Test类中的成员内部类A被编译成<code>Test$A.class</code><br> 2) 一个内部类可以使用可见性修饰符(public、private、protected、default)所定义，和应用于一个类中成员的可见性规则一样<br> 3) 一个内部类可以被定义为static，一个static的内部类可以使用外部类的名字访问,一个static内部类不能访问外部类中的非静态成员<br> 4) 内部类对象通常在外部类中创建，但是你也可以从另外一个类中来创建一个内部类的对象。如果内部类是非静态的，你必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类对象：<code>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</code> 如果内部类是静态的，使用下面语法来创建一个内部类对象:<code>OuterClass.InnerClass innerObject = new OuterClass.InnerClass();</code>。<br> 一般建议在外部类中定义一个用于获取内部类对象的方法，以便于从外部类外获取内部类对象，比如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 5) 内部类所有的静态域必须是final修饰的<strong>静态常量</strong>,不能有静态变量，也不能有静态方法</p><p> 一个简单的内部类的用途是将相互依赖的类结合到一个主类中，这样做减少了源文件的数量(因为非内部类如果用public修饰必须放在不同的源文件中，而内部类可放在同一源文件中)，这样也使得类文件容易组织，因为它们都将主类名作为前缀。另外一个内部类的实际用途是避免类名冲突。  </p><p> 内部类对于定义处理器类非常有用，一个处理器类被设计为针对一个GUI组件创建一个处理器对象(比如，一个按钮)。处理器类不会被其他应用所共享，所以将它定义在主类里面作为一个内部类使用是恰如其分的。  </p><p>广泛意义上的内部类一般来说包括四种：<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>和<strong>静态内部类</strong>。下面就先来了解一下这四种内部类的用法。  </p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p> 　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></div><div class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>  这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员），但外部类想要访问内部类的成员属性和方法时必须先实例化内部类对象。<br>  　不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<code>外部类.this.成员变量 外部类.this.成员方法</code></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p> 可以把内部类定义在一个方法中，称为局部内部类，也叫方法内部类。<strong>局部内部类就像是方法里面的一个局部变量一样，不能有public、protected、private以及static修饰符。它的作用域被限定在声明这个局部类的块中。</strong>局部类有一个优势，即对外部世界完全隐藏起来。即使外部类中的其他代码也不能访问它。除了其所在的方法之外，没有任何方法知道该局部类的存在。<strong>局部内部类只能访问被final修饰的局部变量。</strong><br> 局部内部类被编译器编译成一个<code>OuterClassName$1InnerClassName</code>的类。序号逐渐递增。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></div><div class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 注意：上述代码中通过调用getWoman()获取了局部内部类Woman的引用，不能通过<code>局部内部类引用.属性</code>的方式来直接访问局部内部类的成员，所以我们一般会在该方法中直接调用局部内部类的方法进行某种操作，然后返回操作结果。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p> 有时我们在程序中对一个类只使用一次，此时就可以把类的定义和实例化对象整合在一起，来简化对于抽象类和接口实现的操作，这就是<strong>匿名内部类</strong>。<br> 一个匿名内部类是一个没有名字的内部类，其语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> SuperClassName/InterfaceName()&#123;</div><div class="line"><span class="comment">//implement or override methods in superclass or interface</span></div><div class="line">   </div><div class="line">    <span class="comment">//Other methods if necessary</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> 其含义是<strong>创建一个继承自SuperClass或实现Interface的类的实例，并在类块内重写父类或接口的抽象方法</strong>，应该将匿名内部类理解成<strong>一个匿名子类的匿名对象</strong>,而不是理解成一个类。  </p><p> 匿名内部类有如下特征：<br> 1.没有可见性修饰符<br> 2.没有构造方法(因为没有名字,无法命名构造方法),但可以有构造代码块，也可以调用父类的构造方法，即<code>new SuperClassName()</code>调用父类无参构造方法，<code>new SuperClassName(args1,...)</code>调用父类有参构造方法。如果实现的是接口，则不能有任何参数，但是小括号仍然不可缺省<br> 3.必须总是从一个父类继承或者实现一个接口，但是它不能有显式的extends或者implements子句<br> 4.必须实现父类或接口中的所有抽象方法<br> 5.一个匿名内部类被编译成一个名为OuterClassName$n.class的类，例如：如果外部类Test有两个匿名内部类，分别被编译成Test$1.class和Test$2.class  </p><p> <strong>应用一</strong><br> 下面的技巧称为<strong>“双括号初始化”</strong>，这里利用了内部类语法。假设你想构造一个数组列表，并将它传递到一个方法。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">friends.add(<span class="string">"Harry"</span>);</div><div class="line">friends.add(<span class="string">"Tony"</span>);</div><div class="line">invite(friends);</div></pre></td></tr></table></figure></p><p> 如果不再需要这个数组列表，最好让它作为一个匿名列表。语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> invite(<span class="keyword">new</span> ArrayList&lt;String&gt; </div><div class="line"> &#123;</div><div class="line"> &#123;</div><div class="line">    add(<span class="string">"Harry"</span>);</div><div class="line">        add(<span class="string">"Tony"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p> 注意这里的双括号，外括号建立了一个ArrayList的匿名子表，内括号则是一个对象构造块。  </p><p> <strong>应用二</strong><br> 生成日志或调试消息时，通常希望包含当前类的类名，如：<br> <code>System.err.println(&quot;Something awful happened in &quot; + getClass());</code><br> 不过这对于静态方法并不凑效，因为调用getClass()调用的是this.getClass(),但静态方法里没有this，所以应该使用下面的表达式：<code>new Object(){}.getClass().getEnclosingClass()</code>,在这里，new Object(){} 会建立Object的一个匿名子类的匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类 </p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p> 有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象。为此，可以为内部类加上static关键字声明为静态内部类，以便取消产生的引用。<strong>静态内部类中的方法不能直接调用外部类的非静态成员属性和访问非静态方法，如果要调用和访问，必须实例化外部类对象。当静态内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是静态内部类的成员。如果要访问外部类的非静态同名成员，不能再使用<code>外部类.this.成员</code>的形式，而是要实例化外部类对象。如果要访问外部类的静态同名成员，可以通过<code>外部类.成员</code>的方式来访问。</strong>与常规内部类不同，静态内部类可以有<strong>静态变量</strong>和<strong>静态方法</strong>。可以通过<code>外部类.内部类.静态成员</code>方式来访问。<br> 下面是一个使用静态内部类的典型例子。考虑一下计算一个数组中最大值和最小值的问题，当然，可以编写两个方法，一个计算最大值，一个计算最小值，在调用这两个方法的时候，数组被遍历两次，而如果数组只被遍历一次就可以计算出最大值和最小值，那么效率就大大提高了。通过一个方法就计算出最大值和最小值：这个方法需要返回两个数（max 和 min），为此可以定义一个Pair类来封装这种数据结构，但是Pair是个非常大众的名字，可能在其他地方定义过，会发生名字冲突，此时可以将Pair定义为ArrayAlg类的内部类ArrayAlg.Pair。又因为Pair没有必要访问外围类ArrayAlg的数据域或方法，应该定义为静态内部类。<br> 下面给出代码：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">    <span class="comment">//Pair类，起数据封装的作用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> s)</span></span>&#123;</div><div class="line">            first = f;</div><div class="line">            second = s;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFirst</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> second;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">maxmin</span><span class="params">(<span class="keyword">double</span>[] values)</span></span>&#123;</div><div class="line">        <span class="keyword">double</span> min = Double.POSITIVE_INFNITY;</div><div class="line">        <span class="keyword">double</span> max = Double.NEGATIVE_INFNITY;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> x : values)&#123;</div><div class="line">            <span class="keyword">if</span>(x&lt;min) min = x;</div><div class="line">            <span class="keyword">if</span>(x&gt;max) max = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(max,min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Test te = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">double</span>[] teArgs = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2.13</span>,<span class="number">100.0</span>,<span class="number">11.2</span>,<span class="number">34.5</span>,<span class="number">67.1</span>,<span class="number">88.9</span>&#125;;</div><div class="line">        Pair res = te.maxmin(teArgs);</div><div class="line">        System.out.println(<span class="string">"max = "</span>+res.getFirst());</div><div class="line">        System.out.println(<span class="string">"min = "</span>+res.getSecond());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 特别注意：代码中的Pair类如果没有声明为static，就不能在静态方法minmax中构造Pair的实例，编译器会给出错误报告：没有可用的隐式ArrayAlg类型对象初始化内部类对象  </p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p> lambda表达式可以被看作使用精简语法的匿名内部类，编译器对待一个lambda表达式如同它是从一个匿名内部类创建的对象。它是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda表达式，可以用一种精简的方式表示使用回调或变量行为的代码。如果要编译器理解lambda表达式，其代替的匿名内部类实现的接口必须只包含一个抽象方法，这样的接口被称为函数式接口(功能接口、单抽象方法接口）。在底层，接受lambda表达式的方法会接受实现某函数式接口的类的对象，并在这个对象上调用接口的方法，所以可以把lambda表达式赋给函数式接口(lambda表达式实际是一个实现了该函数式接口的类的类型，这里用到了多态)，不能把lambda表达式赋给Object变量，因为Object不是一个函数式接口。<br> 一个lambda表达式就是一个代码块，以及必须传入代码的变量规范。其基础语法是(expression只有一条语句，不用花括号，也不用分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; expression</div></pre></td></tr></table></figure></p><p> 或者(statements是多条语句，要花括号，每条语句之后要分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; &#123;statements;&#125;</div></pre></td></tr></table></figure></p><p> 一个参数的数据类型既可以显式声明，也可以由编译器隐式推断。如果只有一个参数，并且没有显式的数据类型，圆括号可以被省略。如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">e -&gt; &#123;</div><div class="line"><span class="comment">// Code for processing event e</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 即使lambda表达式没有参数，也要提供空括号，就像无参数方法一样：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span>;i &gt;=<span class="number">0</span> ;i--) System.out.println(i);&#125;</div></pre></td></tr></table></figure></p><p>  无需指定lambda表达式的返回类型，编译器会由上下文推断，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(String first,String second) -&gt; first.length() - second.length()</div></pre></td></tr></table></figure></p><p> 可以在需要int类型结果的上下文中使用  </p><p> 如果一个lambda表达式只在某些分支上返回一个值，而在另外一些分支不返回值，是不合法的。例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> x) -&gt; &#123;<span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</div></pre></td></tr></table></figure></p><p> Comparator接口是一个函数式接口，可以用lambda表达式实现自定义排序的简化：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(words,(first,second) </div><div class="line">-&gt; first.length() - second.length());</div></pre></td></tr></table></figure></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p> 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口。<br> 如果自己设计了一个函数式接口，可以用@FunctionalInterface注解来标记这个接口，这样做有两个好处：<br> 1.可以在你无意中增加一个非抽象方法时产生编译错误<br> 2.javadoc页里会指出你的接口是一个函数式接口</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p> 有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如，假设你希望只要出现一个定时器事件就打印这个事件对象，可以调用：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,event -&gt; System.out.println(event));</div></pre></td></tr></table></figure></p><p> 可以直接把println方法传递到Timer的构造器：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</div></pre></td></tr></table></figure></p><p> 表达式System.out::println是一个方法引用，它等价于lambda表达式<code>x -&gt; System.out.println(x)</code><br> 我们再看一个例子，假设要对字符串排序，而不考虑字母的大小写，可以调用<code>Arrays.sort(strings,String::compareToIgnoreCase);</code></p><p> 方法引用主要有三种情况：  </p><ul><li>object::instanceMethod</li><li>Class::staticMethod  </li><li>Class::instanceMethod    </li></ul><p>对于前两种情况，方法引用等价于提供方法参数的lambda表达式。比如：System.out::println等价于x -&gt; System.out.println(x)，Math::pow等价于(x,y) -&gt; Math.pow(x,y)。第三种情况的第一个参数会称成为调用方法的目标对象，其余参数成为方法参数，比如：String::compareToIgnoreCase等价于(x,y) -&gt; x.compareToIgnoreCase(y)<br>可以在方法里使用this和super,this::equals等同于x -&gt; this.equals(x),super::greet等同于() -&gt; super.greet()  </p><p>类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。  </p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用与方法引用类似，只不过方法名为new。例如<code>Employee::new</code>是Employee构造器的一个引用。至于是哪一个构造器取决于上下文，比如<code>Function&lt;Integer,Employee&gt; func1 = Employee :: new;</code>就相当于<code>Function&lt;Integer,Employee&gt; func = x -&gt; new Employee(x);</code><br>数组类型也有构造器引用，如<code>int[]::new</code>等价于lambda表达式<code>x -&gt; new int[x]</code>  </p><h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>我们之前提到，lambda表达式的重点是<strong>延迟执行</strong>，之所以希望以后再执行代码，有很多原因，如：  </p><ul><li>在一个单独的线程中运行代码  </li><li>多次运行代码  </li><li>在算法的恰当位置运行代码(例如，排序中的比较操作)  </li><li>发生某种情况时执行代码(如，点击了一个按钮、数据到达等) </li><li>只在必要时才运行代码  </li></ul><p>下面是常用的函数式接口和基本类型的函数式接口：  </p><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/1.png" alt="fail" title="常用函数式接口">  </p><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/2.png" alt="fail" title="基本类型的函数式接口"></p><p>下面来看一个简单的例子。假设你想要重复一个动作n次。将这个动作和重复次数传递给一个repeat方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,() -&gt; System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure></p><p>要接受这个lambda表达式，需要选择一个函数式接口。在这里，我们可以使用Runnable接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,Runnable action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </div><div class="line">    action.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在让这个例子更复杂一点，我们希望告诉这个动作它出现在那一次迭代中。为此需要选择一个合适的函数式接口，其中要包含一个方法。这个方法有一个int参数而且返回类型为void。处理int值的标准接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntConsumer</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出repeat方法的改进版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,IntConsumer action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)  action.accept(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以如下调用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,i -&gt; System.out.println(<span class="string">"Countdown: "</span> + (<span class="number">9</span> - i)));</div></pre></td></tr></table></figure></p><p>大多数函数标准函数式接口都提供了非抽象方法来生成或合并函数。例如,Predicate.isEqual(a)等同于a::equals,不过如果a为null也能正常工作。已经提供了默认方法and、or和negate来合并谓词。例如,<code>Predicate.isEqual(a).or(Predicate.isEqual(b))</code>就等同于<code>x -&gt; a.equals(x) || b.equals(x)</code></p><h3 id="通过三种方式实现事件处理器"><a href="#通过三种方式实现事件处理器" class="headerlink" title="通过三种方式实现事件处理器"></a>通过三种方式实现事件处理器</h3><h4 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleEvent</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">HBox pane = <span class="keyword">new</span> HBox(<span class="number">10</span>);</div><div class="line">pane.setAlignment(Pos.CENTER);</div><div class="line">Button btOK = <span class="keyword">new</span> Button(<span class="string">"OK"</span>);</div><div class="line">OKHandlerClass handler1 = <span class="keyword">new</span> OKHandlerClass();</div><div class="line">btOK.setOnAction(handler1);</div><div class="line">Button btCancel = <span class="keyword">new</span> Button(<span class="string">"Cancel"</span>);</div><div class="line">CancelHandlerClass handler2 = <span class="keyword">new</span> CancelHandlerClass();</div><div class="line">btCancel.setOnAction(handler2);</div><div class="line">pane.getChildren().addAll(btOK,btCancel);</div><div class="line"></div><div class="line">Scene scene = <span class="keyword">new</span> Scene(pane,<span class="number">100</span>,<span class="number">50</span>);</div><div class="line">primaryStage.setTitle(<span class="string">"HandleEvent"</span>);</div><div class="line">primaryStage.setScene(scene);</div><div class="line">primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OKHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"OK button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"Cancel button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-匿名内部类"><a href="#2-匿名内部类" class="headerlink" title="2.匿名内部类"></a>2.匿名内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process New"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Open"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Save"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Print"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"AnonymousHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3.lambda表达式"></a>3.lambda表达式</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction((ActionEvent e)-&gt;&#123;System.out.println(<span class="string">"Process New"</span>);&#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction((e)-&gt;&#123;System.out.println(<span class="string">"Process Open"</span>);&#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(e-&gt;&#123;System.out.println(<span class="string">"Process Save"</span>);&#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(e-&gt;System.out.println(<span class="string">"Process Print"</span>));</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"LambdaHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p> 见大牛博客  </p><ul><li><a href="http://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="external">Java的三种代理模式</a>  </li><li><a href="http://blog.csdn.net/pangqiandou/article/details/52964066" target="_blank" rel="external">java中Proxy(代理与动态代理)</a>  </li><li><a href="http://layznet.iteye.com/blog/1182924" target="_blank" rel="external">java静态代理和动态代理</a>  </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之反射</title>
    <link href="http://habitdiary.cn/2017/10/14/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <id>http://habitdiary.cn/2017/10/14/Java学习总结之反射/</id>
    <published>2017-10-14T06:32:15.000Z</published>
    <updated>2018-02-21T14:57:34.226Z</updated>
    
    <content type="html"><![CDATA[<p>　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  </p><h3 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1.什么是反射？"></a>1.什么是反射？</h3><p>　　<strong>反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。</strong>也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。<br>　　要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><h3 id="2-反射的作用"><a href="#2-反射的作用" class="headerlink" title="2.反射的作用"></a>2.反射的作用</h3><p>　　1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制<br>　　2.在运行时分析对象的数据域<br>　　3.实现通用的数组操作代码<br>　　4.利用Method对象，这个对象很像C++中的函数指针  </p><h3 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h3><p>　　我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。Class 类的实例表示正在运行的 Java 应用程序中的类或接口。在 Java 中，每个 Class 都有一个相应的 Class 对象，即对于每一个类，.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，用于表示这个类的类型信息，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是<code>java.lang.Class</code>类的一个实例，从中我们可以得出结论：万物皆对象，<code>任何类型(包括基本类型，引用类型，void关键字等).class</code>都是<code>java.lang.Class</code>的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于<code>java.lang.Class</code>类不存在公有构造器，它在每个类第一次被加载时由JVM自动调用，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。<br>　　在下面的讲解中，我们将以People类和Student类为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(getName() + <span class="string">" "</span> + getAge());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">(String course)</span> </span>&#123;</div><div class="line">        System.out.println(name + <span class="string">" learn "</span> + course);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h4 id="获取class对象有以下三种"><a href="#获取class对象有以下三种" class="headerlink" title="获取class对象有以下三种:"></a>获取class对象有以下三种:</h4><p> 1) 可以通过<code>类名.class</code>得到相应类的Class对象，如:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class peopleClass = People.class;</div></pre></td></tr></table></figure><p>2) 如果已知类的<strong>全限定名称(包含包名)</strong>，可以通过Class的forName静态方法得到类的Class对象，如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class peopleClass = Class.forName(<span class="string">"cn.habitdiary.People"</span>);</div><div class="line"><span class="comment">//假设People类在cn.habitdiary包中</span></div></pre></td></tr></table></figure><p>　　在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">String name = <span class="string">"xxx"</span>;</div><div class="line">    Class c1 = Class.forName(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>3) 可以通过<code>类的实例对象.getClass()</code>得到相应类的Class对象，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People people = <span class="keyword">new</span> People(<span class="string">"Steven"</span>， <span class="number">20</span>);</div><div class="line">Class peopleClass = people.getClass();</div></pre></td></tr></table></figure><p>　　<code>实例对象.getClass().getName()</code> 可以获取当前对象的类的全限定名称(包含包名)<br>　　<code>实例对象.getClass().getSimpleName()</code>可以获取当前对象的类的底层类简称(不含包名)<br>　　<code>实例对象.getClass().getCanonicalName()</code>大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。<br>　　但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName()  </p><p><strong>对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的 Class 实例</strong>   </p><p><strong>三种方式的比较：</strong><br>1.调用<code>Class.forName()</code>方法，如果类没有加载就加载，加载时执行static语句，找不到就抛出异常，也可以理解为手动加载类的一种方法，它会自动初始化Class对象。  </p><p>2.<code>getClass()</code>方法，在已经持有该类的对象时来获取Class引用。其Class对象已经被初始化。  </p><p>3.<code>.class</code>方式创建Class对象引用时，不会自动初始化Class对象。主要进行下面的步骤：<br>1)加载，类加载器查找字节码（classpath）创建Class对象；<br>2)链接，为静态域分配存储空间；<br>3)初始化，其被延迟到静态方法或非常数静态域首次引用时。  </p><p><strong>总结：</strong>Java获得Class对象的引用的方法中，<code>Class.forName()</code>方法会自动初始化Class对象，而<code>.class</code>方法不会，<code>.class</code>的初始化被延迟到静态方法或非常数静态域的首次引用。</p><p><strong>注意：</strong><br>　　1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象。<br>　　2.Class类实际上是一个泛型类。  <code>Class c = T.class</code>实际上是<code>Class&lt;T&gt; c = T.class</code>。<code>Class c = x.getClass()</code>实际上是<code>Class&lt;? extends T&gt; c = x.getClass()</code>(T的x的声明类型，x.getClass()获得的是x的实际类型的Class对象)。但有时候我们不能提前确定class对象的类型,如<code>Class c = Class.forName(&quot;T&quot;)</code>实际上是<code>Class&lt;?&gt; c = Class.forName(&quot;T&quot;)</code>。<br>　　3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作，这可以用来判断两个对象属不属于同一个类。<br>　　4.getClass()方法返回的是对象实际类型的class对象，而不是声明类型的class对象。<br>　　5.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，<strong>前提要有无参的构造方法，newInstance()方法是通过调用无参构造方法来创建对象的</strong>。比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s = <span class="string">"java.util.Random"</span>;</div><div class="line">Object m = Class.forName(s).newInstance();</div></pre></td></tr></table></figure><p>　　<strong>如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。</strong>   </p><p><strong>类的静态加载和动态加载</strong><br><strong>静态加载：</strong>在编译时就需要加载所有可能用到的类，比如new关键字就是静态加载类。<br><strong>动态加载：</strong>在运行时加载类。<br>静态加载类的缺点是：比如用new创建了多个类的对象，其中某一个类不存在，则整个程序无法通过编译。而如果动态加载类，只要不使用不存在的类，其他类还可以正常使用。 </p><p>比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    <span class="comment">//静态加载类</span></div><div class="line">    <span class="keyword">if</span>(<span class="string">"Word"</span>.equals(args[<span class="number">0</span>]))&#123;</div><div class="line">        Word w = <span class="keyword">new</span> Word();</div><div class="line">            w.start();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span>(<span class="string">"Excel"</span>.equals(args[<span class="number">0</span>])&#123;</div><div class="line">         Excel e = <span class="keyword">new</span> Excel();</div><div class="line">            e.start();</div><div class="line">         &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>上面的程序通过new关键字创建对象，是静态加载类，所以如果Word类和Excel类中缺少一个，另一个类即使存在也无法通过编译。  </p><p>如果通过反射动态加载类可以解决这个问题，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficeBetter</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="comment">//动态加载类,在运行时刻加载</span></div><div class="line">        Class c = Class.forName(args[<span class="number">0</span>]);</div><div class="line">            <span class="comment">/*通过类类型,创建该类的对象,此时需要强制转换为Excel和Word的公有类型，</span></div><div class="line"><span class="comment">            所以可以定义OfficeAble接口，让Excel和Word实现这个接口*/</span></div><div class="line">            OfficeAble oa = (OfficeAble)c.newInstance();</div><div class="line">            oa.start();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>由于是动态加载类，新增其他实现OfficeAble接口的类不必重新编译OfficeBetter类。</p><h3 id="4-在运行时分析类的能力"><a href="#4-在运行时分析类的能力" class="headerlink" title="4.在运行时分析类的能力"></a>4.在运行时分析类的能力</h3><p>　　下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。<br>Java中为了支持反射机制主要提供了以下的类：<br>java.lang.Class<br>java.lang.reflect.Field<br>java.lang.reflect.Constructor<br>java.lang.reflect.Method<br>java.lang.reflect.Modifier  </p><p><strong>java.lang.Class类的常用API如下：</strong>  </p><ul><li>Field[] getFields()   </li><li>Field[] getDeclaredFields()   </li><li>Method[] getMethods()  </li><li>Method[] getDeclaredMethods()      </li><li>Constructor&lt; ? &gt;[] getConstructors()  </li><li>Constructor&lt; ? &gt;[] getDeclaredConstructors() </li><li>Class&lt; ? &gt; getSupperClass() </li><li>Class&lt; ? &gt;[] getInterfaces()</li></ul><p><strong>提示：</strong>getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，不论访问权限，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象</p><p><strong>其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。<br>这三个类的常用API如下：</strong>  </p><ul><li>String getName() 返回一个用于描述域名、构造器或方法的字符串  </li><li>Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象  </li><li>Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)<br>返回一个用于描述方法抛出异常类型的Class对象数组  </li><li>int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值  </li><li>Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组  </li><li>Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象  </li></ul><p><strong>java.lang.reflect.Modifier类的常用API如下</strong>  </p><ul><li>static String toString(int modifiers)<br>返回修饰符对应的字符串描述</li><li>static boolean isAbstract(int modifiers)  </li><li>static boolean isFinal(int modifiers)</li><li>static boolean isInterface(int modifiers)</li><li>static boolean isNative(int modifiers)</li><li>static boolean isPrivate(int modifiers)</li><li>static boolean isProtected(int modifiers)</li><li>static boolean isPublic(int modifiers)</li><li>static boolean isStatic(int modifiers)</li><li>static boolean isStrict(int modifiers)</li><li>static boolean isSynchronized(int modifiers)</li><li>static boolean isVolatile(int modifiers)<br>上述方法检测修饰符是否是某一特定修饰符<br>java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义   </li></ul><p><strong>下面是一个检测类内部结构的例子</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">import</span> java.lang.Class;</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">if</span>(args.length &gt; <span class="number">0</span>) </div><div class="line">name = args[<span class="number">0</span>];</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">System.out.println(<span class="string">"Enter class name (e.g. java.util.Date)"</span>);</div><div class="line">name = in.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Class&lt;?&gt; c1 = Class.forName(name);</div><div class="line">Class&lt;?&gt; superc1 = c1.getSuperclass();</div><div class="line">String modifiers = Modifier.toString(c1.getModifiers());</div><div class="line"><span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) </div><div class="line">System.out.print(modifiers + <span class="string">" "</span> );</div><div class="line">System.out.print(<span class="string">"class "</span> + name);</div><div class="line"><span class="keyword">if</span>(superc1 != <span class="keyword">null</span> &amp;&amp; superc1 != Object.class)</div><div class="line">System.out.print(<span class="string">"  extends "</span>  +  superc1.getSimpleName());</div><div class="line">System.out.print(<span class="string">"\n&#123;\n"</span>);</div><div class="line">printFields(c1);</div><div class="line">System.out.println();</div><div class="line">printConstructors(c1);</div><div class="line">System.out.println();</div><div class="line">printMethods(c1);</div><div class="line">System.out.println(<span class="string">"&#125;"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(ClassNotFoundException e)</div><div class="line">&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.exit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class&lt;?&gt; c1)</span> </span>&#123;</div><div class="line">Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Constructor&lt;?&gt; c : constructors) &#123;</div><div class="line">String name = c.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(c.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = c.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class&lt;?&gt; c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Method[] methods = c1.getDeclaredMethods();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Method m :methods) &#123;</div><div class="line">Class&lt;?&gt; retType = m.getReturnType();</div><div class="line">String name = m.getName();</div><div class="line"></div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(m.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(retType.getSimpleName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = m.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class&lt;?&gt;  c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Field[] Fields = c1.getDeclaredFields();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Field f : Fields) &#123;</div><div class="line">Class&lt;?&gt; type = f.getType();</div><div class="line">String name = f.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(f.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">"  "</span>);</div><div class="line">System.out.println(type.getSimpleName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-在运行时使用反射分析对象"><a href="#5-在运行时使用反射分析对象" class="headerlink" title="5.在运行时使用反射分析对象"></a>5.在运行时使用反射分析对象</h3><p>　　反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。<br>　　查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Employee harry = <span class="keyword">new</span> Empolyee(<span class="string">"Harry Hacker"</span>,<span class="number">35000</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">1989</span>);</div><div class="line">Class&lt;Employee&gt; c1 = harry.getClass();</div><div class="line">Field f = c1.getDeclaredField(<span class="string">"name"</span>); <span class="comment">//返回某一个特定域</span></div><div class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//由于name是私有域，必须先设置为可访问</span></div><div class="line">Object v = f.get(harry);</div></pre></td></tr></table></figure><p>　　上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value  </p><p><strong>下面是一些相关API</strong><br>在java.lang.reflect.Field中：  </p><ul><li>Object get(Object obj)<br>返回obj对象中用Field对象表示的域值</li><li>xxx getXxx(Object obj)<br>返回obj对象的基本类型的域的值</li><li>void set(Object obj,Object newValue)<br>用一个新值设置obj对象中Field对象表示的域    </li></ul><p>在java.lang.Class中：  </p><ul><li>Field getField(String name)<br>返回指定名称的公有域  </li><li>Field getDeclaredField(String name)  </li><li>返回指定名称的声明的域  </li></ul><p>在java.lang.reflect.AccessibleObject中：  </p><ul><li>void setAccessible(boolean flag)<br>为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置  </li><li>boolean isAccessible()<br>返回反射对象的可访问标志的值  </li><li>static void setAccessible(AccessibleObject[] array,boolean flag)<br>批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 </li></ul><h3 id="6-使用反射编写泛型数组代码"><a href="#6-使用反射编写泛型数组代码" class="headerlink" title="6.使用反射编写泛型数组代码"></a>6.使用反射编写泛型数组代码</h3><p>　　java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee[] a = <span class="keyword">new</span> Employee[<span class="number">100</span>];</div><div class="line">a = Arrays.copyOf(a,<span class="number">2</span> * a.length);</div></pre></td></tr></table></figure></p><p>　　我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a,<span class="keyword">int</span> newLength)&#123;</div><div class="line">Object[] newArray = <span class="keyword">new</span> Object[newLength];</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(a.length,newLength);</div><div class="line">    <span class="keyword">return</span> newArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>　　上述代码存在一个错误，即使用了<code>new Object[newLength]</code>创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。<br><strong>为了解决这个问题，下面提供java.lang.reflect.Array中的API</strong>  </p><ul><li>static Object get(Object array,int index)<br>返回对象数组某个位置上的元素</li><li>static xxx getXxx(Object array,int index)<br>(xxx是基本数据类型)返回基本类型数组某个位置上的值 </li><li>static void set(Object array,int index,Object newValue)<br>设置对象数组某个位置上的元素</li><li>static void setXxx(Object array,int index,xxx newValue)<br>(xxx是基本数据类型)设置基本类型数组某个位置上的值 </li><li>static int getLength(Object array)<br>返回数组的长度  </li><li>static Object newInstance(Class componentType,int length)  </li><li><p>static Object newInstance(Class componentType,int[] length)<br>返回一个具有给定类型、给定维数的新数组  </p><p>下面给出正确的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a,<span class="keyword">int</span> newLength)</span></span>&#123;</div><div class="line">&#123;</div><div class="line">Class c1 = a.getClass();<span class="comment">//获取a数组的类对象</span></div><div class="line">    <span class="keyword">if</span>(!c1.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//确认是一个数组</span></div><div class="line">    Class componentType = c1.getComponentType();</div><div class="line">    <span class="comment">//获取数组类型</span></div><div class="line">    <span class="keyword">int</span> length = Array.getLength(a);</div><div class="line">    Object newArray = Array.newInstance(componentType,newLength);</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</div><div class="line">    <span class="keyword">return</span> newArray;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">a = (<span class="keyword">int</span>[]) goodCopyOf(a,<span class="number">10</span>);</div></pre></td></tr></table></figure><p>　　为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型 </p><h3 id="7-调用任意方法"><a href="#7-调用任意方法" class="headerlink" title="7.调用任意方法"></a>7.调用任意方法</h3><p>　　通过反射还可以调用任意方法，这是通过Method类的invoke方法实现的，方法签名是:<code>Object invoke(Object obj,Object... args)</code>,Object obj表示调用方法的对象，Object…args表示方法的参数列表。<br>如果方法是静态方法，将第一个参数设置为null;如果方法是非静态无参方法，第二个参数列表可以忽略。<br>　　例如：<code>String n = (String)m1.invoke(harry);</code>(m1表示Employee类的getName方法)。如果方法m1的返回值是void，则invoke方法返回null，否则返回具体类型。如果返回值是基本类型，invoke方法会返回其包装器类型,可以利用自动开箱将其还原为基本数据类型。例如:<code>double s = (Double)m2.invoke(harry);</code>(m2表示Employee类的getSalary方法)<br>getMethods方法和getDeclaredMethods会返回一个Method对象列表，如果要得到特定的Method对象，可以调用Class类的getMethod方法，其签名是Method getMethod(String Methodname,Class…parameterTypes)。<br>例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method m1 = Employee.class.getMethod(<span class="string">"getName"</span>);  </div><div class="line">Method m2 = Employee.class.getMethod(<span class="string">"raiseSalary"</span>,<span class="keyword">double</span>.class);</div></pre></td></tr></table></figure></li></ul><p>　　下面给出一个调用任意方法打印函数表的程序(以自定义的square和Math.sqrt方法为例)：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTableTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">Method square =         MethodTableTest.class.getMethod(<span class="string">"square"</span>,<span class="keyword">double</span>.class);</div><div class="line">    Method sqrt = Math.class.getMethod(<span class="string">"sqrt"</span>,<span class="keyword">double</span>.class);</div><div class="line">    </div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,square);</div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,sqrt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from,<span class="keyword">double</span> to,<span class="keyword">int</span> n,Method f)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    System.out.println(f);</div><div class="line">    <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> x = from;x &lt;= to;x += dx)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">try</span></div><div class="line">      &#123;</div><div class="line">         <span class="keyword">double</span> y = (Double)f.invoke(<span class="keyword">null</span>,x);</div><div class="line">         System.out.printf(<span class="string">"%10.4f | %10/4f\n"</span>,x,y);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span>(Exception e)</div><div class="line">      &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p> <strong>invoke方法如果提供了错误的参数，会抛出一个异常，所以要提供一个异常处理器</strong><br> 建议在有必要的时候才使用invoke方法，有如下原因:<br> 1.invoke方法的参数和返回值必须是Object类型，意味着必须进行多次类型转换，这样会使编译器错过检查代码的机会，等到测试阶段才发现错误，找到并改正会更加困难<br> 2.通过反射调用方法比直接调用方法要明显慢一些</p><p><strong>特别重申：</strong>建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的执行速度更快，更易于维护。    </p><h3 id="8-通过反射了解泛型本质"><a href="#8-通过反射了解泛型本质" class="headerlink" title="8.通过反射了解泛型本质"></a>8.通过反射了解泛型本质</h3><p>来看下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">Class c1 = list.getClass();</div><div class="line">Class c2 = list1.getClass();</div><div class="line">System.out.println(c1 == c2); <span class="comment">//true</span></div><div class="line"><span class="comment">/*反射的操作都是编译之后的操作，编译之后会发生类型擦除，即ArrayList&lt;String&gt;被擦除为ArrayList，所以c1 == c2结果为true*/</span></div></pre></td></tr></table></figure></p><p>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，编译之后就会发生类型擦除，所以绕过编译泛型就无效了</p><p>验证：我们可以通过方法的反射来操作，绕过编译<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Method m = c2.getMethod(<span class="string">"add"</span>, Object.class);</div><div class="line">m.invoke(list1, <span class="number">20</span>);<span class="comment">//绕过编译操作就绕过了泛型</span></div><div class="line">System.out.println(list1.size());</div><div class="line">System.out.println(list1);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p> 推荐博客：  </p><ul><li><a href="http://www.cnblogs.com/absfree/p/5277665.html" target="_blank" rel="external">Java核心技术点之反射</a>  </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li><li><a href="http://blog.csdn.net/liujiahan629629/article/details/18013523" target="_blank" rel="external">Java中的反射机制</a></li><li><a href="http://www.importnew.com/9078.html" target="_blank" rel="external">Java反射教程</a></li><li><a href="http://www.cnblogs.com/rollenholt/archive/2011/09/02/2163758.html" target="_blank" rel="external">Java反射详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  &lt;/p&gt;
&lt;h3 id=&quot;1-什么是反射？&quot;&gt;&lt;a href=&quot;#1-什么是反射？&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之继承和多态</title>
    <link href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://habitdiary.cn/2017/10/12/Java学习总结之继承和多态/</id>
    <published>2017-10-12T15:18:55.000Z</published>
    <updated>2018-02-14T07:27:27.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父类与子类"><a href="#父类与子类" class="headerlink" title="父类与子类"></a>父类与子类</h3><p>在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。  </p><h4 id="继承有如下几个关键点"><a href="#继承有如下几个关键点" class="headerlink" title="继承有如下几个关键点"></a>继承有如下几个关键点</h4><p>1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法<br>2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们<br>3.不是所有的“是一种”(is-a)关系都该用继承来建模<br>4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承<br>5.Java中类与类的继承是单一继承  </p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super关键字有两种作用：<br><strong>1.调用父类的构造方法</strong><br>因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。<br>形式是<code>super()</code>或<code>super(arguments)</code>，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条<code>super()</code><br>有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。  </p><p><strong>2.调用父类的方法</strong><br>在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用<code>super.方法名</code>来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，<code>super.super.方法名</code>是不合法的。  </p><h3 id="构造方法链"><a href="#构造方法链" class="headerlink" title="构造方法链"></a>构造方法链</h3><p>在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Faculty</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">       <span class="keyword">new</span> Faculty();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Faculty</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"(4) Performs Faculty's tasks"</span>);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">this</span>(<span class="string">"(2) Invoke Employee's overloaded constructor"</span>);</div><div class="line">        System.out.println(<span class="string">"(3) Perfoms Employee's tasks"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String s)</span></span>&#123;</div><div class="line">  System.out.println(s);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"(1) Performs Person's tasks"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">```  </div><div class="line">打印结果为:  </div><div class="line">(<span class="number">1</span>) Performs Person<span class="string">'s tasks  </span></div><div class="line"><span class="string">(2) Invoke Employee'</span>s overloaded constructor  </div><div class="line">(<span class="number">3</span>) Performs Employee<span class="string">'s tasks  </span></div><div class="line"><span class="string">(4) Performs Faculty'</span>s tasks  </div><div class="line"></div><div class="line">我们可以知道：子类的构造方法的第一条语句要么是**<span class="keyword">super</span>语句(包括编译器隐式插入的)**,要么是**<span class="keyword">this</span>语句**，它通过调用同一个类的另一个重载的构造方法，再调用该方法的<span class="keyword">super</span>语句初始化父类  </div><div class="line"></div><div class="line">注意:如果没有显式在子类构造方法中定义<span class="keyword">super</span>语句，编译器自动插入的<span class="keyword">super</span>语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。  </div><div class="line">### 方法重载与重写  </div><div class="line">**重载**  </div><div class="line">方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型和访问修饰符可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同)  </div><div class="line"></div><div class="line">**重写**  </div><div class="line">方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。  </div><div class="line">为了避免错误，可以使用重写注解，在要重写的方法前加上`<span class="meta">@Override</span>`，该注解会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。</div><div class="line"></div><div class="line">**关于重写的几点注意**  </div><div class="line"><span class="number">1</span>.仅当实例方法是可访问的，它才能被覆盖  </div><div class="line"><span class="number">2</span>.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法  </div><div class="line"><span class="number">3</span>.尽管重写一般用于方法，属性其实也可以重写，即子类可以定义和父类同名的属性，子类的属性会覆盖父类的属性。</div><div class="line"></div><div class="line">方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。</div><div class="line"></div><div class="line">### 多态  </div><div class="line">Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。  </div><div class="line">注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。</div><div class="line">### 动态绑定</div><div class="line">多态机制的底层实现技术是**动态绑定**，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。</div><div class="line"></div><div class="line">对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。  </div><div class="line"></div><div class="line">静态绑定(前期绑定)：</div><div class="line">在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有<span class="keyword">final</span>，<span class="keyword">static</span>，<span class="keyword">private</span>和构造方法是前期绑定。</div><div class="line"></div><div class="line">动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。</div><div class="line">若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</div><div class="line"></div><div class="line">简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。</div><div class="line">### 理解方法调用  </div><div class="line">假设下面要调用x.f(args)，方法调用的过程为：  </div><div class="line"><span class="number">1</span>） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(<span class="keyword">int</span>)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。  </div><div class="line"><span class="number">2</span>） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。  </div><div class="line"><span class="number">3</span>） 如果是<span class="keyword">private</span>方法、<span class="keyword">static</span>方法、<span class="keyword">final</span>方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为<span class="keyword">private</span>方法、构造器不能被继承，更谈不上重写，而<span class="keyword">static</span>方法和<span class="keyword">final</span>方法虽然能被继承，但不能被重写。  </div><div class="line"><span class="number">4</span>) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。  </div><div class="line"></div><div class="line">每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。  </div><div class="line">方法表示例(Manager继承自Employee)：  </div><div class="line"></div><div class="line">Employee:</div><div class="line">getName() -&gt; Employee.getName()  </div><div class="line">getSalary() -&gt; Employee.getSalary()  </div><div class="line">getHireDay() -&gt; Employee.getHireDay()  </div><div class="line">raiseSalary(<span class="keyword">double</span>) -&gt; Employee.raiseSalary(<span class="keyword">double</span>)  </div><div class="line"></div><div class="line">Manager:  </div><div class="line">getName() -&gt; Employee.getName()<span class="comment">//继承的方法  </span></div><div class="line">getSalary() -&gt; Manager.getSalary()<span class="comment">//重写的方法  </span></div><div class="line">getHireDay() -&gt; Employee.getHireDay()<span class="comment">//继承的方法  </span></div><div class="line">raiseSalary(<span class="keyword">double</span>) -&gt; Employee.raiseSalary(<span class="keyword">double</span>)<span class="comment">//继承的方法  </span></div><div class="line">setBonus(<span class="keyword">double</span>) -&gt; Manager.setBonus(<span class="keyword">double</span>)<span class="comment">//新增的方法  </span></div><div class="line"></div><div class="line">### 内联优化  </div><div class="line">带有<span class="keyword">final</span>修饰符的类是不可派生的。在Java核心API中，有许多应用<span class="keyword">final</span>的例子，例如java.lang.String，整个类都是 <span class="keyword">final</span>的。为类指定<span class="keyword">final</span>修饰符可以让类不可以被继承，为方法指定<span class="keyword">final</span>修饰符可以让方法不可以被重写。如果指定了一个类为<span class="keyword">final</span>，则该类所有的方法都是<span class="keyword">final</span>的。Java编译器会寻找机会内联优化所有的<span class="keyword">final</span>方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高<span class="number">50</span>%。如果确定一个类不会被派生或一个方法不会被重写，建议使用<span class="keyword">final</span>关键字修饰。  </div><div class="line"></div><div class="line">### 对象类型转换  </div><div class="line">和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。  </div><div class="line">我们可以通过`<span class="keyword">instanceof</span>`运算符来检测一个对象是否是某个类或接口的实例，其返回值是<span class="keyword">boolean</span>类型的。  </div><div class="line">注意:  </div><div class="line"><span class="number">1</span>.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();  </div><div class="line"><span class="number">2</span>.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。  </div><div class="line">### Object类  </div><div class="line">Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出`<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxx</span> <span class="keyword">extends</span> <span class="title">Object</span>`,在<span class="title">Java</span>中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了<span class="title">Object</span>类。  </span></div><div class="line"><span class="class">下面介绍<span class="title">Object</span>类中的几个重要方法及重写规范：  </span></div><div class="line"><span class="class">#### 1) <span class="title">equals</span>方法  </span></div><div class="line"><span class="class"><span class="title">Object</span>类中的<span class="title">equals</span>方法用于检测一个对象是否等于另外一个对象。在<span class="title">Object</span>类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。  </span></div><div class="line"><span class="class"></span></div><div class="line">equals方法的原型是public boolean equals(Object obj),默认实现是:  </div><div class="line">```java</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</div><div class="line">&#125;</div><div class="line">```    </div><div class="line">调用它的语法是`object1.equals(object2)`，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。    </div><div class="line">比如类Employee定义了数据域：<span class="keyword">private</span> String name,<span class="keyword">private</span> <span class="keyword">double</span> salary,<span class="keyword">private</span> LocalDate hireDay  </div><div class="line">equals方法重写如下：  </div><div class="line">```java </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//快速检测引用是否相等，相等返回ture</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//检测引用是否为空，为空返回false  </span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(getClass() != obj.getClass())  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     <span class="comment">//检测是否属于同一个类，不是返回false  </span></div><div class="line">        </div><div class="line">    Empolyee other = (Employee) obj;<span class="comment">//向下转型  </span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> name.equals(other.name)</div><div class="line">      &amp;&amp; salary == other.salary</div><div class="line">      &amp;&amp; hireDay.equals(other.hireDay);</div><div class="line">      <span class="comment">//逐一比较数据域,有一个不等返回就false，否则返回true</span></div><div class="line">```  </div><div class="line">**进一步改进：**  </div><div class="line">*改进一*  </div><div class="line">上述的第<span class="number">4</span>步检测，可以改为  </div><div class="line">```java</div><div class="line"><span class="keyword">return</span> Objects.equals(name,other.name)</div><div class="line">   &amp;&amp; salary == other.salary</div><div class="line">   &amp;&amp; Objects.equals(hireDay,other.hireDay);</div><div class="line">```  </div><div class="line">其中Objects.equals方法可以防备name 或 hireDay 可能为<span class="keyword">null</span>的情况，如果两个参数都为<span class="keyword">null</span>，Objects(a,b)返回<span class="keyword">true</span>;如果其中一个为<span class="keyword">null</span>，返回<span class="keyword">false</span>;如果两个参数都不为<span class="keyword">null</span>,调用a.equals(b)。Objects类在java.util包中。  </div><div class="line"></div><div class="line">在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。  </div><div class="line">比如Manager类继承自Employee，在父类的基础上增加了<span class="keyword">private</span> <span class="keyword">double</span> bonus：  </div><div class="line">```java</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">super</span>.equals(obj)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Manager other = (Manager) obj;</div><div class="line">        <span class="keyword">return</span> bonus == other.bonus;</div><div class="line">    &#125;</div><div class="line">```  </div><div class="line">*改进二*  </div><div class="line">上述代码的第<span class="number">3</span>步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用<span class="keyword">instanceof</span>进行检测，比如雇员的ID作为相等的概念，就可以用xxx <span class="keyword">instanceof</span> Employee进行检测，并将Empolyee.equals声明为<span class="keyword">final</span>。  </div><div class="line"></div><div class="line">**equals方法要满足下面的特性**  </div><div class="line"><span class="number">1</span>. 自反性: 对于任何非空引用，x.equals(x)应该返回<span class="keyword">true</span>  </div><div class="line"><span class="number">2</span>. 对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同  </div><div class="line"><span class="number">3</span>. 传递性：对于任何引用x、y和z,如果x.equals(y)返回<span class="keyword">true</span>，y.equals(z)返回<span class="keyword">true</span>，那么x.equals(z)也应该返回<span class="keyword">true</span>  </div><div class="line"><span class="number">4</span>. 一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果  </div><div class="line"><span class="number">5</span>. 对于任何非空引用x,x.equals(<span class="keyword">null</span>)应该返回<span class="keyword">false</span></div><div class="line"></div><div class="line">**下面我们给出编写一个完美的equals方法的建议**：  </div><div class="line"><span class="number">1</span>) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测  </div><div class="line"><span class="number">2</span>) 检测引用是否为空，如果为空，不必再检测，直接返回不等  </div><div class="line"><span class="number">3</span>) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:`<span class="keyword">if</span>(getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>`;如果所有子类都拥有统一的语义(父类决定相等)，就使用<span class="keyword">instanceof</span>检测：`<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> ClassName) <span class="keyword">return</span> <span class="keyword">false</span>)`  </div><div class="line"><span class="number">4</span>) 将obj向下转型为相应类的类型变量  </div><div class="line"><span class="number">5</span>) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测    </div><div class="line">**数组对象用静态的Arrays.equals方法判等**</div><div class="line"></div><div class="line">拓展：[Integer判断相等，到底该用==还是equals](http:<span class="comment">//www.jianshu.com/p/9cb9c61b0986)  </span></div><div class="line"></div><div class="line">当我们在方法里调用equals方法时，建议写字符串常量.equals(参数)的形式。比如：  </div><div class="line">```java</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">function</span><span class="params">(String str)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"hello world"</span>.equals(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样可以防止str为null而抛出空指针异常，而根据equals()方法的对称性，这种调换并不会影响方法的功能。</p><h4 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="2) hashCode方法"></a>2) hashCode方法</h4><p>散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。<br>String类使用下列算法计算散列码：  </p><pre><code class="java"><span class="keyword">int</span> hash = <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length();i++){    hash = <span class="number">31</span> * hash + charAt(i);}</code></pre><p>由于hashCode方法定义在Object类中，方法原型是<code>public int hashCode()</code>,因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。<br><strong>如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。</strong><br>hashCode方法应该返回一个整型数值(可以是负数),<strong>并合理地组合实例域的散列码</strong>，以便能让各个不同的对象产生的散列码更均匀。<br>例如，下面是Employee类的hashCode方法  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * name.hashCode()      + <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode()      + <span class="number">13</span> * hireDay.hashCode();</code></pre><p><strong>进一步改进</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name)      + <span class="number">11</span> * Double.hashCode(salary)      + <span class="number">13</span> * Objects.hashCode(hireDay);</code></pre><p><strong>从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()</strong><br>其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象    </p><p><strong>还有更简单的做法</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> Objects.hash(name,salary,hireDay); }</code></pre><p><strong>Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID</strong>  </p><h4 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="3) toString方法"></a>3) toString方法</h4><p>方法原型是<code>public String toString()</code>,用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：<code>类名@对象十六进制内存地址</code>的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似<code>[I@1a46e30</code>的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。<br>toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。<br>当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。  </p><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如：  </p><pre><code class="java"><span class="keyword">int</span> actualSize = . . .;Employee[] staff = <span class="keyword">new</span> Employee[actualSize];</code></pre><p>但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。<br>ArrayList是一个采用<strong>类型参数</strong>的<strong>泛型类</strong>,声明方式为<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;()</code>,从Java SE 7开始，可以省去右边的类型参数，即<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()</code><br>在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于<code>ArrayList&lt;Object&gt;</code>,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。<br>ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。  </p><h4 id="ArrayList类的常用API"><a href="#ArrayList类的常用API" class="headerlink" title="ArrayList类的常用API"></a>ArrayList类的常用API</h4><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  </li></ul><h4 id="对于数组列表有用的方法"><a href="#对于数组列表有用的方法" class="headerlink" title="对于数组列表有用的方法"></a>对于数组列表有用的方法</h4><p><strong>1.数组和ArrayList互相转换</strong>  </p><p>数组转ArrayList:  </p><pre><code class="java">String[] array = {<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>};ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array));</code></pre><p>ArrayList转数组:  </p><pre><code class="java">String[] array = <span class="keyword">new</span> String[list.size()];list.toArray(array);</code></pre><h4 id="2-Collections类"><a href="#2-Collections类" class="headerlink" title="2.Collections类"></a>2.Collections类</h4><p>Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。</p><p><strong>ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。</strong>  </p><h3 id="final关键字总结"><a href="#final关键字总结" class="headerlink" title="final关键字总结"></a>final关键字总结</h3><p>final关键字在不同语句中有不同的作用：<br>1) <strong>修饰类变量或成员变量</strong> 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。只能在定义时、构造方法中或构造代码块中赋值。<br>2）<strong>修饰方法的局部变量，即常量</strong> final修饰的局部变量只要在使用前被赋值即可，不要求在定义时即赋值，但赋值后不可改变。<br>3) <strong>修饰方法</strong> 表示该方法不能被重写，注意final不能修饰构造方法。<br>4) <strong>修饰类</strong> 表示该类不能被扩展</p><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><h4 id="1-将公共操作和域放在超类"><a href="#1-将公共操作和域放在超类" class="headerlink" title="1.将公共操作和域放在超类"></a>1.将公共操作和域放在超类</h4><h4 id="2-不要使用受保护的域"><a href="#2-不要使用受保护的域" class="headerlink" title="2.不要使用受保护的域"></a>2.不要使用受保护的域</h4><p>protected机制并不能够带来更好的保护，其原因主要有两点:<br>第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。<br>第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。<br>不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的  </p><h4 id="3-使用继承实现-“is-a”-关系"><a href="#3-使用继承实现-“is-a”-关系" class="headerlink" title="3.使用继承实现 “is-a” 关系"></a>3.使用继承实现 “is-a” 关系</h4><h4 id="4-除非所有继承的方法都有意义，否则不要使用继承"><a href="#4-除非所有继承的方法都有意义，否则不要使用继承" class="headerlink" title="4.除非所有继承的方法都有意义，否则不要使用继承"></a>4.除非所有继承的方法都有意义，否则不要使用继承</h4><p>比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。  </p><h4 id="5-在覆盖方法时，不要改变预期的行为"><a href="#5-在覆盖方法时，不要改变预期的行为" class="headerlink" title="5.在覆盖方法时，不要改变预期的行为"></a>5.在覆盖方法时，不要改变预期的行为</h4><h4 id="6-使用多态，而非类型信息"><a href="#6-使用多态，而非类型信息" class="headerlink" title="6.使用多态，而非类型信息"></a>6.使用多态，而非类型信息</h4><p>即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为</p><h4 id="7-不要过多地使用反射"><a href="#7-不要过多地使用反射" class="headerlink" title="7.不要过多地使用反射"></a>7.不要过多地使用反射</h4><p>反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;父类与子类&quot;&gt;&lt;a href=&quot;#父类与子类&quot; class=&quot;headerlink&quot; title=&quot;父类与子类&quot;&gt;&lt;/a&gt;父类与子类&lt;/h3&gt;&lt;p&gt;在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之对象与类</title>
    <link href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
    <id>http://habitdiary.cn/2017/10/12/Java学习总结之对象与类/</id>
    <published>2017-10-12T00:40:34.000Z</published>
    <updated>2018-02-14T05:49:56.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h3><p>　　面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。<br>　　传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。<br>　　对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。  </p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>　　类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。<br>　　对象：由类构造的实例，一个类可以构造多个实例。  　　</p><h3 id="设计类的简单规则"><a href="#设计类的简单规则" class="headerlink" title="设计类的简单规则"></a>设计类的简单规则</h3><p>　　先从设计类的数据域开始，再向类里添加方法。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><h4 id="1-依赖-Dependence"><a href="#1-依赖-Dependence" class="headerlink" title="1.依赖(Dependence)"></a>1.依赖(Dependence)</h4><p>　　假设A类的变化引起了B类的变化，则B类依赖于A类。依赖关系(Dependency) 是一种<strong>使用关系</strong>，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。<strong>大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。</strong>应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。<br>　　在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。  </p><p>  <img src="/2017/10/12/Java学习总结之对象与类/依赖.png" alt="fail"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Car car)</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        car.move();  </div><div class="line">    &#125;  </div><div class="line">    ……  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        ......  </div><div class="line">    &#125;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>依赖关系有如下三种情况：<br>　　1、A类是B类中某方法的局部变量；<br>　　2、A类是B类方法当中的一个参数；<br>　　3、A类向B类发送消息，从而影响B类发生变化；</p><h4 id="2-泛化-Generalization"><a href="#2-泛化-Generalization" class="headerlink" title="2.泛化(Generalization)"></a>2.泛化(Generalization)</h4><p>　　A是B和C的父类，B,C具有公共类（父类）A，说明A是B,C的一般化(也称泛化)。<br>　　泛化关系就是继承关系。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。  </p><p>  <img src="/2017/10/12/Java学习总结之对象与类/泛化.png" alt="fail"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>   </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">protected</span> String name;  </div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span>   </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        ……  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span>   </span></div><div class="line"><span class="function">   </span>&#123;  </div><div class="line">        ……  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span>   </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> String studentNo;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span>   </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        ……  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在UML当中，对泛化关系有三个要求：<br>　　1、子类与父类应该完全一致，父类所具有的属性、操作，子类应该都有<br>　　2、子类中除了与父类一致的信息以外，还包括额外的信息<br>　　3、可以使用父类的实例的地方，也可以使用子类的实例</p><h4 id="3-关联-Association"><a href="#3-关联-Association" class="headerlink" title="3.关联(Association)"></a>3.关联(Association)</h4><p>　　类之间的联系，如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单，再如篮球队员与球队之间的关联（下图所示）。  </p><p><img src="/2017/10/12/Java学习总结之对象与类/关联.jpg" alt="fail"><br>　　其中，关联两边的”employee”和“employer”标示了两者之间的关系，而数字表示两者的关系的限制，是关联两者之间的多重性。通常有“<code>*</code>”（表示所有，不限），“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”(表示n到m个都可以)，“m…<code>*</code>”（表示至少m个）。<br>　　关联关系(Association) 是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。在UML类图中，用实线连接有关联的对象所对应的类，在使用Java、C#和C++等编程语言实现关联关系时，通常将一个类的对象作为另一个类的属性。在使用类图表示关联关系时可以在关联线上标注角色名。  </p><p><strong>双向关联:</strong> 默认情况下，关联是双向的。  </p><p><img src="/2017/10/12/Java学习总结之对象与类/双向关联.png" alt="fail"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Product[] products;  </div><div class="line">    ……  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Customer customer;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>单向关联:</strong> 类的关联关系也可以是单向的，单向关联用带箭头的实线表示。<br><img src="/2017/10/12/Java学习总结之对象与类/单向关联.png" alt="fail"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Address address;  </div><div class="line">    ……  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>自关联:</strong> 在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。  </p><p><img src="/2017/10/12/Java学习总结之对象与类/自关联.png" alt="fail">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Node subNode;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>重数性关联:</strong> 重数性关联关系又称为多重性关联关系(Multiplicity)，表示一个类的对象与另一个类的对象连接的个数。在UML中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类的对象的个数。<br><img src="/2017/10/12/Java学习总结之对象与类/重数性关联.png" alt="fail"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Form</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Button buttons[];  </div><div class="line">    ……  </div><div class="line">&#125;   </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    …  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="4-聚合-Aggregation"><a href="#4-聚合-Aggregation" class="headerlink" title="4.聚合(Aggregation)"></a>4.聚合(Aggregation)</h4><p>　　表示的是整体和部分的关系，整体与部分可以分开。聚合关系(Aggregation) 表示一个整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。 </p><p><img src="/2017/10/12/Java学习总结之对象与类/聚合.png" alt="fail">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Engine engine;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span>  </span></div><div class="line"><span class="function">   </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.engine = engine;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.engine = engine;  </div><div class="line">    &#125;  </div><div class="line">    ……  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　如：电话机包括一个话筒;电脑包括键盘、显示器，一台电脑可以和多个键盘、多个显示器搭配，确定键盘和显示器是可以和主机分开的，主机可以选择其他的键盘、显示器组成电脑。<br><img src="/2017/10/12/Java学习总结之对象与类/eg.jpg" alt="fail">  </p><h4 id="5-组合-Composition"><a href="#5-组合-Composition" class="headerlink" title="5.组合(Composition)"></a>5.组合(Composition)</h4><p>　　也是整体与部分的关系，但是整体与部分不可以分开。组合关系(Composition)也表示类之间整体和部分的关系，但是组合关系中部分和整体具有<strong>统一的生存期</strong>。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有<strong>同生共死</strong>的关系。</p><p><img src="/2017/10/12/Java学习总结之对象与类/组合.png" alt="fail">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Mouth mouth;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">()</span>  </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">    mouth = <span class="keyword">new</span> Mouth();  </div><div class="line">    &#125;  </div><div class="line">    ……  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouth</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    ……  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　如：公司和部门，部门是部分，公司是整体，公司A的财务部不可能和公司B的财务部对换，就是说，公司A不能和自己的财务部分开;人与人的心脏。<br><img src="/2017/10/12/Java学习总结之对象与类/eg2.jpg" alt="fail">  </p><h4 id="6-实现-Implementation"><a href="#6-实现-Implementation" class="headerlink" title="6.实现(Implementation)"></a>6.实现(Implementation)</h4><p>　　实现是用来规定接口和实线接口的类或者构建结构的关系，接口是操作的集合，而这些操作就用于规定类或者构建的一种服务。<br>　　接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所     声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。</p><p><img src="/2017/10/12/Java学习总结之对象与类/实现.png" alt="fail">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span>   </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ship</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span>   </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">    ……  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span>  </span></div><div class="line"><span class="class"></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span>   </span></div><div class="line"><span class="function">    </span>&#123;  </div><div class="line">    ……  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h3><p>　　对象是调用构造方法在<strong>堆</strong>上分配内存产生的(用new + 构造方法来调用)，而对象变量是在<strong>栈</strong>上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上创建了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。</p><h3 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h3><p>1.创建的实例及成员变量（静、非静态）在堆中<br>2.局部变量在栈中<br>3.类的基本信息和方法定义在方法区<br><img src="/2017/10/12/Java学习总结之对象与类/store.png" alt="fail"></p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>相关知识见<a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="external">http://www.uml.org.cn/oobject/201211231.asp</a></p><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>　　构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。<br>　　构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，因为它是用来创建实例的，所以它永远是实例方法，不能被static修饰。<br>　　构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。<br>  　　建议在构造方法中调用各属性的set方法来初始化属性，而不是给属性直接赋值，这样set方法的合法性检查也会应用于构造方法。<br>    <strong>在eclipse的source菜单里有添加构造器的快捷选项。</strong></p><h3 id="访问对象的数据和方法"><a href="#访问对象的数据和方法" class="headerlink" title="访问对象的数据和方法"></a>访问对象的数据和方法</h3><p>　　在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。   </p><h3 id="引用数据域和null值"><a href="#引用数据域和null值" class="headerlink" title="引用数据域和null值"></a>引用数据域和null值</h3><p>　　如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。</p><h3 id="默认赋值规则"><a href="#默认赋值规则" class="headerlink" title="默认赋值规则"></a>默认赋值规则</h3><p>　　类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。  </p><h3 id="基本变量和引用变量的区别"><a href="#基本变量和引用变量的区别" class="headerlink" title="基本变量和引用变量的区别"></a>基本变量和引用变量的区别</h3><p>　　基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。<br>　　没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。  </p><h3 id="静态-非静态变量、常量和静态-非静态方法"><a href="#静态-非静态变量、常量和静态-非静态方法" class="headerlink" title="静态/非静态变量、常量和静态/非静态方法"></a>静态/非静态变量、常量和静态/非静态方法</h3><p>静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。不要从构造器中传入参数来初始化静态域，最好使用set方法改变静态数据域。<br>非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。<br>常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。<br>静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。<br>非静态方法：又称实例方法，是依赖于具体对象的方法。<br>关系：<br>静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。<br>静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。<br>在同一个类中： 对于静态方法，其他的静态或非静态方法都可以直接调用它。而对于非静态方法，其他的非静态方法是可以直接调用它的。但是其他静态方法只有通过创建对象才能调用它。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance();  </div><div class="line">NumberFormat percentFormatter = NumberFormat.gerPercentInstance();  </div><div class="line"><span class="keyword">double</span> x = <span class="number">0.1</span>;  </div><div class="line">System.out.println(currencyFormatter.format(x));<span class="comment">// prints $0.10</span></div><div class="line">System.out.println(percentFormatter.format(x));<span class="comment">//prints 10%</span></div></pre></td></tr></table></figure></p><p>使用静态工厂方法的原因主要有两个：<br>1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字<br>2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类</p><h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p>public<br>修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public</p><p>protected<br>修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问</p><p>default<br>缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。  </p><p>private<br>private成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。  </p><p><img src="http://img.blog.csdn.net/20150409153405264" alt="fail" title="四种可见性修饰符比较">  </p><p>注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句<code>package + 包名</code>，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。</p><h3 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h3><p>精确导入：导入某个包的特定类,如<code>import java.util.Scanner</code><br>通配导入：导入某个包的所有类,如<code>import java.util.*</code><br>编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类。<br>静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如<code>import static java.lang.System.*</code>导入了System类的静态方法和静态域，就可以不加类名前缀:<code>out.println(&quot;Hello world!&quot;)</code>，out是System类里定义的静态成员，是PrintStream的实例。<br><strong>注意：</strong><br>1、在要使用某个类时可以不导入，但要采用包名.类名的方式使用这个类。<br>2、<strong>不可以</strong>使用<strong>精确导入</strong>导入两个包中的<strong>同名类</strong>，此时应该一个类精确导入，另一个类通配导入。程序默认使用的类是精确导入的类，如果要使用通配导入的同名类，要使用包名.类名的方式。<br>3、使用通配导入的时候不能跨级导入，比如在<code>cn.habitdiary.core</code>包中的类只能通过<code>cn.habitdiary.core.*</code>来导入，而不能通过<code>cn.habitdiary.*</code>来导入。</p><h3 id="数据域封装"><a href="#数据域封装" class="headerlink" title="数据域封装"></a>数据域封装</h3><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。<br>实现封装的步骤：<br>1.用private可见性修饰符修饰类成员<br>2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()<br>3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue)<br><strong>eclipse的source里有添加getter和setter方法的快捷选项。</strong></p><h3 id="向方法传递对象参数"><a href="#向方法传递对象参数" class="headerlink" title="向方法传递对象参数"></a>向方法传递对象参数</h3><p>可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。  </p><h3 id="对象数组和普通数组"><a href="#对象数组和普通数组" class="headerlink" title="对象数组和普通数组"></a>对象数组和普通数组</h3><p>所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。  </p><h3 id="不可变对象和类"><a href="#不可变对象和类" class="headerlink" title="不可变对象和类"></a>不可变对象和类</h3><p>一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。<br>一个类是不可变类要满足以下三个条件：<br>1.所有的数据域都是私有的<br>2.没有修改器方法<br>3.没有一个返回指向可变数据域引用的访问器方法  </p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>就是错误的，因为j的初始化基于i已经被初始化的前提。  </p><p>局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。  </p><p>建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。</p><h3 id="this引用"><a href="#this引用" class="headerlink" title="this引用"></a>this引用</h3><p>this关键字有两大作用：<br>1.表示指向调用对象本身的引用名<br>2.可以在构造方法内部调用同一个类的其他构造方法，此时<code>this(参数列表)</code>语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用<code>this(参数列表)</code>的形式来实现它们。这样做可以简化代码，使类易于维护。  </p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h4><p>即依赖编译器对数据域的默认初始化。  </p><h4 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h4><p>在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。  </p><h4 id="无参数的构造器"><a href="#无参数的构造器" class="headerlink" title="无参数的构造器"></a>无参数的构造器</h4><p>即将对数据域的初始化置于一个无参的构造器中。  </p><h4 id="有参数的构造器"><a href="#有参数的构造器" class="headerlink" title="有参数的构造器"></a>有参数的构造器</h4><p>即给构造器传入参数对数据域进行初始化  </p><h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>在方法内的代码块称为普通代码块，就是一组用花括号括起来的语句，没有特殊含义。而如果用花括号包含的一组数据域赋值代码块出现在类内，就称为初始化块或构造代码块。初始化块一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块，不允许在静态初始化块内初始化实例成员。</p><h4 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h4><p>1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行(classLoader的类加载过程)。<br>2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行(classLoader类加载过程)。<br>3.父类的实例成员、实例初始化块、构造方法，按在代码中出现的顺序依次执行。<br>4.子类实例成员、实例初始化块、构造方法，按在代码中出现的顺序依次执行。    </p><p>注意：静态成员和静态初始化块只在该类被加载的时候初始化一次，可以看作初始化类。注意是被加载就初始化，不一定要构造对象。且静态成员和静态初始化块的初始化出现在main方法之前。</p><p>比如下面这个例子,有CodeBlock.java和Code.java两个文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CodeBlock.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlock</span></span>&#123;</div><div class="line">   <span class="comment">// 创建CodeBlock的构造块</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"CodeBlock的构造块"</span>);</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//创建CodeBlock的静态代码块</span></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"CodeBlock的静态代码块"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">//创建CodeBlock的构造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodeBlock</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"CodeBlock的构造方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"CodeBlock的主方法"</span>);</div><div class="line">      System.out.println(<span class="string">"产生Code类实例对象"</span>);</div><div class="line">      Code c = <span class="keyword">new</span> Code();</div><div class="line">      System.out.println(<span class="string">"产生CodeBlock类实例对象"</span>);</div><div class="line">      CodeBlock cb = <span class="keyword">new</span> CodeBlock();</div><div class="line">         </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Code.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span></span>&#123;</div><div class="line">   <span class="comment">//创建外部类Code构造块（构造块）</span></div><div class="line">   &#123;</div><div class="line">       System.out.println(<span class="string">"Code的构造块"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">//创建外部类Code静态代码块（静态代码块）</span></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.out.println(<span class="string">"Code的静态代码块"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//创建外部类Code构造方法（构造方法）</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Code</span><span class="params">()</span></span>&#123;</div><div class="line">       System.out.println(<span class="string">"Code的构造方法"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/2017/10/12/Java学习总结之对象与类/初始化.png" alt="fail"></p><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>JDK 包含一个很有用的工具 , 叫做 javadoc , 它可以由源文件生成一个 HTML 文档 。我们平时查阅的API就是这样形成的，而且添加文档注释后，eclipse也会对添加了文档注释的方法等给出智能提示。  </p><h4 id="注释的插入"><a href="#注释的插入" class="headerlink" title="注释的插入"></a>注释的插入</h4><p>javadoc 实用程序 ( utility ) 从下面几个特性中抽取信息：</p><ul><li>包</li><li>公有类与接口</li><li>公有的和受保护的构造器及方法</li><li>公有的和受保护的域    </li></ul><p>应该为上面几部分编写注释。注释应该放置在所描述特性的前面 。注释以 <code>/**</code> 开始, 并以 <code>*/</code> 结束 。插入文档注释的方法是输入<code>/**</code>后回车即可。<br>每个 <code>/** . . . */</code> 文档注释在标记之后紧跟着自由格式文本 (free-form text)。标记由<code>@</code>开始, 如 <code>@ author</code> 或 <code>@ param</code> 。<br>自由格式文本的第一行或几行是关于类、变量和方法的主要描述。javadoc 实用程序自动地将这些句子抽取出来形成概要页 。<br>在自由格式文本中, 可以使用 HTML 修饰符 , 例如 , 用于强调的 <code>&lt;em&gt; ... &lt;/em&gt;</code> 、用于着重强调的<code>&lt;strong&gt; ... &lt;/strong&gt;</code>以及包含图像的&lt; img…/&gt; 等 。 不过, 一定不要使用<code>&lt;hl&gt;</code>或<code>&lt;hr&gt;</code>,因为它们会与文档的格式产生冲突 。若要键入等宽代码, 需使用 <code>{@code...}</code> 而不是<code>&lt;code&gt; ... &lt;/code&gt;</code> ———— 这样一来 , 就不用操心对代码中的 <code>&lt;</code>字符转义了 。  </p><h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><p>类注释必须放在 import 语句之后, 类定义之前 。<br>下面是一个类注释的例子:<br><img src="/2017/10/12/Java学习总结之对象与类/类注释.png" alt="fail"><br>没有必要在每一行的开始用星号<code>*</code>，例如,以下注释同样是合法的:<br><img src="/2017/10/12/Java学习总结之对象与类/类注释2.png" alt="fail"><br>然而,大部分IDE提供了自动添加星号<code>*</code>,并且当注释行改变时,自动重新排列这些星号的功能。  </p><h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>每一个方法注释必须放在所描述的方法之前。除了通用标记之外, 还可以使用下面的标记：  </p><ul><li><code>@param</code> 变量描述<br>这个标记将对当前方法的 “param” ( 参数 ) 部分添加一个条目。这个描述可以占据多行,并可以使用 HTML 标记。一个方法的所有 <code>@param</code> 标记必须放在一起。  </li><li><code>@return</code> 描述<br>这个标记将对当前方法添加 “return” (返回 ) 部分。这个描述可以跨越多行,并可以使用 HTML 标记 。</li><li><code>@throws</code> 类描述<br>这个标记将添加一个注释,用于表示这个方法有可能抛出异常。  </li></ul><p>下面是一个方法注释的示例:<br><img src="/2017/10/12/Java学习总结之对象与类/方法注释.png" alt="fail">  </p><h4 id="域注释"><a href="#域注释" class="headerlink" title="域注释"></a>域注释</h4><p>只需要对公有域(通常指的是静态常量)建立文档。例如：<br><img src="/2017/10/12/Java学习总结之对象与类/域注释.png" alt="fail">  </p><h4 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h4><p>下面的标记可以用在类文档的注释中。<br><img src="/2017/10/12/Java学习总结之对象与类/通用注释1.png" alt="fail"><br><img src="/2017/10/12/Java学习总结之对象与类/通用注释2.png" alt="fail">  </p><h4 id="包与概述注释"><a href="#包与概述注释" class="headerlink" title="包与概述注释"></a>包与概述注释</h4><p><img src="/2017/10/12/Java学习总结之对象与类/包与概述注释.png" alt="fail">  </p><h4 id="注释的抽取"><a href="#注释的抽取" class="headerlink" title="注释的抽取"></a>注释的抽取</h4><p>javadoc 工具将你 Java 程序的源代码作为输入，输出一些包含你程序注释的HTML文件。<br>每一个类的信息将在独自的HTML文件里。javadoc 也可以输出继承的树形结构和索引。<br><img src="/2017/10/12/Java学习总结之对象与类/注释的抽取1.png" alt="fail"><br><img src="/2017/10/12/Java学习总结之对象与类/注释的抽取2.png" alt="fail">  </p><p>文档标签速查：<a href="http://www.runoob.com/java/java-documentation.html" target="_blank" rel="external">菜鸟教程之Java文档注释</a></p><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><h4 id="1-一定要保证数据域私有"><a href="#1-一定要保证数据域私有" class="headerlink" title="1.一定要保证数据域私有"></a>1.一定要保证数据域私有</h4><h4 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2.一定要对数据初始化"></a>2.一定要对数据初始化</h4><p>最好不要依赖默认初始化，会影响程序可读性。  </p><h4 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3.不要在类中使用过多的基本类型"></a>3.不要在类中使用过多的基本类型</h4><p>用其他集合了相关基本类型的类代替多个基本类型使用</p><h4 id="4-不是所有的域都需要独立的域访问器和域修改器"><a href="#4-不是所有的域都需要独立的域访问器和域修改器" class="headerlink" title="4.不是所有的域都需要独立的域访问器和域修改器"></a>4.不是所有的域都需要独立的域访问器和域修改器</h4><p>有的数据域定义后不必要修改</p><h4 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5.将职责过多的类进行分解"></a>5.将职责过多的类进行分解</h4><p>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变,那么这个类就具有多于一个的职责。而<strong>单一职责原则(SRP:Single responsibility principle)</strong>就是指一个类或者模块应该有且只有一个改变的原因。<br>在软件系统中,一个类(大到模块,小到方法)承担的职责越多,它被复用的可能性就越小,而且一个类承担的职责过多,就相当于将这些职责耦合在一起,当其中一个职责变化时,可能会影响其他职责的运作,因此要将这些职责进行分离,将不同的职责封装在不同的类中,即将不同的变化原因封装在不同的类中,如果多个职责总<br>是同时发生改变则可将它们封装在同一类中。</p><h4 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6.类名和方法名要能够体现它们的职责"></a>6.类名和方法名要能够体现它们的职责</h4><h4 id="7-优先使用不可变的类"><a href="#7-优先使用不可变的类" class="headerlink" title="7.优先使用不可变的类"></a>7.优先使用不可变的类</h4><p>更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象程序设计概述&quot;&gt;&lt;a href=&quot;#面向对象程序设计概述&quot; class=&quot;headerlink&quot; title=&quot;面向对象程序设计概述&quot;&gt;&lt;/a&gt;面向对象程序设计概述&lt;/h3&gt;&lt;p&gt;　　面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之区间dp</title>
    <link href="http://habitdiary.cn/2017/10/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8C%BA%E9%97%B4dp/"/>
    <id>http://habitdiary.cn/2017/10/11/算法学习之区间dp/</id>
    <published>2017-10-11T08:11:11.000Z</published>
    <updated>2017-10-18T15:10:45.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。  </p><h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h3><p>设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价<br>每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段  </p><p>For l:=2 to n do // 枚举区间长度<br>for i:=1 to n do // 枚举区间的左端点<br>begin<br>j:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到<br>if j&gt;n then break; // 保证了下标不越界<br>for k:= i to j-1 do // 状态转移，去推出 f[i,j]<br>f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }<br>end;   </p><p>这个结构必须记好，这是区间动态规划的代码结构。  </p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>题目链接:<a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=737" target="_blank" rel="external">http://acm.nyist.net/JudgeOnline/problem.php?pid=737</a></p><p>题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 </p><p>分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。<br>定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。<br>那么dp[i][j] = min(dp[i][k] + dp[k+1][j])<br>那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。<br>这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2）  </p><p>代码1(无优化)<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></div><div class="line"><span class="keyword">int</span> dp[N][N],sum[N];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> a[N];sum[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//因为要求解区间和，先维护前缀和</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> i,j,l,k;</div><div class="line">        <span class="keyword">for</span>(l = <span class="number">2</span>; l &lt;= n; ++l)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; ++i)<span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                j = i + l - <span class="number">1</span>;<span class="comment">//根据左端点和区间长度求区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                dp[i][j] = <span class="number">0x3f3f3f3f</span>;</div><div class="line">                <span class="keyword">for</span>(k = i; k &lt; j; ++k)</div><div class="line">                &#123;</div><div class="line">                    dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码2(平行四边形优化)<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 210</span></div><div class="line"><span class="keyword">int</span> dp[N][N],sum[N],s[N][N];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> a[N];sum[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">            s[i][i]=i;</div><div class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i];<span class="comment">//因为要求解区间和，先维护前缀和</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> i,j,l,k;</div><div class="line">        <span class="keyword">for</span>(l = <span class="number">2</span>; l &lt;= n; ++l)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; ++i) <span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                j = i + l - <span class="number">1</span>;<span class="comment">//根据左端点和区间长度求区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                dp[i][j] = <span class="number">0x3f3f3f3f</span>;</div><div class="line">                <span class="keyword">for</span>(k = s[i][j<span class="number">-1</span>]; k &lt;= s[i+<span class="number">1</span>][j]; ++k)<span class="comment">//四边形优化</span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(dp[i][j]&gt;dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>])</div><div class="line">                         &#123;</div><div class="line">                                dp[i][j]=dp[i][k] + dp[k + <span class="number">1</span>][j] + sum[j] - sum[i<span class="number">-1</span>];</div><div class="line">                                s[i][j]=k;</div><div class="line">                         &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>题目链接：<a href="http://poj.org/problem?id=2955" target="_blank" rel="external">http://poj.org/problem?id=2955</a>  </p><p>题意:给出一串的只有‘（’ ‘）’  ‘[‘  ‘]’四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。  </p><p>分析：<br>定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目<br>1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ;<br>2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)<br>dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] )   </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">120</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s==<span class="string">"end"</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> n = s.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++)<span class="comment">//枚举区间长度</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - len; i++)<span class="comment">//枚举区间左端点</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> j = i + len - <span class="number">1</span>;<span class="comment">//确定区间右端点</span></div><div class="line">                <span class="keyword">if</span>(j &gt; n)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">if</span>(s[i]==<span class="string">'('</span>&amp;&amp;s[j]==<span class="string">')'</span> || s[i]==<span class="string">'['</span>&amp;&amp;s[j]==<span class="string">']'</span>)</div><div class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</div><div class="line">                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);<span class="comment">//枚举中间位置,注意j不取等号</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">0</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果要求打印路径，即输出匹配后的括号  </p><p>题目链接: <a href="http://poj.org/problem?id=1141" target="_blank" rel="external">http://poj.org/problem?id=1141</a>  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N = <span class="number">120</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N],pos[N][N];   <span class="comment">/*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/</span></div><div class="line"><span class="built_in">string</span> s;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i&gt;j)  <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(i==j)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">')'</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"()"</span>;</div><div class="line">        <span class="keyword">else</span>      <span class="built_in">cout</span>&lt;&lt;<span class="string">"[]"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pos[i][j]==<span class="number">-1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;s[i];</div><div class="line">            show(i+<span class="number">1</span>,j<span class="number">-1</span>);</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;s[j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            show(i,pos[i][j]);</div><div class="line">            show(pos[i][j]+<span class="number">1</span>,j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> len=s.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,k=i; k&lt;len; j++,k++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'('</span>&amp;&amp;s[k]==<span class="string">')'</span> || s[j]==<span class="string">'['</span>&amp;&amp;s[k]==<span class="string">']'</span>)</div><div class="line">                &#123;</div><div class="line">                    dp[j][k]=dp[j+<span class="number">1</span>][k<span class="number">-1</span>]+<span class="number">2</span>;</div><div class="line">                    pos[j][k]=<span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> f=j; f&lt;k; f++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(dp[j][f]+dp[f+<span class="number">1</span>][k]&gt;=dp[j][k])</div><div class="line">                    &#123;</div><div class="line">                        dp[j][k]=dp[j][f]+dp[f+<span class="number">1</span>][k];</div><div class="line">                        pos[j][k]=f;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        show(<span class="number">0</span>,len<span class="number">-1</span>);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><p>题目链接：<a href="http://acm.nyist.net/JudgeOnline/problem.php?pid=746" target="_blank" rel="external">http://acm.nyist.net/JudgeOnline/problem.php?pid=746</a>  </p><p>题意:  给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积  </p><p>分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数<br>设a[i][j]为区间[i,j]所形成的数<br>所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i])  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">25</span>][<span class="number">25</span>];</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">25</span>][<span class="number">25</span>];</div><div class="line"><span class="keyword">char</span> str[<span class="number">25</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len, t, m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</div><div class="line">    <span class="keyword">while</span> (t--)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, str, &amp;m);</div><div class="line">        len = <span class="built_in">strlen</span>(str);</div><div class="line">        m--;</div><div class="line">        <span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</div><div class="line">        <span class="built_in">memset</span> (dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)          <span class="comment">//先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值</span></div><div class="line">        &#123;</div><div class="line">            a[i][i] = str[i] - <span class="string">'0'</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</div><div class="line">            &#123;</div><div class="line">                a[i][j] = a[i][j - <span class="number">1</span>] * <span class="number">10</span> + str[j] - <span class="string">'0'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            dp[i][<span class="number">0</span>] = a[<span class="number">0</span>][i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; len; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)</div><div class="line">                &#123;</div><div class="line">                    dp[i][j] = max(dp[i][j], dp[k][j - <span class="number">1</span>] * a[k + <span class="number">1</span>][i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[len - <span class="number">1</span>][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Halloween-Costumes"><a href="#Halloween-Costumes" class="headerlink" title="Halloween Costumes"></a>Halloween Costumes</h3><p>题目链接：<a href="http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422" target="_blank" rel="external">http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422</a>  </p><p>题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会  </p><p>分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有</p><p>①：如果在之后的区间内都不再重复利用这件衣服，那么明显  dp[i][j] = dp[i+1][j] + 1;</p><p>②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，<br>那么转移方程为  dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j])  </p><p>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">int</span> a[<span class="number">105</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> t;</div><div class="line">    <span class="keyword">int</span> cas = <span class="number">0</span>;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">    <span class="keyword">while</span>(t--)</div><div class="line">    &#123;</div><div class="line">        cas ++;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt;= n;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] = j-i+<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + <span class="number">1</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i+<span class="number">1</span>;k &lt;= j;k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(a[i] == a[k])</div><div class="line">                    &#123;</div><div class="line">                        dp[i][j] = min(dp[i][j],dp[i][k<span class="number">-1</span>] + dp[k+<span class="number">1</span>][j]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,cas,dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Cheapest-Palindrome"><a href="#Cheapest-Palindrome" class="headerlink" title="Cheapest Palindrome"></a>Cheapest Palindrome</h3><p>题目链接:<a href="http://poj.org/problem?id=3280" target="_blank" rel="external">http://poj.org/problem?id=3280</a>  </p><p>题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。  </p><p>分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况：</p><p>1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值；</p><p>2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值</p><p>3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小</p><p>然后dp[i][j]取上面这些情况的最小值  </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>],add[<span class="number">27</span>],del[<span class="number">27</span>];</div><div class="line"><span class="keyword">char</span> s[<span class="number">2005</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">char</span> ch[<span class="number">10</span>];</div><div class="line">            <span class="keyword">int</span> tmp1,tmp2;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,ch,&amp;tmp1,&amp;tmp2);</div><div class="line">            add[ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>]=tmp1;</div><div class="line">            del[ch[<span class="number">0</span>]-<span class="string">'a'</span>+<span class="number">1</span>]=tmp2;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j]=min(dp[i+<span class="number">1</span>][j]+add[s[i]-<span class="string">'a'</span>+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]+del[s[i]-<span class="string">'a'</span>+<span class="number">1</span>]);</div><div class="line">                <span class="keyword">int</span> tmp=min(dp[i][j<span class="number">-1</span>]+add[s[j]-<span class="string">'a'</span>+<span class="number">1</span>],dp[i][j<span class="number">-1</span>]+del[s[j]-<span class="string">'a'</span>+<span class="number">1</span>]);</div><div class="line">                dp[i][j]=min(dp[i][j],tmp);</div><div class="line">                <span class="keyword">if</span>(s[i]==s[j])</div><div class="line">                dp[i][j]=min(dp[i][j],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Treats-for-the-Cows"><a href="#Treats-for-the-Cows" class="headerlink" title="Treats for the Cows"></a>Treats for the Cows</h3><p>题目链接:<a href="http://poj.org/problem?id=3186" target="_blank" rel="external">http://poj.org/problem?id=3186</a>  </p><p>题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值  </p><p>分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来<br>转移方程：dp[i][j]=max(dp[i+1][j]+p[i]<em>(n+i-j),dp[i][j-1]+p[j]</em>(n+i-j));  其中n-(j-i)是第几次取  </p><p>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> p[<span class="number">2010</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">2010</span>][<span class="number">2010</span>];</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</div><div class="line">            dp[i][i]= n * p[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</div><div class="line">        &#123;</div><div class="line">           dp[i][j]=max(dp[i+<span class="number">1</span>][j]+p[i]*(n+i-j),dp[i][j<span class="number">-1</span>]+p[j]*(n+i-j));</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问
      
    
    </summary>
    
    
      <category term="算法" scheme="http://habitdiary.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之Java基本程序设计结构</title>
    <link href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/"/>
    <id>http://habitdiary.cn/2017/10/10/Java学习总结之Java基本程序设计结构/</id>
    <published>2017-10-10T15:55:53.000Z</published>
    <updated>2018-02-01T14:42:39.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java是一种<strong>强类型</strong>语言，即意味着必须为每一个变量声明一种类型。在Java中一共有8种基本数据类型，其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真值的boolean类型。  </p><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1) 整型"></a>1) 整型</h4><p>整型用于表示没有小数部分的值，它允许是负数，Java提供了4种整型：<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/range.png" alt="fail"></p><p>在通常情况下,int类型最常用。如果要表示星球上居住的人数，就需要使用long类型了。byte和short类型用于特定的应用场合，比如底层的文件处理或者需要控制占用存储空间量的大数组。<br>整型的直接量默认是int，即2表示int类型的2，为了表示一个long型的整型直接量，在其后追加字母L或l即可(建议使用L,以免和数字1混淆)。语句<code>byte b = 128</code>会造成编译错误，因为128是整型直接量且超过了byte的取值范围。<br>默认情况下，整型直接量是一个十进制整数。要表示一个二进制整数直接量，使用0b或0B开头;表示一个八进制整数直接量，使用0开头;表示一个十六进制整数直接量，使用0x或0X开头。<br>为了提高可读性,Java允许在数值直接量的两个数字之间使用下划线,例如<code>long ssn = 232_45_4519</code><br><strong>Java没有任何无符号(unsigned)形式的int、long、short或byte类型</strong><br>十进制整数转其他进制整数：<code>Integer.toString(int number, int radix)</code>返回一个String<br>其他进制整数转十进制：<code>Integer.parseInt(String s, int radix)</code>返回类型为int</p><h4 id="2）浮点类型"><a href="#2）浮点类型" class="headerlink" title="2）浮点类型"></a>2）浮点类型</h4><p>浮点类型用于表示有小数部分的数值，Java提供了2种浮点类型：<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/range.png" alt="fail"><br>double表示这种类型的数值精度是float的两倍,float称为单精度型,double称为双精度型。通常情况下,应该使用double型,因为它比float型更精确。<br>可以以E或e为指数用科学计数法表示浮点数,例如1.2345E+2,在十六进制中,则使用p表示指数而不是e，且尾数采用十六进制时指数的基数是2而不是10<br>浮点数直接量是double型,即5.0被认为是double型的,可以通过追加f或F表示float型直接量,当然也可以在浮点数值后面添加后缀D或d表示double型(虽然没有必要多此一举)。如果float接受的是一个整数，不需要加f或者F，但是如果是小数一定要加f或者F。<br>常量<strong>Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN</strong>(以及相应的Float类型的常量)分别表示正无穷大、负无穷大和不是一个数。例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。<br>不能用如下的方式检测一个特定的值是否等于Double.NaN:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(x == Double.NaN) <span class="comment">// is never true</span></div></pre></td></tr></table></figure></p><p>应该改成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(Double.isNaN(x)) <span class="comment">// check whether x is "not a number"</span></div></pre></td></tr></table></figure></p><p>浮点数在运算时会产生一定误差,如果对精度有极高要求，应该使用BigDecimal类</p><h4 id="3）Unicode和char类型"><a href="#3）Unicode和char类型" class="headerlink" title="3）Unicode和char类型"></a>3）Unicode和char类型</h4><p>Java中字符采用Unicode编码(统一的字符编号，仅仅提供字符与编号间映射。符号数量在不断增加，已超百万)，Unicode又有不同的UTF(即Unicode转换格式，定义Unicode中编号的编码方式)，常用的有UTF-16和UTF-8，其中UTF-8为变长表示，长度可能为1～6个字节；UTF-16为变长表示，长度可能是2或4个字节。<br>我们先来明确几个概念：<br><strong>内码：</strong>某种语言运行时，其char和string在内存中的编码方式。<br><strong>外码：</strong>除了内码，皆是外码。<br><strong>码点：</strong>Unicode编码中一个字符对应的二进制数。<br><strong>代码单元：</strong>在UTF-16编码中，用char表示的十六位二进制数，占两个字节。<br><strong>要注意的是，源代码编译产生的目标代码文件(可执行文件或class文件)中的编码方式属于外码。</strong></p><p><strong>JVM中内码采用UTF-16。</strong>早期，UTF-16采用固定长度2字节的方式编码，两个字节可以表示65536种符号（其实真正能表示要比这个少），足以表示当时Unicode中所有字符，也就是说当时一个码点就对应一个代码单元，即每个Unicode字符都用一个char表示，一个16位的Unicode码以\u开头的4位十六进制表示，范围从’\u0000’到’\uFFFF’,范围是0~65535。但是随着Unicode中字符的增加，2个字节无法表示所有的字符，UTF-16采用了2字节或4字节的方式来完成编码。Java为应对这种情况，考虑到向前兼容的要求，Java用一对char来表示那些需要4字节的字符。所以，Java中的char固定占用两个字节(即一个代码单元)，大多数常用Unicode字符使用一个代码单元表示，而辅助Unicode字符需要两个代码单元来表示，即一个码点由一个或两个代码单元组成。  </p><p>String的length()方法返回的是采用UTF-16编码表示的给定字符串所需要的<strong>代码单元</strong>数量，它在一些情况下不等于字符串中实际的字符数，length()是一个较为底层的方法。<br>如果要得到实际的字符数(即码点数量),可以调用:<br><code>int cpCount = str.codePointCount(0,str.length());</code><br>调用str.charAt(n)将返回位置n的代码单元，n介于0~str.length()-1之间。要想获得第i个码点,应该使用下列语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> index = str.offsetByCodePoints(<span class="number">0</span>,i);</div><div class="line"><span class="keyword">int</span> cp = str.codePointAt(index);</div></pre></td></tr></table></figure></p><p><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/码点1.png" alt="fail"><br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/码点2.png" alt="fail">  </p><p>更多详见：<a href="https://www.cnblogs.com/louiswong/p/6062417.html" target="_blank" rel="external">Java中char占几个字节</a></p><p>char类型的字面量值要用单引号括起来。例如：’A’是编码值为65所对应的字符常量。它与”A”不同，”A”是包含一个字符A的字符串。char类型可以表示为十六进制值，范围从’\u0000’到’\uFFFF’<br>有一些用于表示特殊字符的<strong>转义序列</strong>,如下：<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/特殊字符的转义序列.png" alt="fail" title="特殊字符的转义序列"><br>注意 \r 和 \n 的区别，前者叫回车(<strong>C</strong>arriage <strong>R</strong>eturn)，后者叫新行(<strong>N</strong>ew <strong>L</strong>ine)，但是都会造成换行。不同操作系统的行分隔符不同，可用System.getProperty(“line.separator”)来获取当前OS的换行符<br>不同系统的换行符为：<br>\r     Mac<br>\n     Unix/Linux<br>\r\n     Windows</p><p> <strong>注释中的\u也会起转义作用,如下：</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// \u00A0 is a newline </span></div><div class="line">  (\u00A0会被替换成换行符)</div><div class="line"></div><div class="line"><span class="comment">// Look inside c:\users </span></div><div class="line">  (会产生编译错误,因为\u后面未跟着<span class="number">4</span>个十六进制数)</div></pre></td></tr></table></figure></p><p> 下面是判断一个字符是否是汉字的方法：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChineseChar</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> String.valueOf(c).getBytes(<span class="string">"UTF-8"</span>).length &gt; <span class="number">1</span>;</div><div class="line">&#125; </div><div class="line">       <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 将字符c先用String.valueOf转换为字符串，然后使用getBytes(“UTF-8”)将字符串按照UTF-8编码格式转换为字节数组，汉字的字节数会大于1,即可判断(如果直接对String使用length得到的是字符数不是字节数)。但是可能会抛出UnsupportedEncodingException，要进行捕获处理。  </p><h4 id="4-boolean类型"><a href="#4-boolean类型" class="headerlink" title="4) boolean类型"></a>4) boolean类型</h4><p>boolean类型有两个值：false和true，用来判定逻辑条件。<strong>不同于C/C++中0代表false，非0代表true，Java中整型值和布尔值之间不能进行相互转换。</strong><br>比如,下面的语句在C/C++中是允许的,表示一个无限循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">do</span> something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是在Java中不允许这么做,可以改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">do</span> something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以打印boolean类型的变量或者布尔表达式，会呈现true或者false  </p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>将一个小范围类型变量转化为大范围类型的变量称为<strong>拓宽类型</strong>，反之称为<strong>缩窄类型</strong>。把小范围类型变量赋值给大范围类型的变量或小范围类型变量和大范围类型变量共同参与运算,Java会自动拓宽类型。而如果要缩窄类型，必须显式完成。  <img src="/2017/10/10/Java学习总结之Java基本程序设计结构/transmit.png" alt="fail"><br><strong>注意：<br>1.类型转换不改变被转换的变量，例如，下面的代码中的d在类型转换之后值不变：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> d = <span class="number">4.5</span>;</div><div class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)d; <span class="comment">// i becomes 4, but d is still 4.5</span></div></pre></td></tr></table></figure></p><p><strong>2.x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。因此，下面代码是正确的：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">sum += <span class="number">4.5</span>;<span class="comment">// 等价于sum = (int)(sum + 4.5)</span></div></pre></td></tr></table></figure></p><p><strong>3.将一个int型变量赋值给short型或byte型的变量，必须显式地使用类型转换，如下面的语句会产生编译错误：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"><span class="keyword">byte</span> b = i; <span class="comment">// Error because explicit casting is required</span></div></pre></td></tr></table></figure></p><p>然而如果整型直接量在目标变量允许的范围内，那么将整型直接量赋给short型或byte型就不需要显式类型转换，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</div></pre></td></tr></table></figure></p><p><strong>4.字符型数据和数值型数据之间的转换：</strong><br>char 型数据可以转换成任意一种数值类型，反之亦然。将整数转换成 char 型数据时，只用到该数据的低十六位，其余部分都被忽略。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch = (<span class="keyword">char</span>)<span class="number">0XAB0041</span>; <span class="comment">/* The lower 16 bits hex code 0041 </span></div><div class="line"><span class="comment">is assigned to ch*/</span> </div><div class="line">System.out.println(ch); <span class="comment">// ch is character A</span></div></pre></td></tr></table></figure></p><p><strong>注意：如果数值类型的值表示范围在0~65535之间，可以隐式转换为char，但如果超过65535就需要强制类型转换，char会截取数据的低十六位。</strong><br>当一个char 型数据转换成数值型时，这个字符的Unicode码就被转换成某个特定的数值类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="string">'A'</span>; <span class="comment">// Decimal 65 is assigned to ch</span></div><div class="line">System.out.println(ch) <span class="comment">// i is 65</span></div></pre></td></tr></table></figure></p><p><strong>如果char的Unicode值未超过数值型范围，可以隐式转换，否则也要强制类型转换。如：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = <span class="string">'A'</span>; <span class="comment">//is OK,b = 65</span></div><div class="line"><span class="keyword">byte</span> c = (<span class="keyword">byte</span>)<span class="string">'\uFFF4'</span>; <span class="comment">//超过byte范围，必须强转</span></div></pre></td></tr></table></figure></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量用于表示在程序中可能被改变的值。<strong>变量声明</strong>告知编译器根据数据类型为变量分配合适的内存空间。变量声明的语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">datatype variableName;</div></pre></td></tr></table></figure></p><p>如果几个变量为同一类型,允许一起声明它们：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">datatype variable1, variable2, ..., variablen;</div></pre></td></tr></table></figure></p><p>可以在声明变量的同时初始化，也可以先声明后初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 声明同时初始化变量</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> count;</div><div class="line">count = <span class="number">1</span>; <span class="comment">//先声明，后初始化</span></div></pre></td></tr></table></figure></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是一个赋值后保持不变的量,用final关键字修饰，在类中定义的常量一般用static final修饰。常量必须在同一条语句中声明和赋值，不可先声明再赋值。<br>使用常量有三个好处：<br>1)不必重复输入同一个值<br>2)如果必须修改常量的值，只需在源代码的一处改动<br>3)给常量赋一个描述性的名字会提高程序的易读性</p><h3 id="数值操作符"><a href="#数值操作符" class="headerlink" title="数值操作符"></a>数值操作符</h3><p>数值数据类型的操作符包括标准的算术操作符：加号(+)、减号(-)、乘号(<code>*</code>)、除号( / )、求余号(%)<br><strong>注意：<br>1.如果被除数是负数，结果是负数;如果除数是负数被除数是正数结果是正数;如果都是负数其结果就是负数。如 -7 % 3 = -1, -26 % -8 = -2,20 % -13 = 7,即无论正负,商和除数乘积的绝对值不能超过被除数的绝对值。<br>2.如果是两个byte short int long相除，得到结构如果是浮点数，小数位全部舍去保留整数部分<br>3.如果是两个byte short int long除以0，等异常信息,那么久报异常java.lang.ArithmeticException: / by zero 看到异常就要立马明白，除数是0，要赶紧检查你的代码的逻辑出现0的地方在哪里。<br>4.float.double除以0得到正无穷和负无穷。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="number">1.0f</span>/<span class="number">0</span>); <span class="comment">//正无穷</span></div><div class="line">System.out.println(-<span class="number">1</span>/<span class="number">0.0</span>); <span class="comment">//负无穷</span></div><div class="line">System.out.println(<span class="number">0.0</span>/<span class="number">0</span>); <span class="comment">//NaN</span></div></pre></td></tr></table></figure></p><h3 id="增强赋值操作符"><a href="#增强赋值操作符" class="headerlink" title="增强赋值操作符"></a>增强赋值操作符</h3><p>x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。其中op可以是加号(+)、减号(-)、乘号(<code>*</code>)、除号( / )、求余号(%)  </p><h3 id="自增和自减操作符"><a href="#自增和自减操作符" class="headerlink" title="自增和自减操作符"></a>自增和自减操作符</h3><p>分为++var、–var、var++、var–四种，加减号决定<strong>给var加1还是减1</strong>，前置还是后置符号决定<strong>先更新后使用值还是先使用值后更新</strong></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>Java中有一系列用于比较关系的运算符：==(等于)、!=(不等于)、&lt;(小于)、&gt;(大于)、&lt;=(小于等于)、&gt;=(大于等于)  </p><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑操作符!(非)、&amp;&amp;(与)、||(或)和^(异或)可以用于产生复合型布尔表达式，逻辑操作符被称为<strong>短路操作符或懒惰操作符</strong>，即按顺序执行表达式，如果某一步已经可以判断整个表达式的真假，不再继续执行，否则继续执行。  </p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>处理整型类型时，可以直接对组成整型数值的各个位完成操作。位运算符包括：&amp;(按位与)、|(按位或)、^(按位异或)、~(按位取反)、&lt;&lt;(左移，高位舍弃，低位补0)、&gt;&gt;(右移，低位舍弃，高位用符号位填充)、&gt;&gt;&gt;(右移，低位舍弃，高位0填充)<br><strong>注意：<br>1) 移位运算符的右操作数要完成模32的运算(除非左操作数是long类型，在这种情况下右操作数要模64),例如1<code>&lt;&lt;</code>35等价于1<code>&lt;&lt;</code>3<br>2) &amp; 、| 和 ^ 也可以用在布尔表达式中，此时它们是逻辑操作符，但不会短路，不推荐使用<br>3) 可以使用掩码技术得到一个数二进制的某一位：<br>int fourthBitFromRight = (n &amp; 0b1000) / 0b1000<br>上式将n的右数第4位保留，将其他位掩掉，再除以0b1000，就得到了该位上的数</strong> </p><p><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/priority.png" alt="fail" title="运算符的优先级"></p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>Java中的选择语句类型有：单分支if语句、双分支if-else语句、嵌套if语句、多分支if-else语句、switch语句、条件表达式</p><h4 id="1-单分支if语句"><a href="#1-单分支if语句" class="headerlink" title="1) 单分支if语句"></a>1) 单分支if语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(布尔表达式)&#123;</div><div class="line">语句(组);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 分支中如果只有单条语句可以省略外围花括号，否则不能省略</p><h4 id="2-双分支if-else语句"><a href="#2-双分支if-else语句" class="headerlink" title="2) 双分支if-else语句"></a>2) 双分支if-else语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(布尔表达式)&#123;</div><div class="line">布尔表达式为真时执行的语句(组);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">else</span>&#123;</div><div class="line">    布尔表达式为假时执行的语句(组);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 嵌套层数没有限制，但为了程序可读性，尽量不要进行过多的嵌套，且嵌套语句应有适当的缩进保持层次关系。</p><h4 id="3-嵌套的if语句和多分支的if-else语句"><a href="#3-嵌套的if语句和多分支的if-else语句" class="headerlink" title="3) 嵌套的if语句和多分支的if-else语句"></a>3) 嵌套的if语句和多分支的if-else语句</h4><p>下面是一个嵌套的if语句，if(j &gt; k)嵌套在语句if(i &gt; k)内<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(i &gt; k) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; k)</div><div class="line">    System.out.println(<span class="string">"i and j greater than k"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">System.out.println(<span class="string">"i is less than or equal to k"</span>);</div></pre></td></tr></table></figure></p><p>下面是一个多分支的if-else语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90.0</span>)</div><div class="line">System.out.print(<span class="string">"A"</span>);</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(score &gt;= <span class="number">80.0</span>)</div><div class="line">      System.out.print(<span class="string">"B"</span>);</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">70.0</span>)  </div><div class="line">          System.out.print(<span class="string">"C"</span>);</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(score &gt;= <span class="number">60.0</span>)</div><div class="line">             System.out.print(<span class="string">"D"</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">             system.out.print(<span class="string">"E"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了可读性，建议改写成如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90.0</span>)</div><div class="line">System.out.print(<span class="string">"A"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">80.0</span>)  </div><div class="line">System.out.print(<span class="string">"B"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">70.0</span>)  </div><div class="line">System.out.print(<span class="string">"C"</span>);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60.0</span>)</div><div class="line">System.out.print(<span class="string">"D"</span>);</div><div class="line"><span class="keyword">else</span></div><div class="line">System.out.print(<span class="string">"E"</span>);</div></pre></td></tr></table></figure></p><p><strong>注意：只有在前面的所有条件都为false才测试下一个条件</strong> </p><h4 id="4-switch语句"><a href="#4-switch语句" class="headerlink" title="4) switch语句"></a>4) switch语句</h4><p>switch语句常用于多分支的选择问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span>(<span class="keyword">switch</span>表达式)&#123;</div><div class="line"><span class="keyword">case</span> value1: 语句(组)<span class="number">1</span>;</div><div class="line">     <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> value2: 语句(组)<span class="number">2</span>;</div><div class="line">     <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">    <span class="keyword">case</span> valueN: 语句(组)N;</div><div class="line">     <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>: 当没有一个给出的<span class="keyword">case</span>与<span class="keyword">switch</span>表达式匹配时执行的语句(组)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：<br>1) switch表达式可以为char、byte、short、int或者String型值(整型中只有long不行),并且总要用括号括住<br>2) value1,…,valueN必须与switch表达式具有相同的数据类型，且是常量表达式，不能出现变量，例如：x、y+1等<br>3) 当switch表达式的值与case语句匹配时,执行从该case开始的语句，直到遇到一个break语句或到达switch语句的结束。break语句是可选的,会立即终止switch语句<br>4) default语句是可选的，当没有一个给出的case与switch表达式匹配时执行default语句指定的操作，如果不加default语句，就什么也不做</strong></p><h4 id="5-条件表达式"><a href="#5-条件表达式" class="headerlink" title="5) 条件表达式"></a>5) 条件表达式</h4><p>条件表达式基于一个条件计算表达式的值，它是Java中唯一的三元操作符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span>-expression ? expression1 : expression2;</div><div class="line"><span class="comment">//(布尔表达式? 表达式1:表达式2)</span></div></pre></td></tr></table></figure></p><p>如果布尔表达式的值为true，则条件表达式的结果为表达式1;否则，结果为表达式2。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println((num % <span class="number">2</span> == <span class="number">0</span>) ? <span class="string">"num is even"</span> : <span class="string">"num is odd"</span>);</div></pre></td></tr></table></figure></p><p>注意冒号两边是<strong>表达式</strong>，不能是其他操作。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="1-块作用域"><a href="#1-块作用域" class="headerlink" title="1) 块作用域"></a>1) 块作用域</h4><p>块(即复合语句)是指由一对大括号括起来的若干条简单的Java语句。<strong>块确定了变量的作用域，变量只在包含自己的块中可见。一个块可以嵌套在另一个块中。</strong>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line">    . . .</div><div class="line">    &#123;</div><div class="line">       <span class="keyword">int</span> k;</div><div class="line">       . . .</div><div class="line">    &#125; <span class="comment">// k is only defined up to here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是不能声明两个作用域(生命周期)重叠的同名变量，例如下面的语句会产生编译错误，这是因为前面定义的n的作用域是从定义处开始到方法末尾，后面定一个的n的作用于是从定义处到代码块末尾，两者作用于发生了重叠：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line">    . . .</div><div class="line">    &#123;</div><div class="line">       <span class="keyword">int</span> k;</div><div class="line">       <span class="keyword">int</span> n;<span class="comment">//Erro -- can't redefine n in inner block</span></div><div class="line">       . . .</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这与C++不同，在C++中允许在重叠的作用域定义同名变量，后定义会覆盖先定义的变量。但在Java中并不允许这么做。  </p><h4 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2) while循环"></a>2) while循环</h4><p>while循环在条件为真的情况下，重复地执行语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(循环继续条件)&#123;</div><div class="line"><span class="comment">//循环体  </span></div><div class="line">    语句(组);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当程序不幸出现了死循环，如果是从命令窗口运行程序的，按CTRL+C键来结束  </p><h4 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3) do-while循环"></a>3) do-while循环</h4><p>do-while循环和while循环基本一样，不同的是while循环是前测循环，即先检测循环条件后执行循环体;do-while是后测循环，即先执行循环体后检测循环条件。只有在一开始就不满足循环继续条件时，两种循环的执行次数不同，即while循环不执行，do-while循环执行一次。否则两种循环的执行次数相同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line"><span class="comment">// 循环体;</span></div><div class="line">    语句(组);</div><div class="line">&#125;<span class="keyword">while</span>(循环继续条件);</div></pre></td></tr></table></figure></p><p><strong>注意do-while循环后面的分号不要丢！</strong>  </p><h4 id="4-for循环"><a href="#4-for循环" class="headerlink" title="4) for循环"></a>4) for循环</h4><p>for循环的基本语法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(初始操作;循环继续条件;每次迭代后的操作) &#123;</div><div class="line"><span class="comment">//循环体  </span></div><div class="line">    语句(组);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>初始动作可以是0个或是多个以逗号隔开的变量声明语句或赋值表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(    ;i &lt; <span class="number">100</span>;i++)&#123;</div><div class="line">System.out.println(<span class="string">"Welcome to Java!"</span>);</div><div class="line">&#125;<span class="comment">// 将初始动作省略，放在循环语句之前执行</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>,n = <span class="number">0</span>; m + n &lt; <span class="number">10</span>; m++,n++)&#123;</div><div class="line">System.out.println(<span class="string">"Welcome to Java!"</span>);</div><div class="line">&#125;<span class="comment">// 多个初始化动作</span></div></pre></td></tr></table></figure></p><p>每次迭代后的操作也可以是0个或多个逗号隔开的语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;  )&#123;</div><div class="line">System.out.println(<span class="string">"Welcome to Java!"</span>);</div><div class="line">    i++;</div><div class="line">&#125;<span class="comment">// 将每次迭代后的操作放入循环体内  </span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">100</span>;System.out.println(i),i++);</div><div class="line"><span class="comment">// 每次迭代后执行多个操作</span></div></pre></td></tr></table></figure></p><p>下面的三种循环写法是等价的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(  ;  ;  )&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(  ;<span class="keyword">true</span>;  )&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="5-for-each循环"><a href="#5-for-each循环" class="headerlink" title="5) for-each循环"></a>5) for-each循环</h4><p>Java有一种很强的循环结构，可以用来依次处理数组中的每个元素(其他类型的元素集合亦可)而不必为指定的下标值而分心。<br>这种增强的for循环的语句格式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(variable : collection) statement</div></pre></td></tr></table></figure></p><p>定义一个变量用于暂存集合中的每一个元素，并执行相应的语句(组)，collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象(例如ArrayList)。<br><strong>for-each循环只能用于按顺序遍历数组或集合的情况，如果要使用其他顺序，应该使用其他循环语句</strong></p><h4 id="6-break和continue"><a href="#6-break和continue" class="headerlink" title="6) break和continue"></a>6) break和continue</h4><p><strong>continue跳出本次迭代进入下一次迭代，break跳出整个循环。</strong><br>虽然不提倡使用goto语句，但偶尔使用goto语句跳出循环还是有益处的。Java中提供了类似于C++中goto语句的带标签的break语句和continue语句，用于跳出多重嵌套的循环语句。<br><strong>标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。另外要注意，只能跳出语句块，而不能跳入语句块。</strong><br>下面的代码使用了带标签的break语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;   </div><div class="line">label1:</div><div class="line"><span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++) &#123;</div><div class="line"><span class="keyword">if</span>(i == <span class="number">5</span>)</div><div class="line"><span class="keyword">break</span> label1;</div><div class="line">&#125;</div><div class="line">System.out.println(i);<span class="comment">// i = 5</span></div></pre></td></tr></table></figure></p><p>上述代码中，i在等于5时跳出循环到循环首部的标签label1位置，由于是带标签的break语句，不再重新进入循环，而是跳过循环执行下面的打印语句。</p><p>如果把改成带标签的continue语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i;   </div><div class="line">label2:</div><div class="line"><span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++) &#123;</div><div class="line"><span class="keyword">if</span>(i == <span class="number">5</span>)</div><div class="line"><span class="keyword">continue</span>  label2;</div><div class="line">&#125;</div><div class="line">System.out.println(i); <span class="comment">// i = 10</span></div></pre></td></tr></table></figure></p><p>上述代码中，i在等于5时也跳出循环到循环首部的标签label2位置，但由于是带标签的continue语句，会重新进入循环。</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>有时，变量的取值只在一个有限集合内。例如：销售的服装或比萨饼只有小、中、大、超大这四种尺寸。此时可以给每种尺寸编号为1、2、3、4,但是为了程序的可读性，可以定义一个枚举类。<br>可以把枚举类看作普通类，它们都可以定义一些属性和方法，也可以添加public等访问修饰符，不同之处是：枚举类不能使用 extends 关键字继承其他类，因为 枚举类已经继承了 java.lang.Enum<code>&lt;T&gt;</code>(java是单一继承),其中T是定义的枚举类类型，也就是说一个枚举类T的类型其实是<code>&lt;T extends Enum&lt;T&gt;&gt;</code>。<strong>Enum类是一个抽象类。</strong><br>下面定义一个简单的枚举类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</div></pre></td></tr></table></figure></p><p>其中<strong>enum</strong>是定义枚举类的关键字，可类比普通类的<strong>class</strong>。<strong>Size</strong>是枚举类名，类比普通类名。<br>SMALL、MEDIUM、LARGE、EXTRA_LARGE是枚举值，为枚举类的静态成员，static关键字被省略，类型为Size，可以用<code>Size.枚举实例名</code>来访问，命名习惯同常量。Size变量只能存储枚举类中定义的枚举值或null，尽量不要构造新的Size类型对象。<br>可以在枚举类中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候使用，下面是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Size</div><div class="line">&#123;</div><div class="line">SMALL(<span class="string">"S"</span>),MEDIUM(<span class="string">"M"</span>),LARGE(<span class="string">"L"</span>),EXTRA_LARGE(<span class="string">"XL"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String abbreviation;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Size</span><span class="params">(String abbreaviation)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.abbreviation = abbreviation;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAbbreviation</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> abbreviation&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>枚举值的声明必须是枚举类定义的第一条语句。枚举类的构造器必须为private，保证了构造器只能用于枚举类中定义的枚举值的构造，而不让客户代码构造新的枚举值。当访问枚举值时，构造方法被调用，枚举值构造方法中的参数被赋值给Abbreviation。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSize</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Size size = Size.LARGE;</div><div class="line">        System.out.println(size.getAbbreviation);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果打印出”L”  </p><p>枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal)构造函数中，在这里，每个枚举值的名称都被转换成一个字符串，且按照在枚举类中出现的先后次序，从0开始进行编号。<br>下面是枚举类的常用API：  </p><ul><li>int ordinal()<br>返回enum声明中枚举常量的位置，位置从0开始计数</li><li>int compareTo(<code>&lt;T extends Enum&lt;T&gt;&gt;</code> o)<br>按照序号(枚举类中的定义次序，即ordinal返回值)比较此枚举与指定对象的顺序，小于返回一个负值，绝对值是两者的序号差;等于返回0;大于返回一个正值，绝对值是两者的序号差   </li><li>boolean equals(<code>&lt;T extends Enum&lt;T&gt;&gt;</code> o)<br>比较两个枚举常量是否相等,可以用==代替</li><li>String toString()<br>返回枚举常量的名称</li><li>static <code>&lt;T extends Enum&lt;T&gt;&gt;</code> valueOf(Class<code>&lt;T&gt;</code> enumType, String name)<br>返回带指定名称的指定枚举类型的枚举常量(是toString的逆操作)  </li><li>static T[] values()<br>返回一个包含全部枚举值的数组  </li></ul><p>例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">int</span> index = Size.SMALL.ordinal();</div><div class="line"> <span class="comment">//index是0</span></div><div class="line"> <span class="keyword">int</span> cmp = Size.SMALL.compareTo(Size.MEDIUM);</div><div class="line"> <span class="comment">//cmp是-1</span></div><div class="line"> <span class="keyword">boolean</span> isEqual = Size.SMALL.equals(Size.MEDIUM);</div><div class="line"> <span class="comment">//isEqual为false</span></div><div class="line"> String enumName = Size.SMALL.toString();</div><div class="line"><span class="comment">//enumName是"SMALL"</span></div><div class="line"> Size s = Enum.valueof(Size.class,<span class="string">"SMALL"</span>);</div><div class="line"> <span class="comment">//s是Size.SMALL</span></div><div class="line">Size[] values = Size.values(); </div><div class="line"><span class="comment">/*返回一个包含Size.SMALL,Size.MEDIUM,Size.LARGE,  </span></div><div class="line"><span class="comment">Size.EXTRA_LARGE的数组 */</span></div></pre></td></tr></table></figure></p><p><strong>要比较两个枚举值是否相同，既可以使用equals也可以使用==</strong>  </p><p>枚举类型可以在一个类内定义，此时枚举类被作为内部类对待。程序编译后，将创建一个名为<code>OuterClassName$EnumName</code>的字节码文件。  </p><p>可以在if或switch语句中使用枚举变量，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(size.equals(Size.SMALL)&#123;</div><div class="line"><span class="comment">// process SMALL</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size.equals(Size.MEDIUM)&#123;</div><div class="line"><span class="comment">// process MEDIUM</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">...</div></pre></td></tr></table></figure></p><p>等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span>(size)&#123;</div><div class="line"><span class="keyword">case</span> SMALL:</div><div class="line">    <span class="comment">// process SMALL</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> MEDIUM:</div><div class="line">    <span class="comment">// process MEDIUM</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>在switch语句中，case标签是一个无限定的枚举值(即SMALL，而不是Size.SMALL)</strong></p><p>更多用法见：<a href="http://blog.csdn.net/qq_27093465/article/details/52180865" target="_blank" rel="external">Java枚举(enum)详解7种常见的用法</a></p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="1-输入"><a href="#1-输入" class="headerlink" title="1) 输入"></a>1) 输入</h4><p>从控制台读取”标准输入流”System.in，需要构造一个<strong>Scanner</strong>对象，并与”标准输入流”System.in关联。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</div></pre></td></tr></table></figure></p><p>下面给出Scanner类的常用API：  </p><ul><li>Scanner(InputStream in)<br>用给定的输入流创建一个Scanner对象(System.in就是一个InputStream,表示系统标准输入流，默认从键盘读取输入)  </li><li>Scanner(File source)<br>用文件创建一个Scanner对象从文件读取输入，如果文件不存在会抛出FileNotFoundException</li><li>Scanner(String str)<br>用字符串创建一个Scanner对象从字符串读取输入</li><li>String nextLine()<br>读取输入的下一行内容(以回车作为分隔符)  </li><li>String next()<br>读取输入的下一个字符串(以空白字符如空格、回车作为分割符)  </li><li>String next(Pattern pattern)<br>读取输入的下一个字符串，进行正则验证，如果输入不符合正则表达式会抛出InputMismatchException    </li><li>int nextInt()<br>读取下一个int  </li><li>double nextDouble()<br>读取下一个double()  </li><li>boolean hasNext()<br>检测输入是否还有单词  </li><li>boolean hasNext(Pattern pattern)<br>检测输入的数据是否符合指定的正则标准</li><li>boolean hasNextInt()<br>检测输入是否还有int  </li><li>boolean hasDouble()<br>检测输入是否还有double </li><li>useDelimiter(String pattern)<br>修改输入分隔符(如果用<code>\n</code>作分隔符,next()就可以实现和nextLine()一样的功能)</li></ul><p><strong>Scanner读入时会有回车残留的问题！</strong>在使用<strong>除了nextLine()</strong>的其他方法(称为标记读取方法)读入时，本次读入不会读取分隔符，即空格、Tab和回车等，但分隔符会进入缓冲区，如果在标记读取方法之后调用nextLine()就会先读取缓冲区的内容。<strong>使用nextLine()</strong>读入，本次读入则不会读入行分隔符(回车)，且回车不会进入缓冲区而是直接被舍弃，不影响下一次读入。<br>行分隔符字符串是由系统定义的，在Windows平台上是\r\n，而在Linux|UNIX平台上是\n。为了得到特定平台上的行分隔符，使用：<code>String lineSeparator = System.getProperty(&quot;line.separator&quot;);</code></p><p>因为输入是可见的，所以Scanner类不适用于从控制台读取密码。Java SE 6特别在io包中引入了Console类实现不回显的输入。要想读取一个密码，可以采用下列代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Console cons = System.console();</div><div class="line"><span class="keyword">if</span>(cons != <span class="keyword">null</span>) &#123;</div><div class="line">    String username = cons.readLine(<span class="string">"User name: "</span>);</div><div class="line"><span class="keyword">char</span>[] passwd = cons.readPassword(<span class="string">"Password: "</span>);</div><div class="line">cons.printf(<span class="string">"Username is: "</span> + username + <span class="string">"\n"</span>);     </div><div class="line">        <span class="comment">// 显示用户名</span></div><div class="line">    cons.printf(<span class="string">"Password is: "</span> + passwd + <span class="string">"\n"</span>);   </div><div class="line">        <span class="comment">// 显示密码</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"> System.out.println(<span class="string">"Console is unavailable."</span>); </div><div class="line">             <span class="comment">// 提示无控制台使用权限</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>几点注意：<br>1.Console类不能用new构造对象，属于单例模式，构造方法被private修饰<br>2.为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理后，应该马上用一个填充值覆盖数组元素。<br>3.采用Console对象处理输入不如Scanner方便，每次只能读取一行输入，而没有能够读取一个单词或一个数值的方法。<br>4.Java要与Console进行交互，不总是能得到可用的Java Console类的。一个JVM是否有可用的Console，依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如linux的终端或windows的cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就我们可以得到一个可用的Console实例。<br>当用Eclipse或NetBean中运行以上代码时Console中将会有以下文字输出：<br><code>Console is unavailable.</code><br>表示Java程序无法获得Console实例，是因为JVM不是在命令行中被调用的，或者输入输出被重定向了。</strong>  </p><p>下面给出Console类的常用API：  </p><ul><li>static Console console()<br>返回一个Console对象  </li><li>static char[] readPassword(String prompt, Object…args)<br>显示提示字符串prompt并读取用户输入，直到输入行结束,结果存放在字符数组中。args参数用来提供输入格式。  </li><li>static String readLine(String prompt,Object…args)<br>显示提示字符串prompt并读取用户输入，直到输入行结束，结果存放在字符串中。args参数用来提供输入格式。  </li></ul><h4 id="2-输出"><a href="#2-输出" class="headerlink" title="2) 输出"></a>2) 输出</h4><p>可以使用 System.out.print(x) 将数值 x 输出到控制台上。这条命令将以 x 对应的数据类型所允许的最大非 0 数字位数打印输出 x 。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> x = <span class="number">10000.0</span> / <span class="number">3.0</span>;</div><div class="line">System.out.print(x);</div></pre></td></tr></table></figure></p><p>打印<br>3333.3333333333335<br>如果希望显示美元、美分等符号， 则有可能会出现问题。<br>在早期的 Java 版本中，格式化数值曾引起过一些争议。庆幸的是，Java SE 5.0 沿用了 C语言库函数中的 printf方法。例如，调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%8.2f"</span>,x);</div></pre></td></tr></table></figure></p><p>可以用 8 个字符的宽度和小数点后两个字符的精度打印 x。也就是说，打印输出一个空格和7 个字符， 如下所示：<br>3333.33<br>在 printf中，可以使用多个参数， 例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"Hello, %s. Next year, you'll be %d"</span>, name, age);</div></pre></td></tr></table></figure></p><p>每一个以 % 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数。  </p><p>下表列出了所有转换符：<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/用于printf的转换符.png" alt="fail" title="用于printf的转换符"><br>另外，还可以给出控制格式化输出的各种标志。例如，逗号<br>标志增加了分组的分隔符。即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%,.2f"</span>, <span class="number">10000.0</span> / <span class="number">3.0</span>);</div></pre></td></tr></table></figure></p><p>打印<br>3,333.33  </p><p>下表列出了用于printf的所有标志<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/用于printf的标志.png" alt="fail" title="用于printf的标志">  </p><p>可以使用静态的 String.format 方法创建一个格式化的字符串，而不打印输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String message = String.format(<span class="string">"Hello, %s. Next year, you'll be %d"</span>, name , age);</div></pre></td></tr></table></figure></p><p>基于完整性的考虑， 下面简略地介绍 printf方法中日期与时间的格式化选项(已经过时)。在新代码中， 应当使用 java.time 包的方法。 不过你可能会在遗留代码中看到 Date 类和相关的格式化选项。格式包括两个字母， 以 t 开始， 以下表中的任意字母结束。<br>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%tc"</span>, <span class="keyword">new</span> Date());</div></pre></td></tr></table></figure></p><p>这条语句将用下面的格式打印当前的日期和时间：<br>Mon Feb 09 18:05:19 PST 2015<br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/日期和时间的转换符1.png" alt="fail"><br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/日期和时间的转换符2.png" alt="fail" title="日期和时间的转换符">  </p><p>从上表可以看到，某些格式只给出了指定日期的部分信息。例如，只有日期或月份。如果需要多次对日期操作才能实现对每一部分进行格式化的目的就太笨拙了。为此，可以采用一个格式化的字符串指出要被格式化的<strong>参数索引</strong>。索引必须紧跟在%后面， 并以<code>$</code>终止。 例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.printf(<span class="string">"%1$s %2$tB %2$te,%2$tY"</span>,<span class="string">"Due date:"</span>,<span class="keyword">new</span> Date());</div></pre></td></tr></table></figure></p><p>打印<br>Due date: February 9, 2015</p><p>还可以选择使用 &lt; 标志。它指示前面格式说明中的参数将被再次使用。也就是说，下列语句将产生与前面语句同样的输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out .printf(<span class="string">"%s %tB %&lt;te, %&lt;tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> Date());</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>参数索引值从1开始，而不是从0开始，%1<code>$</code>…对第一个参数格式化。这就避免了与0标志混淆。  </p><p>现在，已经了解了 printf 方法的所有特性。下表给出了格式说明符的语法图： </p><p><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/格式说明符语法.png" alt="fail" title="格式说明符语法">  </p><h4 id="3-重定向语法"><a href="#3-重定向语法" class="headerlink" title="3) 重定向语法"></a>3) 重定向语法</h4><p>Java使用System.out(系统类的输出流对象)来表示标准输出设备，默认情况下是显示器，而用System.in(系统类的输入流对象)来表示标准输入设备，默认情况下是键盘。<br>有时，我们需要从文件而不是键盘读入数据，并希望将程序输出结果保存到文件中而不是打印在控制台上。此时，可以在命令行利用Shell的重定向语法将任意文件关联到System.in和System.out，例如下面的语句实现了从input.txt文件输入并将程序输出结果输入output.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java MyProg &lt; input.txt &gt; output.txt</div></pre></td></tr></table></figure></p><p>本节只是介绍了最常用的输入输出方式，更多输入输出知识详见：<a href="http://habitdiary.cn/2017/11/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F/">Java学习总结之Java IO系统</a></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1) 定义方法"></a>1) 定义方法</h4><p>下面先来看一个方法的定义，其作用是返回两个整数中的较大者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</div><div class="line"><span class="keyword">int</span> result;</div><div class="line">    <span class="keyword">if</span>(num1 &gt; num2)</div><div class="line">    result = num1;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    result = num2;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中花括号前的部分是<strong>方法头</strong>，花括号包括的部分是<strong>方法体</strong>。方法头包括<strong>修饰符(public static)、返回值类型(int)、方法名(max)、形式参数(int num1、int num2)</strong>。形式参数构成<strong>参数列表</strong>，方法名和参数列表构成<strong>方法签名</strong>。<br>对带返回值的方法而言，return语句是必需的，且如果存在多个选择分支，要确保任何分支都有返回值。对于void方法，也可以在方法中使用return结束方法调用。</p><h4 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2) 调用方法"></a>2) 调用方法</h4><p>如调用上述max方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> z = max(x,y);</div></pre></td></tr></table></figure></p><p>其中x,y是实际参数。</p><p>每当调用一个方法时，系统会创建一个<strong>活动记录</strong>(也称为活动框架)，用于保存方法中的参数和变量。活动记录置于一个内存区域中，称为<strong>调用堆栈(call stack)</strong>。调用堆栈也称为执行堆栈、运行时堆栈，或者一个机器堆栈，常简称为”堆栈”。当一个方法调用另一个方法时，调用者的活动记录保持不动，一个新的活动记录被创建用于被调用的新方法,一个新的记录”入栈”。一个方法结束返回到调用者时，相应的活动记录被释放，其中的参数和变量被销毁，栈顶的记录”出栈”。堆栈的最底层活动记录是main方法的记录，当整个程序结束，main方法记录”出栈”,栈为空，程序结束。  </p><p>当调用带参数的方法时，如果参数是基本数据类型，实参的值传递给形参(即拷贝)，这个过程称为<strong>按值传递</strong>，无论形参在方法中是否改变，实参都不受影响;如果参数是引用类型，则传递的是引用值，可以理解为<strong>传共享</strong>，形参和实参指向同一对象，此时实际对象可能会被改变。  </p><p>main方法也有参数，是一个String数组，可以在命令行里给main方法传递字符串参数(也可以通过eclipse传递参数，在运行——运行配置——自变量里传递)。例如，下面的命令行用三个字符串arg0、arg1、arg2启动程序TestMain：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java TestMain arg0 arg1 arg2</div></pre></td></tr></table></figure></p><p>其中arg0、arg1、arg2都是字符串，但是在命令行中出现时不需要双引号，但如果字符串包含空格，就必须用双引号括住。<br>当调用main方法时，Java解释器会创建一个数组存储命令行参数，然后将该数组的引用传递给args。例如，如果调用有n个命令行参数的程序，Java解释器创建一个如下所示的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">args = <span class="keyword">new</span> String[n];</div></pre></td></tr></table></figure></p><p>然后Java解释器传递参数args去调用main方法<br><strong>注意：如果命令行没有传递参数，那么使用new String[0]创建数组。在这种情况下args引用了一个长度为0的空数组，它的值不是null，但是args.length是0</strong></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java和许多高级语言都提供了一种称作数组的数据结构，可以用它来存储一个元素个数固定且元素类型相同的有序集。<br>数组一旦被创建，它的大小不能改变。使用一个数组引用变量，通过下标来访问数组中的元素。  </p><h4 id="1-声明和创建数组-以一维数组为例"><a href="#1-声明和创建数组-以一维数组为例" class="headerlink" title="1) 声明和创建数组(以一维数组为例)"></a>1) 声明和创建数组(以一维数组为例)</h4><p>来看下面的语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">elementType[] arrayRefVar = <span class="keyword">new</span> elementType[arraySize];</div><div class="line"><span class="comment">//(元素类型[] 数组引用变量 = new 元素类型[数组大小])</span></div></pre></td></tr></table></figure></p><p>该语句完成了三个操作：<br>1.<code>elementType[] arrayRefVar</code>声明了一个elementType类型的数组引用变量arrayRefVar<br>2.<code>new elementType[arraySize]</code>创建了一个大小为arraySize的elementType的数组<br>3.<code>=</code> 把数组引用赋给数组引用变量  </p><p><strong>注意：</strong><br>1.<code>elementType[] arrayRefVar</code>只是声明数组变量，并不在内存中给数组分配任何空间，它只是创建一个对数组应用的存储位置，如果变量不包含对数组的引用，这个变量的值为null<br>2.<code>new elementType[arraySize]</code>在内存中给数组元素分配了存储空间<br>3.一个数组变量看起来似乎是存储了一个数组，但实际上它存储的是只是数组的引用。<br>4.当创建数组后，它的元素被赋予默认值，数值型基本数据类型的默认值为0,char型的默认值为’\u0000’(空字符，但长度为1),boolean型的默认值为false，非基本数据类型的默认值均为null<br>5.与C++不同，Java允许动态开数组，即无需在编译期就确定数组大小，可以在程序运行时决定数组大小并创建相应大小的数组。</p><h4 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2) 初始化数组"></a>2) 初始化数组</h4><p>1.逐一赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myList = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">myList[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">myList[<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line">myList[<span class="number">2</span>] = <span class="number">3</span>;</div><div class="line">myList[<span class="number">3</span>] = <span class="number">4</span>;</div><div class="line">myList[<span class="number">4</span>] = <span class="number">5</span>;</div></pre></td></tr></table></figure></p><p>2.数组初始化语法  </p><p>下面的语法可以给数组的前k个元素赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">elementType[] arrayRefVar = &#123;value0, value1, .., valuek&#125;;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>在使用数组初始化语法时，必须将声明、创建和初始化放在一条语句中，将它们分开会产生语法错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myList;</div><div class="line">myList = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//Error</span></div></pre></td></tr></table></figure></p><h4 id="3-访问数组元素"><a href="#3-访问数组元素" class="headerlink" title="3) 访问数组元素"></a>3) 访问数组元素</h4><p>可以用arrayRefVar.length得到数组长度，数组元素的下标为0 ～ arrayRefVar.length - 1。可以直接使用下标随机访问数组元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayRefVar[index] (数组引用变量[下标])</div></pre></td></tr></table></figure></p><p>如果要打印数组，可以使用一个循环打印逐一数组元素。<strong>如果是字符数组，可以使用一条打印语句打印</strong>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>[] city = &#123;<span class="string">'B'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'g'</span>&#125;;</div><div class="line">System.out.println(city);</div></pre></td></tr></table></figure></p><h4 id="4-复制数组"><a href="#4-复制数组" class="headerlink" title="4) 复制数组"></a>4) 复制数组</h4><p>要将一个数组中的内容复制到另一个中，如果使用<code>=</code>直接赋值，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list2 = list1;</div></pre></td></tr></table></figure></p><p>上述语句只是将list1的引用值复制给了list2，这条语句执行后，list1和list2都指向了同一个数组，如果改变其中一者，另一者也会受到同样的影响。list2原先所引用的数组不能再引用，它就变成了垃圾，会被JVM自动回收。<strong>在Java中，可以使用赋值语句复制基本类型的值，但不能复制数组等引用类型的值。</strong>  </p><p>复制数组的四种方法<br>1.申请一个新数组，遍历原数组逐一复制元素<br>2.使用System类的静态方法arraycopy()<br>3.使用<code>数组对象.clone()</code>返回一个数组克隆的引用<br>4.使用Arrays类的copyOf()方法  </p><p>下面是四种复制数组的方法的效率比较，非常有趣，看来要多读读JDK源码^-^<br>参考博客：<a href="https://www.cnblogs.com/zhengbin/p/5671403.html" target="_blank" rel="external">https://www.cnblogs.com/zhengbin/p/5671403.html</a>  </p><h4 id="5-匿名数组"><a href="#5-匿名数组" class="headerlink" title="5) 匿名数组"></a>5) 匿名数组</h4><p>来看下面的语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> elementType[] &#123;value0,value1, ... ,valuek&#125;;</div></pre></td></tr></table></figure></p><p>该语句创建了一个没有显式引用变量的数组并进行了初始化，这样的数组称为<strong>匿名数组</strong>。注意匿名数组的<strong>方括号里不指定数组长度!</strong>  </p><h4 id="6-可变长参数列表"><a href="#6-可变长参数列表" class="headerlink" title="6) 可变长参数列表"></a>6) 可变长参数列表</h4><p>可以把类型相同但个数可变的参数传递给方法，语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typeName...parameterName (类型名...参数名)</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1.在方法声明中，指定类型后紧跟着省略号(…)<br>2.只能给方法中指定一个可变长参数，且该参数必须是最后一个参数，任何常规参数必须在它之前<br>3.Java将可变长参数当成数组对待，当用数目可变的参数调用方法时，Java会创建一个数组并把参数传给它。所以可以传入一个数组，但反之如果参数是数组类型，不能传递可变长参数。且参数为数组和可变长参数的两个方法(其他参数均相同)不能重载，因为它们被认为是同一方法。<br>4.如果有多个重载的方法都满足被调用的条件，带可变常参数的方法最后考虑被调用。  </p><h4 id="7-Arrays类"><a href="#7-Arrays类" class="headerlink" title="7) Arrays类"></a>7) Arrays类</h4><p>Arrays类中包含了许多对处理数组的方法  </p><p>下面是Arrays类的常用API：  </p><p><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/Arrays类常用API1.png" alt="fail"><br><img src="/2017/10/10/Java学习总结之Java基本程序设计结构/Arrays类常用API2.png" alt="fail" title="Arrays类常用API">  </p><p>如果计算机有多个处理器，可以使用parallelSort，比sort更高效。  </p><h4 id="8-多维数组"><a href="#8-多维数组" class="headerlink" title="8) 多维数组"></a>8) 多维数组</h4><p>以二维数组为例，二维数组引用变量有三种表示方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">elementType arrayRefVar[][]</div><div class="line">elementType[] arrayRefVar[]</div><div class="line">elementType[][] arrayRefVar</div></pre></td></tr></table></figure></p><p>推荐使用<code>elementType[][] arrayRefVar</code>声明二维数组引用变量。<br>初始化语法也适用于多维数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] array = &#123;</div><div class="line">     &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</div><div class="line">     &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>等价于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">array[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">array[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</div><div class="line">array[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">3</span>;</div><div class="line">array[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">4</span>;</div></pre></td></tr></table></figure></p><p><strong>二维数组其实是一个数组，它的每个元素都是一个一维数组，即它是数组的数组。</strong><br>x.length可以获取二维数组的第一维长度，x[index].length可以获取index行对应的第二维长度。如果没有初始化二维数组二维数组的所有元素默认为null，因为二维数组的元素是数组类型，默认值为null<br><strong>二维数组中的每一行本身就是一个数组，因此，各行的长度可以不同。这样的数组称为锯齿数组</strong>，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] triangleArray = &#123;</div><div class="line">   &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">   &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">   &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">   &#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</div><div class="line">   &#123;<span class="number">5</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>其余没有赋值的部分并不会被赋为默认值，就是未分配空间,如果进行访问会抛出ArrayIndexOutOfBoundsException</strong>  </p><p>二维数组在创建时可以省略第二维长度(留到后续指定)，但必须指定第一维长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[][] triangleArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];</div><div class="line">triangleArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">triangleArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">triangleArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</div><div class="line">triangleArray[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">triangleArray[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div></pre></td></tr></table></figure></p><p>如果想打印多维数组，可以使用嵌套循环打印，也可以使用Arrays类的<strong>deepToString()</strong>方法。</p><h3 id="零敲碎打"><a href="#零敲碎打" class="headerlink" title="零敲碎打"></a>零敲碎打</h3><ul><li>一个Java源文件内只能有一个public类,且该类名称必须与文件名相同  </li><li>main方法是程序的入口，JVM将从指定类中的main方法开始执行。根据Java语言规范，main方法必须声明为<code>public static void main(String[] args)</code></li><li>在源代码中，字符串常量不能跨行，因此，下面的语句会造成编译错误：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"Welcome to the</span></div><div class="line"><span class="string">world of Java!"</span>);</div></pre></td></tr></table></figure></li></ul><p>为了改正错误，可以将该字符串分成几个单独的子串，然后再用连接符(+)将它们组合起来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"Welcome to the“ +</span></div><div class="line"><span class="string">”world of Java!"</span>);</div></pre></td></tr></table></figure></p><ul><li>在eclipse中创建一个工程，目录包含关系如下：在work-space文件夹下会生成一个以工程名命名的文件夹，下面有bin和src文件，bin文件夹用于存放字节码文件，src用于存放源文件。如果工程创建了包，比如cn.habitdiary.core，会在bin和src文件夹下都创建三级文件夹cn/habitdiary/core。特别注意，在eclipse中哪怕没有编译，bin中也会出现字节码文件。事实上每次保存源文件都会自动编译。  </li><li>eclipse调试和设置断点：<br>按F11进入程序调试，程序运行到设置的断点处会暂停执行，注意调试到某条语句时该语句是还未执行的状态，按F6单步执行，按F8向下执行直到遇到断点或程序结束，按F5从进入方法进行调试(step in)，按F7从方法内部返回调用处(step out)。  </li><li>eclipse中按Alt+/调出代码提示。  </li><li>eclipse中输入Sysout，按Alt+/即可补全为System.out.println();</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h3&gt;&lt;p&gt;Java是一种&lt;strong&gt;强类型&lt;/strong&gt;语言，即意味着必须为每一个变量声明一种类型。在Java中一共有8种基本
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之Java程序设计概述</title>
    <link href="http://habitdiary.cn/2017/10/07/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <id>http://habitdiary.cn/2017/10/07/Java学习总结之Java程序设计概述/</id>
    <published>2017-10-07T13:46:26.000Z</published>
    <updated>2018-02-01T06:16:42.018Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、走进Java"><a href="#一、走进Java" class="headerlink" title="一、走进Java"></a>一、走进Java</h3><p>Java是一个完整的平台,有一个庞大的库,其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。它是功能完善的通用程序设计语言，可以用来开发健壮的任务关键的应用程序。现在，它不仅用于Web程序设计，而且用于在服务器、台式计算机和移动设备上开发跨平台的独立应用程序。</p><h3 id="二、Java”白皮书”的关键术语"><a href="#二、Java”白皮书”的关键术语" class="headerlink" title="二、Java”白皮书”的关键术语"></a>二、Java”白皮书”的关键术语</h3><h4 id="1-简单性"><a href="#1-简单性" class="headerlink" title="1) 简单性"></a>1) 简单性</h4><p>Java语法是C++语法的一个“纯净”版本。这里没有头文件、指针运算(甚至指针语法)、结构、联合、操作符重载、虚基类等。其剔除了C++中许多很少使用、难以理解、易混淆的特性。目前看来，这些特性带来的麻烦远远多于其带来的好处。  </p><h4 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2) 面向对象"></a>2) 面向对象</h4><p>简单地讲，面向对象设计是一种程序设计技术。传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。</p><h4 id="3-分布式"><a href="#3-分布式" class="headerlink" title="3) 分布式"></a>3) 分布式</h4><p>Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。  </p><h4 id="4-健壮性"><a href="#4-健壮性" class="headerlink" title="4) 健壮性"></a>4) 健壮性</h4><p>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java投入了大量的精力进行早期的问题检测(编译时检测)，后期动态的检测(运行时检测)，并消除了容易出错的情况。  </p><h4 id="5-安全性"><a href="#5-安全性" class="headerlink" title="5) 安全性"></a>5) 安全性</h4><p>Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。  </p><h4 id="6-体系结构中立"><a href="#6-体系结构中立" class="headerlink" title="6) 体系结构中立"></a>6) 体系结构中立</h4><p>Java源文件经过编译生成中间字节码文件(.class)，这是一种体系结构中立的文件格式，精心设计的字节码不仅可以很容易地在任何带Java虚拟机(JVM)的平台上运行，而且还可以动态地翻译成本地机器代码，即Java程序可以”一次编译，处处运行”。当然，解释虚拟机指令肯定会比全速运行机器指令慢很多。虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程称为<strong>即时编译</strong>。  </p><h4 id="7-可移植性"><a href="#7-可移植性" class="headerlink" title="7) 可移植性"></a>7) 可移植性</h4><p>与C和C++不同，Java规范中没有”依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。例如，Java中的int永远是32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是int类型的大小不能低于short int，并且不能高于long int。在Java中，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。</p><h4 id="8-解释型"><a href="#8-解释型" class="headerlink" title="8) 解释型"></a>8) 解释型</h4><p>Java源程序(.java)在编写完成后，经过编译生成中间字节码文件(.class)，字节码文件被JVM解释执行，不同于C/C++等编译型语言，字节码被解释为机器代码后立即执行，不产生中间机器代码文件。</p><h4 id="9-高性能"><a href="#9-高性能" class="headerlink" title="9) 高性能"></a>9) 高性能</h4><p>尽管对解释后的字节码性能已经比较满意，但有些场合下还需要更加高效的性能。字节码可以(在运行时刻)动态地翻译成对应运行这个应用的特定CPU的机器码。  </p><h4 id="10-多线程"><a href="#10-多线程" class="headerlink" title="10) 多线程"></a>10) 多线程</h4><p>多线程可以带来更好的交互响应和实时行为。我们非常关注并发性，因为我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。Java是第一个支持并发程序设计的主流语言。  </p><h4 id="11-动态性"><a href="#11-动态性" class="headerlink" title="11) 动态性"></a>11) 动态性</h4><p>Java能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时的类型信息十分简单。  </p><h3 id="三、名词释疑"><a href="#三、名词释疑" class="headerlink" title="三、名词释疑"></a>三、名词释疑</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>即Java开发工具包(Java Development Kit)，是<strong>编写</strong>Java程序的程序员使用的软件，包括<strong>开发和运行</strong>Java程序的软件。 </p><h4 id="OpenJDK"><a href="#OpenJDK" class="headerlink" title="OpenJDK"></a>OpenJDK</h4><p>Java SE的一个免费开源实现，不包含浏览器集成或JavaFX  </p><h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><p>即Software Development Kit,是一个过时的术语，用于描述1998 ～ 2006年之间的JDK  </p><h4 id="J2"><a href="#J2" class="headerlink" title="J2"></a>J2</h4><p>一个过时的术语，用于描述1998 ～ 2006年之间的Java版本  </p><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>即Java运行时环境(Java Runtime Environment)，是<strong>运行</strong>Java程序的用户使用的软件，它包含Java虚拟机但不包含编译器，为<strong>不需要开发只需要运行</strong>Java程序的用户提供。</p><h4 id="Sever-JRE"><a href="#Sever-JRE" class="headerlink" title="Sever JRE"></a>Sever JRE</h4><p>在服务器上运行Java程序的软件。</p><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>即Java虚拟机(Java Virtual Machine)，用于解释执行中间字节码文件。  </p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>即应用程序接口(Application Program Interface),也称为库，包括为开发Java程序而预定义的类和接口。  </p><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>即集成开发环境(Integrated Development Environment),是为了快速开发程序而提供的开发工具，编辑、编译、链接、调试和在线帮助都集成在一个图形用户界面中。</p><h4 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h4><p>能在Web浏览器中运行的Java程序称为Java小程序(applet)</p><h4 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h4><p>即Java标准版(Java Standard Edition),可以用来开发客户端的应用程序。应用程序可以独立运行或作为applet在Web浏览器中运行。  </p><h4 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h4><p>即Java企业版(Java Enterprise Edition),可以用来开发服务器端的应用程序，例如，Java servlet和JavaServer Pages(JSP)，以及JavaServer Faces(JSF)。 </p><h4 id="Java-ME"><a href="#Java-ME" class="headerlink" title="Java ME"></a>Java ME</h4><p>即Java微型版(Java Micro Edition)，可以用来开发移动设备的应用程序，例如手机。  </p><h4 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h4><p>开发Java GUI程序的框架，在Oracle的Java SE发布版本中提供。  </p><h3 id="四、JDK、JRE和JVM三者的关系"><a href="#四、JDK、JRE和JVM三者的关系" class="headerlink" title="四、JDK、JRE和JVM三者的关系"></a>四、JDK、JRE和JVM三者的关系</h3><p>见大牛博客：<a href="https://www.cnblogs.com/zhangzongxing01/p/5559126.html" target="_blank" rel="external">JDK、JRE、JVM三者间的关系</a><br><img src="/2017/10/07/Java学习总结之Java程序设计概述/relationship.png" alt="fail"></p><h3 id="五、创建、编译和执行Java程序的过程"><a href="#五、创建、编译和执行Java程序的过程" class="headerlink" title="五、创建、编译和执行Java程序的过程"></a>五、创建、编译和执行Java程序的过程</h3><p>Java源程序编写后被保存为.java文件，通过Java编译器编译生成字节码.class文件，字节码文件和所需的库代码被送去JVM解释执行。在执行一个Java程序时，JVM首先会用一个称为<strong>类加载器(class loader)</strong>的程序将类的字节码加载到内存中。如果你的程序中使用其他类，类加载程序会在需要它们之前动态地加载它们。当加载该类后，JVM使用一个字节码验证器(bytecode verifier)的程序来检验字节码的合法性，确保字节码不会违反Java的安全规范，以确保来自网络的Java程序不会篡改和危害你的计算机。<br><img src="/2017/10/07/Java学习总结之Java程序设计概述/1.png" alt="fail"></p><h3 id="六、通过命令行编译、运行Java程序"><a href="#六、通过命令行编译、运行Java程序" class="headerlink" title="六、通过命令行编译、运行Java程序"></a>六、通过命令行编译、运行Java程序</h3><p>在命令行里输入以下命令编译Java程序：<br>java classname.java<br>编译成功后，使用以下语句运行程序：<br>java classname //注意此处不要加.class后缀<br><strong>注意：如果提示命令不存在，应该先配置环境变量，在path中用分号和前面的内容分隔，然后加入jdk/bin的路径，因为java.exe,javac.exe文件都在该目录下。</strong></p><h3 id="七、注释"><a href="#七、注释" class="headerlink" title="七、注释"></a>七、注释</h3><h4 id="1-行注释"><a href="#1-行注释" class="headerlink" title="1) 行注释"></a>1) 行注释</h4><p>行注释以<code>//</code>开始，不能跨行  </p><h4 id="2-块注释"><a href="#2-块注释" class="headerlink" title="2) 块注释"></a>2) 块注释</h4><p>块注释以<code>/*</code>开始，以<code>*/</code>结尾，可以跨行  </p><h4 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3) 文档注释"></a>3) 文档注释</h4><p>文档注释以<code>/**</code>开始，以<code>*/</code>结尾，添加方法是输入<code>/**</code>后回车即可，可以添加<code>@author</code>、<code>@version</code>等参数，它能使用JDK的javadoc命令提取一个HTML文件(在控制台输入<code>javadoc 文件名</code>，然后会在执行目录下生成若干文件，打开index.html即可)。使用javadoc注释来注释整个类或整个方法，为了将这些注释提取出来放在一个javadoc HTML文件中，这些注释必须放在类或者方法头前面。要注释方法中的某一步骤，使用行注释<code>//</code><br>更多文档注释内容详见：<a href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/">Java学习总结之对象与类</a></p><p><strong>eclipse快捷键：<br>选中要注释的区域 ctrl+/ 或者ctrl+shift+c 为该区域加上行注释<br>选中要注释的区域 ctrl+shift+/ 为该区域加上块注释 </strong></p><h3 id="八、程序设计错误"><a href="#八、程序设计错误" class="headerlink" title="八、程序设计错误"></a>八、程序设计错误</h3><h4 id="1-语法错误"><a href="#1-语法错误" class="headerlink" title="1) 语法错误"></a>1) 语法错误</h4><p>在编译过程中出现的错误称为<strong>语法错误</strong>或<strong>编译错误</strong>。  </p><h4 id="2-运行时错误"><a href="#2-运行时错误" class="headerlink" title="2) 运行时错误"></a>2) 运行时错误</h4><p>运行时错误是引起程序非正常中断的错误，即程序能通过编译，但在运行时环境检测到一个不可能执行的操作，就会出现运行错误。  </p><h4 id="3-逻辑错误"><a href="#3-逻辑错误" class="headerlink" title="3) 逻辑错误"></a>3) 逻辑错误</h4><p>当程序没有按预期的方式执行就会发生逻辑错误。  </p><h3 id="九、Java标识符"><a href="#九、Java标识符" class="headerlink" title="九、Java标识符"></a>九、Java标识符</h3><p>Java标识符用于命名类、接口、变量、常量、方法等，有如下规则：  </p><ul><li>标识符是由<strong>字母、数字、下划线(<code>_</code>)和美元符号(<code>$</code>)</strong>组成的字符序列  </li><li>必须以<strong>字母、下划线(<code>_</code>)或美元符号(<code>$</code>)</strong>开头，不能以数字开头  </li><li>标识符不能是关键字(如public)或保留字(如goto)  </li><li>标识符不能是<strong>true、false或null</strong>等字面常量  </li><li>标识符可以为任意长度  </li><li>不要用字符<code>$</code>命名标识符，习惯上<code>$</code>只用于机器自动产生的源代码中 </li></ul><h3 id="十、命名规范"><a href="#十、命名规范" class="headerlink" title="十、命名规范"></a>十、命名规范</h3><p><strong>注意：在命名时尽量避免采用缩写作为标识符，用完整的词汇会更具有描述性，比如numberOfStudents比numStds、numOfStuds或者numOfStudents要好。另外，Java是区分大小写的。</strong></p><h4 id="1-类名和接口"><a href="#1-类名和接口" class="headerlink" title="1) 类名和接口"></a>1) 类名和接口</h4><p>使用Pascal命名法，每个单词的首字母大写,例如类名ComputeArea和System  </p><h4 id="2-变量和方法"><a href="#2-变量和方法" class="headerlink" title="2) 变量和方法"></a>2) 变量和方法</h4><p>使用驼峰命名法，一个单词都小写，如有多个单词则第一个单词字母小写，后面每个单词的首字母大写，例如变量radius以及方法setRadius  </p><h4 id="3-常量"><a href="#3-常量" class="headerlink" title="3) 常量"></a>3) 常量</h4><p>大写常量的所有字母，如果有多个单词，单词之间用下划线连接，例如，常量PI和常量MAX_VALUE  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、走进Java&quot;&gt;&lt;a href=&quot;#一、走进Java&quot; class=&quot;headerlink&quot; title=&quot;一、走进Java&quot;&gt;&lt;/a&gt;一、走进Java&lt;/h3&gt;&lt;p&gt;Java是一个完整的平台,有一个庞大的库,其中包含了很多可重用的代码和一个提供诸如安全性、跨
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SSH远程登录实现本地机和服务器的文件传输</title>
    <link href="http://habitdiary.cn/2017/10/07/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <id>http://habitdiary.cn/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/</id>
    <published>2017-10-07T07:55:41.000Z</published>
    <updated>2017-10-07T08:57:11.077Z</updated>
    
    <content type="html"><![CDATA[<p>SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见:  <a href="http://habitdiary.cn/2017/10/07/%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/#more">在Ubuntu下通过SSH连接远程服务器</a>  </p><h3 id="1-用SSH登录远程ubuntu主机"><a href="#1-用SSH登录远程ubuntu主机" class="headerlink" title="(1)用SSH登录远程ubuntu主机"></a>(1)用SSH登录远程ubuntu主机</h3><p>假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu<br>我们在命令行输入以下命令来连接：<br><code>ssh -l ubuntu 118.89.223.117</code><br>之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/1.png" alt="fail">  </p><h3 id="2-从远程Ubuntu主机下载文件-文件夹到本地-scp"><a href="#2-从远程Ubuntu主机下载文件-文件夹到本地-scp" class="headerlink" title="(2)从远程Ubuntu主机下载文件/文件夹到本地(scp)"></a>(2)从远程Ubuntu主机下载文件/文件夹到本地(scp)</h3><p>语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径  </p><p>我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/4.png" alt="fail"><br>要下载文件到本地,我们要结束SSH连接,切换到本地机,输入<code>eixt</code>或<code>quit</code>即可  </p><p>我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/5.png" alt="fail">  </p><p>我们进入本地目录验证一下<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/6.png" alt="fail">  </p><p>hello文件的确下载到了本地</p><h3 id="3-从本地向远程ubuntu主机上传文件-文件夹-scp"><a href="#3-从本地向远程ubuntu主机上传文件-文件夹-scp" class="headerlink" title="(3)从本地向远程ubuntu主机上传文件/文件夹(scp)"></a>(3)从本地向远程ubuntu主机上传文件/文件夹(scp)</h3><p>语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径  </p><p>假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下  </p><p>要上传本地文件,我们要结束SSH连接,切换到本地机,输入<code>eixt</code>或<code>quit</code>即可<br>然后输入命令<code>$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/</code>，输入密码后提示文件上传成功<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/2.png" alt="fail">  </p><p>我们通过SSH登录到远程主机验证一下,<code>pwd</code>打印当前所在位置，发现我们处于/home/ubuntu目录下,<code>ls</code>显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下<br><img src="/2017/10/07/SSH远程登录实现本地机和服务器的文件传输/3.png" alt="fail">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
      <category term="服务器" scheme="http://habitdiary.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
