<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XJY&#39;s Blog</title>
  
  <subtitle>你要静候再静候 就算失收始终要守</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://habitdiary.cn/"/>
  <updated>2018-03-23T02:30:48.810Z</updated>
  <id>http://habitdiary.cn/</id>
  
  <author>
    <name>谢均宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Java虚拟机之虚拟机锁优化策略</title>
    <link href="http://habitdiary.cn/2018/03/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>http://habitdiary.cn/2018/03/21/深入理解Java虚拟机之虚拟机锁优化策略/</id>
    <published>2018-03-21T12:36:18.000Z</published>
    <updated>2018-03-23T02:30:48.810Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JVM" scheme="http://habitdiary.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之虚拟机类加载机制</title>
    <link href="http://habitdiary.cn/2018/03/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://habitdiary.cn/2018/03/21/深入理解Java虚拟机之虚拟机类加载机制/</id>
    <published>2018-03-21T12:34:16.000Z</published>
    <updated>2018-03-23T04:23:35.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>一个类从加载进内存到卸载出内存为止，一共经历7个阶段：加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化——&gt;使用——&gt;卸载。<br>其中，类加载包括5个阶段： 加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化。<br>在类加载的过程中，以下3个过程称为连接： 验证——&gt;准备——&gt;解析。<br>因此，JVM的类加载过程也可以概括为3个过程： 加载——&gt;连接——&gt;初始化。<br>C/C++在运行前需要完成预处理、编译、汇编、链接；而在Java中，类加载(加载、连接、初始化)是在<strong>程序运行期间</strong>完成的。 在程序运行期间进行类加载会稍微增加程序的开销，但随之会带来更大的好处——提高程序的灵活性。Java语言的灵活性体现在它可以在运行期间<strong>动态扩展</strong>，所谓动态扩展就是在运行期间<strong>动态加载</strong>和<strong>动态连接</strong>。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。从最基础的Applet、JSP到相对复杂的OSGi技术，都使用了Java语言运行期类加载的特性。<br><img src="/2018/03/21/深入理解Java虚拟机之虚拟机类加载机制/类的生命周期.png" alt="fail" title="类的生命周期"></p><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>我们已经知道，类加载的过程包括：加载、验证、准备、解析、初始化。<br>其中加载、验证、准备、初始化的<strong>开始顺序</strong>是依次进行的，这些步骤开始之后的过程可能会有重叠。而<strong>解析阶段</strong>则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。  </p><h3 id="类加载过程中“初始化”开始的时机"><a href="#类加载过程中“初始化”开始的时机" class="headerlink" title="类加载过程中“初始化”开始的时机"></a>类加载过程中“初始化”开始的时机</h3><p>加载、验证、准备阶段要求在初始化阶段之前开始，但对于它们开始的具体时机，Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。<br>但是对于初始化阶段，虚拟机规范则是严格规定了<strong>有且只有5种情况</strong>必须立即对类进行“初始化”：<br>1、遇到new、getstatic、putstatic或invokestatic这4条<strong>字节码指令</strong>时，如果类没有进行过初始化，则需要先触发其初始化。<br>生成这4条指令的最常见的Java代码场景是:  </p><ul><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候  </li><li>调用一个类的静态方法的时候  </li></ul><p>2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。<br>3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br>4、当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。<br>5、当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p><h3 id="主动引用与被动引用"><a href="#主动引用与被动引用" class="headerlink" title="主动引用与被动引用"></a>主动引用与被动引用</h3><p>对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：<strong>“有且只有”</strong>，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。  </p><h4 id="被动引用的场景示例"><a href="#被动引用的场景示例" class="headerlink" title="被动引用的场景示例"></a>被动引用的场景示例</h4><p><strong>示例一：通过子类引用父类的静态字段，不会导致子类初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</div><div class="line"><span class="keyword">static</span>&#123;</div><div class="line">System.out.println(<span class="string">"SuperClass init!"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</div><div class="line"><span class="keyword">static</span>&#123;</div><div class="line">System.out.println(<span class="string">"SubClass init!"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">System.out.println(SubClass.value);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>输出结果：</strong><br>SuperClass init!<br><strong>原因分析：</strong><br>本示例看似满足初始化时机的第一条：当要获取某一个类的静态成员变量的时候如果该类尚未初始化，则对该类进行初始化。但对于静态字段，<strong>只有直接定义这个字段的类才会被初始化</strong>，因此通过其子类来引用父类中定义的静态字段属于间接引用，只会触发父类的初始化而不会触发子类的初始化。  </p><p><strong>示例二：通过数组定义来引用类，不会触发此类的初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>输出结果：</strong><br>无输出<br><strong>原因分析：</strong><br>这个过程看似满足初始化时机的第一条：遇到new创建对象时若类没被初始化，则初始化该类。<br>运行之后发现没有输出“SuperClass init!”，说明并没有触发类cn.habitdiary.SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为 [Lcn.habitdiary.SuperClass 的类的初始化阶段。对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。<br>这个类代表了一个元素类型为cn.habitdiary.SuperClass的一维数组，数组中应有的属性和方法(用户可直接使用的只有被修饰为public的length属性和clone()方法)都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法，而C/C++直接翻译为对数组指针的移动。在Java语言中，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。<br><strong>简言之，现在通过new要创建的是一个SuperClass数组对象，而非SuperClass类对象，因此也属于间接引用，不会初始化SuperClass类。</strong>  </p><p><strong>示例三：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD=<span class="string">"hello world"</span>;</div><div class="line"><span class="keyword">static</span>&#123;</div><div class="line">System.out.println(<span class="string">"ConstClass init!"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">System.out.println(ConstClass.HELLOWORLD);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>输出结果：</strong><br>hello world<br><strong>原因分析：</strong><br>本示例看似满足类初始化时机的第一个条件：获取一个类静态成员变量的时候若类尚未初始化则初始化类。<br>这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但HELLOWORLD是被final修饰的常量，在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了引用它的类（这里是NotInitialization类）的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。<br>也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。  </p><h4 id="接口的初始化"><a href="#接口的初始化" class="headerlink" title="接口的初始化"></a>接口的初始化</h4><p>接口和类都需要初始化，接口和类的初始化过程基本一样，不同点在于：类初始化时，如果发现父类尚未被初始化，则先要初始化父类，然后再初始化自己；但接口初始化时，并不要求父接口已经全部初始化，有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。另外，<strong>接口中不能使用“static{}”语句块</strong>。  </p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>接下来我们详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。  </p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>注意：“加载”是“类加载”过程的第一步，千万不要混淆。  </p><h5 id="加载时JVM做了什么？"><a href="#加载时JVM做了什么？" class="headerlink" title="加载时JVM做了什么？"></a>加载时JVM做了什么？</h5><p>在加载过程中，JVM主要做3件事情：  </p><ul><li>通过一个类的全限定名来获取这个类的二进制字节流，即class文件：在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化时机的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，存储在方法区中。  </li><li>在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口。接下来程序在运行过程中所有对该类的访问都通过这个类对象，也就是这个Class类型的类对象是提供给外界访问该类的接口。  </li></ul><h5 id="从哪里加载？"><a href="#从哪里加载？" class="headerlink" title="从哪里加载？"></a>从哪里加载？</h5><p>1、从压缩包中读取，如：Zip、Jar、War、Ear等。<br>2、从网络中获取，这种场景最典型的应用就是Applet。<br>3、由其他文件动态生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。<br>4、从数据库中读取，将二进制字节流存储至数据库中，然后在加载时从数据库中读取。有些中间件(如SAP Netweaver)会这么做，用来实现代码在集群间分发。<br>5、运行时计算生成,这种场景使用得最多的就是动态代理技术,在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为<code>*$Proxy</code>的代理类的二进制字节流。</p><h5 id="类和数组加载过程的区别？"><a href="#类和数组加载过程的区别？" class="headerlink" title="类和数组加载过程的区别？"></a>类和数组加载过程的区别？</h5><p>一个<strong>非数组类</strong>的加载阶段(准确地说，是加载阶段中获<br>取类的二进制字节流的动作)是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式(即重写一个类加载器的loadClass()方法)。<br>如果数组的组件类型(Component Type，指的是数组去掉一个维度的类型)是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识(这点很重要，一个类必须与类加载器一起确定唯一性)。<br>如果数组的组件类型不是引用类型(例如int[]数组)，Java虚拟机将会把数组C标记为与引导类加载器关联。<br>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类的生命周期&quot;&gt;&lt;a href=&quot;#类的生命周期&quot; class=&quot;headerlink&quot; title=&quot;类的生命周期&quot;&gt;&lt;/a&gt;类的生命周期&lt;/h3&gt;&lt;p&gt;一个类从加载进内存到卸载出内存为止，一共经历7个阶段：加载——&amp;gt;验证——&amp;gt;准备——&amp;gt;解析—
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://habitdiary.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之类文件结构</title>
    <link href="http://habitdiary.cn/2018/03/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://habitdiary.cn/2018/03/21/深入理解Java虚拟机之类文件结构/</id>
    <published>2018-03-21T12:34:01.000Z</published>
    <updated>2018-03-23T02:18:59.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是JVM的“无关性”？"><a href="#什么是JVM的“无关性”？" class="headerlink" title="什么是JVM的“无关性”？"></a>什么是JVM的“无关性”？</h3><p>Java具有<strong>平台无关性</strong>，也就是任何操作系统都能运行Java代码。之所以能实现这一点，是因为Java运行在Java虚拟机之上，不同的操作系统都拥有各自的Java虚拟机，这些虚拟机都可以载入和执行字节码(Byte Code)。<strong>程序编译结果从二进制本地机器码(Native Code)转变为与操作系统和机器指令集无关的、平台中立的字节码(Byte Code)。</strong>因此Java能实现“一次编写，处处运行”。<br>而JVM不仅具有平台无关性，还具有<strong>语言无关性</strong>。平台无关性是指任何操作系统都能运行Java代码，而语言无关性是指Java虚拟机能运行除Java以外的代码！<br>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。<br><strong>简而言之，JVM只认识class文件，它并不管何种语言生成了class文件，只要class文件符合JVM的规范就能运行。</strong>因此目前已经有Clojure、Groovy、JRuby、Jython、Scala等语言能够在JVM上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合JVM规范的class文件，从而能够借助JVM运行它们。<br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/语言无关性.png" alt="fail">  </p><h3 id="纵观Class文件结构"><a href="#纵观Class文件结构" class="headerlink" title="纵观Class文件结构"></a>纵观Class文件结构</h3><p>class文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全是连续的0和1。class文件中的所有内容被分为两种类型：<strong>无符号数</strong>和<strong>表</strong>。<br><strong>无符号数：</strong>它表示class文件中的值，<strong>这些值没有任何类型，但有不同的长度</strong>。根据这些值长度的不同分为：u1、u2、u4、u8，分别代表1字节的无符号数、2字节的无符号数、4字节的无符号数、8字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。<br><strong>表：</strong>表是由<strong>多个无符号数或者其他表</strong>作为数据项构成的<strong>复合数据类型</strong>，所有表都习惯性地以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p><h3 id="class文件的组织结构"><a href="#class文件的组织结构" class="headerlink" title="class文件的组织结构"></a>class文件的组织结构</h3><p>1、魔数<br>2、本文件的版本信息<br>3、常量池<br>4、访问标志<br>5、类索引<br>6、父类索引<br>7、接口索引集合<br>8、字段表集合<br>9、方法表集合  </p><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>每个Class文件的头4个字节称为魔数(Magic Number),它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong>。<br>魔数的作用就相当于文件扩展名，使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动，不安全，因此在class文件中标示文件类型比较合适。<br>class文件的魔数是16进制的 0xCAFEBABE (咖啡宝贝)，非常具有浪漫主义色彩。  </p><h4 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h4><p>紧接着魔数的4个字节是版本号。它表示该class中使用的是哪个版本的JDK。<br>在高版本的JVM上能够运行低版本的class文件，但在低版本的JVM上无法运行高版本的class文件，即使该class文件中没有用到任何高版本JDK的特性也无法运行！  </p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><h5 id="什么是常量池？"><a href="#什么是常量池？" class="headerlink" title="什么是常量池？"></a>什么是常量池？</h5><p>紧接着版本号之后的就是常量池。常量池中存放两种类型的常量。<br><strong>字面量：</strong>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。<br><strong>符号引用：</strong>符号引用是我们定义的各种名字，包括了下面三类常量：<br>1、类和接口的全限定名(Fully Qualified Name)<br>2、字段的名称和描述符(Descriptor)<br>3、方法的名称和描述符</p><h5 id="常量池的特点"><a href="#常量池的特点" class="headerlink" title="常量池的特点"></a>常量池的特点</h5><ul><li><strong>常量池长度不固定：</strong>常量池的大小是不固定的，因此常量池开头放置一个u2类型的无符号数，用来存储当前常量池的容量。JVM根据这个值就知道常量池的头尾。注：这个值是从1开始的，若为5表示池中有4个常量。  </li><li><strong>常量池中的常量用表来表示：</strong>常量池开头有个常量池容量计数器，接下来就全是一个个常量了，<strong>只不过常量都是由一张张二维表构成，除了记录常量的值以外，还记录当前常量的相关信息</strong>。  </li><li><strong>常量池是class文件的资源仓库</strong>  </li><li><strong>常量池是与该class中其它部分关联最多的部分</strong>  </li><li><strong>常量池是class文件中空间占用最大的部分之一</strong>  </li></ul><h5 id="常量池中常量的类型"><a href="#常量池中常量的类型" class="headerlink" title="常量池中常量的类型"></a>常量池中常量的类型</h5><p>常量池中的常量大体上分为：<strong>字面量</strong> 和 <strong>符号引用</strong>。在此基础上，根据常量的数据类型不同，又可以被细分为14种常量类型。这14种常量类型都有各自的二维表示结构。每种常量类型的头1个字节都是tag，用于表示当前常量属于14种类型中的哪一个。<br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/常量类型.png" alt="fail" title="常量类型"><br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/常量项结构总表1.png" alt="fail"><br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/常量项结构总表2.png" alt="fail" title="常量项结构总表"> </p><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>在常量池之后是2字节的访问标志。访问标志是用来表示这个class文件是类还是接口、是否被public修饰、是否被abstract修饰、是否被final修饰等。由于这些标志都由是/否表示，因此可以用0/1表示。访问标志为2字节，可以表示16位标志，但JVM目前只定义了8种，未定义的直接写0。<br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/访问标志.png" alt="fail" title="访问标志">   </p><h4 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h4><p>类索引、父类索引、接口索引集合是用来表示当前class文件所表示类的名字、父类名字、接口的名字。它们按照顺序依次排列，类索引和父类索引各自使用一个u2类型的无符号常量，这个常量指向CONSTANT_Class_info类型的常量，该常量的bytes字段记录了本类、父类的全限定名。由于一个类的接口可能有好多个，因此需要用一个集合来表示接口索引，它在类索引和父类索引之后。这个集合开头入口的第一项是一个u2类型的数据，即接口计数器(interfaces_count)，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0,后面接口的索引表不再占用任何字节。否则，接下来就是接口的名字索引。  </p><h4 id="字段表的集合"><a href="#字段表的集合" class="headerlink" title="字段表的集合"></a>字段表的集合</h4><h5 id="什么是字段表集合？"><a href="#什么是字段表集合？" class="headerlink" title="什么是字段表集合？"></a>什么是字段表集合？</h5><p>字段表(field_info)用于描述接口或者类中声明的变量。字段(field)包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的信息有：字段的作用域(public、private、protected修饰符)、是实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符)、字段数据类型(基本类型、对象、数组)、字段名称。上述这些信息中,各个修饰符都是布尔值,要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类<br>型，这些都是无法固定的，只能引用常量池中的常量来描述。 </p><h5 id="字段表结构的定义"><a href="#字段表结构的定义" class="headerlink" title="字段表结构的定义"></a>字段表结构的定义</h5><p><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/字段表结构.png" alt="fail" title="字段表结构">    </p><ul><li>access_flags：字段的访问标志。在Java中，每个成员变量都有一系列的修饰符，和上述class文件的访问标志的作用一样，只不过成员变量的访问标志与类的访问标志稍有区别。  </li><li>name_index：本字段名字的索引。指向一个CONSTANT_Class_info类型的常量，这里面存储了本字段的名字等信息。  </li><li>descriptor_index：描述符。用于描述本字段在Java中的数据类型等信息（下面详细介绍）。  </li><li>attributes_count：属性表集合的长度。  </li><li>attributes：属性表集合。到descriptor_index为止是字段表的固定信息，光有上述信息可能无法完整地描述一个字段，因此用属性表集合来存放额外的信息，比如一个字段的值（下面会详细介绍）。<br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/字段访问标志.png" alt="fail" title="字段访问标志"><br>很明显,在实际情况中,ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所决定的。<h5 id="什么是描述符？"><a href="#什么是描述符？" class="headerlink" title="什么是描述符？"></a>什么是描述符？</h5>成员变量（包括静态成员变量和实例变量）和 方法都有各自的描述符。 对于字段而言，描述符用于描述字段的数据类型； 对于方法而言，描述符用于描述字段的数据类型、参数列表、返回值。<br>在描述符中，基本数据类型用大写字母表示，对象类型用“L对象类型的全限定名”表示。<br>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为:“[[Ljava/lang/String”，一个整型数组“int[]”将被记录为“[I”。<br>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String”，方法int<br>indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。<br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/描述符标识字符.png" alt="fail" title="描述符标识字符">    <h5 id="字段表集合的注意点"><a href="#字段表集合的注意点" class="headerlink" title="字段表集合的注意点"></a>字段表集合的注意点</h5>1、一个class文件的字段表集合中不能出现从父类/接口继承而来字段<br>2、一个class文件的字段表集合中可能会出现没有人为定义的字段。如编译器会自动地在内部类的class文件的字段表集合中添加外部类对象的成员变量，供内部类访问外部类。<br>3、Java中只要两个字段名字相同就无法通过编译。但在JVM规范中，允许两个字段的名字相同但描述符不同的情况，并且认为它们是两个不同的字段。</li></ul><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><h5 id="什么是方法表集合？"><a href="#什么是方法表集合？" class="headerlink" title="什么是方法表集合？"></a>什么是方法表集合？</h5><p>Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)、属性表集合(attributes)等。<br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/方法表结构.png" alt="fail" title="方法表结构"><br>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。<br><img src="/2018/03/21/深入理解Java虚拟机之类文件结构/方法访问标志.png" alt="fail" title="方法访问标志">      </p><h5 id="方法表集合的注意点"><a href="#方法表集合的注意点" class="headerlink" title="方法表集合的注意点"></a>方法表集合的注意点</h5><p>1、如果本class没有重写父类的方法，那么本class文件的方法表集合中是不会出现父类/父接口的方法表<br>2、本class的方法表集合可能出现没有人为定义的方法 编译器在编译时会在class文件的方法表集合中加入类构造器<code>&lt;Clinit&gt;</code>和实例构造器<code>&lt;init&gt;</code>。<br>3、重载一个方法需要有相同的简单名称和不同的特征签名。JVM的特征签名和Java的特征签名有所不同：<br>Java特征签名：方法参数在常量池中的字段符号引用的集合<br>JVM特征签名：方法参数 + 返回值。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是JVM的“无关性”？&quot;&gt;&lt;a href=&quot;#什么是JVM的“无关性”？&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM的“无关性”？&quot;&gt;&lt;/a&gt;什么是JVM的“无关性”？&lt;/h3&gt;&lt;p&gt;Java具有&lt;strong&gt;平台无关性&lt;/stron
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://habitdiary.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之垃圾收集器与内存分配策略</title>
    <link href="http://habitdiary.cn/2018/03/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://habitdiary.cn/2018/03/20/深入理解Java虚拟机之垃圾收集器与内存分配策略/</id>
    <published>2018-03-20T15:52:42.000Z</published>
    <updated>2018-03-21T12:26:22.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>观察Java内存运行时区域的各个部分，其中程序计数器、Java虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。<strong>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</strong>然而，堆和方法区中的内存清理工作就没那么容易了。 堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。<br>堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。<br>方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。<br>这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，本文后续讨论中的“内存”分配与回收也<strong>仅指Java堆和方法区的内存</strong>。  </p><h3 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h3><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，<strong>第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象)。</strong><br>下面介绍两种判断对象是否存活的算法：  </p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>但主流的Java虚拟机里面没有选用引用计数算法来管理内存，因为这种算法存在一个缺陷，<strong>即它无法解决对象之间相互循环引用的问题：</strong><br>举个简单的例子，对象objA和objB都有字段<br>instance，赋值令objA.instance = objB 及 objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。  </p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>在主流的商用程序语言(Java、C#、Lisp)的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过<strong>一系列的称为“GC Roots”的对象</strong>作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。<br>如下图所示,对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p><img src="/2018/03/20/深入理解Java虚拟机之垃圾收集器与内存分配策略/可达性分析算法.png" alt="fail">  </p><p>在Java语言中，可作为GC Roots的对象包括下面几种:<br>1、虚拟机栈(栈帧中的本地变量表)中引用的对象。<br>2、本地方法栈中JNI(即一般说的Native方法)引用的对象。<br>3、方法区中类静态属性引用的对象。<br>4、方法区中常量引用的对象。   </p><h3 id="回收无效对象的过程"><a href="#回收无效对象的过程" class="headerlink" title="回收无效对象的过程"></a>回收无效对象的过程</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，<strong>至少要经历两次标记过程</strong>：如果对象在进行可达<br>性分析后发现没有与GC Roots相连接的引用链，那它将会被<strong>第一次标记并且进行一次筛选</strong>，筛选的条件是<strong>此对象是否有必要执行finalize()方法</strong>。当对象没有覆盖finalize()方法，或<br>者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。<br>具体步骤如下：</p><p><strong>1）判断该对象是否覆盖了finalize()方法</strong><br>若已覆盖该方法，并该对象的finalize()方法还没有被执行过，那么就会将对象放入F-Queue队列中；若未覆盖该方法，则直接释放对象内存。  </p><p><strong>2）执行F-Queue队列中的finalize()方法</strong><br>虚拟机会以较低的优先级执行这些finalize()方法，所谓的“执行”是指虚拟机会触发这个方法，但不会确保所有的finalize()方法都会执行结束。一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃，此时虚拟机就直接停止执行，将该对象清除。</p><p><strong>3）对象重生或死亡</strong><br>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p><p><strong>注意：强烈不建议使用finalize()函数进行任何操作！如果需要释放资源，请使用try-finally。因为finalize()不确定性大，开销大，无法保证顺利执行。</strong></p><h3 id="Java引用种类"><a href="#Java引用种类" class="headerlink" title="Java引用种类"></a>Java引用种类</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。<br>在JDK 1.2以前,Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。<br>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，<strong>这4种引用强度依次逐渐减弱</strong>。  </p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>我们平时所使用的引用就是强引用。 A a = new A(); 也就是通过关键字new创建的对象所关联的引用就是强引用。 只要强引用存在，该对象永远也不会被回收。  </p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生OutOfMemeryError之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出OutOfMemeryError。软引用的生命周期比强引用短一些。  </p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。  </p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的<strong>唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。  </p><h3 id="方法区的内存回收"><a href="#方法区的内存回收" class="headerlink" title="方法区的内存回收"></a>方法区的内存回收</h3><p>很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。<br>永久代的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong>。  </p><h4 id="如何判定废弃常量？"><a href="#如何判定废弃常量？" class="headerlink" title="如何判定废弃常量？"></a>如何判定废弃常量？</h4><p>清除废弃的常量和清除对象类似，只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。  </p><h4 id="如何判定废弃的类？"><a href="#如何判定废弃的类？" class="headerlink" title="如何判定废弃的类？"></a>如何判定废弃的类？</h4><p>清除废弃类的条件较为苛刻：<br>1、该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。<br>2、加载该类的ClassLoader已经被回收。<br>3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  </p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>现在我们知道了判定一个对象是无效对象、判定一个类是废弃类、判定一个常量是废弃常量的方法，也就是知道了垃圾收集器会清除哪些数据，那么接下来介绍如何清除这些数据。  </p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法是“标记-清除”(Mark-Sweep)算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。<br>之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。<strong>它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</strong>标记—清除算法的执行过程如下图所示：<br><img src="/2018/03/20/深入理解Java虚拟机之垃圾收集器与内存分配策略/“标记-清除”算法示意图.png" alt="fail">    </p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，一种称为“复制”(Copying)的收集算法出现了，它将可用内存按容量划分为<strong>大小相等的两块，每次只使用其中的一块</strong>。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<strong>这种算法避免了碎片空间，但内存被缩小了一半。 而且每次都需要将有用的数据全部复制到另一片内存上去，效率不高。</strong>复制算法的执行过程如下图所示：<br><img src="/2018/03/20/深入理解Java虚拟机之垃圾收集器与内存分配策略/复制算法示意图.png" alt="fail"><br><strong>注意：</strong>在复制的时候会将存活对象复制到<strong>一片连续的空间上</strong>，因为复制算法的内存分配是通过“指针碰撞”方式实现的。  </p><h5 id="解决空间利用率问题"><a href="#解决空间利用率问题" class="headerlink" title="解决空间利用率问题"></a>解决空间利用率问题</h5><p>现在的商业虚拟机都采用这种收集算法来回收<strong>新生代</strong>。在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，所以并不需要按照1:1的比例来划分内存空间，我们将<strong>新生代内存</strong>划分成三块：Eden、Survior1、Survior2，内存大小分别是8:1:1，每次分配内存时，只使用Eden和其中一块Survivor。比如先使用Eden+Survior1，当发现Eden+Survior1的内存即将满时，JVM会发起一次Minor GC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存会被“浪费”。<br>通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。<br>但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。  </p><h5 id="什么是分配担保？"><a href="#什么是分配担保？" class="headerlink" title="什么是分配担保？"></a>什么是分配担保？</h5><p>当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发Minor GC，对该区域的废弃对象进行回收。但如果Minor GC过后只有少量对象被回收，仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。  </p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理算法是一种<strong>老年代</strong>的垃圾收集算法。老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”(Mark-Compact)算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下图所示：<br><img src="/2018/03/20/深入理解Java虚拟机之垃圾收集器与内存分配策略/“标记-整理”算法示意图.png" alt="fail">      </p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并不是一种具体的方法，而是一种思想，即根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</strong>  </p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代。<br>在新生代中为了防止内存碎片问题，因此垃圾收集器一般都选用“复制”算法。因此，堆内存的新生代被进一步分为：Eden区＋Survior1区＋Survior2区。<br>每次创建对象时，首先会在Eden区中分配。若Eden区已满，则在Survior1区中分配。若Eden区＋Survior1区剩余内存太少，导致对象无法放入该区域时，则会触发Minor GC，对该区域的废弃对象进行回收。但如果Minor GC过后只有少量对象被回收，仍然无法装下新对象，就会启用“分配担保”，将当前Eden区＋Survior1区中的对象转移到老年代中，然后再将新对象存入Eden区。<br><strong>新生代GC(Minor GC)：</strong>指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁,一般回收速度也比较快。<br><strong>Minor GC触发条件：</strong>当Eden区满时，触发Minor GC。<br><strong>老年代GC(Major GC/Full GC)：</strong>指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。<br><strong>Full GC触发条件：</strong><br>1）调用System.gc()时，系统<strong>建议执行Full GC，但是不必然执行</strong><br>2）老年代空间不足<br>3）方法区空间不足<br>4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>5）由Eden区、Survivor1区向Survivor2区复制时，对象大小大于Survivor2可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小  </p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓的大对象是指,需要大量连续内存空间的Java对象,最典型的大对象就是那种很长字符串以及数组。<br>当发现一个大对象在Eden区＋Survior1区中存不下的时候就需要分配担保机制把当前Eden区＋Survior1区的所有对象都复制到老年代中去。 我们知道，一个大对象能够存入Eden区＋Survior1区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及到大量的复制，就会造成效率低下。 因此，对于大对象我们直接把他放到老年代中去，从而就能避免大量的复制操作。 那么，什么样的对象才是“大对象”呢？<br><strong>通过-XX:PretrnureSizeThreshold参数设置大对象</strong><br>该参数用于设置大小超过该参数的对象被认为是“大对象”，直接进入老年代。<br><strong>注意：</strong>该参数只对Serial和ParNew收集器有效。  </p><h4 id="生命周期较长的对象进入老年代"><a href="#生命周期较长的对象进入老年代" class="headerlink" title="生命周期较长的对象进入老年代"></a>生命周期较长的对象进入老年代</h4><p>老年代用于存储生命周期较长的对象，那么我们如何判断一个对象的年龄呢？<br>新生代中的每个对象都有一个年龄计数器，当新生代发生一次Minor GC后，存活下来的对象的年龄就加一，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。<br><strong>使用-XXMaxTenuringThreshold设置新生代的最大年龄</strong><br>设置该参数后，只要超过该参数的新生代对象都会被转移到老年代中去。  </p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>如果当前新生代的Survior中，<strong>年龄相同的对象的内存空间总和超过了Survior内存空间的一半，那么所有年龄相同的对象和超过该年龄的对象都被转移到老年代中去</strong>。无需等到对象的年龄超过MaxTenuringThreshold才被转移到老年代中去。  </p><h4 id="“分配担保”策略详解"><a href="#“分配担保”策略详解" class="headerlink" title="“分配担保”策略详解"></a>“分配担保”策略详解</h4><p>当垃圾收集器准备要在新生代发起一次Minor GC时，首先会检查<strong>老年代中最大的连续空闲区域的大小是否大于新生代中所有对象的大小</strong>，也就是老年代中目前能够将新生代中所有对象全部装下。<br>若老年代能够装下新生代中所有的对象，那么此时进行Minor GC没有任何风险，然后就进行Minor GC。<br>若老年代无法装下新生代中所有的对象，那么此时进行Minor GC是有风险的，垃圾收集器会进行一次预测：根据以往MinorGC过后存活对象的平均数来预测这次MinorGC后存活对象的平均数。<br>如果以往存活对象的平均数小于当前老年代最大的连续空闲空间，那么就进行MinorGC，虽然此次MinorGC是有风险的。<br>如果以往存活对象的平均数大于当前老年代最大的连续空闲空间，那么就对老年代进行一次Full GC，通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。<br>这个过程就是<strong>分配担保</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;观察Java内存运行时区域的各个部分，其中程序计数器、Java虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://habitdiary.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机之Java内存区域与内存溢出异常</title>
    <link href="http://habitdiary.cn/2018/03/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://habitdiary.cn/2018/03/17/深入理解Java虚拟机之Java内存区域与内存溢出异常/</id>
    <published>2018-03-17T01:33:49.000Z</published>
    <updated>2018-03-22T14:32:32.342Z</updated>
    
    <content type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于从事C/C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”又是从事最基础工作的“劳动人民”——既拥有每一个对象的“所有权”，又担负着每<br>一个对象生命开始到终结的维护责任。<br>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。</p><h3 id="运行时数据区域-JVM内存模型"><a href="#运行时数据区域-JVM内存模型" class="headerlink" title="运行时数据区域(JVM内存模型)"></a>运行时数据区域(JVM内存模型)</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。<br>Java 虚拟机（Java Virtual Machine=JVM）的内存空间主要分为五个部分，分别是：<br>1、程序计数器<br>2、Java 虚拟机栈<br>3、本地方法栈<br>4、堆<br>5、方法区<br>如下图所示：<br><img src="/2018/03/17/深入理解Java虚拟机之Java内存区域与内存溢出异常/运行时数据区.png" alt="fail">  </p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><h4 id="什么是程序计数器？"><a href="#什么是程序计数器？" class="headerlink" title="什么是程序计数器？"></a>什么是程序计数器？</h4><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是<strong>当前线程</strong>所执行的<strong>字节码的行号指示器</strong>。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。  </p><h4 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h4><p>程序计数器有两个作用：<br>1、在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能<br>会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来<strong>选取下一条需要执行的字节码指令</strong>，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>2、由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。因此，每条线程都需要有一个独立的程序计数器来<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。各条线程之间计数器互不影响，独立存储，我们称这类内存区域为<strong>“线程私有”</strong>的内存。  </p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空(Undefined)。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><h4 id="什么是Java虚拟机栈？"><a href="#什么是Java虚拟机栈？" class="headerlink" title="什么是Java虚拟机栈？"></a>什么是Java虚拟机栈？</h4><p>与程序计数器一样,Java虚拟机栈(Java Virtual Machine Stacks)也是<strong>线程私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个<strong>栈帧(Stack Frame)</strong>用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  </p><h4 id="堆和栈浅谈"><a href="#堆和栈浅谈" class="headerlink" title="堆和栈浅谈"></a>堆和栈浅谈</h4><p>经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack)，这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。<br><strong>局部变量表</strong>存放了<strong>编译期可知的各种基本数据类型</strong>(boolean、byte、char、short、int、float、long、double)、<strong>对象引用</strong>(reference类型,它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和<strong>returnAddress类型</strong>(指向了一条字节码指令的地址)。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的<strong>局部变量空间是完全确定的</strong>,在方法运行期间<strong>不会改变局部变量表的大小</strong>。  </p><h4 id="可能出现的异常"><a href="#可能出现的异常" class="headerlink" title="可能出现的异常"></a>可能出现的异常</h4><p>Java 虚拟机栈会出现两种异常：<strong>StackOverFlowError</strong> 和 <strong>OutOfMemoryError</strong>。  </p><p><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小<strong>不允许动态扩展</strong>，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。<br><strong>OutOfMemoryError：</strong> 若Java虚拟机栈的内存大小<strong>允许动态扩展</strong>，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。<br><strong>StackOverFlowError和OutOfMemoryError的异同：</strong>StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。  </p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样,本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。  </p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h4><p>堆是用来存放对象的内存空间。 几乎所有的对象都存储在堆中。  </p><h3 id="堆的特点"><a href="#堆的特点" class="headerlink" title="堆的特点"></a>堆的特点</h3><p><strong>1、线程共享</strong><br>对于大多数应用来说,Java堆(Java Heap)是Java虚拟机所管理的内存中<strong>最大的一块</strong>。Java堆是<strong>被所有线程共享的一块内存区域</strong>，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例</strong>都在这里分配内存。  </p><p><strong>2、内存回收和内存分配的主要场所</strong><br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”(Garbage<br>Collected Heap)。<br>从<strong>内存回收</strong>的角度来看,由于现在收集器基本都采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为：<strong>新生代和老年代</strong>；新生代又分为<strong>Eden空间、Survivor1空间、Survivor2空间等</strong>。<br>从<strong>内存分配</strong>的角度来看，线程共享的Java堆中可能划分出多个<strong>线程私有的分配缓冲区</strong>(Thread Local Allocation Buffer，TLAB)。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。    </p><p><strong>3、内存空间的不连续性和可扩展性</strong><br><strong>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</strong>在实现时，既可以实现成固定大小的,也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。<strong>如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常。</strong>  </p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><h4 id="什么是方法区？"><a href="#什么是方法区？" class="headerlink" title="什么是方法区？"></a>什么是方法区？</h4><p>方法区(Method Area)与Java堆一样，是<strong>各个线程共享的内存区域</strong>,它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑分区，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。  </p><h4 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h4><p><strong>1、线程共享</strong><br>方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。<br><strong>2、永久代</strong><br>方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为永久代。<br><strong>3、内存回收效率低</strong><br>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区<br>域的内存回收目标主要是：<strong>针对常量池的回收和对类型的卸载</strong>。一般来说,这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。<br><strong>4、Java虚拟机规范对方法区的要求比较宽松</strong><br>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。  </p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>方法区用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。其中常量存储在运行时常量池中。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。<br>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的<strong>各种字面量和符号引用</strong>。<br><strong>当这个类被Java虚拟机加载后，class文件中的常量进入方法区的运行时常量池中。</strong>当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。<br><strong>运行时常量池和Class文件常量池的区别</strong><br>1、Java虚拟机对Class文件每一部分(自然也包括常量池)的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。<br>2、运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。<br>在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配<strong>堆外内存</strong>，然后通过一个存储在Java堆中的<strong>DirectByteBuffer</strong>对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，<strong>因为无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率</strong>。显然，本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存，肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。当内存不足就会抛出OutOfMemoryError异常。  </p><h3 id="各内存区域的总结"><a href="#各内存区域的总结" class="headerlink" title="各内存区域的总结"></a>各内存区域的总结</h3><p>1、Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。<br>2、Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。<br>3、堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。<br>4、程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法栈。并且他们的生命周期和所属的线程一样。 而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象(例如克隆、反序列化)通常仅仅是一个new关键字而已，而在虚拟机中，对象(文中讨论的对象限于普通Java对象，不包括数组和Class对象等)的创建又是怎样一个过程呢?  </p><p>当虚拟机遇到一条含有new的指令时，会进行一系列对象创建的操作：<br><strong>1）检查常量池中是否有即将要创建的这个对象所属的类的符号引用</strong></p><ul><li>若常量池中没有这个类的符号引用，说明这个类还没有被定义，抛出ClassNotFoundException</li><li>若常量池中有这个类的符号引用，则进行下一步工作  </li></ul><p><strong>2）进而检查这个符号引用所代表的类是否已经被JVM加载</strong></p><ul><li>若该类还没有被加载，就找该类的class文件，并加载进方法区  </li><li>若该类已经被JVM加载，则准备为对象分配内存  </li></ul><p><strong>3）根据方法区中该类的信息确定该类所需的内存大小</strong><br><strong>一个对象所需的内存大小是在这个对象所属类被定义完就能确定的</strong>，且一个类所生产的所有对象的内存大小是一样的。JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。  </p><p><strong>4）从堆中划分一块对应大小的内存空间给新的对象</strong><br>分配堆中内存有两种方式：  </p><ul><li>指针碰撞：如果JVM的垃圾收集器采用<strong>复制算法</strong>或<strong>标记-整理算法</strong>，那么堆中空闲内存是<strong>完整的区域</strong>，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。  </li><li>空闲列表：如果JVM的垃圾收集器采用<strong>标记-清除算法</strong>，那么堆中空闲区域和已使用区域<strong>交错</strong>，就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。  </li></ul><p>综上所述：JVM选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时,系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。  </p><p><strong>5）为对象中的成员变量赋上初始值(默认初始化)</strong></p><p><strong>6）设置对象头中的信息</strong></p><p><strong>7）调用对象的构造函数进行初始化</strong>  </p><p>此时，整个对象的创建过程就完成了。  </p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>一个对象从逻辑角度看，它由成员变量和成员函数构成，从物理角度来看，对象是存储在堆中的一串二进制数，这串二进制数的组织结构如下。<br>对象在内存中分为三个部分：<br>1、对象头<br>2、实例数据<br>3、对齐补充  </p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储<strong>对象自身的运行时数据</strong>，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br>对象头的另外一部分是<strong>类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>另外，如果对象是一个数组，那在对象头中还必须有一块用于记录<strong>数组长度</strong>的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。  </p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据就是成员变量的值，其中包含<strong>父类的成员变量和本类的成员变量</strong>。这部分的存储顺序会受到<strong>虚拟机分配策略参数(FieldsAllocationStyle)</strong>和字段在Java源码中<strong>定义顺序</strong>的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)，从分配策略中可以看出，<strong>相同宽度的字段总是被分配到一起。</strong>在满足这个前提条件的情况下，<strong>在父类中定义的变量会出现在子类之前</strong>。如果CompactFields参数值为true(默认为true)，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。  </p><h4 id="对齐补充"><a href="#对齐补充" class="headerlink" title="对齐补充"></a>对齐补充</h4><p>并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或者2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="访问对象的过程"><a href="#访问对象的过程" class="headerlink" title="访问对象的过程"></a>访问对象的过程</h3><p>我们知道，引用类型的变量中存放的是一个地址，那么根据地址类型的不同，对象有不同的访问方式：<br>1、句柄访问方式：堆中分配出一块叫做“句柄池”的内存空间，用于存放对象实例数据与类型数据各自的具体地址信息。引用类型的变量存放的是该对象在句柄池中的地址。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。<br><img src="/2018/03/17/深入理解Java虚拟机之Java内存区域与内存溢出异常/通过句柄访问对象.png" alt="fail">  </p><p>2、直接指针访问方式：引用类型的变量直接存放<strong>对象的地址</strong>，从而不需要句柄池，通过引用能够直接访问对象。<strong>但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。</strong><br><img src="/2018/03/17/深入理解Java虚拟机之Java内存区域与内存溢出异常/通过直接指针访问对象.png" alt="fail">    </p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是<strong>reference中存储的是稳定的句柄地址</strong>，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>使用直接指针访问方式的最大好处就是<strong>速度更快</strong>，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。   </p><p>HotSpot采用<strong>直接指针方式</strong>访问对象，因为它只需一次寻址操作，从而性能比句柄访问方式快一倍。但它需要额外的策略存储对象在方法区中类信息的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。&lt;/p&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;对于从事C/C
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://habitdiary.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之并发</title>
    <link href="http://habitdiary.cn/2018/02/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%B9%B6%E5%8F%91/"/>
    <id>http://habitdiary.cn/2018/02/01/Java学习总结之并发/</id>
    <published>2018-02-01T14:54:54.000Z</published>
    <updated>2018-02-05T13:34:50.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>操作系统的多任务指的是在同一刻运行多个程序的能力。例如，在编辑或下载邮件的同时可以打印文件。今天，人们很可能有单台拥有多个 CPU 的计算机, 但是 , 并发执行的进程数目并不是由 CPU 数目制约的。操作系统将 CPU 的时间片分配给每一个进程，给人并行处理的感觉。  </p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p><strong>并行：</strong>多个cpu或者多台机器同时执行一段处理逻辑，是真正的同时运行。<br><strong>并发：</strong>如果只有一个CPU，如何做到多个进程同时运行呢？我们先来看操作系统的一些相关概念。大部分操作系统(如Windows、Linux)的任务调度是采用<strong>时间片轮转的抢占式调度方式</strong>，即把CPU的执行时间分为很多小块，每一小块的时间相等且固定，我们把任务执行的这一小块时间叫做时间片。任务正在执行时的状态叫运行状态，一个任务执行一小段时间后会被强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来，每个任务在CPU的调度下轮流执行。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。<br>下面是时间片以及CPU轮转调度的示意图：<br><img src="/2018/02/01/Java学习总结之并发/CPU调度.png" alt="fail"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由<strong>程序、数据集合和进程控制块</strong>三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。  </p><p><strong>进程具有的特征：</strong><br><strong>动态性：</strong>进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br><strong>并发性：</strong>任何进程都可以同其他进程一起并发执行；<br><strong>独立性：</strong>进程是系统进行资源分配和调度的一个独立单位；<br><strong>结构性：</strong>进程由程序、数据和进程控制块三部分组成。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。<br>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。<strong>简言之，线程是比进程还要小的运行单位，可以看作是子程序，一个进程包含一个或多个线程。</strong>  </p><h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>JVM调用main()所产生的线程。</p><h4 id="当前线程"><a href="#当前线程" class="headerlink" title="当前线程"></a>当前线程</h4><p>当前正在运行的进程，可通过Thread.currentThread()来获取当前线程。  </p><h4 id="后台线程-守护线程"><a href="#后台线程-守护线程" class="headerlink" title="后台线程(守护线程)"></a>后台线程(守护线程)</h4><p>指为其他线程提供服务的线程，也称为守护线程。比如JVM的垃圾回收、内存管理等线程都是守护线程。当所有前台线程(用户线程)都结束，程序只剩下后台线程的时候，JVM就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。可以通过isDaemon()和setDaemon()方法来判断一个线程是否为后台线程和设置一个线程为后台线程。<br>守护线程有时会被初学者错误地使用，他们不打算考虑关机(shutdown)动作。但这是很危险的。守护线程应该永远不去访问固有资源, 如文件、数据库, 因为它会在任何时候甚至在一个操作的中间发生中断。比如一个守护线程在操作资源的时候，如果所有用户线程都退出了，JVM将直接杀死该守护线程而无法执行finally块中的关闭资源的语句。  </p><p>来看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</div><div class="line">            System.out.println(<span class="string">"我是非守护线程"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        threadStart();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadStart</span><span class="params">()</span></span>&#123;</div><div class="line">        DemoThread dt = <span class="keyword">new</span> DemoThread();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(dt);</div><div class="line">        thread.setDaemon(<span class="keyword">true</span>);</div><div class="line">         </div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果：<br>1、当直接启动时，不会打印出内容<br>2、当去掉thread.setDaemon(true)时，会打印出“我是非守护线程”。</p><p>原因分析：当thread被设置为守护线程时，主线程是前台线程，执行完之后就直接结束，JVM直接杀死thread，这个守护线程中的内容就不会继续执行下去；当去掉那一行时，thread就默认为前台线程，jvm会等所有前台线程执行完之后才会结束，thread线程就打印出内容  </p><h4 id="前台线程-用户线程、非守护线程"><a href="#前台线程-用户线程、非守护线程" class="headerlink" title="前台线程(用户线程、非守护线程)"></a>前台线程(用户线程、非守护线程)</h4><p>是指接受后台线程服务的线程，其实前台后台线程是联系在一起。由前台线程创建的线程默认也是前台线程。</p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>只包含一个线程的程序，即主线程(主方法所在线程)。  </p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>可以同时运行一个以上线程的程序。在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制。当选择下一个线程时，操作系统考虑线程的优先级。  </p><p>下面是单线程和多线程的关系示意图：<br><img src="/2018/02/01/Java学习总结之并发/单线程和多线程.png" alt="fail"></p><h3 id="进程和线程的区别与关系"><a href="#进程和线程的区别与关系" class="headerlink" title="进程和线程的区别与关系"></a>进程和线程的区别与关系</h3><p>1.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆、栈、程序计数器PC等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见。<strong>共享内存空间使线程之间的通信比进程之间的通信更有效、更容易，但也更具风险。</strong><br>2.创建一个新进程或进程之间的切换会有较大的开销，线程则更”轻量级”，创建、撤销、切换一个线程比启动一个新进程的开销要小得多。<br>3.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。<br>4.进程是操作系统进行资源分配和调度的最小单位，线程是程序执行的最小单位。    </p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul><li><strong>新建状态:</strong> 使用 new 关键字创建一个 Thread 类或其子类的线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序调用它的start()方法启动这个线程，随后线程便进入了就绪状态。</li><li><strong>就绪状态(可运行状态):</strong> 当线程对象调用了start()方法之后，该线程并不是立即开始运行，而是进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度，获取CPU使用权后才进入运行状态。</li><li><strong>运行状态:</strong> 如果就绪状态的线程获取 CPU 使用权，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。处于运行状态的线程如果CPU的时间片用完或者调用了yield()方法都会转化为就绪状态。而如果线程调用了sleep()方法、join()方法、wait()方法、获取synchronized同步锁失败或发出了I/O请求<strong>(比如等待用户输入)</strong>，线程都会进入阻塞状态。</li><li><strong>阻塞状态:</strong> 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态(注意阻塞状态无法直接转入运行状态，阻塞解除只能转入就绪状态！)。可以分为三种：<br><strong>1)等待阻塞：</strong>运行状态中的线程执行 wait() 方法，使线程进入到<strong>等待队列</strong>，即进入等待阻塞状态(wait()会释放线程持有的锁)，当调用notice()或noticeAll()方法线程重新转入就绪状态。<br><strong>2)同步阻塞：</strong>也称<strong>锁池状态</strong>，线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)进入同步阻塞状态，当其他线程释放该锁，并且线程调度器允许本线程持有它的时候，线程重新转入就绪状态。<br><strong>3)其他阻塞：</strong>通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 请求完毕<strong>(比如用户输入完毕)</strong>，线程重新转入就绪状态。</li><li><strong>死亡状态(终止状态):</strong><br>一个线程执行完毕或者异常终止，该线程就切换到终止状态。其他四个状态都可以通过调用stop()方法来进入死亡状态，但stop()方法已经过时了，不建议使用。</li></ul><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>即前面提到的线程的五个状态之间的转化，可以通过调用Thread类的方法来影响线程的生命周期。  </p><p><strong>下面是线程生命周期的示意图：</strong><br><img src="/2018/02/01/Java学习总结之并发/线程的生命周期.png" alt="fail">  </p><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Thread类是一个线程类，位于java.lang包下。它实现了Runnable接口。<br>1、构造方法<br><img src="/2018/02/01/Java学习总结之并发/Thread类构造方法.png" alt="fail"><br>2、常量<br><img src="/2018/02/01/Java学习总结之并发/Thread类常量.png" alt="fail"><br>3、常见方法<br><img src="/2018/02/01/Java学习总结之并发/Thread方法1.png" alt="fail"><br><img src="/2018/02/01/Java学习总结之并发/Thread方法2.png" alt="fail"><br>更多见大牛博客<a href="http://blog.csdn.net/u014290221/article/details/51436710" target="_blank" rel="external">JAVA线程-Thread类的方法</a>  </p><h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><ul><li>只有一个方法run();</li><li>Runnable是Java中用于实现线程的接口  </li><li>任何实现线程功能的类都必须实现该接口</li></ul><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>创建线程主要有三种方式：<br><strong>一、继承Thread类创建线程类</strong><br>继承Thread类的方法尽管被列为一种多线程实现方式，但Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。  </p><p><strong>下面是使用这种方法创建线程的具体步骤：</strong><br>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>（2）创建Thread子类的实例，即创建了线程对象。<br>（3）调用线程对象的start()方法来启动该线程。</p><p>来看下面的一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.thread;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(getName()+<span class="string">"该线程正在执行！"</span>);</div><div class="line">        <span class="comment">//通过getName()获取线程名</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"主线程1"</span>);</div><div class="line">MyThread mt=<span class="keyword">new</span> MyThread();</div><div class="line">mt.start();<span class="comment">//启动线程</span></div><div class="line">System.out.println(<span class="string">"主线程2"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上述代码中，我们就通过创建一个继承自Thread类的子类MyThread的对象来创建了一个线程mt，此时该程序中共包含3个线程，一个是mt，一个是主方法所在的主线程，一个是垃圾收集器线程。三条输出语句的打印次序是随机的，这是因为某个线程何时获得CPU的使用权是CPU轮转调度的结果。<br>值得注意的是，<strong>在Java中，每次程序运行至少启动2个线程。一个是主线程，一个是垃圾收集器线程。因为当执行一个程序的时候，实际上都会启动一个JVM，启动一个JVM就是在操作系统中启动了一个进程。</strong><br>我们通过下面的循环输出语句可以令这种线程间的时间片轮转调度更明显：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.thread1;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</div><div class="line">System.out.println(getName()+<span class="string">"正在运行"</span>+i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">MyThread mt1=<span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</div><div class="line">MyThread mt2=<span class="keyword">new</span> MyThread(<span class="string">"线程2"</span>);</div><div class="line">mt1.start();</div><div class="line">mt2.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="/2018/02/01/Java学习总结之并发/运行结果.png" alt="fail"><br>可以看到线程的打印语句随机交替出现，这就证明了线程获得CPU使用权是随机的。<br><strong>注意：</strong><br>1、不要直接调用Thread类或Runnable对象的run方法，如果直接调用run方法，只会执行同一个线程中的任务，而不会启动新的线程。启动线程的唯一方法就是通过Thread类的start()实例方法，这个方法将创建一个执行run方法的新线程。<br>2、不要重复启动同一个线程，比如重复两次调用mt.start(),程序会抛出一个IllegalThreadStateException异常。<br>3、这种继承Thread类创建线程类的方法已不再推荐，应该将要并行运行的任务与运行机制解耦合。如果有很多个任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池来解决这个问题，有关内容参看博客后面的内容。  </p><p><strong>二、通过实现Runnable接口创建线程类</strong><br>我们使用这种方法创建线程的频率更高。<br><strong>提供这种方式的原因有如下：</strong><br>1.Java不支持多继承，如果自定义类已经继承另一个类，就无法继承Thread，此时，必须实现Runnable接口。<br>2.我们有时不打算重写Thread类的其他方法。  </p><p><strong>下面是使用这种方法创建线程的具体步骤：</strong><br>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>（2）创建 Runnable实现类的实例，并依此实例作为Thread的构造方法Thread(Runnable target)的target参数来创建Thread对象，该Thread对象才是真正的线程对象。<br>（3）调用线程对象的start()方法来启动该线程。  </p><p>来看下面一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.runnable;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (i &lt;= <span class="number">10</span>)</div><div class="line">System.out.println(Thread.currentThread().getName()</div><div class="line">            +<span class="string">"正在运行"</span> + (i++)); </div><div class="line">            <span class="comment">/*无法直接调用getName()方法，而是要通过</span></div><div class="line"><span class="comment">            Thread.currentThread()先获取当前线程的</span></div><div class="line"><span class="comment">            对象，再在其上调用getName()方法*/</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">PrintRunnable pr = <span class="keyword">new</span> PrintRunnable();</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(pr);</div><div class="line">t1.start();</div><div class="line"><span class="comment">//PrintRunnable pr1 = new PrintRunnable();</span></div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(pr);</div><div class="line">t2.start();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这段代码中，t1和t2共享PrintRunnable对象的成员变量i，所以语句被两个线程一共交替打印了十次。如果两个线程的pr是不同的PrintRunnable对象，则两个线程交替着各打印十次语句。这就是多个线程共享资源的简单例子。</p><p><strong>注意：</strong>由于Runnable只有一个抽象方法，是一个函数式接口，所以我们也可以通过<strong>匿名内部类或lambda表达式</strong>的方式来简化上述创建线程的步骤。  </p><p><strong>三、通过Callable和Future创建线程</strong>  </p><p><strong>下面是使用这种方法创建线程的具体步骤：</strong><br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值，Callable接口是一个泛型接口。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值，它是一个泛型类。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。  </p><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> cn.habitdiary.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();</div><div class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</div><div class="line">System.out.println(Thread.currentThread().getName()+</div><div class="line">            <span class="string">" 的循环变量i的值"</span>+i);</div><div class="line"><span class="keyword">if</span>(i==<span class="number">20</span>)&#123;</div><div class="line"><span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());</div><div class="line">&#125;</div><div class="line">        <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; </div><div class="line">        <span class="keyword">catch</span> (ExecutionException e)&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()</div><div class="line">        +<span class="string">" "</span>+i);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>四、创建线程的三种方式的对比</strong>  </p><p><strong>1)采用实现Runnable、Callable接口的方式创建多线程</strong><br><strong>优势：</strong><br>1.线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>2.在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>3.线程池只能放入实现Runable或callable类的线程，不能直接放入继承Thread的类。</p><p><strong>劣势：</strong>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。  </p><p><strong>2)使用继承Thread类的方式创建多线程</strong><br><strong>优势：</strong>编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br><strong>劣势：</strong>线程类已经继承了Thread类，所以不能再继承其他父类。且继承Thread不适合线程间进行资源共享。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="1、线程的优先级"><a href="#1、线程的优先级" class="headerlink" title="1、线程的优先级"></a>1、线程的优先级</h4><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。JVM提供了10个线程优先级，即1到10的整数，超出这个范围会抛出异常，但它们与常见的操作系统都不能很好的映射，比如Windows只有7个优先级。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类里三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。主线程的优先级为5。默认情况下，一个线程继承它的父线程的优先级。<br>Thread类中提供了三个常量来表示优先级，分别为：<br>Thread.MIN_PRIORITY(等价于1)<br>Thread.MAX_PRIORITY(等价于10)<br>Thread.NORM_PRIORITY(等价于5)<br>每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于操作系统环境和CPU的调度方式的，不能保证线程执行的顺序，即优先级高的线程呢不一定先执行。例如虽然设置了优先级，但启动线程start()有先后顺序等影响了线程的执行顺序。初级程序员常常过度使用线程优先级，不要将程序构建为功能的正确性依赖于优先级。<br>如果确实要使用优先级，应该避免初学者常犯的一个错误。如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时,首先会在具有高优先级的线程中进行选择,尽管这样会使低优先级的线程完全饿死。  </p><p>Thread类提供了改变和获取某线程优先级的方法<br><img src="/2018/02/01/Java学习总结之并发/优先级.png" alt="fail">  </p><h4 id="2、线程休眠"><a href="#2、线程休眠" class="headerlink" title="2、线程休眠"></a>2、线程休眠</h4><p>线程休眠是使线程让出CPU使用权的最简单做法，某线程休眠的时候，会将CPU交给其他线程，以便轮换执行，而它自身进入阻塞状态，休眠一定时间后，线程会苏醒，进入就绪状态等待执行。线程的休眠方法是<code>Thread.sleep(long millis)</code>和<code>Thread.sleep(long millis,int nanos)</code>，均为静态方法，millis参数设定睡眠的时间，以毫秒为单位。<strong>调用sleep休眠的哪个线程呢？在哪个线程中调用sleep，哪个线程就休眠。</strong><br>来看一个例子，线程1休眠后，让出CPU，线程2执行，线程2执行完后，线程2休眠，让出CPU供线程1执行(此时线程1已经休眠结束，在就绪状态)，如此循环执行，直到结束。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> Thread;</div><div class="line">  </div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">          Thread t1=<span class="keyword">new</span> MyThread_1();</div><div class="line">          Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable1());</div><div class="line">          t1.start();</div><div class="line">          t2.start();</div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread_1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程1第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             <span class="keyword">try</span>&#123;</div><div class="line">                 Thread.sleep(<span class="number">500</span>);</div><div class="line">             &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程2第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             <span class="keyword">try</span>&#123;</div><div class="line">                 Thread.sleep(<span class="number">500</span>);</div><div class="line">             &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                 e.printStackTrace();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>结果如下：<br><img src="/2018/02/01/Java学习总结之并发/Sleep.png" alt="fail"></p><p><strong>注意：</strong>调用sleep()方法时必须处理可能抛出的InterruptedException，一般用try-catch块即可。  </p><p><strong>sleep方法的应用场景：</strong>可以实现计时器效果或定期刷新数据的效果，但是由于线程在苏醒之后不会直接进入运行状态，而是进入就绪状态等待获取CPU使用权，所以同一线程两次执行的时间间隔会略大于休眠时间，不能保证精确定时。  </p><p><strong>我是彩蛋:</strong> 了解了线程休眠，我们就可以写出传说中的睡眠排序了hhh，参考大牛博客<a href="https://www.jianshu.com/p/4f526ea40df4" target="_blank" rel="external">排序算法–睡眠排序、面条排序、猴子排序 (非常严肃)</a></p><h4 id="3、线程加入"><a href="#3、线程加入" class="headerlink" title="3、线程加入"></a>3、线程加入</h4><p>join方法，重载形式如下：<br><img src="/2018/02/01/Java学习总结之并发/join.png" alt="fail"><br>在当前线程中调用要加入的线程的join()方法，则当前线程转入阻塞状态，转而执行新加入的线程，即新加入的线程被优先执行，抢占了CPU资源，直到该进程运行结束(如果调用带参的join方法，则超出时限该进程就会让出CPU)，当前线程再由阻塞转为就绪状态。可以认为join方法的作用是父线程等待子线程执行完成后再执行，换句话说是将异步执行的线程合并为同步执行的线程。  </p><p>下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.join;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i++)</div><div class="line">System.out.println(getName()+<span class="string">"正在执行"</span>+i+<span class="string">"次！"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">MyThread mt=<span class="keyword">new</span> MyThread();</div><div class="line">mt.start();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">mt.join(<span class="number">1</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)&#123;</div><div class="line">System.out.println(<span class="string">"主线程运行第"</span>+i+<span class="string">"次！"</span>);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"主线程运行结束！"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>join方法也会抛出InterruptedException，要进行异常处理。  </p><h4 id="4、线程让步"><a href="#4、线程让步" class="headerlink" title="4、线程让步"></a>4、线程让步</h4><p>让步使用Thread.yield()方法，yield方法为静态方法，功能是让当前运行线程回到可运行状态，以允许具有<strong>相同优先级的其他线程</strong>获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。让出的时间和让出给哪个线程都是不可设定的，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了<strong>同等优先级</strong>的其他线程。<br>例子：一个线程先让步，让另一个线程先执行，然后再执行该线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.thread;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">          Thread t1=<span class="keyword">new</span> MyThread();</div><div class="line">          Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</div><div class="line">          t2.start();</div><div class="line">          t1.start();</div><div class="line">          </div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程1第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">             System.out.println(<span class="string">"线程2第"</span>+i+<span class="string">"次执行！"</span>);</div><div class="line">             Thread.yield();</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p><strong>sleep()和yield()的区别</strong><br>    sleep()使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>    sleep 方法使当前运行中的线程休眠一段时间，进入阻塞状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。<br>       另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()方法执行时，当前线程仍处在就绪状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep() 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。   </p><h4 id="5、未捕获异常处理器"><a href="#5、未捕获异常处理器" class="headerlink" title="5、未捕获异常处理器"></a>5、未捕获异常处理器</h4><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>在大多数实际的多线程应用中, 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象, 并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？可以想象,线程彼此踩了对方的脚。根据各线程访问数据的次序，可能会产生讹误的对象。这样一个情况通常称为<strong>竞争条件(race condition)</strong>。  </p><p>我们先来看一个银行存取款的例子。  </p><p><strong>Bank类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.bank;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> String account;<span class="comment">// 账号</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> balance;<span class="comment">// 账户余额</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(String account, <span class="keyword">int</span> balance)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.account = account;</div><div class="line"><span class="keyword">this</span>.balance = balance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> account;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(String account)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.account = account;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> balance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.balance = balance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"Bank [账号："</span> + account + <span class="string">", 余额："</span> </div><div class="line">        + balance + <span class="string">"]"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 存款</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// 获取当前的账号余额</span></div><div class="line"><span class="keyword">int</span> balance = getBalance();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 修改余额，存100元</span></div><div class="line">balance += <span class="number">100</span>;</div><div class="line"><span class="comment">// 修改账户余额</span></div><div class="line">setBalance(balance);</div><div class="line"><span class="comment">// 输出存款后的账户余额</span></div><div class="line">System.out.println(<span class="string">"存款后的账户余额为："</span> + balance);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawAccount</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">/* 在不同的位置处添加sleep方法来模拟方法在执行过程因为</span></div><div class="line"><span class="comment">           时间片轮转而发生暂停的情况*/</span></div><div class="line"></div><div class="line"><span class="comment">// 获得当前的帐户余额</span></div><div class="line"><span class="keyword">int</span> balance = getBalance();</div><div class="line"><span class="comment">// 修改余额，取200</span></div><div class="line">balance = balance - <span class="number">200</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 修改帐户余额</span></div><div class="line">setBalance(balance);</div><div class="line">System.out.println(<span class="string">"取款后的帐户余额："</span> + balance);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>SaveAccount类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.bank;</div><div class="line"><span class="comment">//存款</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveAccount</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Bank bank;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SaveAccount</span><span class="params">(Bank bank)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.bank=bank;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">bank.saveAccount();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>DrawAccount类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.bank;</div><div class="line"><span class="comment">//取款</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawAccount</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Bank bank;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">DrawAccount</span><span class="params">(Bank bank)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.bank=bank;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">bank.drawAccount();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>Test类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.bank;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 创建帐户，给定余额为1000</span></div><div class="line">Bank bank=<span class="keyword">new</span> Bank(<span class="string">"1001"</span>,<span class="number">1000</span>);</div><div class="line"><span class="comment">//创建线程对象</span></div><div class="line">SaveAccount sa=<span class="keyword">new</span> SaveAccount(bank);</div><div class="line">DrawAccount da=<span class="keyword">new</span> DrawAccount(bank);</div><div class="line">Thread save=<span class="keyword">new</span> Thread(sa);</div><div class="line">Thread draw=<span class="keyword">new</span> Thread(da);</div><div class="line">save.start();</div><div class="line">draw.start();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">draw.join();</div><div class="line">save.join();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(bank);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们把程序设计为账户初始金额1000元，存100元，取200元，余额应该为900元。但输出结果如下：<br><img src="/2018/02/01/Java学习总结之并发/Bank.png" alt="fail">  </p><p>这样的银行系统给人极不可靠的感觉，我们来分析一下原因：由于存取款方法都对同一个数据balance进行操作，很可能在执行存款方法的SaveAccount线程运行到<code>balance += 100</code>时被剥夺了CPU使用权，所以还没来得及修改账户余额，而其中的balance局部变量为1100。此时转入执行取款方法的DrawAccount线程，由于账户余额未被修改还是1000，当这个线程运行到<code>balance = balance + 200;</code>时，balance局部变量为800，此时线程可能又转入SaveAccount线程，继续执行setBalance方法把账户余额设置为1100元并打印输出，之后又回到DrawAccount把账户余额设置为800元再打印输出，于是造成了混乱。<br>混乱的可能还不只如此，这里我们引入一个<strong>原子性</strong>的概念。在Java中，对基本数据类型的变量的<strong>读取和简单赋值操作</strong>是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>比如下面4条赋值语句：<br>1）x = 10  　　　　2）x = y  　　　3）x++ 　　　4）x = x + 2<br><strong>只有1)是原子性操作，2)要先读取y的值并放入寄存器，再赋值给内存中的x，3)和4)则都要先读取x的值。</strong><br>所以一条非原子性的Java语句由多条指令组成，它在执行过程中的任何一个时间点都可能被其他线程打断。<br>所以上述问题的发生的原因就在于存取款方法不是原子性的，它们在执行的过程中可能被其他线程在随机时间点打断，而这些方法操作的又是同一个数据，所以造成了数据更新延迟、更新的数据被覆盖等讹误。</p><p>为了解决这一问题达到线程同步的目的。我们需要引入<strong>锁</strong>。多线程的锁，其实本质上就是给一块内存空间的访问添加访问权限，因为Java中是没有办法直接对某一块内存进行操作的，又因为Java是面向对象的语言，一切皆对象，所以具体的表现就是某一个对象承担锁的功能，每一个对象都可以是一个锁。现在的Java语言中，提供了2种锁，一种是语言特性提供的内置锁，还有一种是java.util.concurrent.locks 包中的显式锁。我们来一一介绍： </p><h4 id="1、内置锁"><a href="#1、内置锁" class="headerlink" title="1、内置锁"></a>1、内置锁</h4><p>内置锁是用语言特性实现的锁，即使用 synchronized 关键字，又叫同步锁、互斥锁，Java的所有对象都有一个同步锁，甚至每个类的class对象也对应一个同步锁。<br>我们先引入一个临界区的概念，<strong>临界区是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行</strong>。<br>Java提供了同步机制。当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已有其他线程进入临界区。如果没有其他线程进入临界区，它就可以进入临界区，即获得了该同步锁；如果已有线程进入了临界区，即同步锁被其他线程占用，它就被同步机制挂起，直到进入的线程离开这个临界区并释放锁，JVM允许它持有锁才能进入临界区。如果在等待进入临界区的线程不止一个，JVM会随机选择其中的一个，其余的将继续等待。<br><strong>使用synchronized内置锁的好处在于，无论线程是执行完临界区代码正常退出还是抛出异常，JVM都会自动释放锁。</strong>   </p><p>synchronized 修饰的对象包括以下几种：  </p><h4 id="修饰一个代码块"><a href="#修饰一个代码块" class="headerlink" title="修饰一个代码块"></a>修饰一个代码块</h4><p>被修饰的代码块称为<strong>同步代码块</strong>，其作用的范围(临界区)是大括号{}括起来的代码，锁住的对象是括号里的obj对象。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(obj)  <span class="comment">/*obj是同步锁锁住的对象,如果是this，</span></div><div class="line"><span class="comment">                        就表示锁住当前对象*/</span></div><div class="line">   &#123;</div><div class="line">       System.out.println(<span class="string">"我是同步代码块"</span>);</div><div class="line">       <span class="keyword">try</span></div><div class="line">       &#123;</div><div class="line">           Thread.sleep(<span class="number">500</span>);</div><div class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">       &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><h4 id="修饰一个非静态方法"><a href="#修饰一个非静态方法" class="headerlink" title="修饰一个非静态方法"></a>修饰一个非静态方法</h4><p>被修饰的方法称为同步方法，临界区是整个方法，锁住的对象是调用这个方法的对象。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span> </span></div><div class="line"><span class="function"></span>&#123; </div><div class="line">System.out.println(<span class="string">"我是同步方法1"</span>); </div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123; </div><div class="line">Thread.sleep(<span class="number">500</span>); </div><div class="line">&#125; </div><div class="line">    <span class="keyword">catch</span> (InterruptedException e) </div><div class="line">&#123; </div><div class="line">e.printStackTrace(); </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面使用同步代码块的写法是等价的，临界区是整个方法，锁住的也是调用方法的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span> </span></div><div class="line"><span class="function"></span>&#123; </div><div class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">    System.out.println(<span class="string">"我是同步方法2"</span>); </div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123; </div><div class="line">Thread.sleep(<span class="number">500</span>); </div><div class="line">&#125; </div><div class="line">    <span class="keyword">catch</span> (InterruptedException e) </div><div class="line">&#123; </div><div class="line">e.printStackTrace(); </div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line">&#125;在</div></pre></td></tr></table></figure></p><h4 id="修改一个类"><a href="#修改一个类" class="headerlink" title="修改一个类"></a>修改一个类</h4><p>其临界区是synchronized后面大括号括起来的部分，作用的对象是这个类的所有对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(Test.class)&#123;</div><div class="line">       System.out.println(＂我修饰Test类＂);</div><div class="line">       <span class="keyword">try</span></div><div class="line"> &#123;</div><div class="line">           Thread.sleep(<span class="number">500</span>);</div><div class="line">       &#125; </div><div class="line">       <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">       &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="修饰一个静态方法"><a href="#修饰一个静态方法" class="headerlink" title="修饰一个静态方法"></a>修饰一个静态方法</h4><p>其临界区是整个静态方法，锁住的对象是这个类的所有对象。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span></span>&#123; </div><div class="line">System.out.println(<span class="string">"我修饰静态方法"</span>); </div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123; </div><div class="line">Thread.sleep(<span class="number">500</span>); </div><div class="line">&#125; </div><div class="line">    <span class="keyword">catch</span> (InterruptedException e) </div><div class="line">&#123; </div><div class="line">e.printStackTrace(); </div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面使用同步代码块的写法是等价的，临界区是整个静态方法，锁住的对象也是这个类的所有对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (Test.class)</div><div class="line">    &#123;</div><div class="line">        System.out.println(＂我修饰静态方法＂);</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</div><div class="line">        &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="对象锁-方法锁-和类锁"><a href="#对象锁-方法锁-和类锁" class="headerlink" title="对象锁(方法锁)和类锁"></a>对象锁(方法锁)和类锁</h4><p>根据锁住的是对象还是类，我们把同步锁分为<strong>对象锁(方法锁)和类锁。</strong><br>对象锁就是方法锁，是用于非静态方法或者一个对象实例上的;类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。<br><strong>也就是说，对象锁只是锁住了一个对象的代码段，防止多个线程同时执行同一对象的同一代码段，但多个线程访问不同对象的这一代码段不受干扰。而类锁则可以锁住同一个类的所有实例对象，它起到了全局锁的作用，真正锁住了代码段。</strong></p><p>例子见大牛博客：<a href="https://www.cnblogs.com/QQParadise/articles/5059824.html" target="_blank" rel="external">synchronized锁住的是代码还是对象</a></p><p><strong>注意：</strong> 我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。原因是基于以上的思想，锁的代码段过长，其他线程等待进入临界区的时间会很长。</p><p><strong>学习了synchronized关键字，我们就可以解决银行转账的讹误了！只要用给setAccount()和drawAccount()加锁即可。</strong></p><p><strong>使用内置锁的缺点：</strong>内置锁在采取的是无限等待的策略，一旦开始等待，就既不能中断也不能取消，容易产生饥饿与死锁的问题。在线程调用notify方法时，会随机选择相应对象的等待队列的一个线程将其唤醒，而不是按照FIFO(先入先出)的方式，如果有强烈的公平性要求，就无法满足。  </p><h4 id="2、显式锁"><a href="#2、显式锁" class="headerlink" title="2、显式锁"></a>2、显式锁</h4><p>java.util.concurrent.locks 包中提供了可重入锁(ReentrantLock)，是一种递归无阻塞的同步机制。它是一种显式锁，需要显式进行 lock 以及 unlock 操作。  </p><p>用 ReentrantLock 保护代码块的基本结构如下 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">myLock.lock() ; <span class="comment">// myLock是一个ReentrantLock对象</span></div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//被同步的临界区</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">myLock.unlock(); <span class="comment">//即使异常抛出也要关闭锁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这一结构确保任何时刻只有一个线程进人临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞，直到第一个线程释放锁对象。  </p><p><strong>可重入锁：</strong>又称递归锁，可重入是指一个线程可以重复获得已持有的锁。即一个线程获得了某个对象的锁，此时这个对象还没有释放，当这个线程再次想获得这个对象的锁的时候还是可以获得的。<strong>synchronized和ReentrantLock都是可重入的。</strong><br>应用场景：<br>1、递归调用一个带锁的方法<br>2、在一个带锁的方法里嵌套调用另一个需要同一个对象的锁的方法。<br><strong>如果锁是不可重入的，那么内部方法将无法获得外部方法的锁，一直等待外部方法释放该锁，于是造成了死锁。</strong> </p><p>每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计加1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个ReentrantLock锁住的方法或synchronized方法/块时，计数器会递减，直到计数器为0才释放该锁。  </p><p><strong>注意：</strong><br>1.把解锁操作置于 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。<br>2.如果使用锁，就不能使用带资源的 try 语句。首先，解锁方法名不是 close。不过，即使将它重命名，带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享的那个变量 (而不是新变量)。</p><h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>通常, 线程进人临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程，我们在条件对象上可以调用Condition类的await(),signal(),signalAll()方法，它们的功能分别对应Object类的wait(),notify(),notifyAll()方法，但前者一般和ReentrantLock配合使用，后者和synchronized块配合使用。我们来介绍Java 库中条件对象的实现。<br>下面是条件对象相关的API<br><img src="/2018/02/01/Java学习总结之并发/条件对象.png" alt="fail">  </p><p>我们来看一个满足账户余额充足条件才能取款的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Condition sufficientFunds; <span class="comment">//条件对象</span></div><div class="line">    <span class="keyword">private</span> Lock bankLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//锁对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;<span class="comment">//账户余额</span></div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    ...</div><div class="line">        sufficientFunds = bankLock.newCondition();</div><div class="line">        <span class="comment">//获得该锁的条件对象</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawAccount</span><span class="params">(<span class="keyword">int</span> amount)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    bankLock.lock();</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">        <span class="keyword">while</span>(balance &lt; amount)</div><div class="line">            sufficientFunds.await();</div><div class="line">            <span class="comment">//saveAccount</span></div><div class="line">            ...</div><div class="line">            sufficientFunds.signalAll();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">finally</span></div><div class="line">         &#123;</div><div class="line">         bankLock.unlock();</div><div class="line">         &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>我们一般使用类似结构检测条件是否满足：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!(ok to proceed))</div><div class="line">condition.await();</div></pre></td></tr></table></figure></p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>当线程的 run 方法执行方法体中最后一条语句后，或者出现了在方法中没有捕获的异常时, 线程将终止。在 Java 的早期版本中，还有一个 stop 方法, 其他线程可以调用它终止线程。但是，这个方法现在已经被弃用了。<br>没有可以强制线程终止的方法。然而,interrupt方法可以用来<strong>请求终止线程</strong>。<br>当对一个线程调用 interrupt 方法时, 线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该<strong>不时地检査这个标志</strong>，以判断线程是否被中断。要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用 islnterrupted 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> more work</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是，如果线程被阻塞，就无法检测中断状态。这是产生 InterruptedException 异常的地方。当在一个被阻塞的线程 (调用 sleep 或 wait)上调用 interrupt 方法时, 阻塞调用将会被 InterruptedException 异常中断。<br>没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。<strong>但是, 更普遍的情况是, 线程将简单地将中断作为一个终止的请求。</strong>这种线程的 run 方法具有如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Runnable r= () -&gt; &#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted &amp;&amp; </div><div class="line">    more work to <span class="keyword">do</span>)&#123;</div><div class="line"><span class="keyword">do</span> more work</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"><span class="comment">// thread was interruputed during sleep or wait</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span>&#123;</div><div class="line"> cleanup,<span class="keyword">if</span> required</div><div class="line">    &#125;<span class="comment">// exiting the run method terminates the thread</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>如果在每次工作迭代之后都调用 sleep 方法 (或者其他的可阻塞方法，isInterrupted 检测既没有必要也没有用处。如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并拋出InterruptedException。因此,如果你的循环调用sleep,不要检测中断状态。相反,要如下所示捕获InterruptedException异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Runnable r= () -&gt; &#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    ...</div><div class="line"><span class="keyword">while</span> (more work to <span class="keyword">do</span>)&#123;</div><div class="line"><span class="keyword">do</span> more work</div><div class="line">                Thread.sleep(delay);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"><span class="comment">// thread was interruputed during sleep or wait</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span>&#123;</div><div class="line"> cleanup,<span class="keyword">if</span> required</div><div class="line">    &#125;<span class="comment">// exiting the run method terminates the thread</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong>有两个非常类似的方法, interrupted 和isInterrupted。Interrupted 方法是一个静态方法，它检测当前的线程是否被中断。而且，调用 interrupted 方法会清除该线程的中断状态。另一方面，isInterrupted 方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。  </p><p>在很多发布的代码中会发现 InterruptedException 异常被抑制在很低的层次上，像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span></span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">try</span> &#123; sleep(delay) ; &#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e) &#123; &#125; <span class="comment">// Don't ignore!</span></div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不要这样做！如果不认为在 catch 子句中做这一处理有什么好处的话，仍然有两种合理的选择:  </p><ul><li>在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">...</div><div class="line"><span class="keyword">try</span> &#123; sleep(delay);&#125;</div><div class="line"><span class="keyword">catch</span>(InterruptedException e) </div><div class="line">&#123;</div><div class="line">Thread.currentThread().interrupt();</div><div class="line">&#125; </div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>或者, 更好的选择是, 用 throws InterruptedException 标记你的方法, 不采用 try 语句块捕获异常。于是，调用者(或者 最终的 run 方法)可以捕获这一异常。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">...</div><div class="line">    sleep(delay);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面是与线程中断有关的API<br><img src="/2018/02/01/Java学习总结之并发/线程中断.png" alt="fail"></p><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>有时我们需要在线程之间进行通信，如上面银行的例子，如果账户余额不足，就要通知取款的线程暂停取款，等存款的线程把钱存入银行后再取款。</p><h4 id="线程等待和线程通知"><a href="#线程等待和线程通知" class="headerlink" title="线程等待和线程通知"></a>线程等待和线程通知</h4><p>我们来了解几个<strong>用于同步方法和同步代码块中</strong>进行线程间通信的常用方法。<strong>它们都是Object类的final方法，都只能在同步方法或同步代码块中调用，否则将抛出一个IllegalMonitorStateException。</strong>  </p><p><strong>wait方法</strong><br>wait()方法导致进入该同步方法或同步代码块的线程进入等待阻塞状态，并释放它持有的同步锁，它有三个重载的方法。<br>1.void wait()<br>导致进入该方法的线程进入等待状态，直到它被通知或者被中断。<br>2.wait(long millis) 设定一个超时间隔，如果在规定时间内没有被通知或中断，线程将被唤醒，millis是毫秒数。<br>3.wait(long millis,int nanos) 设定一个超时间隔，如果在规定时间内没有被通知或中断，线程将被唤醒，millis是毫秒数，nanos是纳秒数。  </p><p>如果在等待阻塞状态线程被中断会抛出一个InterruptedException异常。  </p><p><strong>notify方法</strong><br>在同步方法或同步代码块调用该方法后，JVM会随机选择一个在该对象上调用wait方法的的线程，解除其阻塞状态。</p><p><strong>notifyAll方法</strong><br>在同步方法或同步代码块调用该方法后，会解除所有在该对象上调用wait方法的线程的阻塞状态。  </p><p><strong>注意：</strong>线程被唤醒只是从等待阻塞状态进入了就绪状态，可以参与锁的竞争，但并不代表它已经获得了锁。  </p><h4 id="sleep方法和wait方法的区别"><a href="#sleep方法和wait方法的区别" class="headerlink" title="sleep方法和wait方法的区别"></a>sleep方法和wait方法的区别</h4><p>最简单的区别是，wait方法只能用于同步方法或同步代码块，而sleep方法可以直接调用。而更深层次的区别在于sleep方法只是暂时让出CPU的执行权，并不释放同步锁。而wait方法则会释放锁。sleep()必须捕获异常，wait()不用捕获异常。一个调用了sleep()或wait()方法的线程如果调用interrupt()方法请求中断，都会立即抛出InterruptedException。  </p><h4 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h4><p>下面使用wait()和notifyAll()配合实现一个经典的生产者-消费者模型，即一个线程生产，一个线程消费。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Queue.java</span></div><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line"><span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(!flag)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"消费："</span>+n);</div><div class="line">flag=<span class="keyword">false</span>;<span class="comment">//消费完毕，容器中没有数据</span></div><div class="line">notifyAll();</div><div class="line"><span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(flag)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">wait();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"生产："</span>+n);</div><div class="line"><span class="keyword">this</span>.n = n;</div><div class="line">flag=<span class="keyword">true</span>;<span class="comment">//生产完毕，容器中已经有数据</span></div><div class="line">notifyAll();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Producer.java</span></div><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Queue queue;</div><div class="line">Producer(Queue queue)&#123;</div><div class="line"><span class="keyword">this</span>.queue=queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">queue.set(i++);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Consumer.java</span></div><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">Queue queue;</div><div class="line">Consumer(Queue queue)&#123;</div><div class="line"><span class="keyword">this</span>.queue=queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">queue.get();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">1000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.habitdiary.queue;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Queue queue=<span class="keyword">new</span> Queue();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue)).start();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(queue)).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>如果最后一个活动线程在解除其他线程的阻塞状态之前就调用了wait()或await()，那么它也被阻塞，没有任何线程可以解除其他线程的阻塞，所有的线程都在互相等待，那么程序就发生了死锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;多任务&quot;&gt;&lt;a href=&quot;#多任务&quot; class=&quot;headerlink&quot; title=&quot;多任务&quot;&gt;&lt;/a&gt;多任务&lt;/h3&gt;&lt;p&gt;操作系统的多任务指的是在同一刻运行多个程序的能力。例如，在编辑或下载邮件的同时可以打印文件。今天，人们很可能有单台拥有多个 CPU 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之核心API</title>
    <link href="http://habitdiary.cn/2018/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%A0%B8%E5%BF%83API/"/>
    <id>http://habitdiary.cn/2018/01/30/Java学习总结之核心API/</id>
    <published>2018-01-30T13:11:34.000Z</published>
    <updated>2018-03-10T13:31:54.491Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java 的核心 API 是非常庞大的，这给开发者来说带来了很大的方便。所谓的 API 就是一些已经写好、可直接调用的类库。Java 里有非常庞大的 API，其中有一些类库是我们必须得掌握的，只有熟练掌握了 Java 一些核心的 API，我们才能更好的使用 Java。<br><img src="/2018/01/30/Java学习总结之核心API/general.png" alt="fail"></p><p><center>参考资料：实验楼JDK 核心 API</center><br>下面我们以包为单位对开发中常用的核心API进行总结。  </p><h3 id="java-lang包"><a href="#java-lang包" class="headerlink" title="java.lang包"></a>java.lang包</h3><p>在程序中，java.lang 包并不需要像其他包一样需要import关键字进行引入。系统会自动加载，所以我们可以直接取用其中的所有类。下面我们就来详细地学习一下 java.lang 包吧。</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>Java 是一种面向对象语言，Java 中的类把方法与数据连接在一起，构成了自包含式的处理单元。但在 Java 中不能定义基本数据类型(primitive type)对象，这样存在一个问题：即<strong>基本数据类型不具备对象特性，就不能进行对象化交互。</strong>为了能将基本类型视为对象进行处理，并能连接相关的方法，Java 为每个基本类型都提供了包装类。如 int 型数值的包装类 Integer，boolean 型数值的包装<br>类 Boolean 等，这样便可以把这些基本类型转换为对象来处理了。下面将介绍Java 中提供的各种包装类。<br><img src="/2018/01/30/Java学习总结之核心API/包装类.png" alt="fail"><br>在这八个类名中，除了<strong>Integer类</strong>和<strong>Character类</strong>，其它六个类的类名和基本数据类型一致，只是类名的首字母大写，这八种包装类都是<strong>被final关键字修饰的，没有无参的构造方法，且是不可变的。</strong>其实还有两个包装类，但它们没有对应的基本数据类型，即java.math包中的BigInteger类和BigDecimal类，主要应用于高精度的运算，BigInteger 支持任意精度的整数，BigDecimal 支持任意精度带小数点的运算，它们没有被final关键字修饰。关于这两个类我们将在java.math包中进行详细介绍。  </p><h4 id="基本类型与包装类型的异同"><a href="#基本类型与包装类型的异同" class="headerlink" title="基本类型与包装类型的异同:"></a>基本类型与包装类型的异同:</h4><p>1、在 Java 中，一切皆对象，但八大基本类型却不是对象。<br>2、声明方式的不同，基本类型无需通过 new 关键字来创建，而包装类型需 new 关键字。<br>3、存储方式及位置的不同，基本类型是直接存储变量的值保存在栈中能高效的存取，包装类型需要通过引用指向实例，具体的实例保存在堆中。<br>4、初始值的不同，包装类型的初始值为 null，基本类型的的初始值视具体的类型而定，比如 int 类型的初始值为 0，boolean 类型为 false。<br>5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。</p><h4 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h4><p>在八种包装类中，<strong>数值包装类</strong>(除了Character和Boolean，它们的直接父类是Object)以及之后会介绍的java.math包中的<strong>BigInteger类</strong>和<strong>BigDecimal类</strong>都有一个共同的<strong>抽象父类</strong>，即<strong>Number类</strong>。在学习包装类之前，我们先来学习Number类。<br>抽象类 Number 是父类,Number 的子类必须提供将表示的数值转换成 byte / double / float / long / int / short 的方法。Number 类的方法被 Number 的各子类所实现,常用方法如下:  </p><p><img src="/2018/01/30/Java学习总结之核心API/Number类.png" alt="fail">  </p><h4 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h4><p>1、构造方法有两种:<br>a) 以 int 型变量作为参数创建 Integer 对象,实例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer number=<span class="keyword">new</span> Integer(<span class="number">7</span>);</div></pre></td></tr></table></figure></p><p>b) 以 String 型变量作为参数创建 Integer 对象,实例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer number=<span class="keyword">new</span> Integer(“<span class="number">7</span>”);</div></pre></td></tr></table></figure></p><p>2、常用方法:<br><img src="/2018/01/30/Java学习总结之核心API/Integer类.png" alt="fail"><br>需要注意的是Integer也存在除了intValue()之外的其他xxxValue()方法，可以把Integer类型的对象转换为任意基本数值类型，这是从Number类继承的方法。还有，parseInt()方法有多个重载方法，可以把字符串转换为不同进制的基本数据类型。  </p><p>3、常用的常量:<br>a) MAX_VALUE: 表示 int 型可取的最大值<br>b) MIN_VALUE: 表示 int 型可取的最小值<br>c) SIZE:表示以二进制补码形式表示 int 值的位数<br>d) TYPE: 表示基本类型 Class 实例</p><p>4、基本数据类型、包装类、字符串三者之间的转换：<br>a)基本数据类型和包装类之间的转换<br>我们先来认识两个概念：装箱与拆箱。<br>装箱：把基本数据类型转换成包装类，分为自动装箱和手动装箱。<br>拆箱：把包装类转换成基本数据类型，分为自动拆箱和手动拆箱。<br>下面通过代码来演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//装箱：把基本数据类型转换成包装类</span></div><div class="line"></div><div class="line">        <span class="comment">//自动装箱</span></div><div class="line"><span class="keyword">int</span> t1 = <span class="number">2</span>;</div><div class="line">Integer t2 = t1;</div><div class="line">        </div><div class="line"><span class="comment">//手动装箱</span></div><div class="line">        <span class="comment">//1、构造方法</span></div><div class="line">Integer t3 = <span class="keyword">new</span> Integer(t1);</div><div class="line">        <span class="comment">//2、包装类的valueOf()</span></div><div class="line">        Integer t4 = Integer.valueOf(t1);</div><div class="line">        </div><div class="line">        <span class="comment">//拆箱：把包装类转换成基本数据类型</span></div><div class="line">        </div><div class="line"><span class="comment">//自动拆箱</span></div><div class="line"><span class="keyword">int</span> t4 = t2;</div><div class="line">        </div><div class="line"><span class="comment">//手动拆箱</span></div><div class="line"><span class="keyword">int</span> t5 = t2.intValue();</div><div class="line">```  </div><div class="line">b)基本数据类型和字符串之间的转换   </div><div class="line">直接看代码：  </div><div class="line">```java</div><div class="line"><span class="comment">//基本数据类型转换为字符串</span></div><div class="line"><span class="keyword">int</span> t1=<span class="number">2</span>;</div><div class="line">String t2=Integer.toString(t1);</div><div class="line">        <span class="comment">//也可直接用'+'进行字符串连接，会自动调用toString()</span></div><div class="line">        </div><div class="line">        <span class="comment">//字符串转换为基本数据类型</span></div><div class="line">        <span class="comment">//1、包装类的parseInt</span></div><div class="line"><span class="keyword">int</span> t3=Integer.parseInt(t2);</div><div class="line"><span class="comment">/*2、包装类的valueOf()先将字符串转换为包装类，</span></div><div class="line"><span class="comment">        再通过自动拆箱完成基本类型转换*/</span></div><div class="line"><span class="keyword">int</span> t4=Integer.valueOf(t2);</div></pre></td></tr></table></figure></p><p>c)包装类和字符串之间的转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装类转换为字符串</span></div><div class="line">Integer t1 = <span class="number">10</span>;</div><div class="line">String t2 = t1.toString();</div><div class="line"></div><div class="line"><span class="comment">//字符串转换为包装类  </span></div><div class="line"><span class="comment">//1、构造方法  </span></div><div class="line">Integer t3 = <span class="keyword">new</span> Integer(<span class="string">"10"</span>);</div><div class="line"><span class="comment">//2、包装类的valueOf()</span></div><div class="line">Integer t4 = Integer.valueOf(<span class="string">"10"</span>);</div></pre></td></tr></table></figure></p><p>5、包装类对象间的比较<br>我们先来看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> wrap;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Integer one=<span class="keyword">new</span> Integer(<span class="number">100</span>);</div><div class="line">Integer two=<span class="keyword">new</span> Integer(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"one==two的结果："</span>+(one==two));<span class="comment">//1 false</span></div><div class="line"></div><div class="line">Integer three=<span class="number">100</span>;<span class="comment">//自动装箱</span></div><div class="line">        <span class="comment">//自动装箱时隐式调用Integer three=Integer.valueOf(100);</span></div><div class="line">        System.out.println(<span class="string">"one==three的结果"</span>+(one==three));<span class="comment">//2 false</span></div><div class="line">System.out.println(<span class="string">"three==100的结果："</span>+(three==<span class="number">100</span>));<span class="comment">//3 自动拆箱 true</span></div><div class="line"><span class="comment">//Integer four=100;</span></div><div class="line">Integer four=Integer.valueOf(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"three==four的结果："</span>+(three==four));<span class="comment">//4 true</span></div><div class="line"></div><div class="line">Integer five=<span class="number">200</span>;</div><div class="line">System.out.println(<span class="string">"five==200的结果："</span>+(five==<span class="number">200</span>));<span class="comment">//5 true</span></div><div class="line"></div><div class="line">Integer six=<span class="number">200</span>;</div><div class="line">System.out.println(<span class="string">"five==six的结果："</span>+(five==six));<span class="comment">//6 false</span></div><div class="line"></div><div class="line">Double d1=Double.valueOf(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"d1==100的结果："</span>+(d1==<span class="number">100</span>));<span class="comment">//7 true</span></div><div class="line"></div><div class="line">Double d2=Double.valueOf(<span class="number">100</span>);</div><div class="line">System.out.println(<span class="string">"d1==d2的结果："</span>+(d1==d2));<span class="comment">//8 false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们先来引入一个对象池的概念，Java的内存空间主要分为栈、堆、常量池(对象池)，对象池可以认为是Java提供的缓存技术。当我们调用Integer的valueOf()方法且传入的参数在-128~127之间时<strong>(注意自动装箱的原理实际上就是编译器隐式调用了这个方法)</strong>，会首先在常量池中查找是否存在该对象，如果不存在，就在常量池中创建该对象，并让存在于栈中的Integer引用变量指向它;如果对象池中已经存在这个对象就直接让栈中的Integer引用变量指向它。<br><img src="/2018/01/30/Java学习总结之核心API/对象池.png" alt="fail">     </p><p>我们来逐一解释输出的结果：<br>1处结果为false，因为每次使用new关键字，会在堆上新开辟一块内存空间，所以用==判断结果一定为false。<br>2处结果为false，因为one指向的是堆上开辟的空间，而three自动装箱，会在对象池里创建对象，并指向对象池的对应空间，所以==判断结果为false。<br>3处结果为true，因为当包装类和基本数据类型进行比较时会自动拆箱，相当于比较100==100,结果自然是true。<br>4处结果为true，因为前面three自动装箱已经隐式调用valueOf方法并在对象池中创建过一个100的Integer对象(100在-128~127之间，所以会在对象池中创建该对象)，所以当four再次调用valueOf方法时会在对象池中进行寻找，找到该对象后four也指向该对象，所以three和four指向的是同一个对象，结果为true。<br>5处结果为true，原因同3,不赘述。<br>6处结果为false，这是因为200不在-128~127的范围，不能使用对象池。<br>7处结果为true，自动拆箱，即比较100.0==100，结果为true。<br>8处结果为false，因为在包装类中，Double和Float不存在对象池。  </p><p><strong>最后提醒：比较包装类的值不要使用==，此时并不会对两个包装类进行自动拆箱，而是和其他类型对象比较一样比较其地址，所以比较值还是使用equals或compareTo方法！！！</strong></p><h4 id="Boolean类"><a href="#Boolean类" class="headerlink" title="Boolean类"></a>Boolean类</h4><p>Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean类型的对象只包含一个类型为 boolean 的字段。此外,此类还为 boolean 和String 的相互转换提供了许多方法,并提供了处理 boolean 时非常有用的其他一些常量和方法。<br>1、构造方法:<br>a) 创建一个表示 value 参数的 boolean 对象,实例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Boolean b = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>b)以 String 变量作为参数,创建 boolean 对象。此时,如果传入的字符串不为 null,且忽略大小写后的内容等于”true”,则生成 Boolean 对象值为 true,反之为 false。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Boolean b1 = <span class="keyword">new</span> Boolean(<span class="string">"ok"</span>); </div><div class="line">System.out.println(b1); <span class="comment">//输出false</span></div><div class="line">Boolean b2=<span class="keyword">new</span> Boolean(<span class="string">"TRUE"</span>);</div><div class="line">System.out.println(b2); <span class="comment">//输出true</span></div></pre></td></tr></table></figure></p><p>2、常用方法:<br><img src="/2018/01/30/Java学习总结之核心API/Boolean类.png" alt="fail"><br>3、常用的常量:<br>a) TRUE:对应基值 true 的 Boolean 对象;<br>b) FALSR:对应基值 false 的 Boolean 对象;<br>c) TYPE:表示基本类型 Class 实例</p><h4 id="Byte类"><a href="#Byte类" class="headerlink" title="Byte类"></a>Byte类</h4><p>Byte 类将基本类型为 byte 的值包装在一个对象中,一个 byte 类型的对象只包含一个类型为 byte 的对象。此外,该类还为 byte 和 String 之间相互转换提供方法,并提供了一些处理 byte 时非常有用的常量。<br>1、构造方法<br>Byte 类提供了两种构造方法的重载形式来创建 BYTE 类对象:<br>a) Byte (byte value) 通过这种方法创建的 byte 对象,可表示指定的 byte值。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Byte b = <span class="keyword">new</span> Byte(<span class="number">45</span>);</div></pre></td></tr></table></figure></p><p>b) Byte(String str) 通过这种方法创建的 byte 对象,可表示 String 参数指定的 byte 值，例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Byte mybyte = <span class="keyword">new</span> Byte(<span class="string">"12"</span>);</div></pre></td></tr></table></figure></p><p>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Byte类.png" alt="fail"><br>3、常用的常量<br>a) MIN_VALUE: 最小值<br>b) MAX_VALUE: 最大值<br>c) SIZE: 二进制<br>d) TYPE: 表示基本类型 byte 的 class 实例  </p><h4 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h4><p>Character 类在对象中包装一个基本类型为 char 的值。一个 Character 对象包含类型为 char 的单个字段。<br>1、构造方法<br>Character 类的构造方法的语法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Character(<span class="keyword">char</span> value)</div></pre></td></tr></table></figure></p><p>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Character类.png" alt="fail"><br>还有isDigit(ch)、isLetter(ch)、isLetterOrDigit(ch)等方法分别返回一个布尔值表示ch是否是数字字符、ch是否是字母、ch是否是字母或者数字。</p><h4 id="Double类"><a href="#Double类" class="headerlink" title="Double类"></a>Double类</h4><p>Double 和 Float 包装类是对 double、float 基本类型的封装,他们都是 Number 类的子类,又都是对小数进行操作,所以常用基本方法相同,Double 类在对象中包装一个基本类型为 double 的值,每个 double 类都包含一个 double 类型的字段。<br>1、 构造方法<br>Double 类提供了两种构造方法来获得 Double 类对象<br>a) Double(double value): 基于 double 参数创建 Double 类对象;<br>b) Double(String str): 构造一个新分配的 Double 对象,表示用字符串表示的 Double 类型的浮点值<br>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Double1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/Double2.png" alt="fail"> </p><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><p>我们在编程的过程中，经常需要对一些数字进行数学操作，如初等指数、对数、平方根和三角函数，其实 java.lang 里的 Math 类包含了用于执行基本数学运算的方法。我们就来学习一下吧！<br>1、构造方法<br>Math类的构造方法是private的，这样设计的意图是不让使用者创建Math类的对象，也就是说，Math类的所有方法都是静态方法。另外Math类是final的，设计为不能被继承。<br>2、常用方法<br><img src="/2018/01/30/Java学习总结之核心API/Math类.png" alt="fail">   </p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><p>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/String构造1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String构造2.png" alt="fail"><br>2、常用方法(方法很多，勤查API)<br><img src="/2018/01/30/Java学习总结之核心API/String1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String3.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String4.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String5.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/String6.png" alt="fail">   </p><p><strong>特别关注：</strong><br>1)字符串的替换和分隔<br>replace、replaceFirst、replaceAll、split等方法。<br>2)依照模式匹配、替换和分隔(正则表达式)<br>matches方法配合正则表达式。更多拓展还应学习java.util.regex 包里的Pattern类和Matcher类。<br>3)字符串与字符数组之间的转换<br>字符串转字符数组使用toCharArray()方法，字符数组转字符串使用字符串的构造方法String(char[])或valueOf(char[])。<br>4)字符串与字符和数值之间的转换<br>字符串转字符和数值使用包装类的parseXXX()方法或valueOf(String)方法，字符和数值转字符串可以使用’+’直接连接，也可以使用String类的valueOf方法。<br>5)格式化字符串<br>使用String类的静态format方法，可以格式化字符串。  </p><p>3、等于运算符与equals方法的区别<br>equals比较的是String对象的内容，==比较的是String对象的引用。值得注意的是，String类型变量看似存储了一个字符串，但它仍然属于引用类型变量，所以String类型变量存在于栈中，而实际的字符串对象存在于堆中或常量池中。String类型变量存储的是String对象的引用，String对象存储的才是字符串值。<br>4、String对象的存储<br>我们首先来看看Java中的内存分布。<br><img src="/2018/01/30/Java学习总结之核心API/内存.png" alt="fail"><br>如果我们用<code>String str = &quot;Hello world&quot;</code>的形式创建字符串，会首先在常量池寻找是否存在这样的字符串常量，如果没有，就创建并让字符串变量指向它;如果有，就直接让字符串变量指向它。而如果使用<code>String str = new str(&quot;Hello world&quot;)</code>的形式，就在堆上重新开辟一块内存空间并让字符串变量指向它。<br>示意图如下：<br><img src="/2018/01/30/Java学习总结之核心API/内存2.png" alt="fail"><br>5、String类的不可变性<br>String类是不可变类，即String对象一旦被创建，其内容是不可变的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.string;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo6</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//String的不可变性</span></div><div class="line"><span class="comment">//String对象一旦被创建，则不能修改，是不可变的</span></div><div class="line"><span class="comment">//所谓的修改其实是创建了新的对象，所指向的内存空间不变</span></div><div class="line">String s1=<span class="string">"imooc"</span>;</div><div class="line">        String s2=<span class="string">"hello,"</span>+s1;</div><div class="line">        <span class="comment">//s2指向"hello,imooc"</span></div><div class="line">s1=<span class="string">"hello,"</span>+s1;</div><div class="line"><span class="comment">//s1不再指向imooc所在的内存空间，而是指向了"hello,imooc"</span></div><div class="line">System.out.println(<span class="string">"s1="</span>+s1);<span class="comment">//s1=hello,imooc</span></div><div class="line">System.out.println(<span class="string">"s2="</span>+s2); <span class="comment">//s2=hello,imooc</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2018/01/30/Java学习总结之核心API/change2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/change.png" alt="fail">   </p><h4 id="StringBuilder类-amp-StringBuffer类"><a href="#StringBuilder类-amp-StringBuffer类" class="headerlink" title="StringBuilder类 &amp; StringBuffer类"></a>StringBuilder类 &amp; StringBuffer类</h4><p>由于String类的不可变性，String在操作字符串时可能会产生很多冗余的中间字符串变量。所以，当需要频繁操作字符串时，建议使用StringBuilder类或StringBuffer类，这两个类是可变类。<br>StringBuilder类和StirngBuffer类的区别<br>两者除了StringBuffer修改缓冲区的方法是同步的，其他用法基本相同。而由于StringBuffer类是多线程安全的，所以在单线程程序中StringBuilder性能略高。所以建议在单线程情况下使用StringBuilder，多线程情况下使用StringBuffer。  </p><p>由于两者的构造方法和常见方法基本相同，所以我们以StringBuffer为例进行介绍：<br>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/StringBuffer1.png" alt="fail"><br>2、常见方法<br><img src="/2018/01/30/Java学习总结之核心API/StringBuffer2.png" alt="fail">   </p><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>详见<a href="http://habitdiary.cn/2017/10/14/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84/">Java学习总结之反射</a>  </p><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>掌握Object类的九个方法：equals(),hashCode(),getClass(),toString(),clone(),finalize(),notify(),notifyAll(),wait()(三个重载方法)<br>详见 <a href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/">Java学习总结之继承和多态</a>  和 <a href="http://habitdiary.cn/2018/02/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%B9%B6%E5%8F%91/#more">Java学习总结之并发</a></p><h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><p>详见<a href="http://habitdiary.cn/2017/11/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F/#more">Java学习总结之Java IO系统</a></p><h4 id="Enum类"><a href="#Enum类" class="headerlink" title="Enum类"></a>Enum类</h4><p>详见<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>  </p><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><p>详见<a href="http://habitdiary.cn/2018/02/01/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%B9%B6%E5%8F%91/#more">Java学习总结之并发</a></p><h3 id="java-math包"><a href="#java-math包" class="headerlink" title="java.math包"></a>java.math包</h3><p>java.math包主要包含BigInteger类和BigDecimal类，主要应用于高精度的运算，BigInteger 支持任意精度的整数，BigDecimal 支持任意精度带小数点的运算。<strong>不要混淆java.math包和java.lang包中的Math类。</strong></p><h4 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h4><p>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/BigInteger构造方法.png" alt="fail"><br>2、常见方法<br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法3.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigInteger方法4.png" alt="fail"><br>3、常量<br><img src="/2018/01/30/Java学习总结之核心API/BigInteger常量.png" alt="fail">  </p><h4 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类　　"></a>BigDecimal类　　</h4><p>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal构造方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal构造方法2.png" alt="fail"><br>2、常见方法<br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法3.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法4.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal方法5.png" alt="fail"><br>3、常量<br><img src="/2018/01/30/Java学习总结之核心API/BigDecimal常量.png" alt="fail">  </p><h3 id="java-util包"><a href="#java-util包" class="headerlink" title="java.util包"></a>java.util包</h3><p><img src="/2018/01/30/Java学习总结之核心API/general2.png" alt="fail"></p><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间。<br><strong>1.构造方法</strong><br><img src="/2018/01/30/Java学习总结之核心API/Date构造方法.png" alt="fail"><br><strong>2.常用方法</strong><br><img src="/2018/01/30/Java学习总结之核心API/Date方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/Date方法2.png" alt="fail">  </p><h5 id="1-获取当前日期时间"><a href="#1-获取当前日期时间" class="headerlink" title="1.获取当前日期时间"></a>1.获取当前日期时间</h5><p>Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">       <span class="comment">// 初始化 Date 对象</span></div><div class="line">       Date date = <span class="keyword">new</span> Date();</div><div class="line">        </div><div class="line">       <span class="comment">// 使用 toString() 函数显示日期时间</span></div><div class="line">       System.out.println(date.toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="2-日期比较"><a href="#2-日期比较" class="headerlink" title="2.日期比较"></a>2.日期比较</h5><p>Java使用以下三种方法来比较两个日期：</p><ul><li>使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。  </li><li>使用方法 before()，after() 和 equals()。</li><li>使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</li></ul><h5 id="3-使用-SimpleDateFormat-格式化日期"><a href="#3-使用-SimpleDateFormat-格式化日期" class="headerlink" title="3.使用 SimpleDateFormat 格式化日期"></a>3.使用 SimpleDateFormat 格式化日期</h5><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> java.text.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line"> </div><div class="line">      Date dNow = <span class="keyword">new</span> Date( );</div><div class="line">      SimpleDateFormat ft = </div><div class="line">      <span class="keyword">new</span> SimpleDateFormat (<span class="string">"E yyyy.MM.dd 'at' hh:mm:ss a zzz"</span>);</div><div class="line">      <span class="comment">/*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，</span></div><div class="line"><span class="comment">      MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。*/</span></div><div class="line"> </div><div class="line">      System.out.println(<span class="string">"Current Date: "</span> + ft.format(dNow));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。<br>运行结果如下:<br>Current Date: Wed 2016.11.09 at 08:23:19 AM UTC  </p><p><strong>日期和时间的格式化编码</strong><br>时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下：<br><img src="/2018/01/30/Java学习总结之核心API/SimpleDateFormat1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/SimpleDateFormat2.png" alt="fail">    </p><h5 id="4-使用printf格式化日期"><a href="#4-使用printf格式化日期" class="headerlink" title="4.使用printf格式化日期"></a>4.使用printf格式化日期</h5><p>见博文 <a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a> 的printf部分   </p><h5 id="5-解析字符串为时间"><a href="#5-解析字符串为时间" class="headerlink" title="5.解析字符串为时间"></a>5.解析字符串为时间</h5><p>SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> java.text.*;</div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat (<span class="string">"yyyy-MM-dd"</span>); </div><div class="line"> </div><div class="line">      String input = args.length == <span class="number">0</span> ? <span class="string">"1818-11-11"</span> : args[<span class="number">0</span>]; </div><div class="line"> </div><div class="line">      System.out.print(input + <span class="string">" Parses as "</span>); </div><div class="line"> </div><div class="line">      Date t; </div><div class="line"> </div><div class="line">      <span class="keyword">try</span> &#123; </div><div class="line">          t = ft.parse(input); </div><div class="line">          System.out.println(t); </div><div class="line">      &#125; <span class="keyword">catch</span> (ParseException e) &#123; </div><div class="line">          System.out.println(<span class="string">"Unparseable using "</span> + ft); </div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上实例编译运行结果如下:<br>java DateDemo<br>1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818<br>java DateDemo 2007-12-01<br>2007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007</p><h5 id="6-Calendar类"><a href="#6-Calendar类" class="headerlink" title="6.Calendar类"></a>6.Calendar类</h5><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能<strong>设置和获取日期数据的特定部分</strong>呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢?<br>答案是使用 Calendar 类。<br>Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。<br>Calendar类是一个<strong>抽象类</strong>，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。<br><strong>1) 构造方法</strong><br><strong>创建一个代表系统当前日期的Calendar对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Calendar c = Calendar.getInstance();<span class="comment">/*默认是当前日期,</span></div><div class="line"><span class="comment">返回一个默认用当前的语言环境和时区初始化的</span></div><div class="line"><span class="comment">GregorianCalendar对象*/</span></div></pre></td></tr></table></figure></p><p><strong>创建一个指定日期的Calendar对象</strong><br>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个代表2009年6月12日的Calendar对象</span></div><div class="line">Calendar c1 = Calendar.getInstance();</div><div class="line">c1.set(<span class="number">2009</span>, <span class="number">6</span> - <span class="number">1</span>, <span class="number">12</span>);</div></pre></td></tr></table></figure></p><p><strong>Calendar类对象字段类型</strong><br>Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想<br><img src="/2018/01/30/Java学习总结之核心API/Calendar类常量.png" alt="fail">    </p><p><strong>Calendar类对象信息的设置</strong><br><strong>Set设置</strong><br>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Calendar c1 = Calendar.getInstance();</div></pre></td></tr></table></figure></p><p>调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> date)</span></span></div><div class="line"><span class="function">c1.<span class="title">set</span><span class="params">(<span class="number">2009</span>, <span class="number">6</span> - <span class="number">1</span>, <span class="number">12</span>)</span></span>;</div><div class="line"><span class="comment">/*把Calendar对象c1的年月日分别设这为：2009、6、12,</span></div><div class="line"><span class="comment">注意月份是从0开始的！*/</span></div></pre></td></tr></table></figure></p><p>利用字段类型设置<br>如果只设定某个字段，例如日期的值，则可以使用如下set方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field,<span class="keyword">int</span> value)</span></span></div></pre></td></tr></table></figure></p><p>把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c1.set(Calendar.DATE,<span class="number">10</span>);</div></pre></td></tr></table></figure></p><p>把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c1.set(Calendar.YEAR,<span class="number">2008</span>);</div></pre></td></tr></table></figure></p><p>其他字段属性set的意义以此类推</p><p><strong>Add设置</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Calendar c1 = Calendar.getInstance();</div></pre></td></tr></table></figure></p><p>把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c1.add(Calendar.DATE, <span class="number">10</span>);</div></pre></td></tr></table></figure></p><p>把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c1.add(Calendar.DATE, -<span class="number">10</span>);</div></pre></td></tr></table></figure></p><p>其他字段属性的add的意义以此类推  </p><p><strong>Calendar类对象信息的获得</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Calendar c1 = Calendar.getInstance();</div><div class="line"><span class="comment">// 获得年份</span></div><div class="line"><span class="keyword">int</span> year = c1.get(Calendar.YEAR);</div><div class="line"><span class="comment">// 获得月份</span></div><div class="line"><span class="keyword">int</span> month = c1.get(Calendar.MONTH) + <span class="number">1</span>;</div><div class="line"><span class="comment">// 获得日期</span></div><div class="line"><span class="keyword">int</span> date = c1.get(Calendar.DATE);</div><div class="line"><span class="comment">// 获得小时</span></div><div class="line"><span class="keyword">int</span> hour = c1.get(Calendar.HOUR_OF_DAY);</div><div class="line"><span class="comment">// 获得分钟</span></div><div class="line"><span class="keyword">int</span> minute = c1.get(Calendar.MINUTE);</div><div class="line"><span class="comment">// 获得秒</span></div><div class="line"><span class="keyword">int</span> second = c1.get(Calendar.SECOND);</div><div class="line"><span class="comment">/* 获得星期几（注意（这个与Date类是不同的）：</span></div><div class="line"><span class="comment">1代表星期日、2代表星期1、3代表星期二，以此类推）*/</span></div><div class="line"><span class="keyword">int</span> day = c1.get(Calendar.DAY_OF_WEEK);</div></pre></td></tr></table></figure></p><h5 id="7-GregorianCalendar类"><a href="#7-GregorianCalendar类" class="headerlink" title="7.GregorianCalendar类"></a>7.GregorianCalendar类</h5><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个<strong>具体实现</strong>。<br>Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。  </p><p>下面列出GregorianCalendar对象的几个构造方法：<br><img src="/2018/01/30/Java学习总结之核心API/GregorianCalendar构造方法.png" alt="fail">  </p><p>这里是 GregorianCalendar 类提供的一些有用的方法列表：<br><img src="/2018/01/30/Java学习总结之核心API/GregorianCalendar方法1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/GregorianCalendar方法2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之核心API/GregorianCalendar方法3.png" alt="fail">  </p><p><strong>实例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendarDemo</span> </span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      String months[] = &#123;</div><div class="line">      <span class="string">"Jan"</span>, <span class="string">"Feb"</span>, <span class="string">"Mar"</span>, <span class="string">"Apr"</span>,</div><div class="line">      <span class="string">"May"</span>, <span class="string">"Jun"</span>, <span class="string">"Jul"</span>, <span class="string">"Aug"</span>,</div><div class="line">      <span class="string">"Sep"</span>, <span class="string">"Oct"</span>, <span class="string">"Nov"</span>, <span class="string">"Dec"</span>&#125;;</div><div class="line">      </div><div class="line">      <span class="keyword">int</span> year;</div><div class="line">      <span class="comment">// 初始化 Gregorian 日历</span></div><div class="line">      <span class="comment">// 使用当前时间和日期</span></div><div class="line">      <span class="comment">// 默认为本地时间和时区</span></div><div class="line">      GregorianCalendar gcalendar = <span class="keyword">new</span> GregorianCalendar();</div><div class="line">      <span class="comment">// 显示当前时间和日期的信息</span></div><div class="line">      System.out.print(<span class="string">"Date: "</span>);</div><div class="line">      System.out.print(months[gcalendar.get(Calendar.MONTH)]);</div><div class="line">      System.out.print(<span class="string">" "</span> + gcalendar.get(Calendar.DATE) + <span class="string">" "</span>);</div><div class="line">      System.out.println(year = gcalendar.get(Calendar.YEAR));</div><div class="line">      System.out.print(<span class="string">"Time: "</span>);</div><div class="line">      System.out.print(gcalendar.get(Calendar.HOUR) + <span class="string">":"</span>);</div><div class="line">      System.out.print(gcalendar.get(Calendar.MINUTE) + <span class="string">":"</span>);</div><div class="line">      System.out.println(gcalendar.get(Calendar.SECOND));</div><div class="line">      </div><div class="line">      <span class="comment">// 测试当前年份是否为闰年</span></div><div class="line">      <span class="keyword">if</span>(gcalendar.isLeapYear(year)) &#123;</div><div class="line">         System.out.println(<span class="string">"当前年份是闰年"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">         System.out.println(<span class="string">"当前年份不是闰年"</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果如下：<br>Date: Apr 22 2009<br>Time: 11:25:27<br>当前年份不是闰年</p><h4 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4><p>Java 实用工具类库中的类 java.util.Random 提供了产生各种类型随机数的方法。它可以产生 int、long、float、double 以及 Gaussian 等类型的随机数。这也是它与 java.lang.Math 中的方法 Random() 最大的不同之处，后者只产生 double 型的随机数。<br>1、构造方法<br><img src="/2018/01/30/Java学习总结之核心API/Random构造方法.png" alt="fail"><br>2、常见方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该方法是设定基值seed</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个整型随机数 </span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个long型随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个Float型随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">nextFloat</span><span class="params">()</span></span></div><div class="line"><span class="function">　</span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个Double型随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//该方法是产生一个double型的Gaussian随机数</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">nextGaussian</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">/*synchronized 是 Java 语言的关键字，当它用来修饰</span></span></div><div class="line"><span class="function"><span class="comment">一个方法或者一个代码块的时候，能够保证在同一时刻最</span></span></div><div class="line"><span class="function"><span class="comment">多只有一个线程执行该段代码*/</span></span></div></pre></td></tr></table></figure></p><h4 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h4><p>详见<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>  </p><h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>详见<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>  </p><h4 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h4><p>详见<a href="http://habitdiary.cn/2017/10/23/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88/">Java学习总结之集合</a>  </p><h3 id="java-io包"><a href="#java-io包" class="headerlink" title="java.io包"></a>java.io包</h3><p>详见<a href="http://habitdiary.cn/2017/11/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F/">Java学习总结之Java IO系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Java 的核心 API 是非常庞大的，这给开发者来说带来了很大的方便。所谓的 API 就是一些已经写好、可直接调用的类库。Java 里有非
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之设计模式</title>
    <link href="http://habitdiary.cn/2018/01/30/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://habitdiary.cn/2018/01/30/Java学习总结之设计模式/</id>
    <published>2018-01-30T03:01:50.000Z</published>
    <updated>2018-03-21T12:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<br>设计模式是<strong>一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</strong>  </p><h3 id="使用设计模式的目的"><a href="#使用设计模式的目的" class="headerlink" title="使用设计模式的目的"></a>使用设计模式的目的</h3><p>为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。  </p><h3 id="提出者"><a href="#提出者" class="headerlink" title="提出者"></a>提出者</h3><p>设计模式是由GOF(四人帮，Gang of Four)提出的。<br>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则：</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承。    </li></ul><h3 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h3><p>设计模式在软件开发中的两个主要用途。  </p><h4 id="开发人员的共同平台"><a href="#开发人员的共同平台" class="headerlink" title="开发人员的共同平台"></a>开发人员的共同平台</h4><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。  </p><h4 id="最佳的实践"><a href="#最佳的实践" class="headerlink" title="最佳的实践"></a>最佳的实践</h4><p>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。  </p><h3 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h3><p>根据设计模式的参考书<strong> Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 中所提到的，总共有<strong> 23 种</strong>设计模式。这些模式可以分为三大类：<strong>创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）</strong>。当然，我们还会讨论另一类设计模式：<strong>J2EE 设计模式。</strong><br><img src="/2018/01/30/Java学习总结之设计模式/general1.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之设计模式/general2.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之设计模式/general3.png" alt="fail">  </p><p> 下面用一个图片来整体描述一下设计模式之间的关系：  </p><p><img src="/2018/01/30/Java学习总结之设计模式/设计模式之间的关系.png" alt="fail" title="设计模式之间的关系">   </p><h3 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h3><h4 id="1、单一职责原则（SRP：Single-Responsibility-Principle）"><a href="#1、单一职责原则（SRP：Single-Responsibility-Principle）" class="headerlink" title="1、单一职责原则（SRP：Single Responsibility Principle）"></a>1、单一职责原则（SRP：Single Responsibility Principle）</h4><p>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。  </p><h4 id="2、开闭原则（OCP：Open-Close-Principle）"><a href="#2、开闭原则（OCP：Open-Close-Principle）" class="headerlink" title="2、开闭原则（OCP：Open Close Principle）"></a>2、开闭原则（OCP：Open Close Principle）</h4><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。  </p><h4 id="3、里氏代换原则（LSP：Liskov-Substitution-Principle）"><a href="#3、里氏代换原则（LSP：Liskov-Substitution-Principle）" class="headerlink" title="3、里氏代换原则（LSP：Liskov Substitution Principle）"></a>3、里氏代换原则（LSP：Liskov Substitution Principle）</h4><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。  </p><h4 id="4、依赖倒转原则（DIP：Dependence-Inversion-Principle）"><a href="#4、依赖倒转原则（DIP：Dependence-Inversion-Principle）" class="headerlink" title="4、依赖倒转原则（DIP：Dependence Inversion Principle）"></a>4、依赖倒转原则（DIP：Dependence Inversion Principle）</h4><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。  </p><h4 id="5、接口隔离原则（ISP：Interface-Segregation-Principle）"><a href="#5、接口隔离原则（ISP：Interface-Segregation-Principle）" class="headerlink" title="5、接口隔离原则（ISP：Interface Segregation Principle）"></a>5、接口隔离原则（ISP：Interface Segregation Principle）</h4><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。  </p><h4 id="6、迪米特法则，又称最少知道原则（DP：Demeter-Principle）"><a href="#6、迪米特法则，又称最少知道原则（DP：Demeter-Principle）" class="headerlink" title="6、迪米特法则，又称最少知道原则（DP：Demeter Principle）"></a>6、迪米特法则，又称最少知道原则（DP：Demeter Principle）</h4><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。  </p><h4 id="7、合成复用原则（CRP：Composite-Reuse-Principle）"><a href="#7、合成复用原则（CRP：Composite-Reuse-Principle）" class="headerlink" title="7、合成复用原则（CRP：Composite Reuse Principle）"></a>7、合成复用原则（CRP：Composite Reuse Principle）</h4><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。  </p><h4 id="下面我们将通过Java实例来总结常用的设计模式。"><a href="#下面我们将通过Java实例来总结常用的设计模式。" class="headerlink" title="下面我们将通过Java实例来总结常用的设计模式。"></a>下面我们将通过Java实例来总结常用的设计模式。</h4><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h3 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。  </p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。  </p><p><strong>主要解决：</strong>主要解决接口选择的问题。  </p><p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。  </p><p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。  </p><p><strong>关键代码：</strong>创建过程在其子类执行。  </p><p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。  </p><p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。  </p><p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。  </p><p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 </p><p><img src="/2018/01/30/Java学习总结之设计模式/工厂模式.jpg" alt="fail"></p><p><strong>步骤 1</strong><br>创建一个接口。<br>Shape.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建实现接口的实体类。<br>Rectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>创建一个工厂，生成基于给定信息的实体类的对象。<br>ShapeFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="comment">/*使用 getShape 方法获取形状类型的对象，</span></div><div class="line"><span class="comment">   在实际操作中建议把CIRCLE等定义为常量*/</span></div><div class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;        </div><div class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>使用该工厂，通过传递类型信息来获取实体类的对象。<br>FactoryPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</div><div class="line"></div><div class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></div><div class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</div><div class="line"></div><div class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></div><div class="line">      shape1.draw();</div><div class="line"></div><div class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></div><div class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</div><div class="line"></div><div class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></div><div class="line">      shape2.draw();</div><div class="line"></div><div class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></div><div class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</div><div class="line"></div><div class="line">      <span class="comment">//调用 Square 的 draw 方法</span></div><div class="line">      shape3.draw();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>验证输出。<br>Inside Circle::draw() method.<br>Inside Rectangle::draw() method.<br>Inside Square::draw() method.  </p><p>使用<strong>反射机制</strong>可以解决每次增加一个产品时，都需要增加一个对象实现工厂接口的缺点。注意要使用完整包名，也可以使用Properties文件做映射。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShapeByClassName</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">   Shape obj = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">obj = (Shape)Class.forName(clazz.getName()).newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>工厂模式的实际应用</strong>  </p><p><img src="/2018/01/30/Java学习总结之设计模式/JDBC.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之设计模式/Bean.png" alt="fail"></p><h3 id="2、抽象工厂模式"><a href="#2、抽象工厂模式" class="headerlink" title="2、抽象工厂模式"></a>2、抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  </p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。    </p><p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。  </p><p>为了方便引进抽象工厂模式，引进一个新概念：产品族（Product Family）。所谓产品族，是指位于不同产品等级结构，功能相关联的产品组成的家族。如图：<br><img src="/2018/01/30/Java学习总结之设计模式/产品族1.gif" alt="fail"><br>图中一共有四个产品族，分布于三个不同的产品等级结构中。同一个产品族是同一个工厂生产的，而不同等级结构来自不同的工厂。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。<br>所谓的抽象工厂是指一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。如果用图来描述的话，如下图：<br><img src="/2018/01/30/Java学习总结之设计模式/产品族2.gif" alt="fail"> </p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p><p><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/抽象工厂模式.gif" alt="fail">   </p><p>上图的描述用产品族描述如下：<br><img src="/2018/01/30/Java学习总结之设计模式/产品族3.gif" alt="fail">   </p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>我们来举这样一个例子，QQ秀有不同的装扮，分为男孩和女孩，而男孩又分为圣诞男孩和新年男孩，女孩分为圣诞女孩和新年女孩。那么就可以有一个抽象工厂生产男孩和女孩。两个具体的工厂分别生产圣诞系列的男孩和女孩、新年系列的男孩和女孩。同一系列的男孩和女孩是一个产品族，而不同系列构成不同的产品等级。  </p><p><strong>步骤 1</strong><br>为男孩创建一个接口。<br>Boy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Boy</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMan</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建实现接口的实体类。<br>MCBoy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCBoy</span> <span class="keyword">implements</span> <span class="title">Boy</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMan</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"-----------------圣诞系列的男孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HNBoy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNBoy</span> <span class="keyword">implements</span> <span class="title">Boy</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawMan</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"-----------------新年系列的男孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>为女孩创建一个接口<br>Girl.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Girl</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWomen</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>创建实现接口的实体类。<br>MCGirl.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCGirl</span> <span class="keyword">implements</span> <span class="title">Girl</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWomen</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"-----------------圣诞系列的女孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HNGirl.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNGirl</span> <span class="keyword">implements</span> <span class="title">Girl</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawWomen</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line">System.out.println(<span class="string">"-----------------新年系列的女孩子--------------------"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>创建生产男孩女孩的抽象工厂接口<br>PersonFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span> </span>&#123;</div><div class="line"><span class="comment">//男孩接口</span></div><div class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getBoy</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//女孩接口</span></div><div class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 6</strong><br>创建生产圣诞和新年系列的具体工厂<br>MCFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCFctory</span> <span class="keyword">implements</span> <span class="title">PersonFactory</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getBoy</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MCBoy();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> MCGirl();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HNFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNFactory</span> <span class="keyword">implements</span> <span class="title">PersonFactory</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getBoy</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> HNBoy();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> HNGirl();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 7</strong><br>使用工厂生产<br>AbstractFactoryPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    MCFactory mcFactory = <span class="keyword">new</span> MCFactory();</div><div class="line">        HNFactory hnFactory = <span class="keyword">new</span> HNFactory();</div><div class="line">        Boy mcBoy = mcFactory.getBoy();</div><div class="line">        Girl mcGirl = mcFactory.getGirl();</div><div class="line">        Boy hnBoy = hnFactory.getBoy();</div><div class="line">        Girl hnGirl = hnFactory.getGirl();</div><div class="line">        mcBoy.drawMan();</div><div class="line">        mcGirl.drawWomen();</div><div class="line">        hnBoy.drawMan();</div><div class="line">        hnGirl.drawWomen();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 8</strong><br>验证输出<br>—————–圣诞系列的男孩子——————–<br>—————–圣诞系列的女孩子——————–<br>—————–新年系列的男孩子——————–<br>—————–新年系列的女孩子——————–  </p><p><strong>注意：</strong>抽象工厂也可以运用反射，只不过反射的不再是产品类，而是不同的具体工厂类。<br><img src="/2018/01/30/Java学习总结之设计模式/对比.png" alt="fail"></p><h3 id="3、单例模式"><a href="#3、单例模式" class="headerlink" title="3、单例模式"></a>3、单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个<strong>单一的类</strong>，该类负责<strong>创建自己的对象，同时确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，<strong>可以直接访问，不需要实例化该类的对象</strong>。<br><strong>注意：</strong><br>1、单例类只能有<strong>一个实例</strong>。<br>2、单例类必须<strong>自己创建自己的唯一实例</strong>，而不是在外部随意地new对象。<br>3、单例类必须给所有其他对象<strong>提供</strong>这一实例。  </p><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong>当想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong>构造函数是私有的。<br><strong>应用实例：</strong> 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。<br><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销。2、避免频繁的创建和销毁实例，提高性能（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong>1、扩展比较困难，没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。2、如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失。<br><strong>使用场景：</strong> 1、当多个实例存在可能引起程序逻辑错误，如要求生产唯一序列号。 2、对系统内资源要求统一读写，如读写配置信息，又如WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，但同时又需要用到该对象，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。  </p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。<br><img src="/2018/01/30/Java学习总结之设计模式/单例模式.jpg" alt="fail"><br><strong>步骤 1</strong><br>创建一个 Singleton 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">SingleObject.java</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//创建 SingleObject 的一个对象</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</div><div class="line"></div><div class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">   <span class="comment">//获取唯一可用的对象</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"Hello World!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>从 singleton 类获取唯一的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">SingletonPatternDemo.java</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//不合法的构造函数</span></div><div class="line">      <span class="comment">//编译时错误：构造函数 SingleObject() 是不可见的</span></div><div class="line">      <span class="comment">//SingleObject object = new SingleObject();</span></div><div class="line"></div><div class="line">      <span class="comment">//获取唯一可用的对象</span></div><div class="line">      SingleObject object = SingleObject.getInstance();</div><div class="line"></div><div class="line">      <span class="comment">//显示消息</span></div><div class="line">      object.showMessage();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>验证输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello World!</div></pre></td></tr></table></figure></p><h4 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h4><p>单例模式的实现有多种方式，如下所示：<br><strong>1、懒汉式，线程不安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。假设开始线程1进入，判断instance为空，在将要创建实例时，时间片切换，线程2又进来了，同样判断instance为空，创建了实例，这是CPU调度回到线程1，继续创建实例。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  <span class="comment">/*懒汉式标志：Lazy 初始化,</span></div><div class="line"><span class="comment">    在外部第一次请求使用该类对象时才实例化，是时间换空间的模式*/</span></div><div class="line">        instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong><br><strong>2、懒汉式，线程安全</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="comment">//加同步锁</span></div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;   </div><div class="line">        instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>3、饿汉式</strong><br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">                           <span class="comment">/*饿汉式标志：在类加载时直接初始化，</span></div><div class="line"><span class="comment">                           是空间换时间的模式*/</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>4、双检锁/双重校验锁（DCL，即 double-checked locking）</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。这种方法既能保证线程安全又能提高了效率。<br>假设线程1进入方法，instance为空，进入同步代码块，时间片切换，线程2进来，instance为空，在同步代码块外被阻塞，因为此时线程1正在里面。cup切换，线程1执行创建实例，当2再进入代码块后，此时instace不为空，直接返回instance。当再有线程进来，instance不为空，不用执行同步代码块，提高了效率。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </div><div class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">            singleton = <span class="keyword">new</span> Singleton();  </div><div class="line">        &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> singleton;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>5、登记式/静态内部类</strong><br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>6、枚举</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><strong>代码实例：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。  </p><h3 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h3><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h3><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><h3 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6.适配器模式"></a>6.适配器模式</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。  </p><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决：</strong>继承或依赖（推荐）。</p><p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p><p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/适配器模式.png" alt="fail"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>我们来看这样一个例子，笔记本(Laptop)需要三相插座(ThreePlugIf)充电，但是只有一个国标二相插座(GBTwoPlug),我们可以使用一个适配器来使用二相插座给笔记本充电。</p><p>(1)使用<strong>组合</strong>方式实现<strong>对象</strong>适配器<br>把“被适配者”作为一个对象组合到适配器类中，以修改目标接口包装“被适配者”。<br>ThreePlugIf.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 三相插座接口</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreePlugIf</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//使用三相电流供电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithThree</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>GBTwoPlug.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GBTwoPlug</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//使用二相电流供电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithTwo</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"使用二相电流供电"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>TwoPlugAdapter.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 二相转三相的插座适配器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPlugAdapter</span> <span class="keyword">implements</span> <span class="title">ThreePlugIf</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> GBTwoPlug plug;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TwoPlugAdapter</span><span class="params">(GBTwoPlug plug)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.plug = plug;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithThree</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"通过转化"</span>);</div><div class="line">plug.powerWithTwo();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Laptop.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> ThreePlugIf  plug;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(ThreePlugIf plug)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.plug = plug;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用插座充电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>&#123;</div><div class="line">plug.powerWithThree();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">GBTwoPlug two =  <span class="keyword">new</span> GBTwoPlug();</div><div class="line">ThreePlugIf three = <span class="keyword">new</span> TwoPlugAdapter(two);</div><div class="line">Laptop lp = <span class="keyword">new</span> Laptop(three);</div><div class="line">lp.charge();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>验证输出：<br>通过转化<br>使用二相电流供电  </p><p>分析：Laptop需要一个实现ThreePlugIf接口的对象来使用三相电流供电，我们就传入一个实现了该接口的适配器，看似调用了powerWithThree()方法，实际上是调用了组合在适配器里的GBTwoPlug的powerWithTwo()方法。</p><p>(2)使用<strong>继承</strong>方式实现<strong>类</strong>适配器<br>继承“被适配者”并实现目标接口。<br>TwoPlugAdapterExtends.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 采用继承方式的插座适配器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoPlugAdapterExtends</span> <span class="keyword">extends</span> <span class="title">GBTwoPlug</span> <span class="keyword">implements</span> <span class="title">ThreePlugIf</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerWithThree</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"借助继承适配器"</span>);</div><div class="line"><span class="keyword">this</span>.powerWithTwo();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Laptop.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> ThreePlugIf  plug;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(ThreePlugIf plug)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.plug = plug;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用插座充电</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>&#123;</div><div class="line">plug.powerWithThree();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">three = <span class="keyword">new</span> TwoPlugAdapterExtends();</div><div class="line">lp = <span class="keyword">new</span> Laptop(three);</div><div class="line">lp.charge();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>验证输出：<br>借助继承适配器<br>使用二相电流供电</p><p>两种方法比较，组合适配可以适配”被适配者”的任何子类(根据多态机制可以给适配器中的GBTwoPlug赋予GBTwoPlug的任何子类的引用)，但继承适配是为单一的类服务的(已经继承了GBTwoPlug，不能再继承它的子类)，只能适配”被适配者”。</p><h3 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7.桥接模式"></a>7.桥接模式</h3><h3 id="8-过滤器模式"><a href="#8-过滤器模式" class="headerlink" title="8.过滤器模式"></a>8.过滤器模式</h3><h3 id="9-组合模式"><a href="#9-组合模式" class="headerlink" title="9.组合模式"></a>9.组合模式</h3><h3 id="10-装饰器模式"><a href="#10-装饰器模式" class="headerlink" title="10.装饰器模式"></a>10.装饰器模式</h3><h3 id="11-外观模式"><a href="#11-外观模式" class="headerlink" title="11.外观模式"></a>11.外观模式</h3><h3 id="12-享元模式"><a href="#12-享元模式" class="headerlink" title="12.享元模式"></a>12.享元模式</h3><h3 id="13-代理模式"><a href="#13-代理模式" class="headerlink" title="13.代理模式"></a>13.代理模式</h3><p>在代理模式（Proxy Pattern）中，代理对象为其他对象提供代理以控制对被代理对象的访问。代理对象起到中介作用，可去掉功能服务或增加额外的服务，这种类型的设计模式属于结构型模式。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p><p><strong>如何解决：</strong>增加中间层。</p><p><strong>关键代码：</strong>实现与被代理类<strong>组合</strong>。</p><p><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p><p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p><p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><p><strong>使用场景：</strong>按职责来划分，通常有以下使用场景：<br>1、远程代理。为不同地理的对象提供局域网代表对象。比如通过远程代理监控分店的库存和销售情况。<br>2、虚拟代理。根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建。<br>3、Copy-on-Write 代理。<br>4、保护（Protect or Access）代理。即控制对一个对象的访问权限。比如论坛游客和用户的权限。<br>5、Cache代理。<br>6、防火墙（Firewall）代理。<br>7、同步化（Synchronization）代理。<br>8、智能引用（Smart Reference）代理。提供对目标对象额外的服务。</p><p><strong>注意事项： </strong><a href="http://blog.csdn.net/lulei9876/article/details/39994825" target="_blank" rel="external">菜鸟版JAVA设计模式—适配器模式，装饰模式，代理模式异同</a></p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>我们来看这样一个例子，一辆车有行驶的功能，现在通过代理模式新增记录行驶时间的功能。</p><h4 id="代理模式分类"><a href="#代理模式分类" class="headerlink" title="代理模式分类"></a>代理模式分类</h4><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>代理和被代理对象在代理之前是确定的。它们都实现相同的接口或者继承相同的抽象类。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/静态代理.png" alt="fail"><br><strong>1) 通过继承的方式实现静态代理</strong>  </p><p><strong>步骤 1</strong><br>定义Moveable接口  </p><p>Moveable.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>定义Car类实现Moveable接口  </p><p>Car.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//实现开车</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">System.out.println(<span class="string">"汽车行驶中...."</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>定义代理类Car2类继承被代理类Car，并增加记录时间功能  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car2</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">long</span> starttime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车开始行驶...."</span>);</div><div class="line"><span class="keyword">super</span>.move();</div><div class="line"><span class="keyword">long</span> endtime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车结束行驶....  汽车行驶时间："</span> </div><div class="line">+ (endtime - starttime) + <span class="string">"毫秒！"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>步骤 4</strong><br>定义测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试类</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Moveable m = <span class="keyword">new</span> Car2();</div><div class="line">m.move();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>2) 通过聚合的方式实现静态代理</strong>  </p><p><strong>步骤 1</strong><br>定义Moveable接口  </p><p>Moveable.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>定义Car类实现Moveable接口  </p><p>Car.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//实现开车</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">System.out.println(<span class="string">"汽车行驶中...."</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>定义代理类Car3类实现Moveable接口并聚合被代理类Car，增加记录时间功能  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car3</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> Car car;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car3</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.car = car;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">long</span> starttime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车开始行驶...."</span>);</div><div class="line">car.move();</div><div class="line"><span class="keyword">long</span> endtime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车结束行驶....  汽车行驶时间："</span> </div><div class="line">+ (endtime - starttime) + <span class="string">"毫秒！"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>步骤 4</strong><br>定义测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试类</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Car car = <span class="keyword">new</span> Car();</div><div class="line">Moveable m = <span class="keyword">new</span> Car3(car);</div><div class="line">m.move();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比较两种实现静态代理的方式，会发现随着功能的扩展，使用继承的方式的代理类数量会膨胀，难以维护，而使用聚合的方式更加灵活。所以，<strong>聚合比继承更适合代理模式</strong>。   </p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在上面的例子中我们会发现一个问题，如果想要对自行车、火车等进行记录时间的代理，还需要创建自行车代理类、火车代理类等，如果有很多类需要代理，会造成代理类膨胀。<br>而动态代理能<strong>动态产生</strong>代理，实现对<strong>不同类</strong>,不同<strong>方法</strong>的代理。  </p><p><strong>1) 通过JDK实现动态代理</strong><br>JDK提供了动态代理的API。代理对象不需要实现目标接口，但目标对象必须实现目标接口。代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)，JDK动态代理也叫做接口代理。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/动态代理.png" alt="fail">    </p><p><img src="/2018/01/30/Java学习总结之设计模式/动态代理类1.png" alt="fail">  </p><p><img src="/2018/01/30/Java学习总结之设计模式/动态代理类2.png" alt="fail">    </p><p>我们用动态代理来实现上面的例子  </p><p><strong>步骤 1</strong><br>定义Moveable接口  </p><p>Moveable.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>定义Car类实现Moveable接口  </p><p>Car.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Moveable</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//实现开车</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</div><div class="line">System.out.println(<span class="string">"汽车行驶中...."</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>定义代理类TimeHandler实现InvocationHandler接口，聚合被代理类对象target  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.jdkproxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeHandler</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.target = target;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Object target; <span class="comment">//target对象是聚合在代理类里的目标对象(被代理对象)</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 参数：</span></div><div class="line"><span class="comment"> * proxy  代理对象</span></div><div class="line"><span class="comment"> * method  被代理对象的方法</span></div><div class="line"><span class="comment"> * args 方法的参数</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * 返回值：</span></div><div class="line"><span class="comment"> * Object  方法的返回值</span></div><div class="line"><span class="comment"> * */</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></div><div class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"><span class="keyword">long</span> starttime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车开始行驶...."</span>);</div><div class="line">method.invoke(target); <span class="comment">//被代理的target对象调用method方法，args为null可以不写</span></div><div class="line"><span class="keyword">long</span> endtime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车结束行驶....  汽车行驶时间："</span> </div><div class="line">+ (endtime - starttime) + <span class="string">"毫秒！"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">    <span class="comment">//获取代理对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">/** static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler)</span></div><div class="line"><span class="comment"> * loader  被代理类(Car)的类加载器</span></div><div class="line"><span class="comment"> * interfaces  被代理类(Car)实现的接口</span></div><div class="line"><span class="comment"> * 通过获取Car的类对象获取loader和interfaces</span></div><div class="line"><span class="comment"> * h 实现了InvocationHandler接口的代理类对象</span></div><div class="line"><span class="comment"> */</span></div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</div><div class="line">        target.getClass().getClassLoader(),   </div><div class="line">        target.getClass().getInterfaces(), <span class="keyword">this</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>步骤 4</strong><br>定义测试类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.jdkproxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.imooc.proxy.Car;</div><div class="line"><span class="keyword">import</span> com.imooc.proxy.Moveable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * JDK动态代理测试类</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 实例化目标对象</span></div><div class="line">Car car = <span class="keyword">new</span> Car();</div><div class="line">        <span class="comment">// 实例化InvocationHandler</span></div><div class="line">InvocationHandler h = <span class="keyword">new</span> TimeHandler(car);</div><div class="line">        <span class="comment">// 获取代理对象</span></div><div class="line">Moveable m = (Moveable)h.getProxy();</div><div class="line">        <span class="comment">// 调用代理方法</span></div><div class="line">m.move();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面步骤 3可以直接定义一个动态代理工厂类ProxyFactory，把InvocationHandler作为ProxyFactory的匿名内部类。即：  </p><p>ProxyFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.jdkproxy;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeHandler</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.target = target;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Object target; </div><div class="line"></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">//获取代理对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</div><div class="line">        target.getClass().getClassLoader(),</div><div class="line">        target.getClass().getInterfaces(),</div><div class="line">        <span class="keyword">new</span> InvocationHandler()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[]</span></span></div><div class="line"><span class="function"><span class="params">        args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">long</span> starttime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车开始行驶...."</span>);</div><div class="line">method.invoke(target); <span class="comment">//被代理的target对象调用method方法，args为null可以不写</span></div><div class="line"><span class="keyword">long</span> endtime = System.currentTimeMillis();</div><div class="line">System.out.println(<span class="string">"汽车结束行驶....  汽车行驶时间："</span> </div><div class="line">+ (endtime - starttime) + <span class="string">"毫秒！"</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//方法无返回值,返回null</span></div><div class="line">        &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2018/01/30/Java学习总结之设计模式/DP.png" alt="fail"><br><img src="/2018/01/30/Java学习总结之设计模式/step.png" alt="fail"><br>拓展：  </p><ul><li><a href="http://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="external">Java的三种代理模式</a></li><li><a href="http://blog.csdn.net/bu2_int/article/details/60150319" target="_blank" rel="external">InvocationHandler中invoke方法中的第一个参数proxy的用途</a> </li><li><a href="http://blog.csdn.net/pangqiandou/article/details/52964066" target="_blank" rel="external">java中Proxy(代理与动态代理)</a>  </li><li><a href="http://layznet.iteye.com/blog/1182924" target="_blank" rel="external">java静态代理和动态代理</a>    </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li></ul><p><strong>JDK动态代理的简易实现</strong><br>实现功能：通过Proxy的newProxyInstance返回代理对象  </p><p>（1）声明一段源码（动态产生代理）<br>（2）编译源码（JDK Compiler API），产生新的类（代理类）<br>（3）将这个类load到内存当中，产生一个新的对象（代理对象）<br>（4）return代理对象<br>具体见慕课视频：<a href="https://www.imooc.com/video/4903" target="_blank" rel="external">模拟JDK动态代理实现思路分析</a><br><strong>总结：</strong>代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用JDK动态代理  </p><p><strong>2) 使用cglib实现动态代理</strong><br>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候就可以使用以目标对象子类的方式类实现代理，这种方法就叫做Cglib代理。  </p><p>Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。  </p><p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。  </p><p>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)。</p><p>Cglib子类代理实现方法:<br>1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可。<br>2.引入功能包后,就可以在内存中动态构建子类。<br>3.代理的类不能为final,否则报错。<br>4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/区别.png" alt="fail">  </p><p>Train.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 目标对象,没有实现任何接口</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Train</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"火车行驶中..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ProxyFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Cglib子类代理工厂，实现MethodInterceptor接口  </span></div><div class="line"><span class="comment"> * 设置Cglib子类的父类为目标对象的类</span></div><div class="line"><span class="comment"> * 对Train在内存中动态构建一个子类对象</span></div><div class="line"><span class="comment"> * 重写intercept方法对目标父类的方法调用进行拦截</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</div><div class="line">    <span class="comment">//维护目标对象</span></div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//给目标对象创建一个代理对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//1.创建加强器，用来创建动态代理类</span></div><div class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</div><div class="line">        <span class="comment">//2.为加强器指定要代理的业务类（即为下面生成的代理类指定父类）</span></div><div class="line">        en.setSuperclass(target.getClass());</div><div class="line">        <span class="comment">//3.设置回调：在调用目标方法时，CgLib会回调intercept方法进行拦截，来实现你自己的代理逻辑</span></div><div class="line">        en.setCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//4.创建动态代理类对象并返回  </span></div><div class="line">        <span class="keyword">return</span> en.create();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">`<span class="comment">/**</span></div><div class="line"><span class="comment"> * 拦截所有目标父类方法的调用</span></div><div class="line"><span class="comment"> * obj  目标类的实例</span></div><div class="line"><span class="comment"> * method   目标方法的反射对象</span></div><div class="line"><span class="comment"> * args  方法的参数</span></div><div class="line"><span class="comment"> * proxy 代理类的实例</span></div><div class="line"><span class="comment"> */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"日志开始..."</span>);</div><div class="line"><span class="comment">//代理类调用父类的方法</span></div><div class="line">proxy.invokeSuper(obj, args);</div><div class="line">System.out.println(<span class="string">"日志结束..."</span>);</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//方法无返回值，返回null</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Client.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试类</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//目标对象</span></div><div class="line">        Train target = <span class="keyword">new</span> Train();</div><div class="line"></div><div class="line">        <span class="comment">//代理对象</span></div><div class="line">        Train proxy = </div><div class="line">        (Train)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</div><div class="line"></div><div class="line">        <span class="comment">//执行代理对象的方法</span></div><div class="line">        proxy.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><h3 id="14-责任链模式"><a href="#14-责任链模式" class="headerlink" title="14.责任链模式"></a>14.责任链模式</h3><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。<br>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p><p><strong>如何解决：</strong>拦截的类都实现统一接口。</p><p><strong>关键代码：</strong>Handler里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 4.JAVA 的异常链机制</p><p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><p><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/责任链模式.png" alt="fail"></p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>我们以销售楼盘为例，客户是Customer类，发送一个折扣请求给责任链。责任链由楼盘各级人员组成，都继承自PriceHandler抽象类，自底向上为Sales(销售)、Lead(销售小组长)、Manager(销售经理)、Director(销售总监)、VicePresident(销售副总裁)、CEO(首席执行官)。沿着责任链，能批准折扣的力度依次上升。  </p><p><strong>步骤 1</strong> 创建PriceHandler抽象类<br>PriceHandler.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 价格处理人，负责处理客户折扣申请</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 直接后继，用于传递请求</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">protected</span> PriceHandler successor;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(PriceHandler successor)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.successor = successor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 处理折扣申请</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">processDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong> 创建PriceHandler的具体类<br>Sales.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 销售， 可以批准5%以内的折扣</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sales</span> <span class="keyword">extends</span> <span class="title">PriceHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(discount &lt;= <span class="number">0.05</span>)&#123;</div><div class="line">System.out.format(<span class="string">"%s批准了折扣：%.2f%n"</span>, <span class="keyword">this</span>.getClass().getName(), discount);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">successor.processDiscount(discount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Lead.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 销售小组长， 可以批准15%以内的折扣</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lead</span> <span class="keyword">extends</span> <span class="title">PriceHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(discount&lt;=<span class="number">0.15</span>)&#123;</div><div class="line">System.out.format(<span class="string">"%s批准了折扣:%.2f%n"</span>,<span class="keyword">this</span>.getClass().getName(),discount);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">successor.processDiscount(discount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Manager.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 销售经理， 可以批准30%以内的折扣</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">PriceHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(discount&lt;=<span class="number">0.3</span>)&#123;</div><div class="line">System.out.format(<span class="string">"%s批准了折扣:%.2f%n"</span>,<span class="keyword">this</span>.getClass().getName(),discount);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">successor.processDiscount(discount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Director.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 销售总监， 可以批准40%以内的折扣</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">PriceHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(discount&lt;=<span class="number">0.4</span>)&#123;</div><div class="line">System.out.format(<span class="string">"%s批准了折扣:%.2f%n"</span>,<span class="keyword">this</span>.getClass().getName(),discount);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">successor.processDiscount(discount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>VicePresident.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 销售副总裁， 可以批准50%以内的折扣</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VicePresident</span> <span class="keyword">extends</span> <span class="title">PriceHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(discount&lt;=<span class="number">0.5</span>)&#123;</div><div class="line">System.out.format(<span class="string">"%s批准了折扣:%.2f%n"</span>,<span class="keyword">this</span>.getClass().getName(),discount);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">successor.processDiscount(discount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>CEO.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * CEO， 可以批准55%以内的折扣</span></div><div class="line"><span class="comment"> * 折扣超出55%， 就拒绝申请</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> <span class="keyword">extends</span> <span class="title">PriceHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(discount&lt;=<span class="number">0.55</span>)&#123;</div><div class="line">System.out.format(<span class="string">"%s批准了折扣:%.2f%n"</span>,<span class="keyword">this</span>.getClass().getName(),discount);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">System.out.format(<span class="string">"%s拒绝了折扣:%.2f%n"</span>, <span class="keyword">this</span>.getClass().getName(),discount);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong> 创建PriceHandlerFactory类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor.handler;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceHandlerFactory</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 创建PriceHandler的工厂方法，类似于构建链表并返回表头</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PriceHandler <span class="title">createPriceHandler</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">PriceHandler sales = <span class="keyword">new</span> Sales();</div><div class="line">PriceHandler lead = <span class="keyword">new</span> Lead();</div><div class="line">PriceHandler man = <span class="keyword">new</span> Manager();</div><div class="line">PriceHandler dir = <span class="keyword">new</span> Director();</div><div class="line">PriceHandler vp = <span class="keyword">new</span> VicePresident();</div><div class="line">PriceHandler ceo = <span class="keyword">new</span> CEO();</div><div class="line"></div><div class="line">sales.setSuccessor(lead);</div><div class="line">lead.setSuccessor(man);</div><div class="line">man.setSuccessor(dir);</div><div class="line">dir.setSuccessor(vp);</div><div class="line">vp.setSuccessor(ceo);</div><div class="line"></div><div class="line"><span class="keyword">return</span> sales;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong> 创建Customer类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.imooc.pattern.cor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> com.imooc.pattern.cor.handler.PriceHandler;</div><div class="line"><span class="keyword">import</span> com.imooc.pattern.cor.handler.PriceHandlerFactory;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 客户，请求折扣</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> PriceHandler priceHandler;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriceHandler</span><span class="params">(PriceHandler priceHandler)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.priceHandler = priceHandler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDiscount</span><span class="params">(<span class="keyword">float</span> discount)</span></span>&#123;</div><div class="line">priceHandler.processDiscount(discount);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">Customer customer = <span class="keyword">new</span> Customer();</div><div class="line">customer.setPriceHandler(PriceHandlerFactory.createPriceHandler());</div><div class="line"></div><div class="line">Random rand = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</div><div class="line">System.out.print(i+<span class="string">":"</span>);</div><div class="line">customer.requestDiscount(rand.nextFloat());</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="15-命令模式"><a href="#15-命令模式" class="headerlink" title="15.命令模式"></a>15.命令模式</h3><h3 id="16-解释器模式"><a href="#16-解释器模式" class="headerlink" title="16.解释器模式"></a>16.解释器模式</h3><h3 id="17-迭代器模式"><a href="#17-迭代器模式" class="headerlink" title="17.迭代器模式"></a>17.迭代器模式</h3><h3 id="18-中介者模式"><a href="#18-中介者模式" class="headerlink" title="18.中介者模式"></a>18.中介者模式</h3><h3 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19.备忘录模式"></a>19.备忘录模式</h3><h3 id="20-观察者模式"><a href="#20-观察者模式" class="headerlink" title="20.观察者模式"></a>20.观察者模式</h3><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象，被通知的对象会做出各自的反应。观察者模式属于行为型模式。  </p><h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，进行广播通知，所有的依赖对象（观察者对象）都将得到通知并做出各自的反应。</p><p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的，被观察者只知道观察者接口，不知道具体的观察者类，实现了被观察者类和具体观察者类的解耦。 2、建立一套触发机制，实现了动态联动。<br>3、支持广播通信。</p><p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>使用场景：</strong> 1、一个抽象模型有两个方面，其中一个方面的操作(观察者)依赖于另一个方面状态的变化(被观察者)。 2、如果在更改一个对象的时候，需要同时连带改变其他对象，而且不知道究竟有多少对象需要被连带改变。 3、当一个对象必须通知其他对象，而又希望这个对象和其他被通知的对象是松散耦合的。</p><p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br>ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/观察者模式.jpg" alt="fail">  </p><h4 id="观察者模式实现的两种方式"><a href="#观察者模式实现的两种方式" class="headerlink" title="观察者模式实现的两种方式"></a>观察者模式实现的两种方式</h4><p><strong>1) 推模型</strong><br>目标对象主动向观察者推送目标的详细信息，推送的信息通常是目标或目标对象的全部数据。一般这种模型的实现中，会把目标对象想要推送的信息通过update方法传递给观察者。<br><strong>步骤 1</strong><br>创建 Subject 类(目标类、被观察者类)<br>Subject.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> List&lt;Observer&gt; observers </div><div class="line">      = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.state = state;</div><div class="line">      notifyAllObservers(state);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</div><div class="line">      observers.add(observer);        </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>&#123;</div><div class="line">     observers.remove(observer);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">(<span class="keyword">int</span> state)</span></span>&#123;</div><div class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</div><div class="line">         observer.update(state);</div><div class="line">      &#125;</div><div class="line">   &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建 Observer 类  </p><p>Observer.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> state)</span></span>; <span class="comment">//传递要推送的信息，观察者只能接收到目标推送的数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>创建实体观察者类  </p><p>BinaryObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">      System.out.println( <span class="string">"Binary String: "</span> </div><div class="line">      + Integer.toBinaryString(state)); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OctalObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">     System.out.println( <span class="string">"Octal String: "</span> </div><div class="line">     + Integer.toOctalString(state)); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HexaObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">      System.out.println( <span class="string">"Hex String: "</span> </div><div class="line">      + Integer.toHexString(state).toUpperCase()); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>使用 Subject 和实体观察者对象  </p><p>ObserverPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Subject subject = <span class="keyword">new</span> Subject();</div><div class="line">      Observer o1 = <span class="keyword">new</span> HexaObserver();</div><div class="line">      Observer o2 = <span class="keyword">new</span> OctalObserver();</div><div class="line">      Observer o3 = <span class="keyword">new</span> BinaryObserver();</div><div class="line">  subject.attach(o1);</div><div class="line">      subject.attach(o2);</div><div class="line">      subject.attach(o3);</div><div class="line">      System.out.println(<span class="string">"First state change: 15"</span>);    </div><div class="line">      subject.setState(<span class="number">15</span>);</div><div class="line">      System.out.println(<span class="string">"Second state change: 10"</span>);    </div><div class="line">      subject.setState(<span class="number">10</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>验证输出</p><p>First state change: 15<br>Hex String: F<br>Octal String: 17<br>Binary String: 1111<br>Second state change: 10<br>Hex String: A<br>Octal String: 12<br>Binary String: 1010  </p><p><strong>2) 拉模型</strong><br>目标对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于观察者从目标对象中拉数据。一般这种模型的实现中，会把目标对象自身的引用通过update方法传递给观察者。<br><strong>步骤 1</strong><br>创建 Subject 类(目标类、被观察者类)  </p><p>Subject.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> List&lt;Observer&gt; observers </div><div class="line">      = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> state;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.state = state;</div><div class="line">      notifyAllObservers();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</div><div class="line">      observers.add(observer);        </div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>&#123;</div><div class="line">     observers.remove(observer);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</div><div class="line">         observer.update(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建 Observer 类  </p><p>Observer.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line"><span class="comment">/*传递目标对象自身的引用，观察者可自己选择</span></div><div class="line"><span class="comment">    从目标对象中拉哪些数据*/</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject message)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>创建实体观察者类  </p><p>BinaryObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject message)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> state = message.getState(); </div><div class="line">      System.out.println( <span class="string">"Binary String: "</span> </div><div class="line">      + Integer.toBinaryString(state)); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OctalObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject message)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> state = message.getState(); </div><div class="line">     System.out.println( <span class="string">"Octal String: "</span> </div><div class="line">     + Integer.toOctalString(state)); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HexaObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject message)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> state = message.getState(); </div><div class="line">      System.out.println( <span class="string">"Hex String: "</span> </div><div class="line">      + Integer.toHexString(state).toUpperCase()); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>使用 Subject 和实体观察者对象  </p><p>ObserverPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Subject subject = <span class="keyword">new</span> Subject();</div><div class="line">      Observer o1 = <span class="keyword">new</span> HexaObserver();</div><div class="line">      Observer o2 = <span class="keyword">new</span> OctalObserver();</div><div class="line">      Observer o3 = <span class="keyword">new</span> BinaryObserver();</div><div class="line">  subject.attach(o1);</div><div class="line">      subject.attach(o2);</div><div class="line">      subject.attach(o3);</div><div class="line">      System.out.println(<span class="string">"First state change: 15"</span>);    </div><div class="line">      subject.setState(<span class="number">15</span>);</div><div class="line">      System.out.println(<span class="string">"Second state change: 10"</span>);    </div><div class="line">      subject.setState(<span class="number">10</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>验证输出</p><p>First state change: 15<br>Hex String: F<br>Octal String: 17<br>Binary String: 1111<br>Second state change: 10<br>Hex String: A<br>Octal String: 12<br>Binary String: 1010  </p><p><strong>两种模型的区别：</strong><br>1) 推模型由目标对象决定推送的信息，观察者不能获取推送信息之外目标对象的其他信息，较为被动。拉模型虽然仍是目标对象主动推送信息，但推送的是整个目标对象的引用，观察者可以选择性接收目标对象的信息。<br>2) 推模型一般用于目标对象知道观察者需要的数据;而拉模型则用于目标对象不知道观察者需要的数据，因此把自身传递给观察者，由观察者来取值。<br>3) 推模型会使观察者对象难以复用。拉模型下，update方法的参数是目标对象本身，基本上可以适应各种情况的需要。  </p><h4 id="利用Java提供的观察者实现"><a href="#利用Java提供的观察者实现" class="headerlink" title="利用Java提供的观察者实现"></a>利用Java提供的观察者实现</h4><p>Java提供了观察者模式的实现，有关类和接口是java.util包的Observable类和Observer接口。<br>和自己实现对比：<br>1.不需要自己定义观察者和目标接口了，JDK帮忙定义了<br>2.具体的目标实现里面不需要再维护观察者的注册信息了，这个在Java中的Observable类里面已经帮忙实现好了。<br>3.触发通知的方式有一点变化，要先调用setChanged方法,这个是Java为了帮助实现更精确的触发控制而实现的功能。<br>4.具体观察者的实现里面，update方法其实能同时支持推模型和拉模型，这个是Java在定义的时候，就已经考虑进去的了。</p><p>实现方法：<br>1、让具体Subject实现类继承Observable目标父类，Observable意为可被观察的，所以让具体目标类继承它。<br>2、让具体观察者实现类实现Observer接口，Observer意为观察者，所以让具体观察者实现类实现它。  </p><p><strong>步骤 1</strong><br>创建具体目标对象实现类继承Observable类<br>Subject.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Observable;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> state;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.state = state;</div><div class="line"><span class="comment">//通知观察者之前必须调用setChanged()</span></div><div class="line"><span class="keyword">this</span>.setChanged();</div><div class="line"></div><div class="line"><span class="comment">/*通知所有观察者，既传递目标对象引用给观察者，</span></div><div class="line"><span class="comment"> * 也传递参数给观察者update的第二个参数*/</span></div><div class="line"><span class="keyword">this</span>.notifyObservers(Integer.valueOf(state));</div><div class="line"></div><div class="line"><span class="comment">/* 重载方法的无参方法notifyObservers()</span></div><div class="line"><span class="comment"> * 通知所有观察者，但只是传递目标对象引用给观察者，</span></div><div class="line"><span class="comment"> * 观察者update的第二个参数为null</span></div><div class="line"><span class="comment"> * */</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建观察者的具体实现类实现Observer接口<br>BinaryObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Observable;</div><div class="line"><span class="keyword">import</span> java.util.Observer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Observable o是目标对象传递的引用，用于拉模型</span></div><div class="line"><span class="comment"> * Object arg是目标对象主动推送的信息，用于推模型</span></div><div class="line"><span class="comment"> * 如果目标对象使用带参的notifyObservers方法，</span></div><div class="line"><span class="comment"> * 则即可推也可拉;如果使用无参的notifyObservers方法，</span></div><div class="line"><span class="comment"> * 则只能拉</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line"><span class="comment">//1.推的方式</span></div><div class="line">System.out.println( <span class="string">"推模型：Binary String: "</span> </div><div class="line">    + Integer.toBinaryString(((Integer)arg).intValue())); </div><div class="line"><span class="comment">//2.拉的方式  </span></div><div class="line">System.out.println( <span class="string">"拉模型：Binary String: "</span> </div><div class="line">    + Integer.toBinaryString(((Subject)o).getState())); </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HexaObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Observable;</div><div class="line"><span class="keyword">import</span> java.util.Observer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line">System.out.println( <span class="string">"推模型：Hex String: "</span> </div><div class="line">    + Integer.toHexString(((Integer)arg).intValue()).toUpperCase()); </div><div class="line">System.out.println( <span class="string">"拉模型：Hex String: "</span> </div><div class="line">    + Integer.toHexString(((Subject)o).getState()).toUpperCase()); </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OctalObserver.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Observable;</div><div class="line"><span class="keyword">import</span> java.util.Observer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</div><div class="line">System.out.println( <span class="string">"推模型：Octal String: "</span> </div><div class="line">    + Integer.toOctalString(((Integer)arg).intValue())); </div><div class="line">System.out.println( <span class="string">"拉模型：Octal String: "</span> </div><div class="line">    + Integer.toOctalString(((Subject)o).getState())); </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>创建测试类<br>ObserverPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Observer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Subject subject = <span class="keyword">new</span> Subject();</div><div class="line">      Observer o1 = <span class="keyword">new</span> HexaObserver();</div><div class="line">      Observer o2 = <span class="keyword">new</span> BinaryObserver();</div><div class="line">      Observer o3 = <span class="keyword">new</span> OctalObserver();</div><div class="line">  subject.addObserver(o1); <span class="comment">//注册观察者</span></div><div class="line">  subject.addObserver(o2);</div><div class="line">  subject.addObserver(o3);</div><div class="line">      System.out.println(<span class="string">"First state change: 15"</span>);    </div><div class="line">      subject.setState(<span class="number">15</span>);</div><div class="line">      System.out.println(<span class="string">"Second state change: 10"</span>);    </div><div class="line">      subject.setState(<span class="number">10</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>验证输出<br>First state change: 15<br>推模型：Octal String: 17<br>拉模型：Octal String: 17<br>推模型：Binary String: 1111<br>拉模型：Binary String: 1111<br>推模型：Hex String: F<br>拉模型：Hex String: F<br>Second state change: 10<br>推模型：Octal String: 12<br>拉模型：Octal String: 12<br>推模型：Binary String: 1010<br>拉模型：Binary String: 1010<br>推模型：Hex String: A<br>拉模型：Hex String: A</p><h4 id="区别对待观察者模式"><a href="#区别对待观察者模式" class="headerlink" title="区别对待观察者模式"></a>区别对待观察者模式</h4><p>之前的观察者模式是目标对象无条件通知所有观察者对象，然而有时需要在特定条件下对特定的观察者进行通知。这是就需要观察者模式的变形 —— <strong>区别对待观察者模式</strong>。<br>具体实现只要修改Subject类的notifyAllObservers方法,对Observer的身份做特定判断，然后有条件的推送信息即可。  </p><h3 id="21-状态模式"><a href="#21-状态模式" class="headerlink" title="21.状态模式"></a>21.状态模式</h3><h3 id="22-空对象模式"><a href="#22-空对象模式" class="headerlink" title="22.空对象模式"></a>22.空对象模式</h3><h3 id="23-策略模式"><a href="#23-策略模式" class="headerlink" title="23.策略模式"></a>23.策略模式</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。  </p><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码：</strong>抽象出行为的共性作为一个策略接口，各种策略类实现这个接口。在调用这个行为的类中通过组合持有这个接口的对象，通过这个策略接口对象代理具体的行为。</p><p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p><p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。   </p><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br>StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br><img src="/2018/01/30/Java学习总结之设计模式/策略模式.jpg" alt="fail">  </p><p><strong>步骤 1</strong><br>创建一个接口。<br>Strategy.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建实现接口的实体类。<br>OperationAdd.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> num1 + num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OperationSubstract.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> num1 - num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OperationMultiply.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> num1 * num2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>创建 Context 类。<br>Context.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> Strategy strategy;<span class="comment">//组合一个策略接口对象</span></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</div><div class="line">      <span class="keyword">this</span>.strategy = strategy;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</div><div class="line">      <span class="comment">//用策略接口对象代理具体实现</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>使用 Context 来查看当它改变策略 Strategy 时的行为变化。<br>StrategyPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());        </div><div class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</div><div class="line"></div><div class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());        </div><div class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</div><div class="line"></div><div class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());        </div><div class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 5</strong><br>验证输出。<br>10 + 5 = 15<br>10 - 5 = 5<br>10 * 5 = 50</p><h3 id="24-模板模式"><a href="#24-模板模式" class="headerlink" title="24.模板模式"></a>24.模板模式</h3><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。  </p><h4 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p><p><strong>何时使用：</strong>有一些通用的方法。</p><p><strong>如何解决：</strong>将这些通用算法抽象出来。</p><p><strong>关键代码：</strong>准备一个抽象类，将部分逻辑以具体方法的形式实现，然后声明一些抽象方法交由子类实现剩余逻辑，用钩子方法给予子类更大的灵活性。最后将方法汇总为一个final的模板方法。</p><p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p><p><strong>优点：</strong> 1、封装性好，封装不变部分，扩展可变部分。 2、复用性好，提取公共代码，便于维护。 3、屏蔽细节，行为由父类控制，子类实现。</p><p><strong>缺点：</strong>1、每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。2、Java的单继承使得继承了其他父类子类难以实现对模板基类的继承。</p><p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。在模板方法内的步骤中，通用的方法在抽象基类里提供实现，特定的方法定义为抽象方法，延迟到子类中实现。</p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。<br>TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。  </p><p><img src="/2018/01/30/Java学习总结之设计模式/模板模式.jpg" alt="fail">  </p><p><strong>步骤 1</strong><br>创建一个抽象类，它的模板方法被设置为 final。<br>Game.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</div><div class="line">   <span class="comment">//如果子类通用，可以在抽象基类实现，不必定义为抽象方法</span></div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">//模板,定义为final，防止被子类重写</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">//初始化游戏</span></div><div class="line">      initialize();</div><div class="line"></div><div class="line">      <span class="comment">//开始游戏</span></div><div class="line">      startPlay();</div><div class="line"></div><div class="line">      <span class="comment">//结束游戏</span></div><div class="line">      endPlay();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 2</strong><br>创建扩展了上述类的实体类。<br>Cricket.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Football.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 3</strong><br>使用 Game 的模板方法 play() 来演示游戏的定义方式。<br>TemplatePatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">      Game game = <span class="keyword">new</span> Cricket();</div><div class="line">      game.play();</div><div class="line">      System.out.println();</div><div class="line">      game = <span class="keyword">new</span> Football();</div><div class="line">      game.play();        </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>步骤 4</strong><br>验证输出。<br>Cricket Game Initialized! Start playing.<br>Cricket Game Started. Enjoy the game!<br>Cricket Game Finished!<br>Football Game Initialized! Start playing.<br>Football Game Started. Enjoy the game!<br>Football Game Finished!  </p><p>如果想要灵活选择模板中的某一步骤是否出现，可以添加一个钩子方法：比如在泡饮品的模板方法中，烧水——倒入饮品冲剂——加水——加调料。如果有的饮品不想要调料，可以在模板方法中把加调料放在if语句中，if的条件是一个返回值为boolean类型的方法，比如isCustomerWantsCondiments(),提供一个空的或者默认返回true的实现，称为钩子方法。子类可以根据需要重写该钩子方法选择要不要加调料。</p><h3 id="25-访问者模式"><a href="#25-访问者模式" class="headerlink" title="25.访问者模式"></a>25.访问者模式</h3><h3 id="J2EE模式"><a href="#J2EE模式" class="headerlink" title="J2EE模式"></a>J2EE模式</h3><h3 id="26-MVC-模式"><a href="#26-MVC-模式" class="headerlink" title="26.MVC 模式"></a>26.MVC 模式</h3><h3 id="27-业务代表模式"><a href="#27-业务代表模式" class="headerlink" title="27.业务代表模式"></a>27.业务代表模式</h3><h3 id="28-组合实体模式"><a href="#28-组合实体模式" class="headerlink" title="28.组合实体模式"></a>28.组合实体模式</h3><h3 id="29-数据访问对象模式"><a href="#29-数据访问对象模式" class="headerlink" title="29.数据访问对象模式"></a>29.数据访问对象模式</h3><h3 id="30-前端控制器模式"><a href="#30-前端控制器模式" class="headerlink" title="30.前端控制器模式"></a>30.前端控制器模式</h3><h3 id="31-拦截过滤器模式"><a href="#31-拦截过滤器模式" class="headerlink" title="31.拦截过滤器模式"></a>31.拦截过滤器模式</h3><h3 id="32-服务定位器模式"><a href="#32-服务定位器模式" class="headerlink" title="32.服务定位器模式"></a>32.服务定位器模式</h3><h3 id="33-传输对象模式"><a href="#33-传输对象模式" class="headerlink" title="33.传输对象模式"></a>33.传输对象模式</h3><p>参考资料：菜鸟教程之设计模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;设计模式概述&quot;&gt;&lt;a href=&quot;#设计模式概述&quot; class=&quot;headerlink&quot; title=&quot;设计模式概述&quot;&gt;&lt;/a&gt;设计模式概述&lt;/h3&gt;&lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://habitdiary.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shell脚本对拍</title>
    <link href="http://habitdiary.cn/2017/12/02/Linux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E5%AF%B9%E6%8B%8D/"/>
    <id>http://habitdiary.cn/2017/12/02/Linux下shell脚本对拍/</id>
    <published>2017-12-01T16:14:43.000Z</published>
    <updated>2017-12-01T16:47:50.024Z</updated>
    
    <content type="html"><![CDATA[<p>在算法竞赛中，我们常常会遇到一道题一直WA的情况，这时我们不得不自己造样例，这会耗费大量时间，而且还不一定能快速确定样例的答案。所以，如果时间充足，可以写一个对拍程序。<br>对拍程序需要四个文件：<br>1.我们已经写好但WA的待测试文件，记为code.cpp<br>2.一个纯暴力程序(复杂度高但能保证答案一定正确)，记为std.cpp<br>3.一个数据生成器(用srand函数和rand函数产生随机数即可)，记为data.cpp<br>4.一个用于比较输出的shell脚本,记为duipai.sh<br>对拍程序，顾名思义，就是随机生成数据给两个程序分别跑一遍，看看对不对的上。  </p><p>我们以一个计算1到n的和的程序为例，我们都知道计算1到n的暴力方法是用循环加和，简便方法则是使用等差数列求和公式。  </p><p>下面是待测试程序code.cpp(等比数列求和,当然这里没有WA)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> n;</div><div class="line">  <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;n * (n + <span class="number">1</span>) / <span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面是暴力求和程序std.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> n;</div><div class="line">  <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</div><div class="line">   ans += i;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后是随机数据生成器data.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  srand(time(<span class="number">0</span>));</div><div class="line">  <span class="keyword">int</span> n = <span class="number">100</span>;</div><div class="line">  <span class="keyword">while</span>(n--)&#123;</div><div class="line">  <span class="keyword">int</span> k = rand() % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">//生成100个[1,10]的随机数</span></div><div class="line">  <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>rand函数和srand函数的用法有点忘了，参见：<a href="https://www.cnblogs.com/guihailiuli/p/4154416.html" target="_blank" rel="external">有关rand()，srand()产生随机数学习总结</a> </p><p>最后是duipai.sh<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></div><div class="line">    ./data &gt; data.in</div><div class="line">    ./std &lt;data.in &gt;std.out</div><div class="line">    ./code &lt;data.in &gt;code.out</div><div class="line">    <span class="keyword">if</span> diff std.out code.out; <span class="keyword">then</span></div><div class="line">        <span class="built_in">printf</span> <span class="string">"AC\n"</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span> <span class="string">"Wa\n"</span></div><div class="line">        <span class="built_in">exit</span> 0</div><div class="line">    <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p><p>这个程序的意思是运行三个可执行文件，比较std.out code.out是否相同，相同输出”AC”，不相同输出错误信息，并输出”WA”且退出。  </p><p>下面开始跑对拍，先用g++编译三个cpp文件，<code>g++ code.cpp -o code</code>,<code>g++ std.cpp -o std</code>,<code>g++ data.cpp -o data</code>。<code>g++ code.cpp -o code</code>表示将code.cpp编译并连接生成一个名为code的可执行文件，如果不加 -o 选项，所有cpp文件都默认生成一个名为a.out的可执行文件。通过<code>./a.out</code>可以运行这个可执行文件,<code>./</code>表示当前目录。如果加上 -c 选项，如<code>g++ -c code.cpp -o code</code>则只编译不连接，会产生一个obj文件而不是exe文件。  </p><p>编译完成后，输入<code>sh duipai.sh</code>即得结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在算法竞赛中，我们常常会遇到一道题一直WA的情况，这时我们不得不自己造样例，这会耗费大量时间，而且还不一定能快速确定样例的答案。所以，如果时间充足，可以写一个对拍程序。&lt;br&gt;对拍程序需要四个文件：&lt;br&gt;1.我们已经写好但WA的待测试文件，记为code.cpp&lt;br&gt;2.
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://habitdiary.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用jsoup简易爬取POJ题面</title>
    <link href="http://habitdiary.cn/2017/12/01/%E4%BD%BF%E7%94%A8jsoup%E7%AE%80%E6%98%93%E7%88%AC%E5%8F%96POJ%E9%A2%98%E9%9D%A2/"/>
    <id>http://habitdiary.cn/2017/12/01/使用jsoup简易爬取POJ题面/</id>
    <published>2017-12-01T15:16:14.000Z</published>
    <updated>2017-12-03T13:43:35.630Z</updated>
    
    <content type="html"><![CDATA[<p>最近校创的项目终于立项啦！一直在等答辩通知，结果无需答辩直接立项2333。马上和队友开始着手项目，目标是做一个基于习题推荐的算法分类学习平台，简单来说就是一个根据用户历史做题情况自动推荐相应难度或类型题目的Online Judge。作为ACM校队的弱菜，正好造福一下学弟学妹ORZ<br>当然，作为一个新兴的OJ，肯定是没有题目来源的，所以我们把罪恶的双手(嘘~)伸向了一些目前主流的OJ。我们需要用爬虫技术爬取这些OJ的题面，并提取总提交数和通过数来计算AC率，从而把AC率作为题目难度的一个指标，以便后续实现题目推荐。<br>之前没有写过爬虫，队友告诉我Java可以用jsoup库很方便地解析html网页的元素。于是粗略学习了jsoup,再配合一点CSS选择器的知识，这对于一般的html网页的爬取就够用了，下面是几个学习的网站：<br><a href="http://www.open-open.com/jsoup/" target="_blank" rel="external">jsoup Cookbook(中文版)</a><br><a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="external">CSS 选择器</a></p><p>我分到的是<a href="http://poj.org/" target="_blank" rel="external">POJ</a>，打开Problems，选择第一道题，即<a href="http://poj.org/problem?id=1000" target="_blank" rel="external">A+B Problem</a>。查看网页的源代码发现TABLE标签之后的table标签恰好包括了所有我需要的信息(POJ真友好啊)，将爬到的内容重定向到一个html文件，我们就得到了题面。核心代码只有几行，不多说上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</div><div class="line"><span class="keyword">import</span> org.jsoup.nodes.Node;</div><div class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Crawler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pid = <span class="number">1000</span>;pid &lt;= <span class="number">1100</span>;pid++) &#123;</div><div class="line">Document doc = Jsoup.connect(<span class="string">"http://poj.org/"</span></div><div class="line">                    +<span class="string">"problem?id="</span> + pid).get();</div><div class="line">        Elements text = doc.select(<span class="string">"TABLE+table"</span>);</div><div class="line">        <span class="comment">//选择TABLE标签之后的table标签</span></div><div class="line">    text.select(<span class="string">".ptt"</span>).attr(<span class="string">"align"</span>, <span class="string">"center"</span>);</div><div class="line">        <span class="comment">//题目没有居中，添加居中属性</span></div><div class="line">        Elements image = text.select(<span class="string">"img"</span>);</div><div class="line"><span class="keyword">for</span>(Element e:image) &#123;</div><div class="line">String href = e.attr(<span class="string">"src"</span>);</div><div class="line">e.attr(<span class="string">"src"</span>,<span class="string">"http://poj.org/"</span>+href);</div><div class="line">        &#125;</div><div class="line">       <span class="comment">/*图片在poj服务器上，必须修改图片路径为</span></div><div class="line"><span class="comment">         绝对路径，否则无法显示*/</span></div><div class="line">        System.setOut(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> </div><div class="line">                      FileOutputStream(<span class="string">"problem"</span>+pid+<span class="string">".html"</span>)));</div><div class="line">        System.out.println(text);</div><div class="line">      <span class="comment">//重定向输出到html文件</span></div><div class="line">            &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>耐心等待爬取题目编号为1000到1100的题目,显示如下：<br><img src="/2017/12/01/使用jsoup简易爬取POJ题面/1.png" alt="fail"><br>用浏览器打开problem1000.html，效果如下：<br><img src="/2017/12/01/使用jsoup简易爬取POJ题面/2.png" alt="fail"><br>大功告成！！！  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近校创的项目终于立项啦！一直在等答辩通知，结果无需答辩直接立项2333。马上和队友开始着手项目，目标是做一个基于习题推荐的算法分类学习平台，简单来说就是一个根据用户历史做题情况自动推荐相应难度或类型题目的Online Judge。作为ACM校队的弱菜，正好造福一下学弟学妹
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
      <category term="爬虫" scheme="http://habitdiary.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之Java IO系统</title>
    <link href="http://habitdiary.cn/2017/11/28/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F/"/>
    <id>http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/</id>
    <published>2017-11-28T14:07:13.000Z</published>
    <updated>2018-02-21T12:18:58.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。  </p><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>JAVA中IO操作有相应步骤，以文件操作为例，主要操作流程如下：<br>1.使用File类打开一个文件<br>2.通过字节流或字符流的子类，指定输出的位置<br>3.进行读/写操作<br>4.关闭输入/输出  </p><p>那么我们先来介绍一下File类<br>Java文件类在Java.io包中，它以<strong>抽象</strong>的方式代表文件名和目录路径名。该类主要用于获取文件和目录的<strong>属性</strong>，文件和目录的<strong>创建、查找、删除、重命名</strong>等,但<strong>不能</strong>进行文件的<strong>读写操作</strong>。<br>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。  </p><p>通过给定的<strong>父抽象路径名</strong>和<strong>子路径名字符串</strong>创建一个新的File实例。<br><code>File(File parent, String child)</code>  </p><p>通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。<br><code>File(String pathname)</code>  </p><p>根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。<br><code>File(String parent, String child)</code>  </p><p>通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。<br><code>File(URI uri)</code>  </p><p><strong>注意：</strong><br>1.在各个操作系统中，路径的分隔符是不一样的，例如：Windows中使用反斜杠：”<code>\</code>“，Linux|Unix中使用正斜杠：”<code>/</code>“。在使用反斜杠时要写成”<code>\\</code>“的形式，因为反斜杠要进行转义。如果要让Java保持可移植性，应该使用File类的静态常量File.pathSeparator。<br>2.<strong>构建一个File实例并不会在机器上创建一个文件。</strong>不管文件是否存在，都可以创建任意文件名的File实例。可以调用File实例上的exists()方法来判断这个文件是否存在。通过后续的学习我们会知道，当把一个输出流绑定到一个不存在的File实例上时，会自动在机器上创建该文件，如果文件已经存在，把输出流绑定到该文件上则会覆盖该文件，但这些都不是在创建File实例时进行的。</p><p>创建File对象成功后，可以使用以下列表中的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/File1.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File2.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File3.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File4.png" alt="fail">  </p><p>下面给出一个使用File类的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      String dirname = <span class="string">"/java"</span>;</div><div class="line">      File f1 = <span class="keyword">new</span> File(dirname);</div><div class="line">      <span class="keyword">if</span> (f1.isDirectory()) &#123;</div><div class="line">         System.out.println( <span class="string">"Directory of "</span> + dirname);</div><div class="line">         String s[] = f1.list();</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">            File f = <span class="keyword">new</span> File(dirname + <span class="string">"/"</span> + s[i]);</div><div class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</div><div class="line">               System.out.println(s[i] + <span class="string">" is a directory"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               System.out.println(s[i] + <span class="string">" is a file"</span>);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         System.out.println(dirname + <span class="string">" is not a directory"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>小贴士：</strong>lastModified()方法返回的是从时间戳(1970年1月1日0时0分0秒)到当前的毫秒数，返回值类型是long，可以用Date类对它进行包装使其更易读。</p><h3 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h3><p><strong>创建目录：</strong><br>File类中有两个方法可以用来创建文件夹：</p><ul><li>mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li><li>mkdirs()方法创建一个文件夹和它的所有父文件夹。<br>下面的例子创建 “/tmp/user/java/bin”文件夹：  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDir</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    String dirname = <span class="string">"/tmp/user/java/bin"</span>;</div><div class="line">    File d = <span class="keyword">new</span> File(dirname);</div><div class="line">    <span class="comment">// 现在创建目录</span></div><div class="line">    d.mkdirs();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>mkdirs是递归创建文件夹，允许在创建某文件夹时其父文件夹不存在,从而一同创建;mkdir必须满足路径上的父文件夹全都存在</strong><br><strong>注意：</strong> Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。<br><strong>读取目录：</strong><br>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。<br>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。<br>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。<br>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    String dirname = <span class="string">"/tmp"</span>;</div><div class="line">    File f1 = <span class="keyword">new</span> File(dirname);</div><div class="line">    <span class="keyword">if</span> (f1.isDirectory()) &#123;</div><div class="line">      System.out.println( <span class="string">"目录 "</span> + dirname);</div><div class="line">      String s[] = f1.list();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">        File f = <span class="keyword">new</span> File(dirname + <span class="string">"/"</span> + s[i]);</div><div class="line">        <span class="keyword">if</span> (f.isDirectory()) &#123;</div><div class="line">          System.out.println(s[i] + <span class="string">" 是一个目录"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          System.out.println(s[i] + <span class="string">" 是一个文件"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      System.out.println(dirname + <span class="string">" 不是一个目录"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>删除目录或文件：</strong><br>删除文件可以使用 java.io.File.delete() 方法。<br>以下代码会删除目录/tmp/java/，即便目录不为空。<br>测试目录结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/tmp/java/</div><div class="line">|-- <span class="number">1</span>.log</div><div class="line">|-- test</div></pre></td></tr></table></figure></p><p>deleteFolder是一个递归函数，类似于DFS思想<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteFileDemo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      <span class="comment">// 这里修改为自己的测试目录</span></div><div class="line">    File folder = <span class="keyword">new</span> File(<span class="string">"/tmp/java/"</span>);</div><div class="line">    deleteFolder(folder);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//删除文件及目录</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(File folder)</span> </span>&#123;</div><div class="line">    File[] files = folder.listFiles();</div><div class="line">        <span class="keyword">if</span>(files!=<span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">for</span>(File f: files) &#123;</div><div class="line">                <span class="keyword">if</span>(f.isDirectory()) &#123;</div><div class="line">                    deleteFolder(f);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    f.delete();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        folder.delete();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>RandomAccessFile不同于File，它提供了对文件内容的访问，可以<strong>读写文件且支持随机访问文件的任意位置</strong>。<br>RandomAccessFile读写用到文件指针，它的初始位置为0,可以用getFilePointer()方法获取文件指针的位置。下面是RandomAccessFile常用的方法。  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/RandomAccessFile.png" alt="fail"><br>public int read(int x) throws IOException 方法只读取一个字节，也就是x的低八位。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.RandomAccessFile ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo01</span></span>&#123;</div><div class="line"><span class="comment">// 所有的异常直接抛出，程序中不再进行处理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;<span class="comment">// 指定要操作的文件</span></div><div class="line">RandomAccessFile rdf = <span class="keyword">null</span> ;<span class="comment">// 声明RandomAccessFile类的对象</span></div><div class="line">rdf = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"rw"</span>) ;<span class="comment">// 读写模式，如果文件不存在，会自动创建</span></div><div class="line">String name = <span class="keyword">null</span> ;</div><div class="line"><span class="keyword">int</span> age = <span class="number">0</span> ;</div><div class="line">name = <span class="string">"zhangsan"</span> ;<span class="comment">// 字符串长度为8</span></div><div class="line">age = <span class="number">30</span> ;<span class="comment">// 数字的长度为4</span></div><div class="line">rdf.writeBytes(name) ;<span class="comment">// 将姓名写入文件之中</span></div><div class="line">rdf.writeInt(age) ;<span class="comment">// 将年龄写入文件之中</span></div><div class="line">name = <span class="string">"lisi    "</span> ;<span class="comment">// 字符串长度为8</span></div><div class="line">age = <span class="number">31</span> ;<span class="comment">// 数字的长度为4</span></div><div class="line">rdf.writeBytes(name) ;<span class="comment">// 将姓名写入文件之中</span></div><div class="line">rdf.writeInt(age) ;<span class="comment">// 将年龄写入文件之中</span></div><div class="line">name = <span class="string">"wangwu  "</span> ;<span class="comment">// 字符串长度为8</span></div><div class="line">age = <span class="number">32</span> ;<span class="comment">// 数字的长度为4</span></div><div class="line">rdf.writeBytes(name) ;<span class="comment">// 将姓名写入文件之中</span></div><div class="line">rdf.writeInt(age) ;<span class="comment">// 将年龄写入文件之中</span></div><div class="line">rdf.close() ;<span class="comment">// 关闭</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>写完之后，开始读取数据。写的时候可以将一个字符串写入，读的时候需要一个个的以字节的形式读取出来。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.RandomAccessFile ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo02</span></span>&#123;</div><div class="line"><span class="comment">// 所有的异常直接抛出，程序中不再进行处理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;<span class="comment">// 指定要操作的文件</span></div><div class="line">RandomAccessFile rdf = <span class="keyword">null</span> ;<span class="comment">// 声明RandomAccessFile类的对象</span></div><div class="line">rdf = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"r"</span>) ;<span class="comment">// 以只读的方式打开文件</span></div><div class="line">String name = <span class="keyword">null</span> ;</div><div class="line"><span class="keyword">int</span> age = <span class="number">0</span> ;</div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>] ;<span class="comment">// 开辟byte数组</span></div><div class="line"><span class="comment">// 读取第二个人的信息，意味着要空出第一个人的信息</span></div><div class="line">rdf.skipBytes(<span class="number">12</span>) ;<span class="comment">// 跳过第一个人的信息</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">b[i] = rdf.readByte() ;<span class="comment">// 读取一个字节</span></div><div class="line">&#125;</div><div class="line">name = <span class="keyword">new</span> String(b) ;<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">age = rdf.readInt() ;<span class="comment">// 读取数字</span></div><div class="line">System.out.println(<span class="string">"第二个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line"><span class="comment">// 读取第一个人的信息</span></div><div class="line">rdf.seek(<span class="number">0</span>) ;<span class="comment">// 指针回到文件的开头</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">b[i] = rdf.readByte() ;<span class="comment">// 读取一个字节</span></div><div class="line">&#125;</div><div class="line">name = <span class="keyword">new</span> String(b) ;<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">age = rdf.readInt() ;<span class="comment">// 读取数字</span></div><div class="line">System.out.println(<span class="string">"第一个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line">rdf.skipBytes(<span class="number">12</span>) ;<span class="comment">// 跳过第二个人的信息</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">b[i] = rdf.readByte() ;<span class="comment">// 读取一个字节</span></div><div class="line">&#125;</div><div class="line">name = <span class="keyword">new</span> String(b) ;<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">age = rdf.readInt() ;<span class="comment">// 读取数字</span></div><div class="line">System.out.println(<span class="string">"第三个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line">rdf.close() ;<span class="comment">// 关闭</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>结果如下：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/result.png" alt="fail"> </p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>在Java程序中所有的数据都是以<strong>流</strong>的方式进行<strong>传输或保存</strong>的，程序需要数据的时候要使用<strong>输入流</strong>读取数据，而当程序需要将一些数据保存起来的时候，就要使用<strong>输出流</strong>完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是<strong>字节文件</strong>。流涉及的领域很广：标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Stream.png" alt="fail"><br>流具有<strong>方向性</strong>，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。<br>可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Information.jpg" alt="fail"><br>先上一个<strong>Java IO流类层次图</strong>，如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/JavaIO流类层次图.png" alt="fail" title="Java IO流类层次图"><br>是不是被吓到了？没关系，我们将通过一个个例子来学习这些功能。  </p><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><h4 id="1-按操作数据类型分：字符流和字节流"><a href="#1-按操作数据类型分：字符流和字节流" class="headerlink" title="1.按操作数据类型分：字符流和字节流"></a>1.按操作数据类型分：字符流和字节流</h4><p><strong>字符流：</strong>Java中的字符流处理的最基本的单元是<strong>2字节的Unicode码元(char)</strong>，它通常用来处理文本数据，如字符、字符数组或字符串等。所谓Unicode码元，也就是一个Unicode代码单元，范围是0x0000~0xFFFF。在以上范围内的每个数字都与一个字符相对应，Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。然而与存储在内存中不同，存储在磁盘上的数据通常有着各种各样的编码方式。使用不同的编码方式，相同的字符会有不同的二进制表示。实际上字符流是这样工作的：  </p><ul><li>输出字符流：把要写入文件的字符序列(实际上是Unicode码元序列)转为指定编码方式下的字节序列，然后再写入到文件中。</li><li>输入字符流：把要读取的字节序列按指定编码方式解码为相应字符序列(实际上是Unicode码元序列从)从而可以存在内存中。 </li></ul><p>也就是说，所有的文件在<strong>硬盘</strong>或在<strong>传输</strong>时都是以<strong>字节</strong>的方式进行的，包括图片等都是<strong>按字节的方式存储</strong>的，而字符是只有在<strong>内存</strong>中才会形成。 </p><p><strong>字节流：</strong>Java中的字节流处理的最基本单位为<strong>单个字节(byte)</strong>，它通常用来处理二进制数据,如果要得到字节对应的字符需要强制类型转换。  </p><p><strong>两者比较：</strong><br>1.字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性较好，如果要操作中文数据等，用字符流。<br>2.字符流只用来处理文本数据，字节流还可以用来处理媒体数据，如视频、音频、图片等。<br>3.字符流的两个<strong>抽象基类</strong>为Reader和Writer，字节流的两个<strong>抽象基类</strong>为InputStream和OutputStream。它们的具体子类名以基类名为后缀进行扩展。<br>4.字节流在操作的时候不会用到缓冲区(内存)，是直接对文件本身操作的，而字符流在操作的时候使用缓冲区。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Compare.jpg" alt="fail"></p><p>以向一个文件输出”Hello world!”为例，我们分别使用字节流和字符流进行输出，且在使用完之后都不关闭流。</p><p>使用字节流不关闭执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOPractice</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="comment">// 第1步：使用File类找到一个文件    </span></div><div class="line">     File f = <span class="keyword">new</span> File(<span class="string">"/home/xiejunyu/"</span>+</div><div class="line">             <span class="string">"桌面/text.txt"</span>);   </div><div class="line"><span class="comment">// 第2步：通过子类实例化父类对象     </span></div><div class="line">         OutputStream out = <span class="keyword">new</span> FileOutputStream(f); </div><div class="line"><span class="comment">// 通过对象多态性进行实例化    </span></div><div class="line"><span class="comment">// 第3步：进行写操作    </span></div><div class="line">     String str = <span class="string">"Hello World!"</span>;      </div><div class="line"><span class="comment">// 准备一个字符串    </span></div><div class="line">     <span class="keyword">byte</span> b[] = str.getBytes();          </div><div class="line"><span class="comment">// 字符串转byte数组    </span></div><div class="line">     out.write(b);                      </div><div class="line"><span class="comment">// 将内容输出    </span></div><div class="line"> <span class="comment">// 第4步：关闭输出流    </span></div><div class="line">    <span class="comment">// out.close();                  </span></div><div class="line"><span class="comment">// 此时没有关闭    </span></div><div class="line">        &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/1.png" alt="fail"><br>此时没有关闭字节流操作，但是文件中也依然存在了输出的内容，证明字节流是直接操作文件本身的。  </p><p>使用字符流不关闭执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileWriter;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.Writer;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOPractice</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"> <span class="comment">// 第1步：使用File类找到一个文件    </span></div><div class="line">        File f = <span class="keyword">new</span> File(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">        <span class="comment">// 第2步：通过子类实例化父类对象            </span></div><div class="line">        Writer  out = <span class="keyword">new</span> FileWriter(f);            </div><div class="line">        <span class="comment">// 第3步：进行写操作    </span></div><div class="line">        String str = <span class="string">"Hello World!"</span>;      </div><div class="line">        <span class="comment">// 准备一个字符串    </span></div><div class="line">        out.write(str);                    </div><div class="line">        <span class="comment">// 将内容输出    </span></div><div class="line">        <span class="comment">// 第4步：关闭输出流    </span></div><div class="line">        <span class="comment">// out.close();</span></div><div class="line">        <span class="comment">// 此时没有关闭    </span></div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/2.png" alt="fail"></p><p>程序运行后会发现文件中没有任何内容，这是因为字符流操作时使用了缓冲区，而在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果程序没有关闭字符流，缓冲区中的内容是无法输出的，所以得出结论：<strong>字符流使用了缓冲区，而字节流没有使用缓冲区。</strong>如果想让缓冲区中的内容输出，要么关闭流强制刷新缓冲区，要么调用flush方法冲刷缓冲区。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源(如文件或数据库)，则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。<br>在字符流的操作中，所有的字符都是在内存中形成的，在输出前会将所有的内容暂时保存在内存之中，所以使用了缓冲区暂存数据。  </p><p><strong>建议：</strong><br>1.虽然不关闭字节流不影响数据的输出，且后续JVM会自动回收这部分内存，但还是建议在使用完任何流对象之后关闭流。<br>2.使用流对象都要声明或抛出IOException<br>3.在创建一个文件时，如果目录下有同名文件将被覆盖<br>4.在写文件时，如果文件不存在，会在创建输出流对象并绑定文件时自动创建文件，不必使用File的exists方法提前检测<br>4.在读取文件时，必须使用File的exists方法提前检测来保证该文件已存在，否则抛出FileNotFoundException</p><h4 id="2-按流向分：输入流和输出流"><a href="#2-按流向分：输入流和输出流" class="headerlink" title="2.按流向分：输入流和输出流"></a>2.按流向分：输入流和输出流</h4><p>输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络等)，即是将数据源读入到程序的通信通道。输入流主要包括两个抽象基类：InputStream(字节输入流)和Reader(字符输入流)及其扩展的具体子类。<br>输出流：程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道。输出流主要包括两个抽象基类：OutputStream(字节输出流)和Writer(字符输出流)及其扩展的具体子类。 </p><h4 id="3-按功能分：节点流和处理流"><a href="#3-按功能分：节点流和处理流" class="headerlink" title="3.按功能分：节点流和处理流"></a>3.按功能分：节点流和处理流</h4><p>按照流是否<strong>直接</strong>与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两类。<br>节点流：程序用于直接操作目标设备所对应的类叫节点流。(低级流)<br>处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据，这个间接流类就是处理流。处理流可以看成是对已存在的流进行连接和封装的流。(高级流)  </p><p><strong>注意：在使用到处理流对流进行连接和封装时，读写完毕要关闭所有出现的流，包括节点流和处理流。</strong>  </p><h5 id="1-节点流"><a href="#1-节点流" class="headerlink" title="(1) 节点流"></a>(1) 节点流</h5><p><img src="/2017/11/28/Java学习总结之Java-IO系统/节点流.png" alt="fail">  </p><ul><li>File 文件流。对文件进行读、写操作：FileReader、FileWriter、FileInputStream、FileOutputStream。  </li><li>Memory 流。<br>向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。<br>向内存字符串读写数据：StringReader、StringWriter、StringBufferInputStream。  </li><li>Pipe管道流：实现管道的输入和输出(进程间通信)： PipedReader与PipedWriter、PipedInputStream与PipedOutputStream。    </li></ul><p><img src="/2017/11/28/Java学习总结之Java-IO系统/节点流示意图.png" alt="fail">  </p><h5 id="1-处理流"><a href="#1-处理流" class="headerlink" title="(1) 处理流"></a>(1) 处理流</h5><p><img src="/2017/11/28/Java学习总结之Java-IO系统/处理流.png" alt="fail">  </p><ul><li>Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。   </li><li>Filtering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。  </li><li>Converting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换(Stream到Reader)：InputStreamReader、OutputStreamWriter。   </li><li>Object Serialization 对象流 ：ObjectInputStream、ObjectOutputStream。   </li><li>DataConversion数据流：按基本数据类型读、写(处理的数据是Java的基本类型)：DataInputStream、DataOutputStream 。 </li><li>Counting计数流：在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。 </li><li>Peeking Ahead预读流： 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream。   </li><li>Printing打印流： 包含方便的打印方法 ：PrintWriter、PrintStream。  </li></ul><p><img src="/2017/11/28/Java学习总结之Java-IO系统/处理流示意图.png" alt="fail">  </p><h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>在Java中，从控制台输入有三种方法：  </p><h4 id="1-使用标准输入流对象System-in"><a href="#1-使用标准输入流对象System-in" class="headerlink" title="1.使用标准输入流对象System.in"></a>1.使用标准输入流对象System.in</h4><p>System.in是System中内置的InputStream类对象，它的read方法一次只读入<strong>一个字节</strong>数据，返回0 ~ 255的一个byte值,一般用来读取一个字符，需要强制类型转换为char类型，而我们通常要取得一个字符串或一组数字，故这种方法不常用。下面给出这种方法的一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharTest</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> <span class="keyword">try</span>&#123;   </div><div class="line"> System.out.print(<span class="string">"Enter a Char:"</span>);   </div><div class="line"> <span class="keyword">char</span> i = (<span class="keyword">char</span>)System.in.read();   </div><div class="line"> System.out.println(<span class="string">"Yout Enter Char is:"</span> + i);    &#125;   </div><div class="line"> <span class="keyword">catch</span>(IOException e)&#123;   </div><div class="line">    e.printStackTrace();   </div><div class="line"> &#125;   </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>使用这种方法必须提供try-catch块或者在main方法首部声明IOException异常，因为System.in是一个流对象</strong>  </p><h4 id="2-使用Scanner类"><a href="#2-使用Scanner类" class="headerlink" title="2.使用Scanner类"></a>2.使用Scanner类</h4><p>Scanner类功能十分强大，可以读入字符串、整数、浮点数、布尔类型值等等。下面是例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);   </div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Name:"</span>);   </div><div class="line">    String name = sc.nextLine();  <span class="comment">//读取字符串型输入   </span></div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Age:"</span>);   </div><div class="line">    <span class="keyword">int</span> age = sc.nextInt();    <span class="comment">//读取整型输入   </span></div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Salary:"</span>);   </div><div class="line">    <span class="keyword">float</span> salary = sc.nextFloat(); <span class="comment">//读取float型输入   </span></div><div class="line">    System.out.println(<span class="string">"Your Information is as below:"</span>);   </div><div class="line">    System.out.println(<span class="string">"Name:"</span> + name +<span class="string">"\n"</span> + <span class="string">"Age:"</span>+age </div><div class="line">    + <span class="string">"\n"</span>+<span class="string">"Salary:"</span>+salary);   </div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1.用nextXXX()读入XXX类型的数据，XXX可以是除了char外的所有基本数据类型，还可以是BigInteger或BigDecimal，其中凡是整型类型的数据还可以指定radix(进制)，可以用next()和nextLine()读取一个字符串或一行字符<br>2.next()和nextLine()的区别：<br>next()</p><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li>next() 不能得到带有空格的字符串，除非用useDelimeter方法修改分隔符。  </li></ul><p>nextLine()</p><ul><li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul><p>3.可以用循环配合hasNextXXX方法判断输入是否继续<br>4.Scanner类没有直接提供读取一个字符的方法，如果要读取一个字符，有三种方法，一是<strong>读入一个字符串后取字符串的第一个字符</strong>，二是使用<strong>System.in的read方法</strong>，三是使用<strong>字符流</strong>读入</p><p>更多Scanner的用法之前已经在<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>中总结过了，不再赘述。</p><h4 id="3-使用BufferedReader对象"><a href="#3-使用BufferedReader对象" class="headerlink" title="3.使用BufferedReader对象"></a>3.使用BufferedReader对象</h4><p>可以把 System.in 包装在一个 BufferedReader 对象中来创建一个<strong>字符流</strong>。<br>下面是创建 BufferedReader 的基本语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </div><div class="line">                      InputStreamReader(System.in));</div></pre></td></tr></table></figure></p><p>其中，System.in是一个InputStream对象(字节流)，使用InputStreamReader作为桥梁，将字节流转换为字符流，然后再使用BufferedReader进行进一步包装。<br>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符(读入一个用0~65535之间的整数表示的字符，需要强制类型转换为char类型，如果已到达流末尾，则返回 -1)，或者用 readLine() 方法读取一个字符串。下面是例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"><span class="comment">//必须要处理java.io.IOException异常</span></div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader</div><div class="line">  (System.in ));</div><div class="line">  <span class="comment">//java.io.InputStreamReader继承了Reader类</span></div><div class="line">  String read = <span class="keyword">null</span>;</div><div class="line">  System.out.print(<span class="string">"输入数据："</span>);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">   read = br.readLine();</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">   e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">  System.out.println(<span class="string">"输入数据："</span>+read);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRRead</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="comment">// 使用 System.in 创建 BufferedReader </span></div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </div><div class="line">                       InputStreamReader(System.in));</div><div class="line">    System.out.println(<span class="string">"输入字符, 按下 'q' 键退出。"</span>);</div><div class="line">    <span class="comment">// 读取字符</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       c = (<span class="keyword">char</span>) br.read();</div><div class="line">       System.out.println(c);</div><div class="line">    &#125; <span class="keyword">while</span>(c != <span class="string">'q'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面的程序读取和显示字符行直到你输入了单词”end”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符</span></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRReadLines</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="comment">// 使用 System.in 创建 BufferedReader </span></div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></div><div class="line">                            InputStreamReader(System.in));</div><div class="line">    String str;</div><div class="line">    System.out.println(<span class="string">"Enter lines of text."</span>);</div><div class="line">    System.out.println(<span class="string">"Enter 'end' to quit."</span>);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       str = br.readLine();</div><div class="line">       System.out.println(str);</div><div class="line">    &#125; <span class="keyword">while</span>(!str.equals(<span class="string">"end"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>在ACM等算法竞赛中，我们常常也会使用Java，在输入数据时有以下几点注意：</strong><br>1.hasXXX等价于C++中读到文件末尾(EOF)<br>2.使用BufferedReader输入会比Scanner输入快十倍左右!</p><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>控制台的输出由 print() 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类的一个对象。<br>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。<br>PrintStream 定义 write() 的最简单格式如下所示：<br><code>void write(int byteval)</code>该方法将 byteval 的低八位字节写到流中,即System.out的write方法一次只能写一个字节(类比System.in的read方法一次只能读取一个字节)。<br>下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="comment">// 演示 System.out.write().</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> b; </div><div class="line">      b = <span class="string">'A'</span>;<span class="comment">//向上类型转换</span></div><div class="line">      System.out.write(b);</div><div class="line">      System.out.write(<span class="string">'\n'</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。</strong></p><h3 id="字节流-OutputStream、InputStream"><a href="#字节流-OutputStream、InputStream" class="headerlink" title="字节流(OutputStream、InputStream)"></a>字节流(OutputStream、InputStream)</h3><p>字节流主要是操作byte类型的数据，以byte数组为准，主要操作类是OutputStream、InputStream。<br>由于文件读写最为常见，我们先讨论两个重要的字节流 FileInputStream(文件输入流) 和 FileOutputStream(文件输出流)，分别是抽象类InputStream和OutputStream的具体子类：</p><p><strong>FileInputStream</strong><br>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>有多种构造方法可用来创建对象。<br>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/java/hello"</span>);</div></pre></td></tr></table></figure></p><p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(f);</div></pre></td></tr></table></figure></p><p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/InputStream.png" alt="fail" title="InputStream"><br>下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">InputStream f  = <span class="keyword">new</span> FileInputStream</div><div class="line">(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>((c =  f.read()) != -<span class="number">1</span>) </div><div class="line">    <span class="comment">//这里也可以先用available方法得到可读的字节数</span></div><div class="line">System.out.println((<span class="keyword">char</span>)c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们需要创建一个byte[]来保存读取的字节时，如果数组太小，无法完整读入数据，如果太大又会造成内存浪费。<strong>可以使用File类的length方法得到文件的数据字节数，从而有效确定byte数组的大小。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 创建一个FileInputStream对象</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</div><div class="line">fis.read(b,<span class="number">0</span>,<span class="number">5</span>); </div><div class="line">            <span class="comment">/*把字节从文件读入b数组，从b数组的0位置开始存放，</span></div><div class="line"><span class="comment">            读取5个字节*/</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(b));</div><div class="line">fis.close();</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意:</strong> 每调用一次read方法,当前读取在文件中的位置就会向后移动一个字节或者移动byte[]的长度(read的两个重载方法)，已经到文件末尾会返回-1，可以通过read方法返回-1判断是否读到文件末尾，也可以使用available方法返回下一次可以不受阻塞读取的字节数来读取。<strong>FileInputStream不支持mark和reset方法进行重复读取。BufferedInputStream支持此操作。</strong>  </p><p><strong>FileOutputStream</strong><br>该类用来创建一个文件并向文件中写数据。<br><strong>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</strong><br>有两个构造方法可以用来创建 FileOutputStream 对象。<br>使用字符串类型的文件名来创建一个输出流对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/java/hello"</span>)</div></pre></td></tr></table></figure></p><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</div></pre></td></tr></table></figure></p><p>之前的所有操作中，如果重新执行程序，则肯定会覆盖文件中的已有内容，那么此时就可以通过FileOutputStream向文件中追加内容，FileOutputStream的另外一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file,<span class="keyword">boolean</span> append)</span></span></div></pre></td></tr></table></figure></p><p>在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。程序代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f,<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileOutputStream.png" alt="fail" title="FileOutputStream"><br>当有一个字符串时，可以用getBytes方法转为byte数组用于字节流的输出。  </p><p>下面是一个演示 InputStream 和 OutputStream 用法的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      <span class="keyword">byte</span> bWrite[] = <span class="string">"ABC"</span>.getBytes();</div><div class="line">      OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x &lt; bWrite.length ; x++)&#123;</div><div class="line">      os.write(bWrite[x] ); <span class="comment">// writes the bytes</span></div><div class="line">    &#125;</div><div class="line">    os.close();</div><div class="line"> </div><div class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">    <span class="keyword">int</span> size = is.available();</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; size; i++)&#123;</div><div class="line">      System.out.print((<span class="keyword">char</span>)is.read() + <span class="string">"  "</span>);</div><div class="line">    &#125;</div><div class="line">      is.close();</div><div class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">      System.out.print(<span class="string">"Exception"</span>);</div><div class="line">    &#125;  </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。<br>以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileStreamTest2</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    </div><div class="line">    File f = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</div><div class="line">    FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(f);</div><div class="line">    <span class="comment">// 构建FileOutputStream对象,文件不存在会自动新建;如果存在会覆盖原文件</span></div><div class="line">    </div><div class="line">    OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fop, <span class="string">"UTF-8"</span>);</div><div class="line">    <span class="comment">// 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"中文输入"</span>);</div><div class="line">    <span class="comment">// 写入到缓冲区</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"\r\n"</span>);</div><div class="line">    <span class="comment">//换行</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"English"</span>);</div><div class="line">    <span class="comment">// 刷新缓冲区,写入到文件,如果下面已经没有写入的内容了,直接close也会写入</span></div><div class="line">    </div><div class="line">    writer.close();</div><div class="line">    <span class="comment">//关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉</span></div><div class="line">    </div><div class="line">    fop.close();</div><div class="line">    <span class="comment">// 关闭输出流,释放系统资源</span></div><div class="line"> </div><div class="line">    FileInputStream fip = <span class="keyword">new</span> FileInputStream(f);</div><div class="line">    <span class="comment">// 构建FileInputStream对象</span></div><div class="line">    </div><div class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fip, <span class="string">"UTF-8"</span>);</div><div class="line">    <span class="comment">// 构建InputStreamReader对象,编码与写入相同</span></div><div class="line"> </div><div class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">    <span class="keyword">while</span> (reader.ready()) &#123;</div><div class="line">      sb.append((<span class="keyword">char</span>) reader.read());</div><div class="line">      <span class="comment">// 转成char加到StringBuffer对象中</span></div><div class="line">    &#125;</div><div class="line">    System.out.println(sb.toString());</div><div class="line">    reader.close();</div><div class="line">    <span class="comment">// 关闭读取流</span></div><div class="line">    </div><div class="line">    fip.close();</div><div class="line">    <span class="comment">// 关闭输入流,释放系统资源</span></div><div class="line"> </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上例子证明：在对多国语言的支持上，字符流表现更优，此时应使用字符流而不是字节流。  </p><p>还可以用InputStream和OutputStream配合进行文件的复制，即读取原件数据，写入副本文件。<br>复制有两种实现方式：<br>实现一：将源文件中的内容全部读取进来，之后一次性的写入到目标文件<br>实现二：边读边写  </p><p>在实际开发中建议使用边读边写的方式，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 文件拷贝</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">FileInputStream fis=<span class="keyword">new</span> FileInputStream(<span class="string">"happy.gif"</span>);</div><div class="line">FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"happycopy.gif"</span>);</div><div class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">while</span>((n=fis.read(b))!=-<span class="number">1</span>)&#123; </div><div class="line">            <span class="comment">/*循环读取，每次1024个字节，最后一次可能不满1024。</span></div><div class="line"><span class="comment">            后面的字节覆盖前面的字节，不必担心数组溢出。*/</span></div><div class="line">fos.write(b,<span class="number">0</span>,n); <span class="comment">//n是实际读取到的字节数，如果写fos.write(b)，会造成最后一次数组未满的情况也写1024个字节，从而造成副本比原件略大</span></div><div class="line">&#125;</div><div class="line">fis.close();</div><div class="line">fos.close();</div><div class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line"><span class="comment">// TODO Auto-generated catch block</span></div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实际上边读边写也分为三种方式：<br>1.批量拷贝(循环读取，每次读入一个byte数组)<br>2.缓冲拷贝(使用缓冲流)<br>3.批量+缓冲拷贝(循环批量读取到字节数组中，然后使用缓冲输出流写入到文件)  </p><p><strong>第三种方式是最快的。</strong>  </p><p><strong>注意：</strong>InputStream的int read()方法读取一个字节，并用这个字节填充整型的低八位并返回，OutputStream的void write(int x)写入x的低八位，如果要写入一个int，需要移位并写4次。读写基本数据类型建议使用DataInputStream和DataOutputStream。</p><h3 id="字符流-Writer、Reader"><a href="#字符流-Writer、Reader" class="headerlink" title="字符流(Writer、Reader)"></a>字符流(Writer、Reader)</h3><p>Java提供了两个操作字符的字符流基类，分别是Writer和Reader。先来了解两个用于读写文件的字符流FileReader(字符输入流)和FileWriter(字符输出流)：  </p><p><strong>FileReader</strong><br>FileReader类从InputStreamReader类继承而来。该类按字符读取流中数据。可以通过以下几种构造方法创建需要的对象。<br>在给定从中读取数据的 File 的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(File file)</div></pre></td></tr></table></figure></p><p>在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(FileDescriptor fd)</div></pre></td></tr></table></figure></p><p>在给定从中读取数据的文件名的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(String fileName)</div></pre></td></tr></table></figure></p><p>创建FIleReader对象成功后，可以参照以下列表里的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileReader.png" alt="fail" title="FileReader">  </p><p><strong>FileWriter</strong><br>FileWriter 类从 OutputStreamWriter 类继承而来。该类按字符向流中写入数据。可以通过以下几种构造方法创建需要的对象。<br>在给出 File 对象的情况下构造一个 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(File file)</div></pre></td></tr></table></figure></p><p>在给出 File 对象的情况下构造一个 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(File file, <span class="keyword">boolean</span> append)</div></pre></td></tr></table></figure></p><p>构造与某个文件描述符相关联的 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(FileDescriptor fd)</div></pre></td></tr></table></figure></p><p>在给出文件名的情况下构造 FileWriter 对象，它具有指示是否挂起写入数据的 boolean 值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(String fileName, <span class="keyword">boolean</span> append)</div></pre></td></tr></table></figure></p><p>创建FileWriter对象成功后，可以参照以下列表里的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileWriter.png" alt="fail" title="FileWriter"><br><strong>字符流的操作比字节流操作方便一点，就是可以直接输出字符串。不在用再像之前那样进行字节转换操作了。使用字符流默认情况下依然是覆盖已有的文件，如果想追加的话，则直接在FileWriter上增加一个可追加的标记即可。</strong></p><p>下面的例子演示了FileReader和FileWriter的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">      File file = <span class="keyword">new</span> File(<span class="string">"Hello1.txt"</span>);</div><div class="line">      <span class="comment">// 创建文件</span></div><div class="line">      file.createNewFile();</div><div class="line">      <span class="comment">// creates a FileWriter Object</span></div><div class="line">      FileWriter writer = <span class="keyword">new</span> FileWriter(file); </div><div class="line">      <span class="comment">// 向文件写入内容</span></div><div class="line">      writer.write(<span class="string">"This\n is\n an\n example\n"</span>); </div><div class="line">      writer.flush();</div><div class="line">      writer.close();</div><div class="line">      <span class="comment">//创建 FileReader 对象</span></div><div class="line">      FileReader fr = <span class="keyword">new</span> FileReader(file); </div><div class="line">      <span class="keyword">char</span> [] a = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</div><div class="line">      fr.read(a); <span class="comment">// 从数组中读取内容</span></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">char</span> c : a)</div><div class="line">          System.out.print(c); <span class="comment">// 一个个打印字符</span></div><div class="line">      fr.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="字节-字符转换流-OutputStreamWriter、InputStreamReader"><a href="#字节-字符转换流-OutputStreamWriter、InputStreamReader" class="headerlink" title="字节-字符转换流(OutputStreamWriter、InputStreamReader)"></a>字节-字符转换流(OutputStreamWriter、InputStreamReader)</h3><p>在整个IO包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流-字符流的转换类。  </p><p><strong>InputStreamReader</strong><br>InputStreamReader是<strong>字节流</strong>通向<strong>字符流</strong>的桥梁，它使用指定的charset读取字节并将其解码为字符。它拥有一个InputStream类型的变量，并继承了Reader，使用了对象的适配器模式，如图所示：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/InputStreamReader.jpg" alt="fail"><br>根据InputStream的实例创建InputStreamReader的方法有4种：<br>1.根据默认字符集创建<br>InputStreamReader(InputStream in)<br>2.使用给定字符集创建<br>InputStreamReader(InputStream in, Charset cs)<br>3.使用给定字符集解码器创建<br>InputStreamReader(InputStream in, CharsetDecoder dec)<br>4.使用指定字符集名字符串创建<br>InputStreamReader(InputStream in, String charsetName)</p><p>后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。<br><strong>注意：</strong>在对文件进行读写操作时，默认使用的是项目的编码，如果要读写其他编码方式的文件，要在构造输入输出流时指定对应的编码。这一般通过字节-字符转换流完成。   </p><p>每次调用InputStreamReader中的一个read()方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。共有3个可用的read()方法：  </p><p>int read(); //读取单个字符<br>int read(char[] cbuf, int offset, int length);<br>//将字符读入数组中的某一部分<br>boolean ready(); //判断此流是否已经准备好用于读取 </p><p>使用字符流的形式读取字节流的文件，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + </div><div class="line">        <span class="string">"test.txt"</span>) ;</div><div class="line">Reader reader = <span class="keyword">new</span> InputStreamReader</div><div class="line">        (<span class="keyword">new</span> FileInputStream(f)) ;</div><div class="line">        <span class="comment">// 将字节流变为字符流</span></div><div class="line"><span class="keyword">char</span> c[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>] ;</div><div class="line"><span class="keyword">int</span> len = reader.read(c) ;<span class="comment">// 读取</span></div><div class="line">reader.close() ;<span class="comment">// 关闭</span></div><div class="line">System.out.println(<span class="keyword">new</span> String(c,<span class="number">0</span>,len)) ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>OutputStreamWriter</strong><br>OutputStreamWriter是<strong>字符流</strong>通向<strong>字节流</strong>的桥梁，可使用指定的charset将要写入流中的字符编码成字节。因此，它拥有一个OutputStream类型的变量，并继承了Writer，使用对象的适配器模式,如图所示：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/OutputStreamWriter.jpg" alt="fail" title="OutputStreamWriter"><br>根据OutputStream的实例创建OutputStreamWriter的方法有4种：  </p><p>1.根据默认字符集创建<br>OutputStreamReader(OutputStream out)  </p><p>2.使用给定字符集创建<br>OutputStreamReader(OutputStream out, Charset cs)       </p><p>3.使用给定字符集解码器创建<br>OutputStreamReader(OutputStream out, CharsetDecoder dec)  </p><p>4.使用指定字符集名字符串创建<br>OutputStreamReader(OutputStream out, Stroutg charsetName)        </p><p>后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。  </p><p>每次调用write()方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给write()方法的字符没有缓冲。共有3个可用的write()方法：<br>void write(char[] cbuf, int off, int len); //写入字符数组的某一部分<br>void write(int c); //写入单个字符<br>void write(String str, int off, int len); //写入字符串的某一部分 </p><p>例如：将字节的文件输出流，以字符的形式输出。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</div><div class="line">Writer out = <span class="keyword">new</span> OutputStreamWriter</div><div class="line">        (<span class="keyword">new</span> FileOutputStream(f)) ;<span class="comment">// 字节流变为字符流</span></div><div class="line">    out.write(<span class="string">"hello world!!"</span>) ;</div><div class="line">           <span class="comment">// 使用字符流输出</span></div><div class="line">out.close() ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>特别说明：</strong>OutputStreamWriter是字符流到字节流的桥梁，这不表示OutputStreamWriter接收一个字符流并将其转换为字节流，恰恰相反，其接收的OutputStream是一个字节流，而它本身是一个字符流。<strong>那为什么说它是字符流到字节流的桥梁呢？</strong><br>我们以文件操作为例，之前已经提到，在内存中数据是以字符形式存在的，而在文件中数据是以字节形式保存的。所以在<strong>内存</strong>中的<strong>字符数据</strong>需要通过OutputStreamWriter变为<strong>字节流</strong>才能保存在文件之中，读取的时候需要将读入的<strong>字节流</strong>通过InputStreamReader变为<strong>字符流</strong>。<br>但OutputStreamWriter和InputStreamReader都是字符流，也就是说，OutputStreamWriter以字符输出流形式操作了字节的输出流，但实际上还是以字节的形式输出。而InputStreamReader，虽然以字符输入流的形式操作，但实际上还是使用的字节流输入，也就是说，传输或者是从文件中读取数据的时候，文件中真正保存的数据永远是字节。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/change.png" alt="fail">  </p><p>输入流和输出流要指定相同的字符集才能避免乱码！</p><p><strong>FileWriter和FileReader的说明</strong><br>从JDK文档中可以知道FileOutputStream是OutputStream的直接子类，FileInputStream也是InputStream的直接子类，但是在字符流文件的两个操作类却有一些特殊，FileWriter并不直接是Writer的子类，而是转换流OutputStreamWriter的子类，而FileReader也不直接是Reader的子类，而是转换流InputStreamReader的子类，那么从这两个类的继承关系就可以清楚的发现，不管是是使用字节流还是字符流实际上最终都是以字节形式操作输出流的。</p><h3 id="缓冲流-BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream"><a href="#缓冲流-BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream" class="headerlink" title="缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)"></a>缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)</h3><p>缓冲流是一系列处理流(包装流)，目的是为了提高I/O效率，它们为I/O提供了内存缓冲区，这是一种常见的性能优化，增加缓冲区的两个目的：<br>(1)允许Java的I/O一次不只操作一个字符，这样提高了整个系统的性能<br>(2)由于有缓冲区，使得在流上执行skip、mark和reset方法都成为可能。<br>如果没有缓冲区，每次调用 read() 或 write()方法都会对文件进行读或写字节，在文件和内存之间发生字节和字符的转换，这是极其低效的。  </p><p><strong>BufferedReader</strong><br>BufferedReader是一个包装类，是为了提高读效率提供的，其可以接收一个Reader,然后用readLine()逐行读入字符流，直到遇到换行符为止（相当于反复调用Reader类对象的read()方法读入多个字符）。<br><strong>因此，建议用 BufferedReader 包装所有其 read() 操作可能开销很高的 Reader（如 FileReader 和 InputStreamReader),如：</strong>   </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/Buffer.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedReader1.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedReader2.png" alt="fail"> </p><p> markSupported 判断该输入流能支持 mark 和 reset 方法。mark 用于标记当前位置，readlimit 制定可以重新读取的最大字节数，如果标记后读取的字节数不超过 readlimit 可以用 reset 回到标志位置重复读取。</p><p><strong>BufferedWriter</strong><br>同理建议用BfferedWriter包装所有其write()操作可能开销很高的Writer(如FileWriter和OutputStreamWriter)<br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedWriter.png" alt="fail" title="BufferedWriter">    </p><p><strong>BufferedInputStream</strong><br>BufferedInputStream用于包装其他较为缓慢的InputStream<br>构造方法摘要  </p><ul><li>BufferedInputStream(InputStream in)<br>创建一个使用默认大小输入缓冲区的缓冲字节输入流</li><li>BufferedInputStream(InputStream in, int size)<br>创建一个使用指定大小输入缓冲区的缓冲字节输入流  </li></ul><p>方法摘要  </p><ul><li>public int read();<br>从该输入流中读取一个字节</li><li>public int read(byte[] b,int off,int len);<br>从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。  </li></ul><p><strong>BufferedOutputStream</strong><br>BufferedOutputStream用于包装其他较为缓慢的OutputStream<br>构造方法摘要  </p><ul><li>BufferedOutputStream(OutputStream out);<br>创建一个使用默认大小输入缓冲区的缓冲字节输出流</li><li>BufferedOutputStream(OutputStream out,int size);<br>创建一个使用默认大小输入缓冲区的缓冲字节输出流  </li></ul><p>方法摘要  </p><ul><li>public void write(int b);<br>向输出流中输出一个字节  </li><li>public void write(byte[] b,int off,int len);<br>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。  </li><li>public void flush();<br>刷新此缓冲的输出流。这迫使所有缓冲的输出字节被写出到底层输出流中。  </li></ul><p><strong>其他</strong><br>（1）缓冲输入流BufferedInputSTream除了支持read和skip方法意外，还支持其父类的mark和reset方法;<br>（2）BufferedReader提供了一种新的ReadLine方法用于读取一行字符串（以\r或\n分隔）;<br>（3）BufferedWriter提供了一种新的newLine方法用于写入一个行分隔符;<br>（4）<strong>对于输出的缓冲流，BufferedWriter和BufferedOutputStream，写出的数据会先在缓冲区(由缓冲流提供的一个字节数组，是不可见的)中缓存，直到缓冲区满了会自动写数据到输出流，如果缓冲区未满，可以使用flush方法将会使缓冲区的数据强制写出。关闭输出流也会造成缓冲区中残留的数据被写出。注意BufferedReader和BufferedInputStream没有flush方法，因为flush只用于输出到文件时。</strong>  </p><h3 id="打印流-PrintStream、PrintWriter"><a href="#打印流-PrintStream、PrintWriter" class="headerlink" title="打印流(PrintStream、PrintWriter)"></a>打印流(PrintStream、PrintWriter)</h3><p>在整个IO包中，打印流是<strong>输出信息最方便</strong>的类，主要包含字节打印流(PrintStream)和字符打印流(PrintWriter)。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等。<br>相较OutputStream在输出时的各种麻烦(比如要将String转为byte[]才能输出)打印流中可以方便地进行输出。  </p><p><strong>PrintStream</strong><br>1、public PrintStream(File file) throws FileNotFoundException<br>//构造方法 通过一个File对象实例化PrintStream类  </p><p>2、public PrintStream(OutputStream out)<br>//构造方法 接收OutputStream对象，实例化PrintStream类  </p><p>3、public PrintStream printf(Locale l, String format, Object …arg)<br>//普通方法 根据指定的Locale进行格式化输出</p><p>4、public PrintStream printf(String format,Object … arg)<br>//普通方法 根据本地环境进行格式化输出</p><p>5、public void print(boolean b)<br>//普通方法 此方法被重载很多次，输出任意数据</p><p>6、public void println(boolean b)<br>//普通方法 此方法被重载很多次，输出任意数据后换行  </p><p><strong>打印流的好处：</strong>在PrintStream中定义的构造方法中可以清楚的发现有一个构造方法可以直接接收OutputStream类的实例，这是因为与OutputStream相比起来，PrintStream可以更加方便的输出数据，这就好比将OutputStream重新包装了一下，使之输出更加方便。  </p><p><strong>PrintWriter</strong><br><strong>构造方法</strong>  </p><p>//使用指定文件创建不具有自动行刷新的新 PrintWriter<br>public PrintWriter(File file);</p><p>//创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter<br>public PrintWriter(File file,String csn);</p><p>//根据现有的 OutputStream 创建不带自动行刷新的新PrintWriter<br>public PrintWriter(OutputStream out);</p><p>//通过现有的 OutputStream 创建新的 PrintWriter(具有自动行刷新)<br>public PrintWriter(OutputStream out,boolean autoFlush);</p><p>//创建具有指定文件名称且不带自动行刷新的新PrintWriter<br>public PrintWriter(String fileName);</p><p>//创建具有指定文件名称和字符集且不带自动行刷新的PrintWriter<br>public PrintWriter(String fileName,String csn);</p><p>//创建新 PrintWriter(具有自动行刷新)<br>public PrintWriter(Writer out,boolean autoFlush)   </p><p><strong>常用方法</strong><br>//打印boolean值<br>public void print(boolean b)<br>//打印 boolean 值，然后终止该行<br>public void println(boolean x)</p><p>//打印字符<br>public void print(char c)<br>//打印字符，然后终止该行<br>public void println(char x)</p><p>//打印字符数组<br>public void print(char[] s)<br>//打印字符数组，然后终止该行<br>public void println(char[] x)</p><p>//打印 double 精度浮点数<br>public void print(double d)<br>//打印 double 精度浮点数,然后终止该行<br>public void println(double x)</p><p>//打印一个浮点数<br>public void print(float f)<br>//打印浮点数，然后终止该行<br>public void println(float x)  </p><p>//打印整数<br>public void print(int i)<br>//打印整数，然后终止该行<br>public void println(int x)</p><p>//打印 long 整数<br>public void print(long l)<br>//打印 long 整数，然后终止该行<br>public void println(long x)</p><p>//打印对象<br>public void print(Object obj)<br>//打印 Object，然后终止该行<br>public void println(Object x)  </p><p>//打印字符串。如果参数为 null，则打印字符串 “null”<br>public void print(String s)<br>//打印 String，然后终止该行<br>public void println(String x)</p><p>//通过写入行分隔符字符串终止当前行<br>public void println()</p><p>//使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区<br>public PrintWriter format(Locale l,String format,Object… args)  </p><p>//使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区<br>public PrintWriter format(String format,Object… args)  </p><p>//将指定字符添加到此 writer<br>public PrintWriter append(char c)<br>//将指定的字符序列添加到此 writer<br>public PrintWriter append(CharSequence csq)<br>//将指定字符序列的子序列添加到此 writer<br>public PrintWriter append(CharSequence csq,int start,int end)</p><p>//写入字符数组<br>public void write(char[] buf)<br>//写入字符数组的某一部分<br>public void write(char[] buf,int off,int len)<br>//写入单个字符<br>public void write(int c)<br>//写入字符串<br>public void write(String s)<br>//写入字符串的某一部分<br>public void write(String s,int off,int len)</p><p><strong>提示：</strong>由于BufferedWriter没有PrintWriter使用灵活，所以在实际的操作中，我们往往会使用<strong>PrinterWriter/BufferedReader</strong>这种组合。  </p><h3 id="内存操作流"><a href="#内存操作流" class="headerlink" title="内存操作流"></a>内存操作流</h3><p>之前的程序中，输出输入都是在内存和文件之间进行的，当然，输入输出也可以不访问文件，只在内存中进行。也就是把数据的输入源和输出目的地从文件改成了byte数组、char数组或字符串。  </p><h4 id="字节数组流-ByteArrayInputStream、ByteArrayOutputStream"><a href="#字节数组流-ByteArrayInputStream、ByteArrayOutputStream" class="headerlink" title="字节数组流(ByteArrayInputStream、ByteArrayOutputStream)"></a>字节数组流(ByteArrayInputStream、ByteArrayOutputStream)</h4><p>ByteArrayInputStream的主要功能是完成将byte数组的内容写入到内存之中，而ByteArrayOutputStream的主要功能是将内存中的数据输出到byte数组。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/test.png" alt="fail">  </p><p><strong>ByteArrayInputStream</strong><br>字节数组输入流从内存中的一个字节数组读取字节到内存，这个字节数组就是数据的输入源。创建字节数组输入流对象有以下几种方式。<br>接收字节数组作为参数创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayInputStream bArray = </div><div class="line"><span class="keyword">new</span> ByteArrayInputStream(<span class="keyword">byte</span> [] b);</div></pre></td></tr></table></figure></p><p>另一种创建方式是接收一个字节数组，和两个整型变量 off、len，off表示第一个读取的字节，len表示读取字节的长度,<strong>即将字节数组中从off开始的len个字节读入该输入流</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayInputStream bArray = <span class="keyword">new</span></div><div class="line">ByteArrayInputStream(<span class="keyword">byte</span> []b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</div></pre></td></tr></table></figure></p><p>成功创建字节数组输入流对象后，可以参见以下列表中的方法，对流进行读操作或其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/ByteArrayInputStream.png" alt="fail" title="ByteArrayInputStream">  </p><p><strong>ByteArrayOutputStream</strong><br>字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中，可以用toByteArray()得到该字节数组，也可以用toString()得到缓冲区内容转换得到的字符串。创建字节数组输出流对象有以下几种方式。<br>下面的构造方法创建一个32字节（默认大小）的缓冲区。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream();</div></pre></td></tr></table></figure></p><p>另一个构造方法创建一个大小为n字节的缓冲区。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream(<span class="keyword">int</span> n)</div></pre></td></tr></table></figure></p><p>成功创建字节数组输出流对象后，可以参见以下列表中的方法，对流进行写操作或其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/ByteArrayOutputStream.png" alt="fail" title="ByteArrayOutputStream"><br>下面的例子演示了ByteArrayInputStream 和 ByteArrayOutputStream的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"HELLOWORLD"</span> ;<span class="comment">// 定义一个字符串，全部由大写字母组成</span></div><div class="line">ByteArrayInputStream bis = <span class="keyword">null</span> ;<span class="comment">// 内存输入流</span></div><div class="line">ByteArrayOutputStream bos = <span class="keyword">null</span> ;<span class="comment">// 内存输出流</span></div><div class="line">bis = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()) ;<span class="comment">// 向内存中输入内容</span></div><div class="line">bos = <span class="keyword">new</span> ByteArrayOutputStream() ;<span class="comment">// 准备从内存ByteArrayInputStream中读取内容</span></div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;</div><div class="line"><span class="keyword">while</span>((temp=bis.read())!=-<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) temp ;<span class="comment">// 读取的数字变为字符</span></div><div class="line">bos.write(Character.toLowerCase(c)) ;<span class="comment">// 将字符变为小写</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 所有的数据就全部都在ByteArrayOutputStream中</span></div><div class="line">String newStr = bos.toString() ;<span class="comment">// 取出内容</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">bis.close() ;</div><div class="line">bos.close() ;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">System.out.println(newStr) ;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="字符数据流-CharArrayReader、CharArrayWriter"><a href="#字符数据流-CharArrayReader、CharArrayWriter" class="headerlink" title="字符数据流(CharArrayReader、CharArrayWriter)"></a>字符数据流(CharArrayReader、CharArrayWriter)</h4><p>CharArrayReader、CharArrayWriter和ByteArrayInputStream、ByteArrayOutputStream类似，只不过后者是字节数组输入流，而前者是字符数组输入流。<br><strong>CharArrayReader</strong><br>构造方法摘要  </p><ul><li>CharArrayReader(char buf[]);<br>使用传入的buf构造CharArrayReader </li><li>CharArrayReader(char buf[], int offset, int length);<br>使用传入的buf的一部分构造CharArrayReader    </li></ul><p>方法摘要  </p><ul><li>void close(); 关闭此流  </li><li>void mark(int readAheadLimit); 标记当前流读取的位置  </li><li>void markSupport(); 检测此流是否支持标记  </li><li>int read(); 读取一个字符、并以整数形式返回  </li><li>int read(char[] b, int off, int len); 将buf中len个字符读取到下标从off开始的b中、返回读取的字符个数  </li><li>boolean ready(); 查看CharArrayReader是否可读。  </li><li>void reset(); 将此流开始位置重置到最后一次调用mark是流的读取位置  </li><li>long skip(long n); 丢弃buf中n个字符、返回实际丢弃的字符个数  </li></ul><p><strong>CharArrayWriter</strong><br>构造方法摘要    </p><ul><li>public CharArrayWriter()<br>使用默认的buf大小创建CharArrayWriter。   </li><li>public CharArrayWriter(int initialSize)<br>使用指定的buf大小创建CharArrayWriter。  </li></ul><p>方法摘要  </p><ul><li>CharArrayWriter append(CharSequence csq)<br>将一串有序字符序列写入buf中  </li><li>CharArrayWriter append(CharSequence csq, int start, int end)<br>将一串有序字符序列的一部分写入buf中  </li><li>CharArrayWriter append(char c) 将一个字符写入buf中</li><li>void close() 关闭此流（没有效果，因为不访问文件）</li><li>void flush() flush此流（没有效果，因为不访问文件）</li><li>void reset() 清空buf、重头开始</li><li>int size() 查看当前buf中字符总数</li><li>char[] toCharArray() 将buf中内容转换成char[]</li><li>String toString() 将buf中字符转换成String返回</li><li>void write(int c) 写入一个字符。</li><li>void write(char c[], int off, int len)<br>将一个char[]的一部分写入buf中、若buf满、扩容。</li><li>void write(String str, int off, int len)<br>将一个字符串写入buf中、满自动扩容</li><li>void writeTo(Writer out)<br>将buf中现有的字节写入到另一个输出字符流out中</li></ul><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">       String str = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line">       <span class="comment">// 构建字符输入流</span></div><div class="line">       CharArrayReader reader = <span class="keyword">new</span> CharArrayReader(str.toCharArray());</div><div class="line"></div><div class="line">       <span class="comment">// 从字符输入流读取字符</span></div><div class="line">       <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">       <span class="keyword">int</span> len = reader.read(chars);</div><div class="line">       System.out.println(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//构建字符输出流</span></div><div class="line">   CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter(<span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line"></div><div class="line">       <span class="comment">// 将字符串写入到CharArrayWriter</span></div><div class="line">       String msg = <span class="string">"hello world！！！22121"</span>;</div><div class="line">       writer.write(msg.toCharArray());</div><div class="line"></div><div class="line">       System.out.println(writer.toString());</div><div class="line"></div><div class="line">       writer.close();</div></pre></td></tr></table></figure></p><h4 id="字符串流-StringReader、StringWriter"><a href="#字符串流-StringReader、StringWriter" class="headerlink" title="字符串流(StringReader、StringWriter)"></a>字符串流(StringReader、StringWriter)</h4><p>字符串流和字符数据流基本一样，只是把char[]数组换成了String，在此不赘述。  </p><h3 id="合并流-SequenceInputStream、SequenceOutputStream"><a href="#合并流-SequenceInputStream、SequenceOutputStream" class="headerlink" title="合并流(SequenceInputStream、SequenceOutputStream)"></a>合并流(SequenceInputStream、SequenceOutputStream)</h3><p><strong>SequenceInputStream</strong><br>有些情况下，当我们需要从多个输入流中向程序读入数据。此时，可以使用合并流，将多个输入流合并成一个SequenceInputStream流对象。<br>SequenceInputStream会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。 合并流的作用是将多个源合并合一个源。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/合并流.png" alt="fail">  </p><p>构造方法<br>public SequenceInputStream(InputStream s1,InputStream s2)<br>使用两个输入流对象实例化本类对象。  </p><p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.SequenceInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 所有异常抛出</span></div><div class="line">InputStream is1 = <span class="keyword">null</span> ;<span class="comment">// 输入流1</span></div><div class="line">InputStream is2 = <span class="keyword">null</span> ;<span class="comment">// 输入流1</span></div><div class="line">OutputStream os = <span class="keyword">null</span> ;<span class="comment">// 输出流</span></div><div class="line">SequenceInputStream sis = <span class="keyword">null</span> ;<span class="comment">// 合并流</span></div><div class="line">is1 = <span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"a.txt"</span>);</div><div class="line">is2 = <span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"b.txt"</span>);</div><div class="line">os = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"ab.txt"</span>);</div><div class="line">sis = <span class="keyword">new</span> SequenceInputStream(is1,is2) ;</div><div class="line">        <span class="comment">// 实例化合并流</span></div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;<span class="comment">// 接收内容</span></div><div class="line"><span class="keyword">while</span>((temp=sis.read())!=-<span class="number">1</span>)&#123;<span class="comment">// 循环输出</span></div><div class="line">os.write(temp) ;<span class="comment">// 保存内容</span></div><div class="line">&#125;</div><div class="line">sis.close() ;<span class="comment">// 关闭合并流</span></div><div class="line">is1.close() ;<span class="comment">// 关闭输入流1`</span></div><div class="line">is2.close() ;<span class="comment">// 关闭输入流2</span></div><div class="line">os.close() ;<span class="comment">// 关闭输出流</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>SequenceOutputStream</strong><br>同SequenceInputStream,区别在于合并的是两个OutputStream，在此不赘述。</p><h3 id="数据操作流-DataInputStream、DataOutputStream"><a href="#数据操作流-DataInputStream、DataOutputStream" class="headerlink" title="数据操作流(DataInputStream、DataOutputStream)"></a>数据操作流(DataInputStream、DataOutputStream)</h3><p><strong>DataInputStream</strong><br>数据输入流允许应用程序以与机器无关方式从底层输入流中读取<strong>Java 8种基本数据类型</strong>，方法命名为readXxx。<br>下面的构造方法用来创建数据输入流对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(InputStream in);</div></pre></td></tr></table></figure></p><p>另一种创建方式是接收一个字节数组，和两个整形变量 off、len，off表示第一个读取的字节，len表示读取字节的长度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">byte</span>[] a,<span class="keyword">int</span> off,<span class="keyword">int</span> len);</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/DataInputStream.png" alt="fail" title="DataInputStream"><br><strong>DataOutputStream</strong><br>数据输出流允许应用程序以与机器无关方式将<strong>Java 8种基本数据类型</strong>写到底层输出流,方法命名为writeXxx。<br>下面的构造方法用来创建数据输出流对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(OutputStream  out);</div></pre></td></tr></table></figure></p><p>创建对象成功后，可以参照以下列表给出的方法，对流进行写操作或者其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/DataOutputStream.png" alt="fail" title="DataOutputStream"><br>下面的例子演示了DataInputStream和DataOutputStream的使用，该例从文本文件test.txt中读取5行，并转换成大写字母，最后保存在另一个文件test1.txt中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"></div><div class="line">      DataInputStream d = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span></div><div class="line">                               FileInputStream(<span class="string">"test.txt"</span>));</div><div class="line"></div><div class="line">      DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span></div><div class="line">                               FileOutputStream(<span class="string">"test1.txt"</span>));</div><div class="line"></div><div class="line">      String count;</div><div class="line">      <span class="keyword">while</span>((count = d.readLine()) != <span class="keyword">null</span>)&#123;</div><div class="line">          String u = count.toUpperCase();</div><div class="line">          System.out.println(u);</div><div class="line">          out.writeBytes(u + <span class="string">"  ,"</span>);</div><div class="line">      &#125;</div><div class="line">      d.close();</div><div class="line">      out.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="对象流-ObjectInputStream、ObjectOutputStream"><a href="#对象流-ObjectInputStream、ObjectOutputStream" class="headerlink" title="对象流(ObjectInputStream、ObjectOutputStream)"></a>对象流(ObjectInputStream、ObjectOutputStream)</h3><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>对象序列化，就是把一个对象变为二进制的数据流的一种方法，通过对象序列化可以方便的实现对象的传输或存储。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/对象序列化.png" alt="fail" title="对象序列化">    </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/对象序列化步骤.png" alt="fail" title="对象序列化"><br><strong>注意：</strong>Serializable接口和Cloneable接口一样是一个标记接口，即没有任何方法的接口。但只有一个类实现了Serializable接口，它才能被序列化为二进制流进行传输，否则会抛出NotSerializableException异常。一个类如果实现了Serializable接口，其子类也都可以序列化。  </p><p>定义一个可被序列化的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> String name ; </div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> age ;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name ;</div><div class="line"><span class="keyword">this</span>.age = age ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"；年龄："</span> + <span class="keyword">this</span>.age ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>以后此类的对象就可以被序列化了。变为二进制byte流。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/序列化和反序列化.png" alt="fail" title="序列化和反序列化">   </p><h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>在对象进行序列化或反序列化操作的时候，要考虑JDK版本的问题，如果序列化的JDK版本和反序列化的JDK版本不统一则就有可能造成异常。所以在序列化操作中引入了一个serialVersionUID的常量，可以通过此常量来验证版本的一致性，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现版本不一致的异常。</p><p>在上述的Person类中添加<code>private static final long serialVersionUID = 1L;</code>即可</p><h4 id="对象的序列化和反序列化"><a href="#对象的序列化和反序列化" class="headerlink" title="对象的序列化和反序列化"></a>对象的序列化和反序列化</h4><p>要想完成对象的输入或输出，还必须依靠对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）,<br><strong>使用对象输出流输出序列化对象的过程，即把Java对象转换为字节序列的过程</strong>，也称为<strong>序列化</strong>，而<strong>使用对象输入流读入的过程，即把字节序列恢复为Java对象的过程</strong>，也称为<strong>反序列化</strong>。  </p><h4 id="ObjectOutputStream-序列化"><a href="#ObjectOutputStream-序列化" class="headerlink" title="ObjectOutputStream(序列化)"></a>ObjectOutputStream(序列化)</h4><p>常用构造方法：<br>public ObjectOutputStream(OutputStream out)  //接收一个字节输出流对象  </p><p>常用方法：<br>public final void writeObject(Object obj) //把一个对象写入输出流 </p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo01</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"test.txt"</span>) ; <span class="comment">// 定义保存路径  </span></div><div class="line">        ObjectOutputStream oos = <span class="keyword">null</span> ; <span class="comment">// 声明对象输出流  </span></div><div class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f) ;    <span class="comment">// 文件输出流  </span></div><div class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(out) ;  </div><div class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">30</span>)) ;  <span class="comment">// 保存对象  </span></div><div class="line">        oos.close() ;   <span class="comment">// 关闭  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>对象序列化的真正内容：由于堆中只保存对象的非静态属性，方法和静态属性保存在静态区。所以序列化的实际是对象的非静态属性。  </p><h4 id="ObjectInputStream-反序列化"><a href="#ObjectInputStream-反序列化" class="headerlink" title="ObjectInputStream(反序列化)"></a>ObjectInputStream(反序列化)</h4><p>常用构造方法：<br>public ObjectInputStream(InputStream in)  //接收一个字节输入流对象<br>常用方法：<br>public final Object readObject()  //把输入流读出对象</p><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"test.txt"</span>) ;</div><div class="line">ObjectInputStream ois = <span class="keyword">null</span> ;</div><div class="line">InputStream in = <span class="keyword">new</span> FileOutputStream(f);</div><div class="line">ois = <span class="keyword">new</span> ObjectInStream(in) ;</div><div class="line">Person person = (Person)ois.readObject();</div><div class="line">oos.close() ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><p>当使用Serializable接口实现序列化操作时，如果一个对象中的某个属性不希望被JVM默认序列化的话，则可以使用transient关键字进行声明。如果用transient声明一个实例变量，当对象存储时，它的值不需要维持，而会保持默认值。换句话来说就是，用transient关键字标记的成员变量不参与JVM的默认序列化过程。  </p><p>更多序列化知识见：<br><a href="https://www.jianshu.com/p/0221518ad38f" target="_blank" rel="external">Java序列化心得（一）：序列化设计和默认序列化格式的问题</a><br><a href="https://www.jianshu.com/p/352fa61e0512" target="_blank" rel="external">Java序列化心得（二）：自定义序列化</a><br><a href="http://blog.csdn.net/u013087513/article/details/52174690" target="_blank" rel="external">Java IO操作——对象序列化（Serializable接口、ObjectOutputStream、以及与Externalizable接口的用法和区别）</a></p><p>拓展：ArrayList源码中对序列化的实现就是默认序列化和自定义序列化混合，只对底层数组的有效元素进行序列化，多余空间不必序列化，从而提高了性能。  </p><p>在对子类进行反序列化的操作时，没有实现Serializable接口的父类的构造方法会被自顶向下调用。</p><h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>在日常的使用中经常会使用到像WinRAR或WinZIP这样的压缩文件，通过这些软件可以把一个很大的文件进行压缩以方便传输。<br>在JAVA中 为了减少传输时的数据量也提供了专门的压缩流，可以将文件或文件夹压缩成ZIP、JAR、GZIP等文件的格式。<br>具体见大牛博客：<br><a href="http://blog.csdn.net/u013087513/article/details/52151227" target="_blank" rel="external">http://blog.csdn.net/u013087513/article/details/52151227</a>  </p><h3 id="管道流-PipedOutputStream、PipedInputStream"><a href="#管道流-PipedOutputStream、PipedInputStream" class="headerlink" title="管道流(PipedOutputStream、PipedInputStream)"></a>管道流(PipedOutputStream、PipedInputStream)</h3><p>管道流的作用是可以进行两个线程间的通讯，分为管道输出流(PipedOutputStream)、管道输入流(PipedInputStream)如果要想进行管道输出，则必须把输出流连在输入流之上，在PipedOutputStream中有一个方法用于连接管道：<br><strong>public void connect(PipedInputStream snk) throws IOException</strong>  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/管道流.png" alt="fail">  </p><p>例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;<span class="comment">// 线程类</span></div><div class="line"><span class="keyword">private</span> PipedOutputStream pos = <span class="keyword">null</span> ;<span class="comment">// 管道输出流</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.pos = <span class="keyword">new</span> PipedOutputStream() ;<span class="comment">// 实例化输出流</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">String str = <span class="string">"Hello World!!!"</span> ;<span class="comment">// 要输出的内容</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">this</span>.pos.write(str.getBytes()) ;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">this</span>.pos.close() ;</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getPos</span><span class="params">()</span></span>&#123;<span class="comment">// 得到此线程的管道输出流</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.pos ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> PipedInputStream pis = <span class="keyword">null</span> ;<span class="comment">// 管道输入流</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Receive</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.pis = <span class="keyword">new</span> PipedInputStream() ;<span class="comment">// 实例化输入流</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>] ;<span class="comment">// 接收内容</span></div><div class="line"><span class="keyword">int</span> len = <span class="number">0</span> ;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">len = <span class="keyword">this</span>.pis.read(b) ;<span class="comment">// 读取内容</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">this</span>.pis.close() ;<span class="comment">// 关闭</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"接收的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getPis</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.pis ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">Send s = <span class="keyword">new</span> Send() ;</div><div class="line">Receive r = <span class="keyword">new</span> Receive() ;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">s.getPos().connect(r.getPis()) ;<span class="comment">// 连接管道</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Thread(s).start() ;<span class="comment">// 启动线程</span></div><div class="line"><span class="keyword">new</span> Thread(r).start() ;<span class="comment">// 启动线程</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="回退流-PushbackInputStream和PushbackReader"><a href="#回退流-PushbackInputStream和PushbackReader" class="headerlink" title="回退流(PushbackInputStream和PushbackReader)"></a>回退流(PushbackInputStream和PushbackReader)</h3><p>在Java IO中所有的数据都是采用顺序的读取方式，即对于一个输入流来讲都是采用从头到尾的顺序读取的，如果在输入流中某个不需要的内容被读取进来，则只能通过程序将这些不需要的内容处理掉，为了解决这样的处理问题，在Java中提供了一种回退输入流(PushbackInputStream、PushbackReader),可以把读取进来的某些数据重新回退到输入流的缓冲区之中。</p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/回退流.png" alt="fail" title="回退流的工作原理">  </p><p>回退流分为字节回退流和字符回退流，我们以字节回退流PushbackInputStream为例。  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/PushbackInputStream.png" alt="fail">   </p><p>对于回退操作来说，提供了三个unread()的操作方法，这三个操作方法与InputStream类中的read()方法是一一对应的。</p><p> 例子如下，内存中使用ByteArrayInputStream，把内容设置到内存之中：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PushbackInputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushInputStreamDemo</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">String str = <span class="string">"www.baidu.com"</span> ;<span class="comment">// 定义字符串</span></div><div class="line">PushbackInputStream push = <span class="keyword">null</span> ;<span class="comment">// 定义回退流对象</span></div><div class="line">ByteArrayInputStream bai = <span class="keyword">null</span> ;<span class="comment">// 定义内存输入流</span></div><div class="line">bai = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()) ;<span class="comment">// 实例化内存输入流</span></div><div class="line">push = <span class="keyword">new</span> PushbackInputStream(bai) ;<span class="comment">// 从内存中读取数据</span></div><div class="line">System.out.print(<span class="string">"读取之后的数据为："</span>) ;</div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ; </div><div class="line"><span class="keyword">while</span>((temp=push.read())!=-<span class="number">1</span>)&#123;<span class="comment">// 读取内容</span></div><div class="line"><span class="keyword">if</span>(temp==<span class="string">'.'</span>)&#123;<span class="comment">// 判断是否读取到了“.”</span></div><div class="line">push.unread(temp) ;<span class="comment">// 放回到缓冲区之中</span></div><div class="line">temp = push.read() ;<span class="comment">// 再读一遍</span></div><div class="line">System.out.print(<span class="string">"（退回"</span>+(<span class="keyword">char</span>)temp+<span class="string">"）"</span>) ;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">System.out.print((<span class="keyword">char</span>)temp) ;<span class="comment">// 输出内容</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="选择合适的IO流"><a href="#选择合适的IO流" class="headerlink" title="选择合适的IO流"></a>选择合适的IO流</h3><p>1.首先，明确IO流中有两个主要的体系，即  InputStream、OutputStream和Reader、Writer。其次，明确数据的来源和数据将要到达的目的地。  </p><p>2.明确将要操作的数据是否是纯文本数据。如果数据源是纯文本数据选Reader;数据源不是纯文本数据选择InputStream。如果数据目的地是纯文本数据就选择Writer;如果不是则选择OutputStream。  </p><p>3.明确具体的设备。即数据源是从哪个设备来的：是硬盘就加File;是键盘用System.in(是一个InputStream对象);是内存用数组;是网络用Socket流。同样目的是哪个设备：是硬盘就加File;是键盘用System.out(是一个PrintStream对象);是内存用数组;是网络用Socket流。    </p><p>4.明确是否还需要其他额外功能呢，例如：<br>①是否需要较高的效率，即是否需要使用缓冲区，是就加上Buffered;<br>②是否需要转换，是就使用转换流，InputStreamReader 和OutputStreamWriter。  </p><p>例子：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/1.jpg" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/2.jpg" alt="fail">   </p><h3 id="System类对IO的支持-out、err、in"><a href="#System类对IO的支持-out、err、in" class="headerlink" title="System类对IO的支持(out、err、in)"></a>System类对IO的支持(out、err、in)</h3><p>System类的常量<br>System表示系统类，实际上在Java中也对IO给予了一定的支持<br>1、public static final PrintStream out<br>//常量  对应系统标准输出，一般是显示器<br>2、public static final PrintStream err<br>//常量 错误信息输出<br>3、public static final InputStream in<br>//常量 对应标准输出，一般是键盘</p><p>使用static final关键字声明的变量是全局常量，只要是常量，则所有的单词字母必须全部大写，按照现在的标准：<br>System.OUT —&gt; System.out  </p><h4 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h4><p>使用System.out输出的时候就是将输出的位置定义在了显示器之中。FileOutputStream是定位在文件里，而System.out是定位在屏幕上输出。PrintStream就是OutputStream的子类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.OutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.IOException ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo01</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">OutputStream out = System.out ;<span class="comment">// 此时的输出流是向屏幕上输出</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">out.write(<span class="string">"hello world!!!"</span>.getBytes()) ;<span class="comment">// 向屏幕上输出</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;<span class="comment">// 打印异常</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">out.close() ;<span class="comment">// 关闭输出流</span></div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">e.printStackTrace() ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System1.png" alt="fail">   </p><h4 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h4><p>System.err 表示的是错误的标准输出，如果程序中出现了错误的话，则直接使用System.err进行输出即可。程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo02</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"hello"</span> ;<span class="comment">// 声明一个非数字的字符串</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(Integer.parseInt(str)) ;<span class="comment">// 转型</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">System.err.println(e) ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System2.png" alt="fail"><br>使用System.out输出错误如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo03</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"hello"</span> ;<span class="comment">// 声明一个非数字的字符串</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(Integer.parseInt(str)) ;<span class="comment">// 转型</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">System.out.println(e) ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System3.png" alt="fail">  </p><p><strong>System.out 和System.err 的区别：</strong>System.out和System.err都是PrintStream的实例化对象，而且通过代码可以发现，两者都可以输出错误信息，但是一般来讲System.out是将信息显示给用户看，是正常的信息显示，而System.err的正好相反是不希望用户看到的，会直接在后台打印，是专门显示错误的。<br>一般来讲，如果要输出错误信息的时候最好不要使用System.out而是直接使用System.err 这一点只能从其概念上划分。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/System4.png" alt="fail">  </p><h4 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h4><p>System.in实际上是一个键盘的输入流，其本身是InputStream类型的对象。那么，此时就可以利用此方式完成从键盘读取数据的功能。<br>InputStream对应的是输入流，输入流的话肯定是从指定位置读取的，之前使用的是FileInputStream，是从文件中读取的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo04</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">InputStream input = System.in ;<span class="comment">// 从键盘接收数据</span></div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>] ;<span class="comment">// 开辟空间，接收数据</span></div><div class="line">System.out.print(<span class="string">"请输入内容："</span>) ;<span class="comment">// 提示信息</span></div><div class="line"><span class="keyword">int</span> len = input.read(b) ;<span class="comment">// 接收数据</span></div><div class="line">System.out.println(<span class="string">"输入的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">input.close() ;<span class="comment">// 关闭输入流</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>但是以上的操作存在如下问题：<br>问题一：指定了输入数据的长度，如果现在输入的数据超过了长度范围，只能输入部分的数据。<br>问题二：如果byte数组是奇数的话，则还可能出现中文乱码的情况，因为一个字符是两个字节。  </p><p>可以通过标志位的方式避免指定byte数组大小来解决。实例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo05</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">InputStream input = System.in ;<span class="comment">// 从键盘接收数据</span></div><div class="line">StringBuffer buf = <span class="keyword">new</span> StringBuffer() ;<span class="comment">// 使用StringBuffer接收数据</span></div><div class="line">System.out.print(<span class="string">"请输入内容："</span>) ;<span class="comment">// 提示信息</span></div><div class="line"><span class="keyword">int</span> temp = <span class="number">0</span> ;<span class="comment">// 接收内容</span></div><div class="line"><span class="keyword">while</span>((temp=input.read())!=-<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>) temp ;<span class="comment">// 将数据变为字符</span></div><div class="line"><span class="keyword">if</span>(c==<span class="string">'\n'</span>)&#123;<span class="comment">// 退出循环，输入回车表示输入完成</span></div><div class="line"><span class="keyword">break</span> ;</div><div class="line">&#125;</div><div class="line">buf.append(c) ;<span class="comment">// 保存内容</span></div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"输入的内容为："</span> + buf) ;</div><div class="line">input.close() ;<span class="comment">// 关闭输入流</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这种方法读取中文还是会乱码，这是因为每读取一个字节就将其转为字符，字母和数字都是占1个字节 可以正常显示。但是如果是中文的话，就相当于每读取到一个字节就是半个字符就进行转化，所以导致乱码的错误。<br>最好的输入方式是将全部输入的数据暂时存放在一块内存之上，之后一次性的从内存中读取数据，这样所有数据就整体只读了一次，则不会造成乱码，而且也不会受到长度的限制。  </p><p><img src="/2017/11/28/Java学习总结之Java-IO系统/System5.png" alt="fail">  </p><p>上述功能可以通过BufferedReader实现。  </p><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>从之前的操作中知道System.out、System.err、System.in三个常量的作用，但是通过System类也可以改变System.in的输入流来源，以及System.out和System.err两个输出流的输出位置。<br>1、public static void setOut(PrintStream out)<br>//普通方法 重定向标准输出流<br>2、public static void setErr(PrintStream err)<br>//普通方法 重定向标准错误输出流<br>3、public static void setIn(InputStream in)<br>//普通方法 重定向标准输入流</p><h4 id="为System-out输出重定向"><a href="#为System-out输出重定向" class="headerlink" title="为System.out输出重定向"></a>为System.out输出重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo06</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">System.setOut(</div><div class="line"><span class="keyword">new</span> PrintStream(</div><div class="line"><span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span> + </div><div class="line">File.separator + <span class="string">"red.txt"</span>))) ;<span class="comment">// System.out输出重定向</span></div><div class="line">System.out.print(<span class="string">"hello"</span>) ;<span class="comment">// 输出时，不再向屏幕上输出</span></div><div class="line">System.out.println(<span class="string">",world"</span>) ;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>System.out是希望用户看得到信息，一旦有错误，最好保存起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo07</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">String str = <span class="string">"hello"</span> ;<span class="comment">// 声明一个非数字的字符串</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.out.println(Integer.parseInt(str)) ;<span class="comment">// 转型</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">System.setOut(</div><div class="line"><span class="keyword">new</span> PrintStream(</div><div class="line"><span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span></div><div class="line">+ File.separator + <span class="string">"err.log"</span>))) ;<span class="comment">// 输出重定向</span></div><div class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">System.out.println(e) ;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>通过此操作就可以完成错误的重定向，保存错误日志。</strong>  </p><h4 id="为System-err重定向"><a href="#为System-err重定向" class="headerlink" title="为System.err重定向"></a>为System.err重定向</h4><p>利用System.err向屏幕上输出信息，此时，为了方便起见，使用内存操作流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo08</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">ByteArrayOutputStream bos = <span class="keyword">null</span> ;<span class="comment">// 声明内存输出流</span></div><div class="line">bos = <span class="keyword">new</span> ByteArrayOutputStream() ;<span class="comment">// 实例化</span></div><div class="line">System.setErr(<span class="keyword">new</span> PrintStream(bos)) ;<span class="comment">// 输出重定向</span></div><div class="line">System.err.print(<span class="string">"hello"</span>) ;<span class="comment">// 错误输出，不再向屏幕上输出</span></div><div class="line">System.err.println(<span class="string">"world"</span>) ;<span class="comment">// 向内存中输出</span></div><div class="line">System.out.println(bos) ;<span class="comment">// 输出内存中的数据</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>一般不建议去修改System.err的输出位置，因为这样的信息都不太希望用户可以看见。  </p><h4 id="为System-in重定向"><a href="#为System-in重定向" class="headerlink" title="为System.in重定向"></a>为System.in重定向</h4><p>默认情况下System.in是指键盘输入，也可以通过setIn()方法，将其输入流的位置改变，例如，现在从文件中读取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo09</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;<span class="comment">// 所有异常抛出</span></div><div class="line">System.setIn(<span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span></div><div class="line">+ File.separator + <span class="string">"demo.txt"</span>)) ;<span class="comment">// 设置输入重定向</span></div><div class="line">InputStream input = System.in ;<span class="comment">// 从文件中接收数据</span></div><div class="line"><span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">// 开辟空间，接收数据</span></div><div class="line"><span class="keyword">int</span> len = input.read(b) ;<span class="comment">//接收</span></div><div class="line">System.out.println(<span class="string">"输入的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">input.close() ;<span class="comment">// 关闭输入流</span></div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个常量的使用：  </p><ul><li>System.out是希望用户可以看见的信息。用IDE(Eclipse)的话错误信息使用黑颜色显示的。  </li><li>System.err 是不希望用户可以看见的信息。则在IDE中将以红色的文字显示错误信息。  </li><li>System.in 对应键盘输入。  </li><li>以上三个常量的输入、输出都可以重定向，但是一般建议只修改setOut的重定向。  </li><li>System.in读取的时候会出现中文乱码的问题，则可以通过BufferedReader完成读取功能。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用telnet发送HTTP请求报文</title>
    <link href="http://habitdiary.cn/2017/11/19/%E4%BD%BF%E7%94%A8telnet%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87/"/>
    <id>http://habitdiary.cn/2017/11/19/使用telnet发送HTTP请求报文/</id>
    <published>2017-11-19T15:30:25.000Z</published>
    <updated>2017-11-29T13:32:18.128Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以使用telnet给特定的Web服务器发送HTTP请求报文，得到服务器的HTTP相应报文。</p><p>比如，打开终端输入下面命令：  </p><p>telnet www.baidu.com 80  //Web服务器ip或域名、端口<br>GET <a href="https://www.baidu.com/" target="_blank" rel="external">https://www.baidu.com/</a>  HTTP/1.1<br>//请求行：方法字段、URL字段、HTTP版本字段<br>Host: www.baidu.com //首部行</p><p>在输入最后一个首部行之后连续按两次回车，这就打开一个到主机 www.baidu.com 的80端口的TCP连接，并发送一个HTTP请求报文。你将会看到一个携带包括百度主页的HTML基本文件的相应报文(HTML文件，即对象被封装在相应报文的实体体中)。如果只是想看一下HTTP协议的报文行，而不是获取对象本身的话，可以用HEAD代替GET。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以使用telnet给特定的Web服务器发送HTTP请求报文，得到服务器的HTTP相应报文。&lt;/p&gt;
&lt;p&gt;比如，打开终端输入下面命令：  &lt;/p&gt;
&lt;p&gt;telnet www.baidu.com 80  //Web服务器ip或域名、端口&lt;br&gt;GET &lt;a href=
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://habitdiary.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用telnet登录SMTP服务发送邮件</title>
    <link href="http://habitdiary.cn/2017/11/19/%E4%BD%BF%E7%94%A8telnet%E7%99%BB%E5%BD%95SMTP%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>http://habitdiary.cn/2017/11/19/使用telnet登录SMTP服务发送邮件/</id>
    <published>2017-11-19T13:59:48.000Z</published>
    <updated>2017-11-19T15:28:43.717Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《计算机网络自顶向下方法》，初步了解了SMTP协议。尝试用telnet登录SMTP服务给自己的qq邮箱发送了一封邮件，中间踩了很多坑，现在把具体步骤总结如下：  </p><p><strong>1.打开终端，输入<code>telnet</code>,回车</strong>  </p><p><strong>2.输入<code>o smtp.139.com 25</code>,此处o是open的缩写,以139邮箱为例,25表示SMTP服务器时刻监听的端口号,登录SMTP服务器。服务器返回<code>220 localhost richmail system v10(2eff5a1190ba8e2-ea850)</code>表示成功</strong>  </p><p><strong>3.输入<code>HELO xxx</code>,和服务器打招呼,xxx可以是任意内容,确认服务器应答,服务器返回<code>250 localhost richmail system v10(2eff5a1190ba8e2-ea850)</code>表示成功</strong>  </p><p><strong>4.输入<code>auth login</code>,请求登录,服务器返回<code>334 dXNlcm5hbWU6</code>,334是成功的状态码,后面是 username: 的base64码,可以在网上找到编码和解码工具</strong>  </p><p><strong>5.输入转换为base64码后的发送邮箱的用户名,不用带邮件域名，服务器返回<code>334 UGFzc3dvcmQ6</code>，334是成功的状态码，后面是 password: 的base64码</strong>  </p><p><strong>6.输入转换为base64码后的发送邮箱的密码,服务器返回<code>235 Authentication successful</code>表示登录成功</strong>  </p><p><strong>7.输入<code>MAIL FROM:&lt;发件人邮箱地址&gt;</code>，告诉服务器发信人的地址,服务器返回<code>250 Mail OK</code>表示成功</strong>  </p><p><strong>8.输入<code>RCPT TO:&lt;收件人邮箱地址&gt;</code>，告诉服务器收信人的地址,服务器返回<code>250 Mail OK</code>表示成功</strong>  </p><p><strong>9.输入<code>DATA</code>,开始写邮件,服务器返回<code>354 End data with .</code>提示邮件以一个单独占有一行的<code>.</code>结束</strong>  </p><p><strong>10.邮件格式如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">To:收件人邮箱地址</div><div class="line">From:发件人邮箱地址</div><div class="line">Subject:邮件主题 //前三行是首部行</div><div class="line">//首部行和报文体之间要有一个空行</div><div class="line">邮件正文//报文体</div><div class="line">． //结束邮件的标志</div></pre></td></tr></table></figure></p><p><strong>服务器返回<code>250 ok</code>表示发送成功，如果要继续发送，则返回步骤7重复即可。</strong>  </p><p><strong>11.发送完所有邮件之后输入<code>QUIT</code>,关闭TCP连接</strong> </p><p><strong>下面是成功接收的邮件</strong></p><p><img src="/2017/11/19/使用telnet登录SMTP服务发送邮件/test.png" alt="fail">  </p><p><strong>注意几个坑：<br>1.发件方使用的是139邮箱，尝试qq邮箱和163邮箱开启了SMTP服务也不成功，可能是基于安全性考虑进行了限制<br>2.收件方邮箱如果有反垃圾机制，应该事先关闭，否则会拒绝接收邮件</strong>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在看《计算机网络自顶向下方法》，初步了解了SMTP协议。尝试用telnet登录SMTP服务给自己的qq邮箱发送了一封邮件，中间踩了很多坑，现在把具体步骤总结如下：  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.打开终端，输入&lt;code&gt;telnet&lt;/code&gt;,回车&lt;/str
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://habitdiary.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之异常处理</title>
    <link href="http://habitdiary.cn/2017/11/08/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://habitdiary.cn/2017/11/08/Java学习总结之异常处理/</id>
    <published>2017-11-08T13:42:16.000Z</published>
    <updated>2018-02-01T12:44:29.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在程序运行过程中<strong>(注意是运行阶段，程序可以通过编译)</strong>，如果JVM检测出一个不可能执行的操作，就会出现<strong>运行时错误</strong>。例如，使用一个越界的下标访问数组，程序就会产生一个ArrayIndexOutOfBoundsException的运行时错误。如果程序需要输入一个整数的时候用户输入了一个double值，会得到一个InputMismatchException的运行时错误。<br>在Java中，运行时错误会作为<strong>异常</strong>抛出。<strong>异常</strong>就是一种对象，表示阻止正常进行程序执行的错误或者情况。如果异常没有被处理，那么程序就会非正常终止。<br>人们在遇到错误时会感觉不爽。如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序了，为了避免这类事<br>情的发生，至少应该做到以下几点：  </p><ul><li>向用户通告错误</li><li>保存所有的工作结果</li><li>允许用户以妥善的形式退出程序  </li></ul><p>Java使用一种称为<strong>异常处理</strong>的错误捕获机制处理，从而使程序继续运行或优雅终止。  </p><h3 id="异常处理概述"><a href="#异常处理概述" class="headerlink" title="异常处理概述"></a>异常处理概述</h3><p>异常处理使得程序可以处理非预期的情景，并且继续正常的处理。<br>我们来看一个读取两个整数并显示它们商的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quotient</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">        <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">        <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">        + <span class="string">" is "</span> + (number1 / number2));</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果number2为0,就会产生一个运行时错误，因为不能用一个整数除以0(注意，一个浮点数除以0不会产生异常)。<br>我们可以添加一个if语句来测试第二个数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quotient</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">        <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">        <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">        <span class="keyword">if</span>(number2 != <span class="number">0</span>)</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">        + <span class="string">" is "</span> + (number1 / number2));</div><div class="line">        <span class="keyword">else</span></div><div class="line">        System.out.println(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了介绍异常处理，我们使用一个<strong>方法</strong>来实现两个整数求商的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuotientWithMethod</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(number2 == <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> number1 / number2;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">    <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> result = quotient(number1,number2);</div><div class="line">    System.out.println(number1 + <span class="string">" / "</span> + number2 </div><div class="line">    + <span class="string">" is "</span> + result);</div></pre></td></tr></table></figure></p><p>但上述代码有一个问题：当number2为0时，程序在quotient方法内终止。但不应该让一个方法来终止程序 —— <strong>应该由方法的调用者决定是否终止程序，即方法只需要通知其调用者有运行时错误产生，而不应该自己做决定。</strong><br>下面使用异常处理的方法，让quotient方法抛出一个异常，使其被调用这捕获和处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuotientWithException</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (number2 == <span class="number">0</span>) </div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"Divisor cannot be zero"</span>);</div><div class="line">        <span class="keyword">return</span> number1 / number2;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Scanner input = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"Enter two integers: "</span>);</div><div class="line">    <span class="keyword">int</span> number1 = input.nextInt();</div><div class="line">    <span class="keyword">int</span> number2 = input.nextInt();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">int</span> result = quotient(number1,number2);</div><div class="line">        System.out.println(number1 + <span class="string">" / "</span> + number2 + <span class="string">" is "</span></div><div class="line">        + result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(ArithmeticException ex) &#123;</div><div class="line">System.out.println(<span class="string">"Exception: an integer "</span> + </div><div class="line">        <span class="string">"cannot be divided by zero"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"Execution continues ..."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以看到，上面的代码能使方法抛出一个异常给调用者，并由调用者处理该异常。如果不这么做，被调用的方法本身必须处理异常或者终止程序。但是库方法在设计时通常无法确定在出错时要进行什么操作，最好的做法就是将检测出的错误作为异常抛出给调用者处理，查阅API我们也会发现库方法会对其可能抛出的异常进行说明。异常处理的最根本优势就是<strong>将检测错误(由被调用的方法完成)从处理错误(由调用方法完成)中分离出来。</strong><br>当然，如果运行时错误发生在main方法中，就不必抛出异常了，可以考虑提供一个异常处理器对异常进行捕获和处理。  </p><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>异常是对象，而对象都采用类来定义。在 Java 程序设计语言中， 异常对象都是派生于 Throwable 类的一个实例。稍后还可以看到，如果 Java 中内置的异常类不能够满足需求，用户可以创建自己的异常类。  </p><p>下面是Java中的异常层次结构：  </p><p><img src="/2017/11/08/Java学习总结之异常处理/Java异常层次结构.jpg" alt="fail" title="Java异常层次结构"><br>可以看到，Throwable是所有异常类的根类，所有异常类都直接或间接继承自 Throwable。但在下一层立即分解为两个分支：Error 和 Exception。<br><strong>Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。</strong>应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。这种情况很少出现。<br>在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：<br>一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像 I/O 错误这类<br>问题导致的异常属于其他异常。<br>有一条相当有道理的规则：<strong>如果出现 RuntimeException，那么就一定是你的问题</strong>。<br>也就是说，RuntimeException是可以在编程时避免的。比如，可以通过检测数组下标是否越界来避免IndexOutOfBoundsException，可以通过在使用变量前检测是否为null杜绝NullPointerException。  </p><p><strong>免检异常：</strong>又称非受查异常(Unchecked Exception)，RuntimeException、Error以及它们的子类都称为免检异常。意思是编译器不会强制检查程序是否处理或声明了异常。如果想让使用某方法的程序员注意到方法可能抛出的免检异常，可以给该方法加上文档注释。<br><strong>必检异常：</strong>又称受查异常(Checked Exception)，除了免检异常的其他异常都是必检异常，意思是编译器会强制程序员检查并通过try-catch语句处理它们，或者在方法头进行声明，否则无法通过编译。  </p><h3 id="关于异常处理的更多知识"><a href="#关于异常处理的更多知识" class="headerlink" title="关于异常处理的更多知识"></a>关于异常处理的更多知识</h3><p><strong>异常处理器是通过从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到的。</strong>即如果某方法的异常没有在该方法内被捕获和处理，就会被抛出给它的调用者，并在调用者中搜寻相应的异常处理器，如果还没有找到就继续上抛，如果在整个方法调用链中异常都没有被捕获处理，该异常会被抛给JVM，JVM会终止程序并打印错误信息。<br>Java的异常处理模型基于三种操作：  </p><ul><li>声明异常  </li><li>抛出异常  </li><li>捕获异常  </li></ul><h3 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h3><p>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如，一段读取文件的代码知道有可能读取的文件不存在， 或者内容为空，因此， 试图处理文件信息的代码就需要通知编译器可能会抛出 IOException 类的异常。<br>方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出异常。<br>每个方法只需声明所有它可能抛出的<strong>必检异常类型</strong>，这称为<strong>声明异常</strong>。无需声明免检异常，因为免检异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)。<br>可以声明多个异常，用逗号隔开即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception1, Exception2,...</span></div></pre></td></tr></table></figure></p><p>当然，从前面的示例中可以知道：除了声明异常之外， 还可以捕获异常。这样会使异常不被抛到方法之外，也不需要 throws 规范。稍后，将会讨论如何决定一个异常是被捕获，还是被抛出让其他的处理器进行处理。<br>下面有一些规则：  </p><ul><li>在方法定义处声明的异常类型可以是方法内抛出异常的类型及其父类型。</li><li>如果在子类中重写了父类的一个方法，子类方法中声明的受查异常必须是父类所声明异常的同类或子类(也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常)  </li><li>如果在超类方法中没有声明/抛出异常，子类也不能声明/抛出异常  </li></ul><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>检测到错误的程序可以创建一个合适的异常类型的实例并抛出它，这就称为<strong>抛出异常</strong>。下面有一个例子，方法的参数必须是非负的，如果传入一个负参数，程序就创建一个IllegalArgumentException实例并抛出它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IllegalArgumentException ex = </div><div class="line"><span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong Argument"</span>);</div><div class="line"><span class="keyword">throw</span> ex;</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Wrong Argument"</span>);</div></pre></td></tr></table></figure></p><p>第一种写法创建了一个异常对象并赋给一个异常类引用变量，并抛出它;第二种写法则直接抛出一个匿名异常对象。<br>Java库中每个异常类一般至少有两个构造方法：一个无参构造方法和一个带可描述这个异常的String参数的构造方法。如上述就使用了带参数的构造方法并传入了”Wrong Argument”的异常描述。可以通过在异常对象上调用getMessage()获取异常描述字符串。<br>抛出异常的三个步骤：  </p><ol><li>找到一个合适的异常类  </li><li>创建这个类的一个对象 </li><li>将对象抛出  </li></ol><p><strong>注意：</strong>这里所说抛出异常是指我们在编写程序时用throw关键字显式抛出异常，但是在很多情况下，异常是由库方法抛出的，throw关键字被封装在库方法中，对用户是不可见的，此时用户程序中是没有显式的throw关键字的。  </p><p>我们使用throw关键字手动抛出异常有两种基本方案：<br>1、在throw语句外加上对应异常的try-catch块，即自己抛出的异常自己捕获处理。<br>2、在含有throw语句的方法声明处通过throws关键字声明对应的异常，由方法的调用者来处理这个异常。<br><img src="/2017/11/08/Java学习总结之异常处理/throw.png" alt="fail"></p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>当抛出一个异常时，可以提供try-catch语句来捕获和处理它，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   statements; <span class="comment">// Statements that may throw exceptions</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception exVar1) &#123;</div><div class="line">    handler <span class="keyword">for</span> exception1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception exVar2) &#123;</div><div class="line">    handler <span class="keyword">for</span> exception2;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="keyword">catch</span>(Exception exVarN) &#123;</div><div class="line">    handler <span class="keyword">for</span> exceptionN;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>可以为一个try块提供多个catch语句，因为一个try块可能抛出多种不同类型的异常。<br>如果在执行try块的过程中没有出现异常，则跳过catch子句。<br>如果try块中的某条语句抛出一个异常，Java就会跳过try块中剩余的语句，然后开始查找合适的处理异常的代码，即<strong>异常处理器</strong>。可以从当前的方法开始，沿着方法调用链，按照异常的<strong>反向传播</strong>方向找到这个处理器。从第一个到最后一个逐个检查catch块，判断在catch块中的异常类变量是否是该异常对象的类型。如果是，就将该异常对象赋值给所声明的变量，然后执行catch块中的代码。如果没有发现异常处理器，Java会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来查找处理器。如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息。<strong>寻找处理器的过程称为捕获异常。</strong><br><strong>注意：</strong>如果一个catch块可以捕获一个父类的异常对象，它就能捕获那个父类的所有子类的异常对象。在catch块中异常被指定的顺序是非常重要的，如果父类异常的catch块在子类异常的catch块之前，就会导致编译错误。道理很简单，如果将父类异常的catch块放在子类异常的catch块之前，则子类异常对象一定会被父类异常的catch块捕获，子类异常的catch块就失去了意义。<strong>因为我们无法保证所编写的catch块涵盖了try块中可能出现的所有异常类型，所以建议在多重catch块的最后添加所有异常的父类Exception的异常处理器来保证try块中出现的任何异常被捕获。</strong><br>对于使用同样的处理代码处理多个异常的情况，可以使用<strong>多捕获</strong>特征简化异常的代码编写，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">catch</span>(Exception1 | Exception2 | ... | ExceptionN ex) &#123;</div><div class="line"><span class="comment">// Same code for handling these exceptions</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>小提示：对于InputMismatchedException，要在catch块中吸收错误输入，否则该错误输入将被下一条读取语句读取。</strong></p><h3 id="创建自定义异常类"><a href="#创建自定义异常类" class="headerlink" title="创建自定义异常类"></a>创建自定义异常类</h3><p>在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。在这种情况下，我们可以通过派生Exception类或其子类来创建自定义的异常类。<br>下面给出一个例子，当半径为负时，setRadius方法会抛出一个异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidRadiusException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidRadiusException</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(<span class="string">"Invalid radius "</span> + radius);</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> radius;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>可见异常类里可定义数据域和访问器，使外界能访问到导致异常的非法参数。<br><strong>注意：</strong>建议不要让自定义的异常类继承RuntimeException及其子类，这样会使自定义的异常类称为免检异常，最好使自定义的异常类必检，这样编译器就可以在程序中强制捕获或声明这些异常。</p><h3 id="从异常中获取信息"><a href="#从异常中获取信息" class="headerlink" title="从异常中获取信息"></a>从异常中获取信息</h3><p>异常对象中包含了关于异常的有价值的信息，可以利用Throwable类中的实例方法获取有关的信息，如下所示：<br><img src="/2017/11/08/Java学习总结之异常处理/Throwable1.png" alt="fail"><br><img src="/2017/11/08/Java学习总结之异常处理/Throwable2.png" alt="fail"></p><ul><li>Throwable() 无参构造器  </li><li>Throwable(String message) 带描述异常信息字符串的构造器 </li><li>String getMessage() 返回一个描述该异常对象信息的字符串 </li><li>String toString() 返回三个字符串的连接：1) 异常类的全名; 2) “: “ 一个冒号和一个空格 3) getMessage(方法)  </li><li>void printStackTrace() 在控制台上打印 Throwable对象和它的调用堆栈信息  </li></ul><p>同样Exception和RuntimeException也有类似的方法<br><img src="/2017/11/08/Java学习总结之异常处理/Exception.png" alt="fail"><br><img src="/2017/11/08/Java学习总结之异常处理/RuntimeException.png" alt="fail"><br>堆栈轨迹(stack trace)是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。类似于数据结构中的栈，一个方法被调用就会入栈，即最先被调用的方法(main方法)在栈底，后被调用的方法在栈顶。当一个方法调用结束，就会出栈，也是栈顶方法先出栈，最后main方法也调用完毕，整个方法栈被销毁，程序结束。<br>Throwable的printStackTrace方法就是这样从上到下打印了方法栈，栈顶是产生异常的方法，栈底是main方法。比如下面的代码访问了数组的-1下标，抛出一个ArrayIndexOutOfBoundsException：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">    printArrayElement(array,-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArrayElement</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">System.out.println(a[index]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>打印的堆栈轨迹是：<br><img src="/2017/11/08/Java学习总结之异常处理/stack trace.png" alt="fail"><br>一种更灵活的方法是getStackTrace()，它会得到一个StackTraceElement对象的一个数组，每个元素都是方法堆栈中的一个方法，其API如下：<br><img src="/2017/11/08/Java学习总结之异常处理/getStackTrace.png" alt="fail">  </p><h3 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h3><p>当异常被捕获之后，可以在catch子句中重新抛出异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用的子系统，那么，用于表示子系统的异常类型可能会产生多种解释。ServletException就是这样一个异常类型的例子。执行servlet的代码可能不想知道发生错误的细节原因，但希望明确地知道servlet是否有问题。<br>同原始异常一起抛出一个新异常(带有附加信息)，这称为<strong>异常链</strong>。<br>下面给出了抛出异常链的基本方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">access the database</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SQLException e)</div><div class="line">&#123;</div><div class="line">Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error: "</span> </div><div class="line">    + e.getMessage());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不过，我们发现原始异常被改变了。有一种更好的处理方法，可以将原始异常设置为新异常的”原因”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">access the database</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(SQLException e)</div><div class="line">&#123;</div><div class="line">Throwable se = <span class="keyword">new</span> ServletException(<span class="string">"database error"</span>);</div><div class="line">se.initCause(e);</div><div class="line"><span class="keyword">throw</span> se;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当捕获到异常时，就可以使用下面的这条语句重新得到原始异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Throwable e = se.getCause();</div></pre></td></tr></table></figure></p><p>强烈建议使用这种包装技术，这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。也可以使用带有包装功能的构造方法来封装原始异常并抛出该新异常。  </p><h3 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h3><p>当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有的异常。但是，这种解决方案比较乏味，这是因为需要在两个地方清除所分配的资源。一个在正常的代码中；另一个在异常代码中。<br>Java 有一种更好的解决方案，这就是 finally 子句。无论异常是否产生，finally子句总是会被执行,即使在到达finally子句之前有一个return语句，finally块还是会执行。唯一使finally子句不执行的方法是在finally子句前使用<code>System.exit(1)</code>方法，这个方法的作用是终止正在运行的JVM，参数为0表示程序正常终止，非0表示异常终止。在try块(或try-catch块)和finally块之间不能有其他任何代码。finally子句常用于在抛出异常时关闭资源，比如关闭文件和关闭与数据库的连接。<br>比如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(. . .);</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="comment">//1</span></div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line"><span class="comment">//2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// 3</span></div><div class="line">show error message</div><div class="line"><span class="comment">// 4</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line"><span class="comment">// 5</span></div><div class="line">in.close();</div><div class="line">&#125;</div><div class="line"><span class="comment">//6</span></div></pre></td></tr></table></figure></p><p>在上面的代码中，有下列3种情况会执行finally子句：<br>1) 代码没有抛出异常。在这种情况下，程序首先执行 try 语句块中的全部代码，然后执行 finally 子句中的代码。随后，继续执行 try 语句块之后的下一条语句。也就是说，执行标<br>注的1、2、5、6处<br>2) 抛出一个在 catch 子句中捕获的异常。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try语句块中的所有代码，直到发生异常为止。此时，将跳过 try语句块中的剩余代码，转去执行与该异常匹配的 catch 子句中的代码， 最后执行 finally 子句中的代码。<br> 如果 catch 子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6 处的语句。<br> 如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。在这里， 执行标注<br>1、 3、 5 处的语句。<br>3) 代码抛出了一个异常，但这个异常不是由 catch 子句捕    获的。在这种情况下，程序将执行 try 语句块中的所有语句，直到有异常被抛出为止。此时，将跳过 try 语句块中的剩余代<br>码，然后执行 finally 子句中的语句，并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。<br>try 语句可以只有 finally 子句，而没有 catch 子句。例如，下面这条 try 语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   InputStream in = . .</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>无论在 try 语句块中是否遇到异常，finally 子句中的 in.close()语句都会被执行。当然,<br>如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 catch 子句捕获。<br>强烈建议解耦合 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">InputStream in = . . .;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line">show error message</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>内层的 try 语句块只有一个职责，就是确保关闭输入流。外层的 try 语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚， 而且还具有一个功能，就是<strong>将会报告 finally 子句中出现的错误。</strong><br><strong>注意：</strong>当 finally 子句包含 return 语句时，将会出现一种意想不到的结果„ 假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值。请看一个复杂的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> r = n * n;</div><div class="line"><span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句然而，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值4。<br>有时候， finally 子句也会带来麻烦。例如， 清理资源的方法也有可能抛出异常。假设希望能够确保在流处理代码中遇到异常时将流关闭。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">InputStream in = . . .;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">in.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在，假设在 try 语句块中的代码抛出了一些非 IOException 的异常，这些异常只有这个方法的调用者才能够给予处理。执行 finally 语句块，并调用 close 方法。而 close 方法本身也<br>有可能抛出 IOException 异常。当出现这种情况时， 原始的异常将会丢失，转而抛出 close 方法的异常。<br>这会有问题， 因为第一个异常很可能更有意思。如果你想做适当的处理，重新抛出原来的异常， 代码会变得极其繁琐。 如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">InputStream in = . . .;</div><div class="line">Exception ex = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">    code that might <span class="keyword">throw</span> exceptions</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Exception e)</div><div class="line">    &#123;</div><div class="line">    ex = e;</div><div class="line"><span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">in.close()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Exception e)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (ex = <span class="keyword">null</span>) <span class="keyword">throw</span> e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码太繁琐，在 Java SE 7中提供了一种更便捷的方法。  </p><h3 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的try语句</h3><p>对于以下代码模式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">open a resource</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">work with the resource</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span></div><div class="line">&#123;</div><div class="line">close the resource</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。AutoCloseable 接口有一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div></pre></td></tr></table></figure></p><p>另外，还有一个 Closeable 接口。这是 AutoCloseable 的子接口， 也包含一个 close方法。不过，这个方法声明为抛出一个 IOException。<br>带资源的 try 语句（try-with-resources) 的最简形式为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (声明和创建资源)&#123;</div><div class="line">使用资源来处理文件;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>try块退出时，会自动调用 res.close()。下面给出一个典型的例子， 这里要读取一个文件中的所有单词：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="number">7</span>usr/share/dict/words<span class="string">")), "</span>UTF-<span class="number">8</span><span class="string">")</span></div><div class="line"><span class="string">&#123;</span></div><div class="line"><span class="string">while (in.hasNext())</span></div><div class="line"><span class="string">System.out.println(in.next());</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure></p><p>这个块正常退出时， 或者存在一个异常时， 都会调用 in.close() 方法， 就好像使用了finally块一样。<br>还可以指定多个资源,例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> (Scanner in = <span class="keyword">new</span> Scanne(<span class="keyword">new</span> FileInputStream(<span class="string">"7usr/share/dict/words"</span>), <span class="string">"UTF-8"</span>);</div><div class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"out.txt"</span>))</div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span> (in.hasNext())</div><div class="line">out.println(in.next().toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不论这个块如何退出， in 和 out 都会关闭。如果你用常规方式手动编程，就需要两个嵌套的 try/finally语句。<br>前面已经看到，如果 try 块抛出一个异常， 而且 close 方法也抛出一个异常，这就会带来一个难题。带资源的 try 语句可以很好地处理这种情况。原来的异常会重新抛出，而 close方法抛出的异常会”被抑制”。这些异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。 如果对这些异常感兴趣， 可以调用 getSuppressed 方法，它会得到从 close 方法抛出并被抑制的异常列表。<br>你肯定不想采用这种常规方式编程。只要需要关闭资源， 就要尽可能使用带资源的 try语句。</p><h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><h4 id="1-异常处理不能代替简单的测试"><a href="#1-异常处理不能代替简单的测试" class="headerlink" title="1.异常处理不能代替简单的测试"></a>1.异常处理不能代替简单的测试</h4><p>异常处理需要初始化新的异常对象，需要调用栈返回，而且还需要沿着方法调用链来传播异常以找到它的异常处理器，所以，异常处理通常需要更多的时间和资源。<br>如果能在发生异常的方法中处理异常，就不需要抛出异常。在个别方法中的简单错误最好进行局部处理，无须抛出异常。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(refVar.toString());</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(NullPointerException ex) &#123;</div><div class="line">System.out.println(<span class="string">"refVar is null"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最好用下面的代码代替：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (refVar != <span class="keyword">null</span>)</div><div class="line">System.out.println(refVar.toString());</div><div class="line"><span class="keyword">else</span></div><div class="line">System.out.println(<span class="string">"refVar is null"</span>);</div></pre></td></tr></table></figure></p><p>只有在异常不可预料的情况下才抛出异常，简单的情况不应该使用异常机制。</p><h4 id="1-不要过分细化异常"><a href="#1-不要过分细化异常" class="headerlink" title="1.不要过分细化异常"></a>1.不要过分细化异常</h4><p>很多程序员习惯将每一条语句都分装在一个独立的 try 语句块中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">PrintStream out;</div><div class="line">Stack s;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">n = s.pop();</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (EmptyStackException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// stack was empty</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">out.writelnt(n);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// problem writing to file</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种编程方式将导致代码量的急剧膨胀。首先看一下这段代码所完成的任务。在这里，希望从栈中弹出 100 个数值， 然后将它们存入一个文件中。如果栈是空的， 则不会变成非空状态；如果文件出现错误， 则也很难给予排除。出现上述问题后，这种编程方式无能为力。因此，有必要将整个任务包装在一个 try语句块中，这样，当任何一个操作出现问题时，整个任务都可以取消。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">&#123;</div><div class="line">n = s.pop();</div><div class="line">out.writelnt(n);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (IOException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// problem writing to file</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (EmptyStackException e)</div><div class="line">&#123;</div><div class="line"><span class="comment">// stack was empty</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这段代码看起来清晰多了。这样也满足了异常处理机制的其中一个目标，将正常处理与错误处理分开。</p><h4 id="3-利用异常层次结构"><a href="#3-利用异常层次结构" class="headerlink" title="3.利用异常层次结构"></a>3.利用异常层次结构</h4><p>不要只抛出 RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。<br>不要只捕获 Thowable 异常， 否则，会使程序代码更难读、 更难维护。<br>考虑受查异常与非受查异常的区别。 已检查异常本来就很庞大，不要为逻辑错误抛出这些异常。（例如， 反射库的做法就不正确。 调用者却经常需要捕获那些早已知道不可能发生的异常。）<br>将一种异常转换成另一种更加适合的异常时不要犹豫。例如， 在解析某个文件中的一个整数时，捕获NumberFormatException 异 常，然后将它转换成 IOException 或 MySubsystemException 的子类。  </p><h4 id="4-不要压制异常"><a href="#4-不要压制异常" class="headerlink" title="4.不要压制异常"></a>4.不要压制异常</h4><p>在 Java 中，往往强烈地倾向关闭异常。如果编写了一个调用另一个方法的方法，而这个方法有可能 100 年才抛出一个异常， 那么， 编译器会因为没有将这个异常列在 throws 表中产生抱怨。而没有将这个异常列在 throws 表中主要出于编译器将会对所有调用这个方法的方法进行异常处理的考虑。因此，应该将这个异常关闭：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">loadImage</span><span class="params">(String s)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="comment">// code that threatens to throw checked exceptions</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Exception e)</div><div class="line">&#123;&#125; <span class="comment">// so there</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在，这段代码就可以通过编译了。除非发生异常，否则它将可以正常地运行。即使发生了异常也会被忽略。如果认为异常非常重要，就应该对它们进行处理。  </p><h4 id="5-在检测错误时，”苛刻”要比放任更好"><a href="#5-在检测错误时，”苛刻”要比放任更好" class="headerlink" title="5.在检测错误时，”苛刻”要比放任更好"></a>5.在检测错误时，”苛刻”要比放任更好</h4><p>当检测到错误的时候，有些程序员担心抛出异常。在用无效的参数调用一个方法时，返回一个虚拟的数值， 还是抛出一个异常， 哪种处理方式更好？ 例如， 当栈空时，Stack.pop 是<br>返回一个 null, 还是抛出一个异常？ 我们认为：在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一个 NullPointerException 异常更好。  </p><h4 id="6-不要羞于传递异常"><a href="#6-不要羞于传递异常" class="headerlink" title="6.不要羞于传递异常"></a>6.不要羞于传递异常</h4><p>很多程序员都感觉应该捕获抛出的全部异常。如果调用了一个抛出异常的方法，例如，FilelnputStream 构造器或 readLine 方法，这些方法就会本能地捕获这些可能产生的异常。其实， 传递异常要比捕获这些异常更好：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStuff</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function"><span class="comment">// not a sign of shame!</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">InputStream in = <span class="keyword">new</span> FilelnputStream(filename);</div><div class="line">. . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>让高层次的方法通知用户发生了错误， 或者放弃不成功的命令更加适宜。<br><strong>规则 5、6 可以归纳为”早抛出，晚捕获”</strong></p><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><p>在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此，可以将这些检测删掉，并在其他测试需要时将它们粘贴回来，这是一件很乏味的事。  </p><h4 id="1-断言的概念"><a href="#1-断言的概念" class="headerlink" title="1.断言的概念"></a>1.断言的概念</h4><p>假设确信某个属性符合要求，并且代码的执行依赖于这个属性。例如，需要计算：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> y = Math.sqrt(x);</div></pre></td></tr></table></figure></p><p>我们确信，这里的 X 是一个非负数值。原因是：X 是另外一个计算的结果，而这个结果不可能是负值；或者 X 是一个方法的参数，而这个方法要求它的调用者只能提供一个正整数。<br>然而，还是希望进行检查，以避免让“不是一个数”的数值参与计算操作。当然，也可以抛出一个异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"x &lt; 0"</span>);</div></pre></td></tr></table></figure></p><p>但是这段代码会一直保留在程序中，即使测试完毕也不会自动地删除。如果在程序中含有大量的这种检查，程序运行起来会相当慢。<br>断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。<br>Java 语言引人了关键字 assert。这个关键字有两种形式：<br><code>assert 条件;</code>和<code>assert 条件：表达式;</code><br>这两种形式都会对条件进行检测，如果结果为 false, 则在第一种形式中会抛出一个 AssertionError 异常。在第二种形式中，表达式将被传人 AssertionError 的构造器，并转换成一个消息字符串,在打印异常信息时会随之显示出来。<br><strong>注意：</strong>“表达式”部分的唯一目的是产生一个消息字符串。AssertionError 对象并不存储表达式的值，因此，不可能在以后得到它。正如 JDK 文档所描述的那样：如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。<br>要想断言 x 是一个非负数值，只需要简单地使用下面这条语句：<br><code>assert x &gt;= 0;</code><br>或者将 x 的实际值传递给 AssertionError 对象， 从而可以在后面显示出来：<br><code>assert x &gt;= 0 : x;</code>  </p><h4 id="2-启用和禁用断言"><a href="#2-启用和禁用断言" class="headerlink" title="2.启用和禁用断言"></a>2.启用和禁用断言</h4><p>在默认情况下，断言被禁用。可以在运行程序时用<br><code>-enableassertions</code> 或 <code>-ea</code> 选项启用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -enableassertions MyApp</div></pre></td></tr></table></figure></p><p>需要注意的是，在启用或禁用断言时<strong>不必重新编译程序</strong>。启用或禁用断言是类加载器(class loader) 的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。<br>也可以在某个类或整个包中使用断言，例如：<br><code>java -ea:MyClass -ea:com.mycompany.mylib... MyApp</code>  </p><p>这条命令将开启 MyClass 类以及在 com.mycompany.mylib 包和它的子包中的所有类的断言。选项 -ea 将开启默认包中的所有类的断言。 也可以用选项 <code>-disableassertions</code> 或 <code>-da</code> 禁用某个特定类和包的断言：<br><code>java -ea:... -da:MyClass MyApp</code><br>有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。<br>然而，启用和禁用所有断言的 <code>-ea</code> 和 <code>-da</code> 开关不能应用到那些没有类加载器的”系统类”上。对于这些系统类来说，需要使用 <code>-enablesystemassertions/-esa</code> 开关启用断言。<br>在程序中也可以控制类加载器的断言状态。有关这方面的内容请参看本文末尾的 API 注释。<br>还可以在eclipse里开启断言，只要Run -&gt; Run Configurations -&gt; Arguments页签 -&gt; VM arguments文本框中加上断言开启的标志:<br>-enableassertions 或者-ea 就可以了。  </p><h4 id="3-使用断言完成参数检查"><a href="#3-使用断言完成参数检查" class="headerlink" title="3.使用断言完成参数检查"></a>3.使用断言完成参数检查</h4><p>在 Java 语言中，给出了3种处理系统错误的机制：</p><ul><li>抛出一个异常</li><li>日志</li><li>使用断言</li></ul><p>什么时候应该选择使用断言呢？ 请记住下面几点：</p><ul><li>断言失败是致命的、 不可恢复的错误。</li><li>断言检查只用于开发和测阶段(这种做法有时候被戏称为“ 在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”)。  </li></ul><p>因此，<strong>不应该</strong>使用断言向程序的其他部分通告发生了<strong>可恢复性的错误</strong>，或者，不应该作为程序向用户通告问题的手段。断言只应该用于在测试阶段<strong>确定程序内部的错误位置</strong>。<br>下面看一个十分常见的例子：检查方法的参数。是否应该使用断言来检查非法的下标值或null 引用呢？ 要想回答这个问题， 首先阅读一下这个方法的文档。假设实现一个排序方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Sorts the specified range of the specified array in ascending </span></div><div class="line"><span class="comment">numerical order.</span></div><div class="line"><span class="comment">The range to be sorted extends from fromlndex, inclusive, </span></div><div class="line"><span class="comment">to tolndex, exclusive.</span></div><div class="line"><span class="comment"><span class="doctag">@param</span> a the array to be sorted.</span></div><div class="line"><span class="comment"><span class="doctag">@param</span> fromlndex the index of the first element (inclusive) </span></div><div class="line"><span class="comment">to be sorted.</span></div><div class="line"><span class="comment"><span class="doctag">@param</span> tolndex the index of the last element (exclusive) to be </span></div><div class="line"><span class="comment">sorted.</span></div><div class="line"><span class="comment">©throws IllegalArgumentException if fromlndex &gt; tolndex</span></div><div class="line"><span class="comment">©throws ArraylndexOutOfBoundsException if fromlndex &lt; 0 or </span></div><div class="line"><span class="comment">tolndex &gt; a.length</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromlndex, <span class="keyword">int</span> tolndex)</span></span></div></pre></td></tr></table></figure></p><p>文档指出，如果方法中使用了错误的下标值，那么就会抛出一个异常。这是方法与调用者之间约定的处理行为。如果实现这个方法，那就必须要遵守这个约定，并抛出表示下标值有误的异常。因此，这里使用断言不太适宜。<br>是否应该断言 a 不是 null 呢？ 这也不太适宜。当 a 是 null 时，这个方法的文档没有指出应该采取什么行动。在这种情况下，调用者可以认为这个方法将会成功地返回，而不会抛出<br>一个断言错误。<br>然而，假设对这个方法的约定做一点微小的改动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@param</span> <span class="function">a the array to be <span class="title">sorted</span> <span class="params">(must not be <span class="keyword">null</span>)</span></span></div></pre></td></tr></table></figure></p><p>现在，这个方法的调用者就必须注意：不允许用 null 数组调用这个方法，并在这个方法的开头使用断言：<code>assert a != null;</code><br>计算机科学家将这种约定称为前置条件(Precondition)。最初的方法对参数没有前置条件， 即承诺在任何条件下都能够给予正确的执行。修订后的方法有一个前置条件，即 a 非空。如果调用者在调用这个方法时没有提供满足这个前置条件的参数， 所有的断言都会失败，并且这个方法可以执行它想做的任何操作。事实上，由于可以使用断言，当方法被非法调用时， 将会出现难以预料的结果。有时候会拋出一个断言错误， 有时候会产生一个 null 指针异常， 这完全取决于类加载器的配置。  </p><h4 id="4-为文档假设使用断言"><a href="#4-为文档假设使用断言" class="headerlink" title="4.为文档假设使用断言"></a>4.为文档假设使用断言</h4><p>很多程序员使用注释说明假设条件。看一下下面的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> = <span class="number">1</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span> <span class="comment">// (i % 3 == 2)</span></div><div class="line">. . .</div></pre></td></tr></table></figure></p><p>在这个示例中，使用断言会更好一些。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>)</div><div class="line">. . .</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">assert</span> i % <span class="number">3</span> == <span class="number">2</span>;</div><div class="line">    . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当然，如果再仔细地考虑一下这个问题会发现一个更有意思的内容。i%3 会产生什么结果？如果 i 是正值，那余数肯定是 0、 1 或 2。如果 i 是负值，则余数则可以是 -1 和-2。然而，实际上都认为 i 是非负值， 因此， 最好在 if 语句之前使用下列断言：<code>assert i &gt;= 0;</code><br>无论如何，这个示例说明了程序员如何使用断言来进行自我检查。前面已经知道，断言是一种测试和调试阶段所使用的战术性工具; 而日志记录是一种在程序的整个生命周期都可以使用的策略性工具。  </p><p><img src="/2017/11/08/Java学习总结之异常处理/ClassLoader.png" alt="fail"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在程序运行过程中&lt;strong&gt;(注意是运行阶段，程序可以通过编译)&lt;/strong&gt;，如果JVM检测出一个不可能执行的操作，就会出现&lt;st
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之集合</title>
    <link href="http://habitdiary.cn/2017/10/23/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>http://habitdiary.cn/2017/10/23/Java学习总结之集合/</id>
    <published>2017-10-23T13:40:35.000Z</published>
    <updated>2018-02-01T11:32:40.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><p>Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Java只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、Bitset和Enumeration接口，其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，但要想建立一个全面的集合类库还需要大量的时间和高超的技能。<br>后来，经过艰难的抉择，设计人员设计出了一组功能完善的数据结构，下面我们来进入集合框架的学习。    </p><h4 id="使用集合的场景"><a href="#使用集合的场景" class="headerlink" title="使用集合的场景"></a>使用集合的场景</h4><p><img src="/2017/10/23/Java学习总结之集合/应用场景.png" alt="fail"></p><h4 id="集合接口与具体实现分离"><a href="#集合接口与具体实现分离" class="headerlink" title="集合接口与具体实现分离"></a>集合接口与具体实现分离</h4><p>Java集合类库将接口与实现分离。比如队列接口，其指出可以在队列的尾部添加元素，在队头删除元素，并可以查找队列中元素的个数等。队列接口的最简形式可能类似下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;</div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这个接口并没有说明队列的具体实现，实际上，队列的实现主要有两种方式：<strong>一是使用循环数组，二是使用链表。</strong>如果需要一个循环数组队列，可以使用<strong>ArrayDeque类</strong>;如果需要一个链表队列，就直接使用<strong>LinkedList类</strong>。这两个类都实现了Queue接口。<br>当我们使用队列时，一旦创建了集合就不用关心究竟使用了哪种实现，因此，只有在构建集合时，使用具体的类才有意义。<br>用两种具体类实现Queue接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">Queue&lt;E&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</div></pre></td></tr></table></figure></p><p><strong>注意：一般情况下循环数组比链表更高效，但它是一个有界集合，即容量有限，超过一定范围会进行扩容，降低效率。所以如果处理的数据量较小，优先使用循环数组，但如果程序要收集的对象数量没有上限，最好使用链表实现。</strong><br>在研究API时会发现一组名字以Abstract开头的类，例如，AbstractQueue。这些类是为类库设计者设计的，如果想要实现自己的队列类，会发现扩展AbstractQueue类比实现Queue接口中的所有方法轻松得多。  </p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>在Java类库中，集合类的基本接口是Collection接口，其常用API如下：    </p><ul><li>boolean add(E e)<br>将一个元素添加到集合中。如果由于这个调用改变了集合，返回true。   </li><li>boolean addAll(Collection&lt;? extends E&gt; other)<br>将other集合中的所有元素都添加到这个集合。如果由于这个调用改变了集合，返回true。  </li><li>void clear()  移除这个集合中的所有元素。  </li><li>boolean contains(Object obj)<br>如果这个集合包含了一个与obj相等的对象，返回true。  </li><li>boolean    containsAll(Collection&lt;?&gt; other)<br>如果这个集合包含other集合中的所有元素，返回 true。    </li><li>boolean isEmpty() 如果这个集合没有元素，返回 true。</li><li>Iterator<code>&lt;E&gt;</code>    iterator()<br>返回一个用于访问集合中每个元素的迭代器。  </li><li>boolean remove(Object obj)<br>从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true。  </li><li>boolean removeAll(Collection&lt;?&gt; other)<br>从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true。  </li><li>boolean retainAll(Collection&lt;?&gt; other)<br>仅保留这个集合中那些也包含在other集合里的元素  </li><li>int size()  返回这个集合的元素数。</li><li>Object[]    toArray() 返回这个集合的对象数组。</li><li><code>&lt;T&gt;</code> T[] toArray(T[] arrayToFill)<br>返回这个集合的对象数组。如果arrayToFill足够大，就将集合的元素填入这个数组中，剩余空间补null;否则，分配一个新数组，其成员类型和arrayToFill一样，其长度等于集合的大小，并填充集合元素。  </li><li>default boolean removeIf(Predicate&lt;? super E&gt; filter)<br>从这个集合中删除filter返回true的所有元素。如果这个调用改变了集合，返回true </li></ul><p><strong>注意：在使用Object[] toArray()时不能把返回的Object[]数组成强制类型转换其他类型的数组，因为所有数组类型的父类都是Object，甚至Object[]的父类也是Object，所以这种向下类型转换是错误的,会抛出一个ClassCastException</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer[] array = (Integer[])a.toArray();<span class="comment">// Error</span></div><div class="line">Object[] array =  a.toArray();<span class="comment">// Right</span></div></pre></td></tr></table></figure></p><p> 或者使用<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer[] array = a.toArray(<span class="keyword">new</span> Integer[<span class="number">10</span>]);</div></pre></td></tr></table></figure></p><p> removeIf函数的参数是一个函数式接口Predicate，表示布尔值函数，可以传递一个lambda表达式描述要删除的元素的特征。例如下面的代码可以删除列表中的所有偶数：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.removeIf(e -&gt; e %<span class="number">2</span> == <span class="number">0</span>);</div></pre></td></tr></table></figure></p><p> 同队列，Java也给类库设计者提供了一个AbstractCollection类，其提供了一些例行方法，可以让实现者更容易实现自己的集合类。</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p> Collection接口的<code>Iterator&lt;E&gt;    iterator()</code>方法可以返回一个迭代器，它是一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。<br> Iterator接口包含4个方法：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</div></pre></td></tr></table></figure></p><p> C++的STL中的迭代器是根据数组索引建模的，即迭代器指向指定位置的元素。但Java中的迭代器应该理解为位于两个元素之间，其起始位置在所有元素之前。调用next方法，迭代器会<strong>越过一个元素并且返回被越过的元素</strong>。通过next方法可以逐个访问集合中的每个元素，但是如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此,需要在每次调用next方法之前调用hasNext方法。如果迭代器还有剩余供访问的元素，这个方法就返回true。如果要想查看一个集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复调用next方法，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Collection&lt;String&gt; c = . . .;</div><div class="line">Iterator&lt;String&gt; iter = c.iterator();</div><div class="line"><span class="keyword">while</span>(iter.hasNext())</div><div class="line">&#123;</div><div class="line">String element = iter.next();</div><div class="line">   <span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> “for-each”循环可以更简练地表示同样的操作：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String element: c)</div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> something with element</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 编译器简单地将”for-each”循环翻译为<strong>带有迭代器的循环</strong>，”for-each”循环可以和任何实现了Iterable接口的对象一起工作，这个接口只包含一个抽象方法：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function">Interator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> Iterable接口表示实现它的类是可以迭代的(即可以返回一个迭代器对象)，Collection接口扩展了Iterable接口，所以<strong>对于标准类库中的任何集合都可以使用”for-each”循环</strong><br> Java SE 8提供了一种更简便的方式，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式(它会处理一个元素)。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止,例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iter.forEachRemaining(element -&gt; <span class="keyword">do</span> something with element);</div></pre></td></tr></table></figure></p><p> <strong>元素被访问的顺序取决于集合类型。</strong>如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次索引加1.如果访问HashSet中的元素，每个元素将会以某种随机的次序出现。但这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说没有影响。<br> Iterator接口的remove方法将会删除<strong>上一次调用next方法</strong>时返回的元素，也就是说，如果要删除某个元素，必须先用next方法越过它：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; it = c.iterator();</div><div class="line">it.next();<span class="comment">// skip over the first element</span></div><div class="line">it.remove(); <span class="comment">// now remove it</span></div></pre></td></tr></table></figure></p><p>如果在调用remove方法之前没有调用next方法会抛出一个IllegalStateException。<br>如果想删除两个相邻的元素，不能直接连续调用两次remove：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.remove();<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>必须先越过要删除的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">it.remove();</div><div class="line">it.next();</div><div class="line">it.remove();<span class="comment">//OK</span></div></pre></td></tr></table></figure></p><p>所以删除元素必须在刚越过该元素时就进行，否则”过了这个村就没这个店了”  </p><h3 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h3><p>Java集合框架为不同类型的集合定义了大量接口，如下图所示：  <img src="/2017/10/23/Java学习总结之集合/集合框架的接口.png" alt="fail" title="集合框架的接口"><br>集合有两个基本接口：<strong>Collection</strong>和<strong>Map</strong>。Collection用于保存一个元素序列，Map用于表示键值对之间的映射关系。在Collection中插入元素使用<code>boolean add(E element)</code>,获取元素使用迭代器访问;在Map中插入元素使用<code>V put(K key,V value)</code>,通过key获取value使用<code>V get(K key)</code><br>List是一个有序集合，允许有null值存在。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，使用一个整数索引访问。前者称为顺序访问，后者称为随机访问。<br>List的重要API如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">* <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素  </span></div><div class="line"><span class="function">* ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">   返回一个列表迭代器，以便用来访问列表中的元素，</span></div><div class="line"><span class="function">   初始位置在索引为index元素的前面，索引从0开始  </span></div><div class="line"><span class="function">* <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span> 在给定位置添加一个元素  </span></div><div class="line"><span class="function">* E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> 删除给定位置的元素并返回这个元素  </span></div><div class="line"><span class="function">* E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> 获取给定位置的元素  </span></div><div class="line"><span class="function">* E <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, E element)</span> </span></div><div class="line"><span class="function">   用新元素取代给定位置的元素，并返回原来那个元素  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素  </span></div><div class="line"><span class="function"> 在列表中第一次出现的位置，如果没有这样的元素返回-1  </span></div><div class="line"><span class="function">* <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object element)</span> 返回与指定元素相等的元素</span></div><div class="line"><span class="function"> 在列表中最后一次出现的位置，如果没有这样的元素返回-1</span></div></pre></td></tr></table></figure></p><p>我们发现List接口提供了多个用于随机访问的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,E element)</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></div><div class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span></div></pre></td></tr></table></figure></p><p>当我们给List接口选择具体实现类时，需要考虑顺序访问和随机访问哪种情况更多，如果随机访问占操作的大多数，应该使用数组或动态列表ArrayList实现List接口，否则应该使用链表LinkedList实现List接口。<br>为了避免对链表进行随机访问，Java定义了一个标记接口RandomAccess，这个接口不包含任何方法，但可以用来测试一个特定的集合是否支持高效的随机访问：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(c <span class="keyword">instanceof</span> RandomAccess)</div><div class="line">&#123;</div><div class="line">use random access algorithm</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">use sequential access algorithm</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不建议在LinkedList实现的List列表中使用get、set等随机访问方法，此时应该通过一个ListIterator顺序访问列表。<br>ListIterator接口是Iterator的一个子接口，它是一种更灵活的迭代器，只用于List。下面是ListIterator的重要API：  </p><ul><li>void add(E newElement) 在当前位置前添加一个元素  </li><li>void set(E newElement) 用新元素取代next或previous上次访问的元素。</li><li>boolean hasPrevious() 当反向迭代列表时，还有可供访问的元素，返回true  </li><li>E previous() 返回前一个对象，如果已经到达了列表的头部，就抛出一个NoSuchElementException  </li><li>int nextIndex() 返回下次调用next方法时将返回元素的索引  </li><li>int previous() 返回下次调用previous方法时将返回元素的索引  </li></ul><p><strong>并发修改：</strong>如果在一个迭代器修改集合时，另一个迭代器对它进行遍历，一定会出现混乱。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = . . .;</div><div class="line">ListIterator&lt;String&gt; iter1 = list.ListIterator();</div><div class="line">ListIterator&lt;String&gt; iter2 = list.ListIterator();</div><div class="line">iter1.next();</div><div class="line">iter1.remove();</div><div class="line">iter2.next();<span class="comment">//throws ConcurrentModificationException</span></div></pre></td></tr></table></figure></p><p>上述代码中iter2迭代器在遍历链表时，iter1修改了链表结构，iter2会检测到这种变化，抛出一个ConcurrentModificationException。<br>为了避免出现并发修改异常，请遵循下述简单规则：<strong>可以根据需要给容器附加许多迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读也写的迭代器</strong>。<br>通过调用AbstractCollection类的toString方法可以打印出集合中的所有元素。<br><strong>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集(Set)的add方法不允许增加重复的元素,允许有null值，当然只允许一个null值。要适当定义equals方法：只要两个集包含同样的元素就认为是相等的，而不要求有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。<br>SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集试图的方法。<br>最后，Java SE 6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集和映射的方法，TreeSet和TreeMap实现了这些接口。</strong>  </p><h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p>下面是Java库中的具体集合和集合框架中的类<br><img src="/2017/10/23/Java学习总结之集合/Java库中的具体集合.png" alt="fail" title="Java库中的具体集合"><br><img src="/2017/10/23/Java学习总结之集合/集合框架中的类.png" alt="fail" title="集合框架中的类"></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList是链表类，相较于数组以及动态的ArrayList类，能够更高效地从集合的中间位置插入、删除元素，Java中的LinkedList类是<strong>双向链接</strong>的。<br>除了实现了Collection接口和List接口之外，LinkedList还提供了以下API：  </p><ul><li>LinkedList() 构造一个空链表  </li><li>LinkedList(Collection&lt;? extends E&gt; elements)<br>构造一个链表，并将集合中的所有元素添加到这个链表中  </li><li>void addFirst(E element) 将某个元素添加到列表的头部  </li><li>void addLast(E element) 将某个元素添加到列表的尾部  </li><li>E getFirst 返回列表头部的元素  </li><li>E getLast 返回列表尾部的元素  </li><li>E removeFirst() 删除并返回列表头部的元素 </li><li>E removeLast() 删除并返回列表尾部的元素    </li></ul><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList是动态数组列表，适用于常常要随机访问元素的情况。下面给出ArrayList的常用API：  </p><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  </li></ul><p><strong>ArrayList和Vector的区别：</strong>Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vector对象，然而如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。所以建议在不需要同步的时候使用ArrayList，而不要使用Vector</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>链表和数组可以按照人们的意愿排列元素的次序，但如果要查看某个元素，却忘记了它的位置，需要访问所有元素直到找到为止，将会消耗很多时间。<br>HashSet是一种基于<strong>散列表</strong>的集，实现了Set接口，它无法控制元素的次序，但可以快速查找元素。散列表基于散列码，散列码由类的hashCode方法提供，用于将元素插入散列表的特定位置，hashCode和equals方法应该兼容，即使用equals方法返回true的两个对象应该有相同的散列码，<strong>一个自定义类如果重写了equals方法就必须要重写hashCode方法，以便于将该类的对象插入散列表中。否则HashSet无法知道插入的两个对象是否相同，无法保证集合元素的唯一性。这两个方法的重写在eclipse的source菜单里也有快捷添加选项。</strong><br>在Java中，散列表用链表数组实现，每个<strong>散列单元</strong>被称为<strong>桶</strong>。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，如果桶中没有元素，可以直接插入，如果已经有元素，即发生<strong>散列冲突</strong>，则需要将新元素和桶中已有的所有元素进行比较，如果桶中有元素和新元素相等，就不插入，反之插入。<strong>注意：在HashSet的一个桶中可以有多个不同元素，即使用链地址法解决冲突。</strong>如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。这样，当我们在HashSet中查找某元素时，不必像在线性表中一样循环遍历整个表来比较，只需要根据散列规则找到对应的桶，对桶里的元素进行遍历比较即可。<br><strong>所以，从上面的分析我们可以得到equals方法和hashCode方法之间的关系：</strong><br>1、如果重写了equals方法，必须重写hashCode方法，因为两个对象的euqals方法如果返回true,它们的hashCode值一定要相同。<br>2、如果两个对象的hashCode值相同，它们并不一定相同，比如HashSet中同一个桶中的对象就是发生了散列冲突的具有相同hashCode值的对象。它们的equals方法有可能返回false。  </p><p>这就是为什么我们在HashSet使用时要同时重写这两个方法的原因，重写hashCode方法以进行桶间的查找，重写equals方法以进行同一个桶内对象的比较。<br>在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。<br>如果想更多地控制散列表的运行性能，就要指定一个初始桶数。通常将桶数设置为预计元素个数的75% ~ 150%,最好将桶数设置为一个<strong>素数</strong>,以防键的集聚。标准类库使用的桶数是2的幂，默认值为16,<strong>为散列表的大小提供的任何值都被自动转换为2的下一个幂</strong>。<br>如果最初的估计过低，散列表太满，散列表会进行再散列，创建一个桶数更多的表。<strong>装填因子</strong>决定何时再散列，比如装填因子为0.75，当散列表中超过75%的位置已经填入了元素，这个表就会用双倍的桶数自动进行再散列，大多数情况装填因子为0.75是比较合理的。<br>下面是HashSet的常用API：  </p><ul><li>HashSet() 构造一个空散列集  </li><li>HashSet(Collection&lt;? extends E&gt; elements)<br>构造一个散列集，并将集合中的所有元素添加到这个散列集中 </li><li>HashSet(int initialCapacity) 构造一个具有指定容量(桶数)的散列集  </li><li>HashSet(int initialCapacity,float loadFactor) 构造一个具有指定容量和装填因子(一个0.0 ~ 1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集      </li></ul><p><strong>特别要注意,在HashSet中没有get和set方法，因为HashSet是无序集，不存在索引概念，如果要访问HashSet中的元素应该使用迭代器，另外contains方法也被重新定义，可以快速查看某个元素是否出现在集中，此时不用查看集中的所有元素，只用通过散列码定位到一个桶，查看这个桶中的所有元素即可</strong>  </p><p>如果要查找HashSet中符合某条件的对象，可以使用迭代器遍历或者使用foreach循环遍历HashSet。如果要删除符合某条件的对象，如果在for-each循环中边删除边遍历会抛出一个并发修改异常ConcurrentModificationException，此时有两种解决方案：<br>1、如果只删除一个元素，就在remove之后break即可<br>2、如果要删除多个元素，就先把要删除的元素添加到另一个集合中，循环结束后调用removeAll的求差集方法删除目标子集即可。  </p><p><strong>还可以使用迭代器遍历来避免这种情况。</strong></p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet和HashSet十分类似，不过当元素以任意顺序插入TreeSet时，TreeSet会保证元素是有序排列的。其底层是由<strong>红黑树</strong>实现的,每次将一个元素添加到树中，都被放置在正确的排序位置上。<br><strong>一个元素添加到树中比添加到散列表中慢</strong>，但是与检查数组或链表中的重复元素相比还是快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。如果对集合中的元素次序没有要求，应该使用HashSet而不是TreeSet，即使排序的花销不大，但也会影响效率。<br><strong>注意：要使用TreeSet，插入的元素必须可排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator</strong><br>从Java SE 6起,TreeSet类实现了Navigable接口，这个接口增加了几个便于定位元素以及反向遍历的方法。  </p><p>下面是TreeSet的常用API：  </p><ul><li>TreeSet() 构造一个空树集  </li><li>TreeSet(Collection&lt;? extends E&gt; elements)<br>构造一个空树集，并将集合中的所有元素添加到这个树集中  </li><li>TreeSet(Comparator&lt;? super E&gt; comparator)  构造一个空树集  </li><li>TreeSet(SortedSet&lt;<code>E</code>&gt; s)<br>构造一个空树集，并将有序集中的所有元素添加到这个树集中，并使用与给定的有序集相同的比较器</li></ul><p>下面是SortedSet的常用API：  </p><ul><li>Comparator&lt;? super E&gt; comparator()<br>返回用于对元素进行排序的比较器。如果元素用Comparable接口的compareTo方法进行比较则返回null  </li><li>E first() 返回有序集中的最小元素  </li><li>E last() 返回有序集中的最大元素   </li></ul><p>下面是NavigableSet的常用API： </p><ul><li>E higher(E value)  </li><li>E lower(E value)<br>返回大于value的最小元素或小于value的最大元素，如果没有这样的元素则返回null  </li><li>E ceiling(E value)  </li><li>E floor(E value)<br>返回大于等于value的最小元素或小于等于value的最大元素，如果没有这样的元素则返回null  </li><li>E poolFirst()  </li><li>E pollLast()<br>删除并返回这个集合中的最大元素或最小元素，这个集合为空时返回null  </li><li>Iterator&lt;<code>E</code>&gt; descendingIterator()<br>返回一个按照递减顺序遍历集中元素的反向迭代器  </li></ul><h4 id="队列与双端队列"><a href="#队列与双端队列" class="headerlink" title="队列与双端队列"></a>队列与双端队列</h4><p>Deque(双端队列)接口继承自Queue(队列)接口，与之有所不同的是，双端队列可以在队列的头部和尾部添加或删除元素，但也不支持在队列中间添加或删除元素。<br>和普通队列一样，双端队列也可以用ArrayDeque和LinkedList实现。  </p><p>下面是Queue的常用API：  </p><ul><li>boolean add(E element)  </li><li>boolean offer(E element)<br>都是将一个元素入队并返回true，如果队列已满，前者会抛出一个IllegalStateException，后者则返回false  </li><li>E remove()  </li><li>E poll()<br>都是将队头元素出队并返回，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null  </li><li>E element()  </li><li>E peek()<br>都是取队头元素但不删除，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null   </li></ul><p>下面是Deque的常用API：  </p><ul><li>void addFirst(E element)  </li><li>void addLast(E element)  </li><li>boolean offerFirst(E element)  </li><li>boolean offerLast(E element)<br>都是将给定元素添加到双端队列的头部或尾部，如果队列满了，前两个方法会抛出一个IllegalStateException，后两个方法则返回false  </li><li>E removeFirst()  </li><li>E removeLast()  </li><li>E pollFirst()  </li><li>E pollLast()<br>都是删除双端队列的头部或尾部并返回元素，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li><li>E getFirst()  </li><li>E getLast() </li><li>E peekFirst()  </li><li>E peekLast()<br>都是返回双端队列的头部或尾部元素但不删除，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null  </li></ul><p>下面是ArrayDeque的常用API：  </p><ul><li>ArrayDeque() 用默认初始容量16构造一个空队列  </li><li>ArrayDeque(int initialCapacity) 用指定容量构造一个空队列    </li></ul><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先出队。优先队列具有最高级先出(first in, largest out)的行为特征。<br>PriorityQueue的底层是通过堆(小根堆，<strong>将较小的元素设为最高优先级</strong>)实现的，堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。<br>PriorityQueue是一个实现了Queue接口的具体类。<br><strong>和TreeSet一样，要实现排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator。</strong>  </p><p><strong>注意：</strong>方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。原因是PriorityQueue内部是一个堆，堆只能保证根具有最高的优先级，但整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历，也就是只能保证数组的第一个元素具有最高优先级。但如果将元素依次出队，出队顺序可以保证是有序的，这是因为在每一次出队后堆会进行调整，将下一个优先级最高的元素移动到根。</p><p>下面是PriorityQueue的常用API：  </p><ul><li>PriorityQueue() 构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity)<br>用指定容量构造一个空优先队列  </li><li>PriorityQueue(int initialCapacity,Comaparator&lt;? super E&gt; c)<br>用指定容量构造一个空优先队列,并指定比较器对元素进行排序  </li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>集(Set)是一个集合，它可以快速查找现有元素。但是，有时我们知道某些键的信息，并想要查找与之对应的元素。映射(map)数据结构就是为此设计的，map用来存放键值对(Key-value)，key-value以Entry类型的对象实例存在，Entry对象是无序排列的。允许使用null键和null值(当然只允许有一个null键)，提供键(Key)就能快速查找到值(Value)。Key不允许重复，每个Key最多只能映射到一个Value。<br>Java类库为映射提供了两个实现：HashMap和TreeMap，这两个类都实现了Map接口。<br>HashMap(散列映射)对<strong>键</strong>进行散列，键值对是无序的。TreeMap(树映射)用<strong>键</strong>的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。<strong>与集一样，HashMap比TreeMap快一些，如果不需要按照排列顺序访问键，就最好选择散列。</strong>  </p><p>下面是Map接口的常用API：  </p><ul><li>V get(Object key)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回null  </li><li>default V getOrDefault(Object key,V defaultValue)<br>获取并返回与键对应的值，如果没有在映射中找到这个键，返回defaultValue  </li><li>V put(K key,V value)<br>将键与对应的值关系插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象，并返回键对应的旧值，如果这个键以前没有出现过则返回null。<strong>键可以为null，但值不能为null</strong>  </li><li>V putAll(Map&lt;? extends K,? extends V&gt; entries)<br>将给定映射中的所有条目添加到这个映射中  </li><li>boolean containsKey(Object key)<br>如果在映射中已经有这个键，返回true </li><li>boolean containsValue(Object value)<br>如果在映射中已经有这个值，返回true  </li><li>default void forEach(BiConsumer&lt;? super K,? super V&gt; action)<br>对这个映射中的所有键值对应用这个动作，参数是一个函数式接口类型，可以传入一个lambda表达式,例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scores.forEach((k,v) -&gt; </div><div class="line">System.out.println(<span class="string">"key="</span> + k + <span class="string">", value="</span> + v));</div></pre></td></tr></table></figure></li></ul><p>下面是HashMap的常用API：   </p><ul><li>HashMap()  构造一个空散列映射</li><li>HashMap(int initialCapacity) 用指定容量构造一个空散列映射 </li><li>HashMap(int initialCapacity,float LoadFactor)<br>用指定容量和装填因子构造一个空散列映射，默认的装填因子是0.75  </li></ul><p>下面是TreeMap的常用API：   </p><ul><li>TreeMap() 构造一个空树映射  </li><li>TreeMap(Comparator&lt;? super K&gt; c)<br>构造一个空树映射，并使用一个指定的比较器对键进行排序  </li><li>TreeMap(Map&lt;? extends K,? extends V&gt; entries) 构造一个空树映射，并将某个映射的所有条目添加到树映射中   </li><li>TreeMap(SortedMap&lt;? extends K,? extends V&gt; entries)<br>构造一个空树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器  </li></ul><p>下面是SortedMap的常用API：   </p><ul><li>Comparator&lt;? super K&gt; comparator()<br>返回对键进行排序的比较器。如果键是用Comparable接口的compareTo方法进行比较的，返回null  </li><li>K firstKey()  </li><li>K lastKey()<br>返回映射中最小元素和最大元素  </li></ul><h4 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h4><p>假设我们要统计一个单词在文件中出现的次数，当得到一个单词时，我们将其计数器加1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>但这可能会出错，如果word第一次出现，counts.get(word)会返回null，从而抛出一个NullPointerException。  </p><p>为了避免这种情况，我们可以用<strong>getOrDefault方法</strong>来取代get方法，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.put(word,counts.getOrDefault(word,<span class="number">0</span>) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>另一种方法是首先调用<strong>putIfAbsent方法</strong>，这个方法会在映射中不存在word时插入键值对初始化word的值为0：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">counts.putIfAbsent(word,<span class="number">0</span>);</div><div class="line">counts.put(word,counts.get(word) + <span class="number">1</span>);</div></pre></td></tr></table></figure></p><p>还可以做得更好,<strong>merge方法</strong>可以简化这个常见操作。如果键原先不存在，则下面的调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">counts.merge(word,<span class="number">1</span>,Integer::sum);</div></pre></td></tr></table></figure></p><p>将把word和1关联，如果word存在，则会使用Integer::sum函数组合原值和1(也就是将原值和1求和)  </p><h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><p>集合框架不认为映射本身是一种集合，不过可以得到映射视图 —— 这是实现了Collection接口或某个子接口的对象。<br>有三种视图：键集、值集合<strong>(不是一个集)</strong>、键值对集。<strong>键集</strong>和<strong>键值对集</strong>是集，因为一个映射中的键是唯一的，但值不能构成集，只能是值集合，因为一个映射中可以有多个相同的值。<br>下面的方法可以从映射中返回这三种视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></div><div class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></div><div class="line"><span class="function">Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span></div></pre></td></tr></table></figure></p><p><strong>需要说明的是，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口，所以可以向使用集合一样使用keySet</strong>  </p><p>键值对是Map.Entry<code>&lt;K,V&gt;</code>类型的，可以使用entrySet()方法返回映射的键值对集，再通过循环对于每个键值对对象使用，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Employee&gt; entry: staff.entrySet())</div><div class="line">&#123;</div><div class="line">String k = entry.getKey();</div><div class="line">    Employee v = entry.getValue();</div><div class="line">    <span class="comment">// do something with k,v</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>getKey方法获取该键值对的键，getValue方法获取该键值对的值，setValue方法将键值对的值设置为新值并返回原值。<br>当然查看键值对最高效的方法是使用forEach方法</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">counts.forEach((k,v) -&gt; &#123;</div><div class="line"><span class="keyword">do</span> something with k,v</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p><strong>注意:</strong>可以在键集视图上调用迭代器的remove方法，结果会在映射中删除这个键和与它关联的值，但不能调用add方法，否则会抛出一个UnsupportedOperationException;可以在值集合视图删除元素，所删除的值和相应的键将从映射中删除，也不能增加元素;可以在键值对集合中删除元素，将从映射中删除相应的键值对，但也不能增加元素。<strong>总之，可删不可增。</strong>  </p><h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p>当一个映射中引用某个值的所有键都消亡，即没有任何途径引用这个值时，这个值成为了无用对象。但是垃圾回收器跟踪<strong>活动的对象</strong>，只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收。于是，长期存活的映射中可能会存在一些无用的值，此时需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用WeakHashMap。当对键的唯一应用来自散列条目时，这种数据结构会协助垃圾回收期协同工作一起删除键值对。<br>下面是这种机制的内部运行情况。WeakHashMap使用<strong>弱引用</strong>保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种特定类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。  </p><p><img src="/2017/10/23/Java学习总结之集合/WeakHashMap.png" alt="fail"></p><p>更多细节见：<a href="http://mikewang.blog.51cto.com/3826268/880775/" target="_blank" rel="external">深入理解WeakHashMap</a>  </p><h4 id="LinkedHashSet-amp-LinkedHashMap"><a href="#LinkedHashSet-amp-LinkedHashMap" class="headerlink" title="LinkedHashSet &amp; LinkedHashMap"></a>LinkedHashSet &amp; LinkedHashMap</h4><p>LinkedHashSet和LinkedHashMap会按照<strong>元素插入顺序</strong>存放元素或键值对。当条目插入到表中时，就会并入到双向链表中。<br><img src="/2017/10/23/Java学习总结之集合/双向链表.png" alt="fail"><br>也可以使用<code>LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)</code>来构造一个按照<strong>元素访问顺序</strong>迭代键值对的LinkedHashMap。每次调用get或put，受到影响的条目将从当前位置删除，并放到条目链表的尾部(只有条目在链表中位置会受影响，而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中)。<br>访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已满时，可以将迭代器加入到表中，并将前几个元素删除掉。这些是近期最少使用的几个元素。<br>甚至可以让这一过程自动化。即构造一个LinkedHashMap的子类，然后覆盖下面的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></div></pre></td></tr></table></figure></p><p>每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。例如，下面的高速缓存可以存放100个元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Map&lt;K, V&gt; cache = <span class="keyword">new</span> </div><div class="line">LinkedHashMap&lt;&gt;(<span class="number">128</span>, <span class="number">0.75F</span>, <span class="keyword">true</span>)</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() &gt; <span class="number">100</span>; </div><div class="line">        <span class="comment">/*当元素个数 &lt;= 100，直接插入元素，</span></div><div class="line"><span class="comment">        否则进行替换，删除“最近最少使用”的元素，</span></div><div class="line"><span class="comment">        插入新元素*/</span></div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p><p>另外，还可以对eldest条目进行评估，以此决定是否应该将它删除。例如，可以检查与这个条目一起存在的时间戳。<br><img src="/2017/10/23/Java学习总结之集合/LinkedHashSet.png" alt="fail"></p><p><img src="/2017/10/23/Java学习总结之集合/LinkedHashMap.png" alt="fail"></p><h4 id="EnumSet-amp-EnumMap"><a href="#EnumSet-amp-EnumMap" class="headerlink" title="EnumSet &amp; EnumMap"></a>EnumSet &amp; EnumMap</h4><p>EnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1.<br>EnumSet没有公共的构造器，可以使用静态工厂方法构造这个集，下面给出得到EnumSet的几个常用方法：<br><img src="/2017/10/23/Java学习总结之集合/枚举集.png" alt="fail"><br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;</div><div class="line">EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);</div><div class="line">EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);</div><div class="line">EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);</div><div class="line">EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY);</div></pre></td></tr></table></figure></p><p>可以使用Set接口的常用方法来修改EnumSet<br>EnumMap是一个<strong>键类型</strong>为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时，需要在构造器中指定键类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EnumMap&lt;Weekday, Employee&gt; personInChange = <span class="keyword">new</span> EnumMap&lt;&gt;(Weekday.class);</div></pre></td></tr></table></figure></p><p>这样就构造了一个键为Weekday类型的空映射。</p><h4 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h4><p>类IdentityHashMap有特殊的作用。在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。而且，在对两个对象进行比较时，IdentityHashMap类使用 == ，而不使用equals<br>也就是说，不同的键对象，即使内容相同，也被视为不同的对象。在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况。<br><img src="/2017/10/23/Java学习总结之集合/IdentityHashMap.png" alt="fail"></p><h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>通过使用<strong>视图</strong>可以获取其他的实现了Collection接口或Map接口的对象，映射类的keySet方法就是这样一个示例。这个方法看似创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。<strong>然而事实并非如此，keySet方法返回一个实现了Set接口的类对象，这个类的方法对原映射进行操作。这样的集合称为视图。</strong>  </p><h4 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h4><p>Arrays类的静态方法asList将返回一个<strong>包装了普通Java数组的List包装器</strong>。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</div><div class="line">   ...</div><div class="line">   List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</div></pre></td></tr></table></figure></p><p>返回的对象不是ArrayList，而是一个视图对象，带有访问底层数组的get和set方法。<br><strong>改变数组大小的所有方法(例如，与迭代器相关的add和remove方法)都会抛出一个UnsupportedOperationException。</strong><br>asList方法可以接收可变数目的参数，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Amy"</span>,<span class="string">"Bob"</span>,<span class="string">"Carl"</span>);</div></pre></td></tr></table></figure></p><p>这个方法调用<code>Collections.nCopies(n,anObject)</code><br>将返回一个实现了List接口的<strong>不可修改的对象</strong>，并给人一种包含n个元素，每个元素都像是一个anObject的错觉。<br>例如，下面的调用将创建一个包含100个字符串的List，每个串都被设置为”DEFAULT”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; settings = Collections.nCopies(<span class="number">100</span>,<span class="string">"DEFAULT"</span>);</div></pre></td></tr></table></figure></p><p>存储代价很小，可用于不需要修改元素的情况。这是视图技术的一种巧妙的应用。<br><strong>注意：</strong>Collections类包含很多使用的方法，这些方法的参数和返回值都是集合，不要将它和Collection接口混起来。  </p><p>如果调用以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.singleton(anObject);</div></pre></td></tr></table></figure></p><p>将返回一个实现了Set接口的视图对象(与产生List视图的ncopies方法不同)，即一个不可修改的单元素集，而不需要付出建立数据结构的开销。singletonList方法与singletonMap方法类似。<br>类似地，对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等等。特别是，集的类型可以推导得出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set&lt;String&gt; deepThoughts = Collections.emptySet();</div></pre></td></tr></table></figure></p><h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><p>可以为很多集合建立子范围视图。例如，假设有一个列表staff，想从中取出第10个-第19个元素。可以使用subList方法来获得一个列表的子范围视图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List group2 = staff.subList(<span class="number">10</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure></p><p>第一个索引包含在内，第二个索引则不包含在内。可以将<strong>任何操作</strong>应用于子范围，该操作会影响整个列表。例如，可以删除整个子范围：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">group2.clear();</div></pre></td></tr></table></figure></p><p>现在，staff列表中该范围的元素也被删除，并且group2为空。<br>对于SortedSet和SortedMap，可以使用排序顺序而不是元素位置建立子范围。SortedSet接口声明了3个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from,E to)</span></span></div><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to)</span></span></div><div class="line"><span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from)</span></span></div></pre></td></tr></table></figure></p><p>这些方法返回大于等于from且小于to的所有元素构成的子集。</p><p>SortedMap也有类似的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">subMap</span><span class="params">(K from,K to)</span></span></div><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">headMap</span><span class="params">(K to)</span></span></div><div class="line"><span class="function">SortedMap&lt;K, V&gt; <span class="title">tailMap</span><span class="params">(K from)</span></span></div></pre></td></tr></table></figure></p><p>返回映射视图，该映射包含<strong>键</strong>落在指定范围内的所有元素。<br>Java SE 6引入的NavigableSet接口赋予子范围操作更多控制能力。可以指定是否包括边界：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E from, <span class="keyword">boolean</span> fromInclusive,E to,<span class="keyword">boolean</span> toInclusive)</span></span></div><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E to,<span class="keyword">boolean</span> toInclusive)</span></span></div><div class="line"><span class="function">NavigableSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E from,<span class="keyword">boolean</span> fromInclusive)</span></span></div></pre></td></tr></table></figure></p><h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p><img src="/2017/10/23/Java学习总结之集合/不可修改的视图1.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/不可修改的视图2.png" alt="fail"></p><h4 id="同步视图"><a href="#同步视图" class="headerlink" title="同步视图"></a>同步视图</h4><p><img src="/2017/10/23/Java学习总结之集合/同步视图.png" alt="fail"></p><h4 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h4><p><img src="/2017/10/23/Java学习总结之集合/受查视图.png" alt="fail"></p><h4 id="关于可选操作的说明"><a href="#关于可选操作的说明" class="headerlink" title="关于可选操作的说明"></a>关于可选操作的说明</h4><p><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明2.png" alt="fail"><br><img src="/2017/10/23/Java学习总结之集合/关于可选操作的说明3.png" alt="fail"></p><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>内容较多，见Java核心技术卷一 P388 ~ P396，并查阅相关API</p><h3 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h3><p>见Java核心技术 P396 ~ P402</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java集合框架&quot;&gt;&lt;a href=&quot;#Java集合框架&quot; class=&quot;headerlink&quot; title=&quot;Java集合框架&quot;&gt;&lt;/a&gt;Java集合框架&lt;/h3&gt;&lt;p&gt;Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Jav
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之泛型程序设计</title>
    <link href="http://habitdiary.cn/2017/10/22/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://habitdiary.cn/2017/10/22/Java学习总结之泛型程序设计/</id>
    <published>2017-10-22T01:09:10.000Z</published>
    <updated>2018-02-01T14:54:17.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h3><p>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，这是一个泛型程序设计的实例。实际上，在Java增加泛型类之前已经有一个ArrayList类，下面来研究泛型程序设计机制是如何演变的。  </p><h3 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h3><p>在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayLists类只维护一个Object引用的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] elementData;</div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; . . . &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123; . . . &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种方法有两个问题，我们以一个保存文件名的files数组列表为例：<br>1) 当获取一个值时必须进行强制类型转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList files = <span class="keyword">new</span> ArrayList();</div><div class="line">. . .</div><div class="line">String filename = (String)files.get(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>2) 当添加一个值时不进行类型检查，可以添加任何类的对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">files.add(<span class="keyword">new</span> File(<span class="string">". . ."</span>));</div></pre></td></tr></table></figure></p><p>此调用在编译和运行时都不会出错，但如果将get的结果强制转换为String会产生一个错误  </p><p>为了解决上述问题，引入了类型参数。ArrayList有一个类型参数用来指示元素类型：<code>ArrayList&lt;T&gt; files = new ArrayList&lt;T&gt;();</code>，<strong>注意前后两个T必须一致，不能是子类和父类！</strong>在Java SE 7及以后的版本，构造函数可以省略类型参数，即<code>ArrayList&lt;T&gt; files = new ArrayList&lt;&gt;();</code><br>这种方法有三个好处：<br>1)get得到的值不必进行强制类型转换<br>2)向数组列表中添加对象时会进行类型检查，如果不符合类型，无法通过编译，出现编译错误比类在运行时出现类的强制转换异常要好得多<br>3)程序具有更好的可读性，比如<code>ArrayList&lt;String&gt; files</code>一看就是聚集了String对象的数组列表  </p><h3 id="定义简单的泛型类"><a href="#定义简单的泛型类" class="headerlink" title="定义简单的泛型类"></a>定义简单的泛型类</h3><p>一个泛型类就是具有一个或多个类型变量的类，下面使用一个简单的Pair类作为例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> T first;</div><div class="line">    <span class="keyword">private</span> T second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair类引入了一个类型变量T，用尖括号括起来，并放在类名的后面。<strong>注意这里的T只是指定了一种类型，不代表类只有一个属性成员，而表示接下来类中出现的T都和尖括号里的类型保持一致,即类定义的类型变量指定方法返回类型以及域和局部变量的类型。</strong><br>泛型类可以有多个类型变量，如可以定义两个域类型不同的Pair类<code>public class Pair&lt;T,U&gt; {. . .}</code><br><strong>类型变量命名规则：</strong>E表示集合的元素类型，K和V分别表示表的关键字和值的类型，T(需要时还可以用临近的字母U和S)表示“任意类型”。<br>实际使用中将类定义尖括号里的T替换为具体类型，类中的T也会进行相应的替换，所以，<strong>泛型类可以看作普通类的工厂</strong>  </p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>前面介绍了如何定义一个泛型类，下面我们来定义一个带有类型参数的简单泛型方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T...a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>1)类型变量放在修饰符(这里是public static)的后面，返回类型的前面<br>2)泛型方法可以定义在普通类中，也可以定义在泛型类中<br>3)当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q."</span>,<span class="string">"Public"</span>);</div></pre></td></tr></table></figure></p><p><strong>我们注意到上面的泛型方法的参数必须是T类型，如果想要传入T类型的子类怎么办呢？我们可以把<code>&lt;T&gt;</code>改为<code>&lt;? extends T&gt;</code>，这样参数就可以接受T类型以及它的子类。类似的<code>&lt;? super T&gt;</code>则表示参数可以为T类型以及它的超类。</strong></p><h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时，类或方法需要对类型变量加以约束。下面是一个典型的例子，我们要计算数组中的最小元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        T smallest = a[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length;i++)</div><div class="line">        <span class="keyword">if</span>(smallest.compareTo(a[i]) &gt; <span class="number">0</span>)</div><div class="line">            smallest = a[i];</div><div class="line">        <span class="keyword">return</span> smallset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们会发现一个问题，smallest的类型为T，既可以是任何一个类的对象，如何保证T类型有compareTo方法呢？<strong>解决方法是限制T为实现了Comparable接口的类</strong>，即将泛型方法定义改为<code>public static &lt;T extends Comparable&gt; T min(T[] a)</code><br><strong>注意：</strong><br>1)限定类时如果实现的是接口也用extends关键字，如上面的<code>T extends Comparable</code><br>2)只需要在尖括号里限定，之后的T不用再加限定  </p><p>一个类型变量或通配符可以有多个限定，用’&amp;’分隔限定类型，用逗号分隔类型变量，例如：<code>T extends Comparable &amp; Serializable</code> <strong>可以有多个接口限定和至多一个类限定，将标记接口(空接口)放在限定列表的末尾，如果用一个类作为限定，它必须是限定列表中的第一个</strong>  </p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p><strong>对于虚拟机来说没有泛型类型，只有普通类和方法。无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。在编译时泛型类型会被转化为原始类型。</strong>原始类型就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(无限定类型的变量替换为Object)。<br>例如，<code>Pair&lt;T&gt;</code>的原始类型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object first;</div><div class="line">    <span class="keyword">private</span> Object second;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first,Object second)</span> </span>&#123;<span class="keyword">this</span>.first = first; <span class="keyword">this</span>.second = second&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123;first = newValue;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123;second = newValue;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>因为T是一个无限定的参数变量，所以直接用Object替换<br>如果是T是一个限定类型的参数变量，用限定列表中的第一个类型替换，比如<code>T extends Comparable &amp; Serializable</code>被替换为<code>Comparable</code>  </p><h3 id="翻译泛型表达式"><a href="#翻译泛型表达式" class="headerlink" title="翻译泛型表达式"></a>翻译泛型表达式</h3><p>当泛型表达式编译时，编译器会将其编译为原始类型并加入强制类型转换。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Employee&gt; buddies = . . . ;</div><div class="line">Employee buddy = buddies.getFirst();</div></pre></td></tr></table></figure></p><p>编译器会把这个方法调用翻译为两条虚拟机指令：  </p><ul><li>对原始方法Pair.getFirst的调用  </li><li>将返回的Object类型强制转换为Employee类型  </li></ul><p>当存入一个泛型域时编译器也会自动在字节码中插入强制类型转换。  </p><h3 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h3><p>类型擦除会发生一些问题，比如一个类subPair继承自类<code>Pair&lt;String&gt;</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">String</span>&gt; //继承一个泛型类</span></div><div class="line"><span class="class"> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;<span class="comment">//重写了父类的方法</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>Pair在编译的时候被类型擦除，Pair的setFirst方法变为了setFirst(Object newValue)，这样SubPair的setFirst(Stirng newValue)方法就无法覆盖父类中的setFirst(Object newValue)方法，因为参数不同，不是同一个方法。<br>SubPair中会出现两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span>&#123;....&#125;</div></pre></td></tr></table></figure></p><p>此时如果有如下测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SubPair p = <span class="keyword">new</span> SubPair(. . .);</div><div class="line">Pair&lt;String&gt; pair = p;</div><div class="line">p.setFirst(<span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure></p><p>按理来说，这段测试代码应该不能通过编译，因为要实现多态的话，所调用的方法必须在子类中重写，但是在这里SubPair类并没有重写Pair类中的setFirst方法，只是单纯的继承而已，并且新加了一个参数不同的同名方法。<br>但结果可以运行，因为为了解决这种<strong>类型擦除和多态的冲突</strong>，编译器会在SubPair类中生成一个桥方法，上述两个方法被编译器变成了这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(String newValue)</span></span>&#123;....&#125; <span class="comment">//子类定义的方法不变</span></div><div class="line"></div><div class="line"><span class="comment">//编译器生成的桥方法 </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   setFirst((String) newValue);</div><div class="line">   <span class="comment">//桥内部调用的是子类中定义的setFirst(String newValue)方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看出，这个桥方法实际上就是对超类中setFirst(Object newValue)的重写。这样做的原因是，当程序员在子类中写下setFirst(String newValue)方法时，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免<strong>类型擦除与多态发生冲突。</strong><br>详见博客：<a href="http://www.cnblogs.com/xz816111/p/7643323.html" target="_blank" rel="external">Java中的类型擦除与桥方法</a>  </p><h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><p>在使用Java泛型时需要考虑一些限制。大多数限制都是由类型擦除引起的。  </p><h4 id="1-不能用基本类型实例化类型参数"><a href="#1-不能用基本类型实例化类型参数" class="headerlink" title="1.不能用基本类型实例化类型参数"></a>1.不能用基本类型实例化类型参数</h4><p>类型参数不能为基本类型。比如，没有<code>Pair&lt;double&gt;</code>只有<code>Pair&lt;Double&gt;</code>,其原因是类型擦除，因为擦除之后，Pair类含有Object类型的域，Object不能存储double值。  </p><h4 id="2-运行时类型查询只适用于原始类型"><a href="#2-运行时类型查询只适用于原始类型" class="headerlink" title="2.运行时类型查询只适用于原始类型"></a>2.运行时类型查询只适用于原始类型</h4><p>使用instanceof查询一个对象是否属于某个泛型类会产生编译错误，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;)<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>同样的道理，getClass方法总是返回原始类型。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; stringPair = . . .;</div><div class="line">Pair&lt;Employee&gt; employeePair = . . .;</div><div class="line"><span class="keyword">if</span>(stringPair.getClass() == employeePair.getClass()) <span class="comment">//equal</span></div></pre></td></tr></table></figure></p><p>其比较结果是true，因为两次调用getClass结果都返回Pair.class  </p><h4 id="3-不能创建参数化类型的数组"><a href="#3-不能创建参数化类型的数组" class="headerlink" title="3.不能创建参数化类型的数组"></a>3.不能创建参数化类型的数组</h4><p>不能实例化参数化类型的数组，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt; [<span class="number">10</span>];<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>最安全而有效的方法是使用ArrayList，即<code>ArrayList&lt;Pair&lt;String&gt;&gt;</code>  </p><h4 id="4-Varargs警告"><a href="#4-Varargs警告" class="headerlink" title="4.Varargs警告"></a>4.Varargs警告</h4><p>考虑下面的方法，它有可变长的泛型类型参数ts：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll,T...ts)</span></span>&#123;</div><div class="line"><span class="keyword">for</span>(t : ts) coll.add(t);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>现在如果调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Collection&lt;Pair&lt;String&gt;&gt; table = . . .;</div><div class="line">Pair&lt;String&gt; pair1 = . . .;</div><div class="line">Pair&lt;String&gt; pair2 = . . .;</div><div class="line">addAll(table,pair1,pair2);</div></pre></td></tr></table></figure></p><p>JVM会为了可变长参数建立一个Pair<string>数组，这违反了前面的规则。<br><strong>这里特别注意</strong>：Java不支持泛型类型的数组，但如果向参数个数可变的方法传递一个泛型类型的实例(即传递一个泛型类型对象的数组)这种规则有所放松，你只会得到一个警告，而不是错误。可以用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>或用<code>@SafeVarags</code>标注addAll方法来抑制警告。<br>即如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SafeVarargs</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll,T...ts)</span></span></div></pre></td></tr></table></figure></string></p><p>现在就可以提供泛型类型来调用这个方法了。</p><h4 id="5-不能实例化类型变量"><a href="#5-不能实例化类型变量" class="headerlink" title="5.不能实例化类型变量"></a>5.不能实例化类型变量</h4><p>不能使用像new T(…),new T[…]或T.class这样的表达式中的类型变量。例如，下面的Pair<code>&lt;T&gt;</code>构造器是非法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">new</span> T();second = <span class="keyword">new</span> T();&#125;<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>类型擦除将T改变成Object，而且本意肯定不希望调用new Object()。在Java SE 8之后，最好的解决方法是让调用者提供一个构造器表达式。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);</div></pre></td></tr></table></figure></p><p>makePair方法接受一个Supplier<code>&lt;T&gt;</code>，这是一个函数式接口，表示一个无参数而且返回类型为T的函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Supplier&lt;T&gt; constr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt; (constr.get(),constr.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比较传统的解决方法是通过反射调用Class.newInstance方法来构造泛型对象。<br>遗憾的是，细节有点复杂。不能调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">first = T.class.newInstance();<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>表达式T.class是不合法的，因为它会被类型擦除为Object.class。必须像下面这样设计API以便得到一个Class对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt; (c1.newInstance(),c1.newInstance())&#125;;</div><div class="line">    <span class="keyword">catch</span>(Exception ex) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方法可以按照下列方式调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</div></pre></td></tr></table></figure></p><p>注意，Class类本身是泛型。例如,String.class是一个Class<code>&lt;String&gt;</code>的实例(事实上，它是唯一的实例)。因此,makePair方法能够推断除pair的类型。  </p><h4 id="6-不能构造泛型数组"><a href="#6-不能构造泛型数组" class="headerlink" title="6.不能构造泛型数组"></a>6.不能构造泛型数组</h4><p>就像不能实例化一个泛型实例一样，也不能实例化数组。不过原因有所不同，毕竟数组会填充null值，构造时看上去是安全的。不过，数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除。例如，考虑下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>];&#125;<span class="comment">//Error</span></div></pre></td></tr></table></figure></p><p>类型擦除会让这个方法永远构造Comparable[2]数组。<br>如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object[],并且在屈原素时进行类型转换。例如，ArrayList可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> Object[] elements;</div><div class="line">    . . .</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (E) elements[i];&#125;<span class="comment">//取元素时强制类型转换</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i,E e)</span> </span>&#123; elements[i] = e;&#125;<span class="comment">//改变元素时不必强转</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实际的实现没有那么清晰：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> E[] elements;</div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;elements = (E[]) <span class="keyword">new</span> Object[<span class="number">10</span>];&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里的强制类型转换E[]是一个假象，而类型擦除使其无法察觉。<br>由于 minmax 方法返回 T[] 数组，使得这一技术无法施展， 如果掩盖这个类型会有运行时错误结果。假设实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T... a)</div><div class="line">&#123;</div><div class="line">Object[] mm = <span class="keyword">new</span> Object[<span class="number">2</span>];</div><div class="line">. . .</div><div class="line"><span class="keyword">return</span> (T[]) mm; <span class="comment">// compiles with warning</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用 String[] ss = ArrayAlg.minmax(“Tom”, “Dick”, “Harry”);<br>编译时不会有任何警告。当 Object[] 引用赋给 Comparable[] 变量时，将会发生 ClassCastException异常。<br>在这种情况下， 最好让用户提供一个数组构造器表达式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String[] ss = ArrayAlg.minmax (String[]::<span class="keyword">new</span>，<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</div></pre></td></tr></table></figure></p><p>构造器表达式 String::new 指示一个函数，给定所需的长度，会构造一个指定长度的<br>String数组。<br>minmax方法使用这个参数生成一个有正确类型的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmax(IntFunction&lt;T[]&gt; constr, T... a)</div><div class="line">&#123;</div><div class="line">T[] mm = constr.apply(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>比较老式的方法是利用反射， 调用 Array.newInstance:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable〉T[] minmaxfT... a)</div><div class="line">&#123;</div><div class="line">T[] mm = (T[]) Array.newlnstance (a.getClass().getComponentType() , <span class="number">2</span>);</div><div class="line"> . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ArrayList 类的 toArray 方法就没有这么幸运。它需要生成一个 T[] 数组， 但没有成分类型。因此， 有下面两种不同的形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object[] toArray()</div><div class="line">T[] toArray(T[] result)</div></pre></td></tr></table></figure></p><p>第二个方法接收一个数组参数。如果数组足够大,就使用这个数组。否则,用 result 的成分类型构造一个足够大的新数组。  </p><h4 id="7-泛型类的静态上下文中类型变量无效"><a href="#7-泛型类的静态上下文中类型变量无效" class="headerlink" title="7.泛型类的静态上下文中类型变量无效"></a>7.泛型类的静态上下文中类型变量无效</h4><p>不能在静态域或方法中引用类型变量。例如， 下列高招将无法施展：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> T singlelnstance; <span class="comment">// Error</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T getSinglelnstanceO <span class="comment">// Error</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (singleinstance == <span class="keyword">null</span>) <span class="comment">//construct new instance of T</span></div><div class="line"><span class="keyword">return</span> singlelnstance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="8-不能抛出或捕获泛型类的实例"><a href="#8-不能抛出或捕获泛型类的实例" class="headerlink" title="8.不能抛出或捕获泛型类的实例"></a>8.不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类对象。实际上， 甚至泛型类扩展 Throwable 都是不合法的。<br>例如， 以下定义就不能正常编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* . . . */</span> &#125; </div><div class="line"><span class="comment">// Error can't extend Throwable</span></div></pre></td></tr></table></figure></p><p>catch 子句中不能使用类型变量。例如， 以下方法将不能编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable〉<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (T e) <span class="comment">// Error can 't catch type variable</span></div><div class="line">&#123;</div><div class="line">Logger.global.info(...)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>不过，在异常规范中使用类型变量是允许的。以下方法是合法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T <span class="comment">// OK</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Throwable real Cause)</div><div class="line">&#123;</div><div class="line">t.initCause(real Cause);</div><div class="line"><span class="keyword">throw</span> t;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="9-可以消除对受查异常的检查"><a href="#9-可以消除对受查异常的检查" class="headerlink" title="9.可以消除对受查异常的检查"></a>9.可以消除对受查异常的检查</h4><p>Java 异常处理的一个基本原则是， 必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。关键在于以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">throw</span> (T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设这个方法包含在类 Block 中，如果调用<code>Block.&lt;RuntimeException&gt;throwAs(t);</code><br>编译器就会认为 t 是一个非受查异常。 以下代码会把所有异常都转换为编译器所认为的非受查异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">do</span> work</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (Throwable t)</div><div class="line">&#123;</div><div class="line">Block.&lt;RuntimeException&gt;throwAs(t) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面把这个代码包装在一个抽象类中。用户可以覆盖 body 方法来提供一个具体的动作。调用 toThread 时， 会得到 Thread 类的一个对象， 它的 run 方法不会介意受查异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">toThrea</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> Thread()</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">body();</div><div class="line">            &#125;</div><div class="line"><span class="keyword">catch</span> (Throwable t)</div><div class="line">&#123;</div><div class="line">            Block.&lt;RuntimeException&gt; throwAs(t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">throw</span> (T) e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>例如， 以下程序运行了一个线程， 它会拋出一个受查异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">new</span> Block()</div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"ququx"</span>) ,<span class="string">"UTF-8"</span>);</div><div class="line"><span class="keyword">while</span> (in.hasNext())</div><div class="line">System.out.println(in.next());</div><div class="line">&#125;</div><div class="line"> &#125; </div><div class="line">   .toThread() .start();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行这个程序时， 会得到一个栈轨迹， 其中包含一个FileNotFoundException ( 当然,假设你没有提供一个名为 ququx 的文件)。<br>这有什么意义呢？ 正常情况下， 你必须捕获线程 run 方法中的所有受查异常， 把它们”包装”到非受查异常中， 因为 run 方法声明为不抛出任何受查异常。<br>不过在这里并没有做这种”包装”。我们只是抛出异常， 并”哄骗”编译器， 让它认为这不是一个受查异常。<br>通过使用泛型类、 擦除和 @SuppressWarnings 注解， 就能消除 Java 类型系统的部分基本限制。  </p><h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><p>当泛型类型被擦除时，无法创建引发冲突的条件。下面是一个示例。假定像下面这样将equals 方法添加到 Pair 类中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123; <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>考虑一个Pair<code>&lt;String&gt;</code>。从概念上讲，它有两个equals方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span> <span class="comment">// defined in Pair&lt;T&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span> <span class="comment">// inherited from Object</span></span></div></pre></td></tr></table></figure></p><p>但是，直觉把我们引入歧途。方法擦除<code>boolean equals(T)</code>，就是<code>boolean equals(Object)</code><br>与 Object.equals 方法发生冲突。<br>当然，补救的办法是重新命名引发错误的方法。<br>泛型规范说明还提到另外一个原则:”要想支持擦除的转换， 就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。”例如，<br>下述代码是非法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Coinparab1e</span>&lt;<span class="title">Emp1oyee</span>&gt; </span>&#123; . . . &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Hanager</span>&gt; </span></div><div class="line"><span class="class"></span>&#123; . . . &#125; <span class="comment">// Error</span></div></pre></td></tr></table></figure></p><p>Manager 会实现 Comparable<code>&lt;Employee&gt;</code> 和 Comparable<code>&lt;Manager&gt;</code>, 这是同一接口的不同参数化。<br>这一限制与类型擦除的关系并不十分明确。毕竟，下列非泛型版本是合法的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123; . . . &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123; . . . &#125;</div></pre></td></tr></table></figure></p><p>其原因非常微妙， 有可能与合成的桥方法产生冲突。实现了 Comparable<code>&lt;X&gt;</code> 的类可以获得一个桥方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123; <span class="keyword">return</span> compareTo((X) other); &#125;</div></pre></td></tr></table></figure></p><p>对于不同类型的 X 不能有两个这样的方法。</p><h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;泛型程序设计&quot;&gt;&lt;a href=&quot;#泛型程序设计&quot; class=&quot;headerlink&quot; title=&quot;泛型程序设计&quot;&gt;&lt;/a&gt;泛型程序设计&lt;/h3&gt;&lt;p&gt;泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之线段树</title>
    <link href="http://habitdiary.cn/2017/10/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://habitdiary.cn/2017/10/18/算法学习之线段树/</id>
    <published>2017-10-18T15:11:27.000Z</published>
    <updated>2017-10-18T16:23:57.942Z</updated>
    
    <content type="html"><![CDATA[<p>最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  </p><h3 id="线段树是什么？有什么用？"><a href="#线段树是什么？有什么用？" class="headerlink" title="线段树是什么？有什么用？"></a>线段树是什么？有什么用？</h3><p>线段树类似区间树，它在各个节点保存一条线段(数组中的一段子数组)，主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。<br>你可能会问：查询区间和可以用O(n)的复杂度预处理一个前缀和数组，然后就可以O(1)地查询某段区间和;查询区间最值，也就是RMQ问题，也可以用O(nlogn)的复杂度预处理ST表，然后O(1)地查询区间最值。那么为什么要使用线段树呢？<br>线段树的精髓就在于它能在支持<strong>区间动态修改</strong>的前提下保持每个操作O(logn)的复杂度，这是其他两者做不到的。<br>线段树能进行的操作主要有：1)单点更新，区间查询  2)区间更新，区间查询 3)区间更新，单点查询<br>除了上述操作，线段树还可以解决区间染色和矩形面积交、面积并等问题。  </p><h3 id="线段树基本知识"><a href="#线段树基本知识" class="headerlink" title="线段树基本知识"></a>线段树基本知识</h3><p>线段树的结构：<br><img src="/2017/10/18/算法学习之线段树/1.png" alt="fail">  </p><p>建立一个线段树的示意图(可以维护区间和或最值)：<br><img src="/2017/10/18/算法学习之线段树/2.png" alt="fail">  </p><p>单点修改后重新调整线段树：<br><img src="/2017/10/18/算法学习之线段树/3.png" alt="fail">  </p><p>区间查询区间最值：<br><img src="/2017/10/18/算法学习之线段树/4.png" alt="fail">  </p><p>线段树的结点关系:<br><img src="/2017/10/18/算法学习之线段树/5.png" alt="fail">  </p><h3 id="线段树的代码实现"><a href="#线段树的代码实现" class="headerlink" title="线段树的代码实现"></a>线段树的代码实现</h3><p>下面给出建立线段树和进行各种操作的模板，关键点在代码的注释中有解释：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*node：区间结点号begin：该node的区间左边界end：该node的区间右边界</span></div><div class="line"><span class="comment">  left：查询区间的左边界right：查询区间的右边界pos：查询区间的点*/</span> </div><div class="line">  </div><div class="line"><span class="comment">/*线段树:求和或最值 </span></div><div class="line"><span class="comment">单点更新,区间查询</span></div><div class="line"><span class="comment">区间更新,单点查询(lazy标记表示本节点的信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。lazy初始为0,区间加上k给该区间管理的结点的lazy加k,push_down给子节点加(end-begin+1)*k)</span></div><div class="line"><span class="comment">区间更新,区间查询 </span></div><div class="line"><span class="comment">lson 2*node</span></div><div class="line"><span class="comment">rson 2*node+1</span></div><div class="line"><span class="comment">[begin,end]</span></div><div class="line"><span class="comment">[begin,mid] [mid+1,end] 其中mid为(begin+end)/2 */</span> </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1) </span></div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> lazy[maxn*<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;<span class="comment">//pushUp自底向上更新区间和与最值 </span></div><div class="line">segTree[node]=segTree[lson]+segTree[rson];<span class="comment">//segTree[node]=max(segTree[lson],segTree[rson]) </span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//pushDown自顶向下更新lazy数组和给结点加上lazy数组的值 </span></div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;<span class="comment">//lazy[node]为0直接return </span></div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node]; </div><div class="line">lazy[lson]+=lazy[node]; </div><div class="line">lazy[rson]+=lazy[node];<span class="comment">//给左右孩子传递lazy,是+=不是=，因为孩子节点可能被多次延迟标记又没有向下传递 </span></div><div class="line">lazy[node]=<span class="number">0</span>;<span class="comment">//把父节点的lazy置为0 </span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//建树 </span></div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;<span class="comment">//begin==end表示管理的是结点 </span></div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);<span class="comment">//按照顺序输入结点，由于建树类似于树的先根遍历，所以建立的线段树的叶子结点从左到右的值就是输入的顺序 </span></div><div class="line"><span class="comment">//segTree[node]=a[begin] 用于任意顺序输入,先将输入存入a数组,下标从1开始，begin = end = index </span></div><div class="line"><span class="keyword">return</span>;<span class="comment">//输入完成后要return，否则会继续访问左右孩子，可能越界</span></div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//单点更新 </span></div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;<span class="comment">//管理的区间不包含pos,直接return </span></div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125; </div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;<span class="comment">//区间查询 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查询结点和区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];<span class="comment">//查询区间包含查询结点 </span></div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//int maxx=-1</span></div><div class="line">sum+=query(lson,begin,mid,left,right);<span class="comment">//maxx=max(maxx,query(lson,begin,mid,left,right))</span></div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);<span class="comment">//maxx=max(maxx,query(rson,mid+1,end,left,right))</span></div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//区间更新 </span></div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;<span class="comment">//结点和更新区间没有公共点 </span></div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;<span class="comment">//更新区间包含结点 </span></div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="一、单点更新，区间查询"><a href="#一、单点更新，区间查询" class="headerlink" title="一、单点更新，区间查询"></a>一、单点更新，区间查询</h4><p>HDU1166 敌兵布阵<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1166" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1166</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[maxn*<span class="number">4</span>];</div><div class="line"><span class="keyword">int</span> T,N,a,b;</div><div class="line"><span class="keyword">char</span> command[<span class="number">10</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,cas++);</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,command)!=EOF)&#123;</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'E'</span>) <span class="keyword">break</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)</div><div class="line"><span class="built_in">cout</span>&lt;&lt;query(<span class="number">1</span>,<span class="number">1</span>,N,a,b)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'A'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,b);</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'S'</span>)</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,a,-b);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1754 I Hate It<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1754" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1754</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> N,M,A,B;</div><div class="line"><span class="keyword">char</span> C[<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=max(segTree[lson],segTree[rson]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> pos,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(pos&lt;begin||pos&gt;end) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=k;<span class="comment">//直接修改</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">update(lson,begin,mid,pos,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,pos,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line"><span class="keyword">int</span> maxx=<span class="number">0</span>;</div><div class="line">maxx=max(maxx,query(lson,begin,mid,left,right));</div><div class="line">maxx=max(maxx,query(rson,mid+<span class="number">1</span>,end,left,right));</div><div class="line"><span class="keyword">return</span> maxx;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M)!=EOF)&#123;</div><div class="line"> build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"> <span class="keyword">while</span>(M--)&#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,C,&amp;A,&amp;B);</div><div class="line"><span class="keyword">if</span>(C[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B);</div><div class="line">&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="二、区间更新，区间查询"><a href="#二、区间更新，区间查询" class="headerlink" title="二、区间更新，区间查询"></a>二、区间更新，区间查询</h3><p>POJ 3468 A Simple Problem with Integers<br>题目链接:<a href="http://poj.org/problem?id=3468" target="_blank" rel="external">http://poj.org/problem?id=3468</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line">ll segTree[<span class="number">4</span>*maxn];</div><div class="line">ll lazy[<span class="number">4</span>*maxn];</div><div class="line">ll N,Q,A,B,C;</div><div class="line"><span class="keyword">char</span> command[<span class="number">3</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(ll node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]+=(mid-begin+<span class="number">1</span>)*lazy[node];</div><div class="line">segTree[rson]+=(end-mid)*lazy[node];</div><div class="line">lazy[lson]+=lazy[node];</div><div class="line">lazy[rson]+=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll node,ll begin,ll end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;segTree[node]);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll node,ll begin,ll end,ll left,ll right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line">ll sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll node,ll begin,ll end,ll left,ll right,ll k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]+=(end-begin+<span class="number">1</span>)*k;</div><div class="line">lazy[node]+=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,command);</div><div class="line"><span class="keyword">if</span>(command[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;A,&amp;B);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(<span class="number">1</span>,<span class="number">1</span>,N,A,B));</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;A,&amp;B,&amp;C);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,A,B,C);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1698 Just A Hook<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1698" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1698</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> segTree[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> lazy[<span class="number">4</span>*maxn];</div><div class="line"><span class="keyword">int</span> T,N,Q,X,Y,Z;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">segTree[node]=segTree[lson]+segTree[rson];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">segTree[node]=<span class="number">1</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,begin,mid);</div><div class="line">build(rson,mid+<span class="number">1</span>,end);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(!lazy[node]) <span class="keyword">return</span>;</div><div class="line">segTree[lson]=(mid-begin+<span class="number">1</span>)*lazy[node];<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">segTree[rson]=(end-mid)*lazy[node];</div><div class="line">lazy[lson]=lazy[node];</div><div class="line">lazy[rson]=lazy[node];</div><div class="line">lazy[node]=<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">segTree[node]=(end-begin+<span class="number">1</span>)*k;<span class="comment">//+=改成=,直接更新到底部</span></div><div class="line">lazy[node]=k;<span class="comment">//+=改成=,因为此时lazy即使没有下传也不叠加</span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">pushDown(node,begin,end);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">pushUp(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end) <span class="keyword">return</span> segTree[node];</div><div class="line">pushDown(node,begin,end);</div><div class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">sum+=query(lson,begin,mid,left,right);</div><div class="line">sum+=query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line"><span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">int</span> cas=<span class="number">1</span>;</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;Q);</div><div class="line">build(<span class="number">1</span>,<span class="number">1</span>,N);</div><div class="line"><span class="keyword">while</span>(Q--)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;X,&amp;Y,&amp;Z);</div><div class="line">update(<span class="number">1</span>,<span class="number">1</span>,N,X,Y,Z);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: The total value of the hook is %d.\n"</span>,cas++,query(<span class="number">1</span>,<span class="number">1</span>,N,<span class="number">1</span>,N));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="三、区间染色问题"><a href="#三、区间染色问题" class="headerlink" title="三、区间染色问题"></a>三、区间染色问题</h3><p>ZOJ 1610 Count the Colors<br>题目链接:<a href="https://vjudge.net/problem/11553/origin" target="_blank" rel="external">https://vjudge.net/problem/11553/origin</a><br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 8005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> col[maxn*<span class="number">4</span>];<span class="comment">//col[node]表示node管辖的区间的颜色 </span></div><div class="line"><span class="keyword">int</span> sum[maxn];<span class="comment">//表示某点的颜色 </span></div><div class="line"><span class="keyword">int</span> res[maxn];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</div><div class="line">col[lson]=col[rson]=col[node];</div><div class="line">col[node]=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line"><span class="keyword">if</span>(left&lt;=begin&amp;&amp;right&gt;=end)&#123;</div><div class="line">col[node]=k;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(col[node]!=<span class="number">-1</span>) pushDown(node);</div><div class="line">update(lson,begin,mid,left,right,k);</div><div class="line">update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"><span class="comment">//不用建树,直接在query里存储颜色即可，因为染色不用求区间和或者最值 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(begin==end)&#123;</div><div class="line">sum[begin]=col[node];<span class="comment">//存储每个点的颜色 </span></div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid,left,right);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end,left,right);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> n,x1,x2,c;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</div><div class="line"><span class="built_in">memset</span>(col,<span class="number">-1</span>,<span class="keyword">sizeof</span>(col));</div><div class="line"><span class="built_in">memset</span>(sum,<span class="number">-1</span>,<span class="keyword">sizeof</span>(sum));</div><div class="line"><span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x1,&amp;x2,&amp;c);</div><div class="line"><span class="keyword">if</span>(x1==x2) <span class="keyword">continue</span>;<span class="comment">//为了保证R-1&gt;=L </span></div><div class="line">update(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,x1,x2<span class="number">-1</span>,c);<span class="comment">//为防止重叠,更新区间[L,R-1]</span></div><div class="line"><span class="comment">/*注意begin=0 end=maxn-1 而不是begin=1 end=n 因为只是涂n次,不一定在1-n范围内涂 */</span> </div><div class="line">&#125;</div><div class="line">query(<span class="number">1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>,<span class="number">0</span>,maxn<span class="number">-1</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++) &#123;</div><div class="line">            <span class="keyword">while</span>(i!=<span class="number">0</span>&amp;&amp;sum[i]!=<span class="number">-1</span>&amp;&amp;sum[i]==sum[i<span class="number">-1</span>])<span class="comment">//涂过同一颜色也加1 </span></div><div class="line">            i++;</div><div class="line">            res[sum[i]]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;maxn; i++)</div><div class="line"><span class="keyword">if</span>(res[i])</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,res[i]);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>POJ 2528 Mayor’s posters<br>题目链接:<a href="http://poj.org/problem?id=2528" target="_blank" rel="external">http://poj.org/problem?id=2528</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*解法：离散化，如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的</span></div><div class="line"><span class="comment">      1   2   3   4  6   7   8   10</span></div><div class="line"><span class="comment">      —   —   —   —  —   —   —   —</span></div><div class="line"><span class="comment">      1   2   3   4  5   6   7   8</span></div><div class="line"><span class="comment">离散化  X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10</span></div><div class="line"><span class="comment">于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。</span></div><div class="line"><span class="comment">但是只是这样简单的离散化是错误的，</span></div><div class="line"><span class="comment">如三张海报为：1~10 1~4 6~10</span></div><div class="line"><span class="comment">离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10</span></div><div class="line"><span class="comment">第一张海报时：墙的1~4被染为1；</span></div><div class="line"><span class="comment">第二张海报时：墙的1~2被染为2，3~4仍为1；</span></div><div class="line"><span class="comment">第三张海报时：墙的3~4被染为3，1~2仍为2。</span></div><div class="line"><span class="comment">最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。</span></div><div class="line"><span class="comment">新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）</span></div><div class="line"><span class="comment">X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10</span></div><div class="line"><span class="comment">这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3</span></div><div class="line"><span class="comment">最终，1~2为2，3为1，4~5为3，于是输出正确结果3。*/</span> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (node&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((node&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((begin+end)&gt;&gt;1)</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></div><div class="line"><span class="comment">//不用建树,直接在query里记录hash即可，因为染色不用求区间和或者最值，也不用pushUp </span></div><div class="line"><span class="keyword">int</span> m, li[maxn], ri[maxn];</div><div class="line"><span class="keyword">int</span> poster[maxn&lt;&lt;<span class="number">3</span>], col[maxn&lt;&lt;<span class="number">4</span>], ans; <span class="comment">//col记录当前该位置最上面一层的海报种类,即染色问题的颜色 </span></div><div class="line"><span class="comment">//poster记录海报位置 </span></div><div class="line"><span class="keyword">bool</span> hash[maxn];<span class="comment">//hash用于标记某种种类的海报是否计算过,若已计算过标记为true,不再重复计算 </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">     col[lson] = col[rson] = col[node];<span class="comment">//类似lazy标记，向下传递后清空</span></div><div class="line">     col[node] = <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin, <span class="keyword">int</span> end,<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(left&gt;end||right&lt;begin) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (begin &gt;= left &amp;&amp; end &lt;= right) &#123;</div><div class="line">         col[node] = k;</div><div class="line">         <span class="keyword">return</span>;</div><div class="line">     &#125;</div><div class="line">    <span class="keyword">if</span>(col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    update(lson,begin,mid,left,right,k);</div><div class="line">    update(rson,mid+<span class="number">1</span>,end,left,right,k);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (begin == end) &#123;</div><div class="line">        <span class="keyword">if</span> (!hash[col[node]]) &#123;</div><div class="line">        ans++;</div><div class="line">        hash[col[node]] = <span class="literal">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (col[node] != <span class="number">-1</span>) pushDown(node);</div><div class="line">    query(lson,begin,mid);</div><div class="line">    query(rson,mid+<span class="number">1</span>,end);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> hh, <span class="keyword">int</span> xx)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mm;</div><div class="line">    <span class="keyword">while</span> (ll &lt;= hh) &#123;</div><div class="line">        mm = (ll + hh) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (poster[mm] == xx) <span class="keyword">return</span> mm;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (poster[mm] &gt; xx)  hh = mm - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> ll = mm + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> t, n, i;</div><div class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;t);</div><div class="line">    <span class="keyword">while</span> (t--) &#123;</div><div class="line">        <span class="built_in">memset</span>(col, <span class="number">-1</span>, <span class="keyword">sizeof</span> (col));<span class="comment">//-1表示没有染色</span></div><div class="line">        <span class="built_in">memset</span> (hash, <span class="literal">false</span>, <span class="keyword">sizeof</span> (hash));<span class="comment">/*因为本题墙的长度为10000000,</span></div><div class="line"><span class="comment">直接做会超时,而实际海报数量只有10000,考虑把每张海报左右两端的两段映射到小范围计算，</span></div><div class="line"><span class="comment">所以考虑离散化,但传统离散化会出错,要如果有两个位置相邻的数字数值不相邻,考虑在中间</span></div><div class="line"><span class="comment">插入一个比大的数小1的数*/</span></div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;n);</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">             <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;li[i], &amp;ri[i]);</div><div class="line">             poster[++cnt] = li[i];</div><div class="line">             poster[++cnt] = ri[i];</div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+cnt+<span class="number">1</span>);</div><div class="line">        m = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= cnt; i++) &#123;</div><div class="line">             <span class="keyword">if</span> (poster[i] != poster[i<span class="number">-1</span>]) poster[++m] = poster[i];<span class="comment">//去重 </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (i = m; i &gt; <span class="number">1</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (poster[i] - poster[i<span class="number">-1</span>] &gt; <span class="number">1</span>) poster[++m] = poster[i] - <span class="number">1</span>;<span class="comment">//在末尾加入要增加的点 </span></div><div class="line">        &#125;</div><div class="line">        sort(poster+<span class="number">1</span>, poster+m+<span class="number">1</span>);<span class="comment">//重新排序 </span></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            <span class="keyword">int</span> l = binarySearch(<span class="number">1</span>, m, li[i]);<span class="comment">//在离散化后的poster数组里二分查找每一组的左右端点</span></div><div class="line">            <span class="keyword">int</span> r = binarySearch(<span class="number">1</span>, m, ri[i]);</div><div class="line">            update(<span class="number">1</span>,<span class="number">1</span>,m,l,r,i);</div><div class="line">        &#125;</div><div class="line">        ans = <span class="number">0</span>;</div><div class="line">        query(<span class="number">1</span>, <span class="number">1</span>, m);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="四、矩形面积交-面积并"><a href="#四、矩形面积交-面积并" class="headerlink" title="四、矩形面积交/面积并"></a>四、矩形面积交/面积并</h3><p>HDU 1542 Atlantis(矩形面积并)<br>题目链接：<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1542" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1542</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"><span class="comment">//沿x轴扫描,沿y轴建树,线段树的结点是纵向的线段,最下面一层结点以排序后相邻的y1,y2为边界 </span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>     //  存储线段信息；</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> x;   <span class="comment">//  该线段的x坐标；</span></div><div class="line">    <span class="keyword">double</span> y_up,y_down;     <span class="comment">//  竖向线段的上下端点；</span></div><div class="line">    <span class="keyword">int</span> flag;<span class="comment">//矩形的左边界为1,右边界为-1 </span></div><div class="line">&#125;line[maxn];</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>//线段树的结点,不再是单个点,是一个区间 </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">double</span> l,r;<span class="comment">//区间的左右边界,即某段扫描线的上下端点 </span></div><div class="line">    <span class="keyword">double</span> x;       <span class="comment">//  记录上一个横坐标位置，用于求面积；</span></div><div class="line">    <span class="keyword">int</span> cover;      <span class="comment">//  记录覆盖的线段数;即同一方向的线段数;由flag累加 </span></div><div class="line">    <span class="keyword">bool</span> flag;      <span class="comment">//  标记只有一个区间的节点,即在线段树最底层的结点,我们将一个个连续的区间离散化成一个结点；</span></div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span>      <span class="comment">//  建树；</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    node[rt].l=y[l];    <span class="comment">//  维护区间；</span></div><div class="line">    node[rt].r=y[r];</div><div class="line">    node[rt].x=<span class="number">-1</span>;</div><div class="line">    node[rt].flag=<span class="literal">false</span>;</div><div class="line">    node[rt].cover=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;             <span class="comment">//  区间是连续的;</span></div><div class="line">        node[rt].flag=<span class="literal">true</span>; <span class="comment">//  标记为结点; </span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    build(lson,l,mid);</div><div class="line">    build(rson,mid,r);   <span class="comment">//  因为将一个个连续区间离散成点，所以此处mid不需要+1；</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span> </span></div><div class="line"><span class="function"><span class="comment">/*查询+更新x处（l,r）区间面积，l和r代表的是区间查询区间的边界，node[rt].l和node[rt].r代表的是结点边界*/</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//  该方向结点不包含所要查询的区间；</span></div><div class="line">    <span class="keyword">if</span>(node[rt].flag)&#123;  <span class="comment">//  找到只有一个区间的叶子结点；</span></div><div class="line">        <span class="keyword">if</span>(node[rt].cover&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">double</span> pre=node[rt].x;</div><div class="line">            <span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l); <span class="comment">//  计算面积；</span></div><div class="line">            node[rt].x=x;       <span class="comment">//  更新定位x位置，便于下次计算面积；</span></div><div class="line">            node[rt].cover+=flag;   <span class="comment">//  更新覆盖的线段数；</span></div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">            node[rt].x=x;</div><div class="line">            node[rt].cover+=flag;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//没有产生面积并也要return 0 </span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> ans1,ans2;</div><div class="line">    ans1=Insert_query(lson,x,l,r,flag);    </div><div class="line">    ans2=Insert_query(rson,x,l,r,flag); </div><div class="line">    <span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> Case=<span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> x1,x2,y1,y2;</div><div class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</div><div class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">            y[cnt]=y1;</div><div class="line">            line[cnt].x=x1;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">1</span>;   <span class="comment">//  表示左边线段；</span></div><div class="line">            y[cnt]=y2;</div><div class="line">            line[cnt].x=x2;</div><div class="line">            line[cnt].y_down=y1;</div><div class="line">            line[cnt].y_up=y2;</div><div class="line">            line[cnt++].flag=<span class="number">-1</span>;  <span class="comment">//  表示右边线段；</span></div><div class="line">        &#125;</div><div class="line">        sort(y,y+cnt);        <span class="comment">//  将所有高度由小到大排序，将区间建树表示</span></div><div class="line">        sort(line,line+cnt,cmp);      <span class="comment">//  因为扫描线从左到右扫描，所以按照横坐标从小到大排序后逐一插入线段树</span></div><div class="line">        build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line">        <span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">            area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Test case #%d\nTotal explored area: %.2lf\n\n"</span>,++Case,area);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>HDU 1255 覆盖的面积(矩形面积交)<br>题目链接:<a href="http://acm.split.hdu.edu.cn/showproblem.php?pid=1255" target="_blank" rel="external">http://acm.split.hdu.edu.cn/showproblem.php?pid=1255</a><br>代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (rt&lt;&lt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rson ((rt&lt;&lt;1)|1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> T,N;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">double</span> y[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LINE</span>&#123;</span></div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">double</span> y_up,y_down;</div><div class="line"><span class="keyword">int</span> flag;</div><div class="line">&#125;line[maxn];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></div><div class="line"><span class="keyword">double</span> l,r;</div><div class="line"><span class="keyword">double</span> x;</div><div class="line"><span class="keyword">int</span> cover;</div><div class="line"><span class="keyword">bool</span> flag;</div><div class="line">&#125;node[maxn&lt;&lt;<span class="number">2</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(LINE a,LINE b)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> a.x&lt;b.x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</div><div class="line">node[rt].l=y[l];</div><div class="line">node[rt].r=y[r];</div><div class="line">node[rt].x=<span class="number">-1</span>;</div><div class="line">node[rt].flag=<span class="literal">false</span>;</div><div class="line">node[rt].cover=<span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(l+<span class="number">1</span>==r)&#123;</div><div class="line">node[rt].flag=<span class="literal">true</span>;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">build(lson,l,mid);</div><div class="line">build(rson,mid,r);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Insert_query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">double</span> x,<span class="keyword">double</span> l,<span class="keyword">double</span> r,<span class="keyword">int</span> flag)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(l&gt;=node[rt].r||r&lt;=node[rt].l) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span>(node[rt].flag)&#123;</div><div class="line"><span class="keyword">if</span>(node[rt].cover&gt;<span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">double</span> pre=node[rt].x;</div><div class="line"><span class="keyword">double</span> ans=(x-pre)*(node[rt].r-node[rt].l);</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">node[rt].x=x;</div><div class="line">node[rt].cover+=flag;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">double</span> ans1,ans2;</div><div class="line">ans1=Insert_query(lson,x,l,r,flag);</div><div class="line">ans2=Insert_query(rson,x,l,r,flag);</div><div class="line"><span class="keyword">return</span> ans1+ans2;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line"><span class="keyword">while</span>(T--)&#123;</div><div class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</div><div class="line"><span class="keyword">while</span>(N--)&#123;</div><div class="line"><span class="keyword">double</span> x1,y1,x2,y2;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</div><div class="line">y[cnt]=y1;</div><div class="line">line[cnt].x=x1;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">1</span>;</div><div class="line">y[cnt]=y2;</div><div class="line">line[cnt].x=x2;</div><div class="line">line[cnt].y_down=y1;</div><div class="line">line[cnt].y_up=y2;</div><div class="line">line[cnt++].flag=<span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line">sort(y,y+cnt);</div><div class="line">sort(line,line+cnt,cmp);</div><div class="line">build(<span class="number">1</span>,<span class="number">0</span>,cnt<span class="number">-1</span>);</div><div class="line"><span class="keyword">double</span> area=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</div><div class="line">area+=Insert_query(<span class="number">1</span>,line[i].x,line[i].y_down,line[i].y_up,line[i].flag);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,area);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。  &lt;/p&gt;
&lt;h3 id=&quot;线段树是什么？有什么用？&quot;&gt;&lt;a href=&quot;#线段树是什么？有什么用？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="算法" scheme="http://habitdiary.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之抽象类、接口、lambda表达式与内部类</title>
    <link href="http://habitdiary.cn/2017/10/16/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://habitdiary.cn/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/</id>
    <published>2017-10-16T00:52:06.000Z</published>
    <updated>2018-02-25T03:21:56.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它子类的共同特征。<strong>如果一个父类设计得非常抽象，以至于它没有任何具体的实例，这样的类称为抽象类，使用abstract关键字修饰。抽象类定义了相关子类的共同行为。</strong>  </p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>如果一个方法非常抽象，只定义了方法，没有提供方法的具体实现，那么我们把它定义为一个抽象方法，它的具体实现由子类提供，即子类覆盖抽象方法提供方法体。<br>抽象方法由abstract关键字修饰，只有方法头，没有花括号和方法体，以分号结尾。比如一个GeometricObject类定义了一个名为getArea的抽象方法，即<code>public abstract double getArea();</code> </p><h3 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h3><p>1.抽象方法应该定义为public，以便子类进行重写。<br>2.抽象类的构造器应该定义为protected，因为抽象类不能通过new直接创建实例，其构造器只被子类调用。创建一个具体子类的实例时，它的父类的构造器被调用以初始化父类中定义的数据域。<br>3.一个包含抽象方法的类必须定义为抽象类，一个不包含抽象方法的类也可以定义为抽象类(如果不想让某类创建实例，可以把它定义为抽象类)<br>4.如果子类继承抽象类时没有覆盖其所有的抽象方法，即子类中仍有抽象方法，子类也应该定义为抽象的<br>5.抽象方法是非静态的<br>6.子类可以覆盖父类的方法并将它定义为abstract,这种情况很少见，但它在当父类方法实现在子类中变得无效时是很有用的，在这种情况下，子类必须定义为abstract<br>7.即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object是具体的，但它的子类GeometricObject是抽象的。<br>8.不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。下面的语句创建一个GeometricObject类型的数组是正确的：<code>GeometricObject[] objects = new GeometricObject[10];</code>然后可以创建一个具体子类的实例并把它的引用赋给数组，如：<code>Objects[0] = new Circle();</code></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在很多方面都与抽象类很相似，但它的目的是指明<strong>相关或者不相关类</strong>的多个对象的共同行为，属性成员都是<strong>公共静态常量</strong>，成员方法都是<strong>公共抽象方法</strong>。例如，使用正确的接口，可以指明这些对象是可比较的、可克隆的。为了区分接口和类，Java采用Interface关键字定义接口。在一个java文件内，只能有一个public类或一个public接口，即public类和public接口不能同文件共存。接口没有构造器，没有实例域，也不能使用new操作符创建实例。接口没有构造器的原因有三点：<br>1.构造器用于初始化成员变量，接口没有成员变量，不需要构造器<br>2.类可以实现多个接口，如果多个接口都有构造方法，不好确定构造方法链的调用次序<br>3.作为高度抽象的概念，接口不能实例化对象，也就不需要构造器  </p><p>像常规类一样，每个接口都被编译为独立的字节码文件，可以作为引用变量的数据类型和类型转换的结果，可以使用instanceof关键字等。<br>类实现接口用implements关键字，一个类可以实现多个接口，用逗号隔开即可，<strong>一个类必须实现它实现接口的所有方法，否则要定义为抽象类。</strong>一个接口可以继承多个接口，用extends关键字，此时实现类需要重写接口继承链上所有接口的所有抽象方法。<strong>如果接口在继承在多个父接口时，父接口中出现了重名的默认方法冲突，就要在该接口中提供一个同名默认方法来解决冲突。</strong><br>在定义接口中的数据域和方法时可以简写，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>可简写成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">T</span></span>&#123;</div><div class="line"><span class="keyword">int</span> K = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要注意接口中所有的数据域都是public static final，所有的方法都是public abstract，在定义接口中允许省略修饰符，但在子类重写方法时不可缺省public修饰符，否则方法的可见性会缩小为包内可见。<br><strong>接口只能使用public修饰符或缺省访问控制修饰符。</strong><br><strong>如果在具体实现类中定义了和接口中常量同名的常量，那么用接口变量指向实现类引用时变量调用的常量仍然是接口中定义的常量。</strong></p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>从Java SE 8开始，允许在接口中增加静态方法，并给静态方法提供方法体实现，该静态方法只能通过<code>接口名.静态方法</code>来调用。实现语法只要在方法前面加static关键字即可，这理论上讲是可以的，但这有违于接口作为抽象规范的初衷。<strong>静态方法只能被具体实现类继承，不能在实现类中重写。</strong>  </p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>可以为接口方法提供一个默认方法体实现，在方法前加default修饰符即可，这样子类无需重写这个方法也能得到一个接口的默认实现。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样实现Collection的程序员就不用操心实现isEmpty方法了。<br><strong>当然，默认方法也可以被具体实现类重写。在实现类中调用默认方法要使用接口名.super.默认方法来调用。</strong><br>默认方法的一个重要用法是<strong>“接口演化”</strong>。以Collection接口为例，这个接口作为Java的一部分已经很多年了，假设很久以前定义了一个实现Collection接口的类Bag。后来在Collection接口中增加了一个stream方法，假设stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。如果不重新编译这个类，而是使用原先包含这个类的JAR文件，这个类仍能正常加载，正常构造实例，但如果在一个Bag实例上调用stream方法，会出现一个AbstractMethodError。<strong>但如果把stream方法定义为默认方法就可以解决这个问题，既可以重新编译也可以使用JAR文件加载类并调用stream方法。</strong>  </p><h3 id="解决默认方法的冲突"><a href="#解决默认方法的冲突" class="headerlink" title="解决默认方法的冲突"></a>解决默认方法的冲突</h3><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生冲突。解决冲突规则如下：<br>1) 超类和接口冲突。如果超类提供了一个具体方法，那么根据超类优先原则，同名而且有相同参数类型的默认方法会被忽略。<br>2) 多接口之间冲突。如果一个实现类实现了多个接口，一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，此时就发生了接口冲突，必须在实现类中重写这个方法来解决冲突。  </p><h3 id="解决重名常量的冲突"><a href="#解决重名常量的冲突" class="headerlink" title="解决重名常量的冲突"></a>解决重名常量的冲突</h3><p>1）超类和接口冲突。如果一个类继承了一个超类和实现了若干接口，此时不像默认方法冲突一样有超类优先原则。只能通过在实现类中覆盖该常量来解决冲突。<br>2）多接口之间冲突。如果一个类实现了多个接口，而这些接口又有重名常量，此时会发生冲突。必须用<code>接口名.常量</code>的方式来精确指明要使用的常量。</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>Comparable接口定义了compareTo方法，用于比较对象。当想使用Arrays类的sort方法对对象数组进行排序时，对象所属的类必须实现了Comparable接口。<br>Comparable接口是一个带泛型的接口，定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> compareTo应该与equals保持一致，即当且仅当o1.equals(o2)为true时，o1.compareTo(o2) == 0成立。以下是compareTo方法的实现：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> Double.compare(salary,other.salary);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> <strong>在比较浮点数时可以使用Double的静态方法compare,这样就不必担心溢出或精度损失，类似的还有Integer.compare方法等</strong><br> <strong>继承过程中的compareTo，如果由子类决定相等的概念，每个compare方法都应该在开始时检测：<code>if(getClass() != other.getClass()) throw new ClassCastException()</code></strong>：<strong>如果父类决定相等的概念，应该在超类中提供一个compareTo方法，并将这个方法声明为final。</strong>  </p><h3 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h3><p> Comparator接口意为”比较器”接口，是一个泛型接口，可用于自定义排序规则和大小比较等。要进行自定义排序，Arrays.sort方法有一个重载版本，需要提供一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。接口定义为：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T first,T second)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 如果要按长度比较字符串，由于String是按字典序比较字符串，肯定不能让String类用两种方法实现compareTo方法 —— 况且String类也不由我们修改。此时可以定义如下实现Comparator<string>的类：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">lengthComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String first,String second)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> first.length() - second.length();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p><p> 因为要调用compare方法，所以具体比较大小和排序时都要创建一个lengthComparator的实例：<br> <strong>大小比较</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> LengthComparator();</div><div class="line"><span class="keyword">if</span>(comp.compare(words[i],words[j]) &gt; <span class="number">0</span>) ...</div></pre></td></tr></table></figure></p><p> <strong>自定义排序</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] friends = &#123;<span class="string">"Peter"</span>,<span class="string">"Paul"</span>,<span class="string">"Mary"</span>&#125;;</div><div class="line">Arrays.sort(friends,<span class="keyword">new</span> LengthComparator());</div></pre></td></tr></table></figure></p><p> <strong>Comparable接口和Comparator接口都可以用于自定义排序。但前者只能在定义要比较的类的同时实现，比如自定义的类，使用sort的不带比较器的方法排序。后者则可用于类的定义时或类已经设计完成但还想进行排序，因为它的实现是在要比较的类之外的，比如对Java类库中的类进行排序，无法修改类的定义，只好在外部定义一个实现了Comparator的比较器，并使用sort带比较器的方法排序。</strong><br>下面对于一个学生类的两个关键字进行排序，先按分数从高到低排序，分数相同按年龄从小到大排序。<br><strong>方法一：实现Comparable接口</strong><br>重写的compareTo方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student stu)</span></span>&#123;    </div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.score&gt;stu.score)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.score &lt; stu.score)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.age&gt;stu.age)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.age &lt; stu.age)&#123;</div><div class="line">                <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">            &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p><strong>方法二：实现Comparator接口</strong><br>重写的compare方法为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student stu1,Student stu2)</span></span>&#123;    </div><div class="line">       <span class="keyword">if</span>(stu1.score&gt;stu2.score)&#123;</div><div class="line">           <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stu1.score&lt;stu2.score)&#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">       &#125;<span class="keyword">else</span>&#123;</div><div class="line">           <span class="keyword">if</span>(stu1.age&gt;stu2.age)&#123;</div><div class="line">               <span class="keyword">return</span> <span class="number">1</span> ;</div><div class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stu1.age&lt;stu2.age)&#123;</div><div class="line">               <span class="keyword">return</span> -<span class="number">1</span> ;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">           &#125;</div><div class="line">       &#125;    </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p><strong>自定义排序总结：</strong>无论是重写compare方法还是compareTo方法，对大于、小于、等于三种情况都要有返回值，否则无法通过编译。在compareTo方法中，规定 this.xxx &gt; o.xxx 返回 1,this.xxx == o.xxx 返回0,this.xxx &lt; o.xxx 返回-1是升序排列，反之就是降序排列。在compare方法中,规定o1.xxx &gt; o2.xxx返回1,o1.xxx == o2.xxx返回0,o1.xxx &lt; o2.xxx返回 -1是升序排列，反之就是降序排列。<br>技巧：如果要比较的属性也实现了Comparable接口，就可以调用它的compareTo方法。如果要降序排列，就交换compareTo的参数顺序即可。如果要比较的类是基本数据类型，可以返回差值，如果差值不是int类型，就转换为int类型。</p><h3 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h3><p> 首先，我们考虑为一个包含对象引用的变量建立副本会发生什么，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Employee original = <span class="keyword">new</span> Employee(<span class="string">"John Public"</span>,<span class="number">50000</span>);</div><div class="line">Employee copy = original;</div><div class="line">copy.ratseSalary(<span class="number">10</span>); <span class="comment">//original的salary也被改变</span></div></pre></td></tr></table></figure></p><p> 原变量和副本都会指向同一个对象，这说明，任何一个变量的改变都会影响到另一个变量。如果有一个对象original，希望创建一个对象copy使得其初始状态与original相同，但是之后它们各自回有自己不同的状态，这种情况下就可以使用克隆，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee copy = original.clone();</div><div class="line">copy.raiseSalary(<span class="number">10</span>); <span class="comment">//original的salary不会被改变</span></div></pre></td></tr></table></figure></p><p>Object类中的clone方法将原始对象的每个数据域复制给目标对象，如果一个数据域是基本数据类型，复制的就是它的值，如果是引用类型，复制的就是它的引用，这种克隆称为<strong>浅复制</strong>,即original != copy,但original.hireDay == copy.hireDay。这有时是不符合我们要求的，我们不希望在改变某个对象的引用类型的数据域时影响到另一个对象，这时我们需要<strong>深复制</strong>,即如果数据域是引用类型，复制的是对象的内容而不是引用。<br>无论是<strong>浅复制</strong>还是<strong>深复制</strong>，我们都需要先实现Cloneable接口，否则会产生一个必检异常。Cloneable接口的定义是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们发现这个接口是空的，一个带空体的接口称为标记接口。一个标记接口既不包括常量也不包括方法，它用来表示一个类拥有的某些特定的属性，其惟一的作用是允许在类型查询中使用instanceof关键字。但如果一个请求克隆的对象不实现这个接口，会产生CloneNotSupportedException，即使clone的默认(浅拷贝)实现能够满足要求，还是要实现这一接口。在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone方法，这个方法是从Object类继承的，这个接口只是作为一个标记。  </p><p>Object类中提供的原始clone方法的方法头是<code>protected native Object clone() throws CloneNotSupportedException</code>,关键字native表明这个方法不是用Java写的，但它是JVM针对自身平台实现的。关键字protected限定方法只能在同一个包内或在其子类中访问。由于这个原因：<strong>必须在要实现克隆的子类中覆盖这个方法并把可见性修饰父改为public</strong>。<br>下面给出一个浅复制的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> (Employee) <span class="keyword">super</span>.clone();</div><div class="line">    &#125;</div><div class="line">    . . .</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出一个深复制的例子：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">     . . .</div><div class="line">     Employee cloned = (Employee) <span class="keyword">super</span>.clone;</div><div class="line">     cloned.hireDay = (Date)hireDay.clone();</div><div class="line">     <span class="keyword">return</span> cloned;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们注意到Object类的clone方法的返回值类型是Object，而Employee类的clone方法返回值类型是Employee，这叫做协变返回类型，即<strong>子类在重写父类方法时可以返回父类返回值类型的子类型</strong>。clone方法声明异常也可以改成捕获异常，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">try</span></div><div class="line">&#123;</div><div class="line">Employee cloned = (Employee) <span class="keyword">super</span>.clone();</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(CloneNotSupportedException e)&#123; <span class="keyword">return</span> <span class="keyword">null</span>;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="复制数组的四种方法"><a href="#复制数组的四种方法" class="headerlink" title="复制数组的四种方法"></a>复制数组的四种方法</h3><p>1.申请一个新数组，遍历原数组逐一复制元素<br>2.使用System类的静态方法arraycopy<br>3.使用<code>数组对象.clone</code>返回一个数组克隆的引用<br>4.使用Arrays类的copyOf方法  </p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>区别：<br>1.接口所有的变量必须是public static final;抽象类的变量无限制<br>2.接口没有构造方法，不能用new操作符实例化;抽象类有构造方法，由子类通过构造方法链调用，不能用new操作符实例化<br>3.接口所有方法必须是公共抽象实例方法(Java SE 8开始允许定义静态方法)，抽象类无限制<br>4.一个类只可以继承一个父类，但可以实现多个接口<br>5.所有的类有一个共同的根Object类，接口没有共同的根<br>6.抽象类和子类的关系应该是强的“是一种”关系(strong is-a relationship),而接口和子类的关系是弱的”是一种”关系(weak is-a relationship)。接口比抽象类更灵活，因为实现接口的子类只需要具有统一的行为即可，不需要都属于同一个类型的类。</p><h3 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h3><p> 回调是一种常见的程序设计模式。回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。<br> 见博客：<a href="https://www.cnblogs.com/heshuchao/p/5376298.html" target="_blank" rel="external">Java回调机制(CallBack)详解</a></p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p> 内部类，或者称为嵌套类，是一个定义在另一个类范围中的类。一个内部类可以如常规类一样使用。通常，在一个类只被它的外部类所使用的时候，才将它定义为内部类，内部类机制主要用于设计具有互相协作关系的类集合。比如：  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//OuterClass.java: inner class demo</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line">   <span class="comment">/** A method in the outer class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="comment">//Do something</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// An inner class</span></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</div><div class="line">   <span class="comment">/** A method in the inner class */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mi</span><span class="params">()</span></span>&#123;</div><div class="line">   data++;</div><div class="line">       m();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p> 为什么要使用内部类，主要原因有三：<br> 1.内部类可以访问包含它的外部类的所有数据域(包括私有数据域)和方法，没有必要将外部类对象的引用传递给内部类的构造方法,内部类有一个指向外部类对象的隐式引用，如果显式写出，外部类的引用是OuterClass.this<br> 2.内部类可以对同一个包中的其他类隐藏起来<br> 3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷  </p><p> 内部类具有一下特征：<br> 1) 一个成员内部类被编译成一个名为<code>OuterClassName$InnerClassName</code>的类。例如，一个定义在Test类中的成员内部类A被编译成<code>Test$A.class</code><br> 2) 一个内部类可以使用可见性修饰符(public、private、protected、default)所定义，和应用于一个类中成员的可见性规则一样<br> 3) 一个内部类可以被定义为static，一个static的内部类可以使用外部类的名字访问,一个static内部类不能访问外部类中的非静态成员<br> 4) 内部类对象通常在外部类中创建，但是你也可以从另外一个类中来创建一个内部类的对象。如果内部类是非静态的，你必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类对象：<code>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</code> 如果内部类是静态的，使用下面语法来创建一个内部类对象:<code>OuterClass.InnerClass innerObject = new OuterClass.InnerClass();</code>。<br> 一般建议在外部类中定义一个用于获取内部类对象的方法，以便于从外部类外获取内部类对象，比如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 5) 内部类所有的静态域必须是final修饰的<strong>静态常量</strong>,不能有静态变量，也不能有静态方法</p><p> 一个简单的内部类的用途是将相互依赖的类结合到一个主类中，这样做减少了源文件的数量(因为非内部类如果用public修饰必须放在不同的源文件中，而内部类可放在同一源文件中)，这样也使得类文件容易组织，因为它们都将主类名作为前缀。另外一个内部类的实际用途是避免类名冲突。  </p><p> 内部类对于定义处理器类非常有用，一个处理器类被设计为针对一个GUI组件创建一个处理器对象(比如，一个按钮)。处理器类不会被其他应用所共享，所以将它定义在主类里面作为一个内部类使用是恰如其分的。  </p><p>广泛意义上的内部类一般来说包括四种：<strong>成员内部类</strong>、<strong>局部内部类</strong>、<strong>匿名内部类</strong>和<strong>静态内部类</strong>。下面就先来了解一下这四种内部类的用法。  </p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p> 　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></div><div class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>  这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员），但外部类想要访问内部类的成员属性和方法时必须先实例化内部类对象。<br>  　不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<code>外部类.this.成员变量 外部类.this.成员方法</code></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p> 可以把内部类定义在一个方法中，称为局部内部类，也叫方法内部类。<strong>局部内部类就像是方法里面的一个局部变量一样，不能有public、protected、private以及static修饰符。它的作用域被限定在声明这个局部类的块中。</strong>局部类有一个优势，即对外部世界完全隐藏起来。即使外部类中的其他代码也不能访问它。除了其所在的方法之外，没有任何方法知道该局部类的存在。<strong>局部内部类只能访问被final修饰的局部变量。</strong><br> 局部内部类被编译器编译成一个<code>OuterClassName$1InnerClassName</code>的类。序号逐渐递增。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></div><div class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 注意：上述代码中通过调用getWoman()获取了局部内部类Woman的引用，不能通过<code>局部内部类引用.属性</code>的方式来直接访问局部内部类的成员，所以我们一般会在该方法中直接调用局部内部类的方法进行某种操作，然后返回操作结果。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p> 有时我们在程序中对一个类只使用一次，此时就可以把类的定义和实例化对象整合在一起，来简化对于抽象类和接口实现的操作，这就是<strong>匿名内部类</strong>。<br> 一个匿名内部类是一个没有名字的内部类，其语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> SuperClassName/InterfaceName()&#123;</div><div class="line"><span class="comment">//implement or override methods in superclass or interface</span></div><div class="line">   </div><div class="line">    <span class="comment">//Other methods if necessary</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p> 其含义是<strong>创建一个继承自SuperClass或实现Interface的类的实例，并在类块内重写父类或接口的抽象方法</strong>，应该将匿名内部类理解成<strong>一个匿名子类的匿名对象</strong>,而不是理解成一个类。  </p><p> 匿名内部类有如下特征：<br> 1.没有可见性修饰符<br> 2.没有构造方法(因为没有名字,无法命名构造方法),但可以有构造代码块，也可以调用父类的构造方法，即<code>new SuperClassName()</code>调用父类无参构造方法，<code>new SuperClassName(args1,...)</code>调用父类有参构造方法。如果实现的是接口，则不能有任何参数，但是小括号仍然不可缺省<br> 3.必须总是从一个父类继承或者实现一个接口，但是它不能有显式的extends或者implements子句<br> 4.必须实现父类或接口中的所有抽象方法<br> 5.一个匿名内部类被编译成一个名为OuterClassName$n.class的类，例如：如果外部类Test有两个匿名内部类，分别被编译成Test$1.class和Test$2.class  </p><p> <strong>应用一</strong><br> 下面的技巧称为<strong>“双括号初始化”</strong>，这里利用了内部类语法。假设你想构造一个数组列表，并将它传递到一个方法。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; friends = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">friends.add(<span class="string">"Harry"</span>);</div><div class="line">friends.add(<span class="string">"Tony"</span>);</div><div class="line">invite(friends);</div></pre></td></tr></table></figure></p><p> 如果不再需要这个数组列表，最好让它作为一个匿名列表。语法如下：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> invite(<span class="keyword">new</span> ArrayList&lt;String&gt; </div><div class="line"> &#123;</div><div class="line"> &#123;</div><div class="line">    add(<span class="string">"Harry"</span>);</div><div class="line">        add(<span class="string">"Tony"</span>);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p> 注意这里的双括号，外括号建立了一个ArrayList的匿名子表，内括号则是一个对象构造块。  </p><p> <strong>应用二</strong><br> 生成日志或调试消息时，通常希望包含当前类的类名，如：<br> <code>System.err.println(&quot;Something awful happened in &quot; + getClass());</code><br> 不过这对于静态方法并不凑效，因为调用getClass()调用的是this.getClass(),但静态方法里没有this，所以应该使用下面的表达式：<code>new Object(){}.getClass().getEnclosingClass()</code>,在这里，new Object(){} 会建立Object的一个匿名子类的匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类 </p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p> 有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象。为此，可以为内部类加上static关键字声明为静态内部类，以便取消产生的引用。<strong>静态内部类中的方法不能直接调用外部类的非静态成员属性和访问非静态方法，如果要调用和访问，必须实例化外部类对象。当静态内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是静态内部类的成员。如果要访问外部类的非静态同名成员，不能再使用<code>外部类.this.成员</code>的形式，而是要实例化外部类对象。如果要访问外部类的静态同名成员，可以通过<code>外部类.成员</code>的方式来访问。</strong>与常规内部类不同，静态内部类可以有<strong>静态变量</strong>和<strong>静态方法</strong>。可以通过<code>外部类.内部类.静态成员</code>方式来访问。<br> 下面是一个使用静态内部类的典型例子。考虑一下计算一个数组中最大值和最小值的问题，当然，可以编写两个方法，一个计算最大值，一个计算最小值，在调用这两个方法的时候，数组被遍历两次，而如果数组只被遍历一次就可以计算出最大值和最小值，那么效率就大大提高了。通过一个方法就计算出最大值和最小值：这个方法需要返回两个数（max 和 min），为此可以定义一个Pair类来封装这种数据结构，但是Pair是个非常大众的名字，可能在其他地方定义过，会发生名字冲突，此时可以将Pair定义为ArrayAlg类的内部类ArrayAlg.Pair。又因为Pair没有必要访问外围类ArrayAlg的数据域或方法，应该定义为静态内部类。<br> 下面给出代码：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</div><div class="line">    <span class="comment">//Pair类，起数据封装的作用</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> s)</span></span>&#123;</div><div class="line">            first = f;</div><div class="line">            second = s;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFirst</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSecond</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> second;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">maxmin</span><span class="params">(<span class="keyword">double</span>[] values)</span></span>&#123;</div><div class="line">        <span class="keyword">double</span> min = Double.POSITIVE_INFNITY;</div><div class="line">        <span class="keyword">double</span> max = Double.NEGATIVE_INFNITY;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> x : values)&#123;</div><div class="line">            <span class="keyword">if</span>(x&lt;min) min = x;</div><div class="line">            <span class="keyword">if</span>(x&gt;max) max = x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(max,min);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Test te = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">double</span>[] teArgs = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">2.13</span>,<span class="number">100.0</span>,<span class="number">11.2</span>,<span class="number">34.5</span>,<span class="number">67.1</span>,<span class="number">88.9</span>&#125;;</div><div class="line">        Pair res = te.maxmin(teArgs);</div><div class="line">        System.out.println(<span class="string">"max = "</span>+res.getFirst());</div><div class="line">        System.out.println(<span class="string">"min = "</span>+res.getSecond());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 特别注意：代码中的Pair类如果没有声明为static，就不能在静态方法minmax中构造Pair的实例，编译器会给出错误报告：没有可用的隐式ArrayAlg类型对象初始化内部类对象  </p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p> lambda表达式可以被看作使用精简语法的匿名内部类，编译器对待一个lambda表达式如同它是从一个匿名内部类创建的对象。它是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda表达式，可以用一种精简的方式表示使用回调或变量行为的代码。如果要编译器理解lambda表达式，其代替的匿名内部类实现的接口必须只包含一个抽象方法，这样的接口被称为函数式接口(功能接口、单抽象方法接口）。在底层，接受lambda表达式的方法会接受实现某函数式接口的类的对象，并在这个对象上调用接口的方法，所以可以把lambda表达式赋给函数式接口(lambda表达式实际是一个实现了该函数式接口的类的类型，这里用到了多态)，不能把lambda表达式赋给Object变量，因为Object不是一个函数式接口。<br> 一个lambda表达式就是一个代码块，以及必须传入代码的变量规范。其基础语法是(expression只有一条语句，不用花括号，也不用分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; expression</div></pre></td></tr></table></figure></p><p> 或者(statements是多条语句，要花括号，每条语句之后要分号结尾)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(type1 param1, type2 param2, ...) -&gt; &#123;statements;&#125;</div></pre></td></tr></table></figure></p><p> 一个参数的数据类型既可以显式声明，也可以由编译器隐式推断。如果只有一个参数，并且没有显式的数据类型，圆括号可以被省略。如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">e -&gt; &#123;</div><div class="line"><span class="comment">// Code for processing event e</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 即使lambda表达式没有参数，也要提供空括号，就像无参数方法一样：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span>;i &gt;=<span class="number">0</span> ;i--) System.out.println(i);&#125;</div></pre></td></tr></table></figure></p><p>  无需指定lambda表达式的返回类型，编译器会由上下文推断，例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(String first,String second) -&gt; first.length() - second.length()</div></pre></td></tr></table></figure></p><p> 可以在需要int类型结果的上下文中使用  </p><p> 如果一个lambda表达式只在某些分支上返回一个值，而在另外一些分支不返回值，是不合法的。例如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> x) -&gt; &#123;<span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</div></pre></td></tr></table></figure></p><p> Comparator接口是一个函数式接口，可以用lambda表达式实现自定义排序的简化：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(words,(first,second) </div><div class="line">-&gt; first.length() - second.length());</div></pre></td></tr></table></figure></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p> 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口。<br> 如果自己设计了一个函数式接口，可以用@FunctionalInterface注解来标记这个接口，这样做有两个好处：<br> 1.可以在你无意中增加一个非抽象方法时产生编译错误<br> 2.javadoc页里会指出你的接口是一个函数式接口</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p> 有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如，假设你希望只要出现一个定时器事件就打印这个事件对象，可以调用：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,event -&gt; System.out.println(event));</div></pre></td></tr></table></figure></p><p> 可以直接把println方法传递到Timer的构造器：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</div></pre></td></tr></table></figure></p><p> 表达式System.out::println是一个方法引用，它等价于lambda表达式<code>x -&gt; System.out.println(x)</code><br> 我们再看一个例子，假设要对字符串排序，而不考虑字母的大小写，可以调用<code>Arrays.sort(strings,String::compareToIgnoreCase);</code></p><p> 方法引用主要有三种情况：  </p><ul><li>object::instanceMethod</li><li>Class::staticMethod  </li><li>Class::instanceMethod    </li></ul><p>对于前两种情况，方法引用等价于提供方法参数的lambda表达式。比如：System.out::println等价于x -&gt; System.out.println(x)，Math::pow等价于(x,y) -&gt; Math.pow(x,y)。第三种情况的第一个参数会称成为调用方法的目标对象，其余参数成为方法参数，比如：String::compareToIgnoreCase等价于(x,y) -&gt; x.compareToIgnoreCase(y)<br>可以在方法里使用this和super,this::equals等同于x -&gt; this.equals(x),super::greet等同于() -&gt; super.greet()  </p><p>类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。  </p><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用与方法引用类似，只不过方法名为new。例如<code>Employee::new</code>是Employee构造器的一个引用。至于是哪一个构造器取决于上下文，比如<code>Function&lt;Integer,Employee&gt; func1 = Employee :: new;</code>就相当于<code>Function&lt;Integer,Employee&gt; func = x -&gt; new Employee(x);</code><br>数组类型也有构造器引用，如<code>int[]::new</code>等价于lambda表达式<code>x -&gt; new int[x]</code>  </p><h3 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h3><p>我们之前提到，lambda表达式的重点是<strong>延迟执行</strong>，之所以希望以后再执行代码，有很多原因，如：  </p><ul><li>在一个单独的线程中运行代码  </li><li>多次运行代码  </li><li>在算法的恰当位置运行代码(例如，排序中的比较操作)  </li><li>发生某种情况时执行代码(如，点击了一个按钮、数据到达等) </li><li>只在必要时才运行代码  </li></ul><p>下面是常用的函数式接口和基本类型的函数式接口：  </p><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/1.png" alt="fail" title="常用函数式接口">  </p><p><img src="/2017/10/16/Java学习总结之抽象类、接口、lambda表达式与内部类/2.png" alt="fail" title="基本类型的函数式接口"></p><p>下面来看一个简单的例子。假设你想要重复一个动作n次。将这个动作和重复次数传递给一个repeat方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,() -&gt; System.out.println(<span class="string">"Hello world"</span>));</div></pre></td></tr></table></figure></p><p>要接受这个lambda表达式，需要选择一个函数式接口。在这里，我们可以使用Runnable接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,Runnable action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) </div><div class="line">    action.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>现在让这个例子更复杂一点，我们希望告诉这个动作它出现在那一次迭代中。为此需要选择一个合适的函数式接口，其中要包含一个方法。这个方法有一个int参数而且返回类型为void。处理int值的标准接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntConsumer</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面给出repeat方法的改进版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> n,IntConsumer action)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)  action.accept(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以如下调用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">repeat(<span class="number">10</span>,i -&gt; System.out.println(<span class="string">"Countdown: "</span> + (<span class="number">9</span> - i)));</div></pre></td></tr></table></figure></p><p>大多数函数标准函数式接口都提供了非抽象方法来生成或合并函数。例如,Predicate.isEqual(a)等同于a::equals,不过如果a为null也能正常工作。已经提供了默认方法and、or和negate来合并谓词。例如,<code>Predicate.isEqual(a).or(Predicate.isEqual(b))</code>就等同于<code>x -&gt; a.equals(x) || b.equals(x)</code></p><h3 id="通过三种方式实现事件处理器"><a href="#通过三种方式实现事件处理器" class="headerlink" title="通过三种方式实现事件处理器"></a>通过三种方式实现事件处理器</h3><h4 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleEvent</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">HBox pane = <span class="keyword">new</span> HBox(<span class="number">10</span>);</div><div class="line">pane.setAlignment(Pos.CENTER);</div><div class="line">Button btOK = <span class="keyword">new</span> Button(<span class="string">"OK"</span>);</div><div class="line">OKHandlerClass handler1 = <span class="keyword">new</span> OKHandlerClass();</div><div class="line">btOK.setOnAction(handler1);</div><div class="line">Button btCancel = <span class="keyword">new</span> Button(<span class="string">"Cancel"</span>);</div><div class="line">CancelHandlerClass handler2 = <span class="keyword">new</span> CancelHandlerClass();</div><div class="line">btCancel.setOnAction(handler2);</div><div class="line">pane.getChildren().addAll(btOK,btCancel);</div><div class="line"></div><div class="line">Scene scene = <span class="keyword">new</span> Scene(pane,<span class="number">100</span>,<span class="number">50</span>);</div><div class="line">primaryStage.setTitle(<span class="string">"HandleEvent"</span>);</div><div class="line">primaryStage.setScene(scene);</div><div class="line">primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OKHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"OK button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelHandlerClass</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ActionEvent</span>&gt;</span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"Cancel button clicked"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="2-匿名内部类"><a href="#2-匿名内部类" class="headerlink" title="2.匿名内部类"></a>2.匿名内部类</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process New"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Open"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Save"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Process Print"</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"AnonymousHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3.lambda表达式"></a>3.lambda表达式</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">import</span> javafx.application.Application;</div><div class="line"><span class="keyword">import</span> javafx.event.ActionEvent;</div><div class="line"><span class="keyword">import</span> javafx.event.EventHandler;</div><div class="line"><span class="keyword">import</span> javafx.geometry.Pos;</div><div class="line"><span class="keyword">import</span> javafx.scene.Scene;</div><div class="line"><span class="keyword">import</span> javafx.scene.control.Button;</div><div class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;</div><div class="line"><span class="keyword">import</span> javafx.stage.Stage;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaHandlerDemo</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    HBox hBox = <span class="keyword">new</span> HBox();</div><div class="line">    hBox.setSpacing(<span class="number">10</span>);</div><div class="line">    hBox.setAlignment(Pos.CENTER);</div><div class="line">    Button btNew = <span class="keyword">new</span> Button(<span class="string">"New"</span>);</div><div class="line">    Button btOpen = <span class="keyword">new</span> Button(<span class="string">"Open"</span>);</div><div class="line">    Button btSave= <span class="keyword">new</span> Button(<span class="string">"Save"</span>);</div><div class="line">    Button btPrint = <span class="keyword">new</span> Button(<span class="string">"Print"</span>);</div><div class="line">    hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint);</div><div class="line">    </div><div class="line">    btNew.setOnAction((ActionEvent e)-&gt;&#123;System.out.println(<span class="string">"Process New"</span>);&#125;);</div><div class="line">    </div><div class="line">    btOpen.setOnAction((e)-&gt;&#123;System.out.println(<span class="string">"Process Open"</span>);&#125;);</div><div class="line">    </div><div class="line">    btSave.setOnAction(e-&gt;&#123;System.out.println(<span class="string">"Process Save"</span>);&#125;);</div><div class="line">    </div><div class="line">    btPrint.setOnAction(e-&gt;System.out.println(<span class="string">"Process Print"</span>));</div><div class="line">    </div><div class="line">    Scene scene = <span class="keyword">new</span> Scene(hBox,<span class="number">300</span>,<span class="number">50</span>);</div><div class="line">    primaryStage.setTitle(<span class="string">"LambdaHandlerDemo"</span>);</div><div class="line">    primaryStage.setScene(scene);</div><div class="line">    primaryStage.show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Application.launch(args);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之反射</title>
    <link href="http://habitdiary.cn/2017/10/14/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
    <id>http://habitdiary.cn/2017/10/14/Java学习总结之反射/</id>
    <published>2017-10-14T06:32:15.000Z</published>
    <updated>2018-03-10T12:52:08.722Z</updated>
    
    <content type="html"><![CDATA[<p>　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  </p><h3 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1.什么是反射？"></a>1.什么是反射？</h3><p>　　<strong>反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制，在编写一些通用性较高的代码或者框架的时候使用。</strong>也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。<br>　　要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><h3 id="2-反射的作用"><a href="#2-反射的作用" class="headerlink" title="2.反射的作用"></a>2.反射的作用</h3><p>　　1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制<br>　　2.在运行时分析对象的数据域<br>　　3.实现通用的数组操作代码<br>　　4.利用Method对象，这个对象很像C++中的函数指针  </p><h3 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h3><p>　　我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。<strong>Class 类的实例表示正在运行的 Java 应用程序中的类或接口。</strong>在 Java 中，每个 Class 都有一个相应的 Class 对象，即对于每一个类，.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，用于表示这个类的类型信息，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是<code>java.lang.Class</code>类的一个实例，从中我们可以得出结论：万物皆对象，<code>任何类型(包括基本类型，引用类型，void关键字等).class</code>都是<code>java.lang.Class</code>的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于<code>java.lang.Class</code>类不存在公有构造器，它在每个类第一次被加载时由JVM自动调用，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。<br>　　在下面的讲解中，我们将以People类和Student类为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(getName() + <span class="string">" "</span> + getAge());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name, age);</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> grade;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.grade = grade;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">(String course)</span> </span>&#123;</div><div class="line">        System.out.println(name + <span class="string">" learn "</span> + course);</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h4 id="获取class对象有以下三种"><a href="#获取class对象有以下三种" class="headerlink" title="获取class对象有以下三种:"></a>获取class对象有以下三种:</h4><p> 1) 可以通过<code>类名.class</code>得到相应类的Class对象，如:   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class peopleClass = People.class;</div></pre></td></tr></table></figure><p>2) 如果已知类的<strong>全限定名称(包含包名)</strong>，可以通过Class的forName静态方法得到类的Class对象，如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class peopleClass = Class.forName(<span class="string">"cn.habitdiary.People"</span>);</div><div class="line"><span class="comment">//假设People类在cn.habitdiary包中</span></div></pre></td></tr></table></figure><p>　　在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">String name = <span class="string">"xxx"</span>;</div><div class="line">    Class c1 = Class.forName(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>3) 可以通过<code>类的实例对象.getClass()</code>得到相应类的Class对象，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People people = <span class="keyword">new</span> People(<span class="string">"Steven"</span>， <span class="number">20</span>);</div><div class="line">Class peopleClass = people.getClass();</div></pre></td></tr></table></figure><p>　　<code>实例对象.getClass().getName()</code> 可以获取当前对象的类的全限定名称(包含包名)<br>　　<code>实例对象.getClass().getSimpleName()</code>可以获取当前对象的类的底层类简称(不含包名)<br>　　<code>实例对象.getClass().getCanonicalName()</code>大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。<br>　　但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName()  </p><p><strong>对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的 Class 实例</strong>   </p><p><strong>三种方式的比较：</strong><br>1.调用<code>Class.forName()</code>方法，如果类没有加载就加载，加载时执行static语句，找不到就抛出异常，也可以理解为手动加载类的一种方法，它会自动初始化Class对象。  </p><p>2.<code>getClass()</code>方法，在已经持有该类的对象时来获取Class引用。其Class对象已经被初始化。  </p><p>3.<code>.class</code>方式创建Class对象引用时，不会自动初始化Class对象。主要进行下面的步骤：<br>1)加载，类加载器查找字节码（classpath）创建Class对象；<br>2)链接，为静态域分配存储空间；<br>3)初始化，其被延迟到静态方法或非常数静态域首次引用时。  </p><p><strong>总结：</strong>Java获得Class对象的引用的方法中，<code>Class.forName()</code>方法会自动初始化Class对象，而<code>.class</code>方法不会，<code>.class</code>的初始化被延迟到静态方法或非常数静态域的首次引用。</p><p><strong>注意：</strong><br>　　1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象。<br>　　2.Class类实际上是一个泛型类。  <code>Class c = T.class</code>实际上是<code>Class&lt;T&gt; c = T.class</code>。<code>Class c = x.getClass()</code>实际上是<code>Class&lt;? extends T&gt; c = x.getClass()</code>(T的x的声明类型，x.getClass()获得的是x的实际类型的Class对象)。但有时候我们不能提前确定class对象的类型,如<code>Class c = Class.forName(&quot;T&quot;)</code>实际上是<code>Class&lt;?&gt; c = Class.forName(&quot;T&quot;)</code>。<br>　　3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作，这可以用来判断两个对象属不属于同一个类。<br>　　4.getClass()方法返回的是对象实际类型的class对象，而不是声明类型的class对象。<br>　　5.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，<strong>前提要有无参的构造方法，newInstance()方法是通过调用无参构造方法来创建对象的</strong>。比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s = <span class="string">"java.util.Random"</span>;</div><div class="line">Object m = Class.forName(s).newInstance();</div></pre></td></tr></table></figure><p>　　<strong>如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。</strong>   </p><p><strong>类的静态加载和动态加载</strong><br><strong>静态加载：</strong>在编译时就需要加载所有可能用到的类，比如new关键字就是静态加载类。<br><strong>动态加载：</strong>在运行时加载类。<br>静态加载类的缺点是：比如用new创建了多个类的对象，其中某一个类不存在，则整个程序无法通过编译。而如果动态加载类，只要不使用不存在的类，其他类还可以正常使用。 </p><p>比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    <span class="comment">//静态加载类</span></div><div class="line">    <span class="keyword">if</span>(<span class="string">"Word"</span>.equals(args[<span class="number">0</span>]))&#123;</div><div class="line">        Word w = <span class="keyword">new</span> Word();</div><div class="line">            w.start();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span>(<span class="string">"Excel"</span>.equals(args[<span class="number">0</span>])&#123;</div><div class="line">         Excel e = <span class="keyword">new</span> Excel();</div><div class="line">            e.start();</div><div class="line">         &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>上面的程序通过new关键字创建对象，是静态加载类，所以如果Word类和Excel类中缺少一个，另一个类即使存在也无法通过编译。  </p><p>如果通过反射动态加载类可以解决这个问题，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficeBetter</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="comment">//动态加载类,在运行时刻加载</span></div><div class="line">        Class c = Class.forName(args[<span class="number">0</span>]);</div><div class="line">            <span class="comment">/*通过类类型,创建该类的对象,此时需要强制转换为Excel和Word的公有类型，</span></div><div class="line"><span class="comment">            所以可以定义OfficeAble接口，让Excel和Word实现这个接口*/</span></div><div class="line">            OfficeAble oa = (OfficeAble)c.newInstance();</div><div class="line">            oa.start();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>由于是动态加载类，新增其他实现OfficeAble接口的类不必重新编译OfficeBetter类。</p><h3 id="4-在运行时分析类的能力"><a href="#4-在运行时分析类的能力" class="headerlink" title="4.在运行时分析类的能力"></a>4.在运行时分析类的能力</h3><p>　　下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。<br>Java中为了支持反射机制主要提供了以下的类：<br>java.lang.Class<br>java.lang.reflect.Field<br>java.lang.reflect.Constructor<br>java.lang.reflect.Method<br>java.lang.reflect.Modifier  </p><p><img src="/2017/10/14/Java学习总结之反射/图解.png" alt="fail"></p><p><strong>java.lang.Class类的常用API如下：</strong>  </p><ul><li>Field[] getFields()   </li><li>Field[] getDeclaredFields()   </li><li>Method[] getMethods()  </li><li>Method[] getDeclaredMethods()      </li><li>Constructor&lt; ? &gt;[] getConstructors()  </li><li>Constructor&lt; ? &gt;[] getDeclaredConstructors() </li><li>Class&lt; ? &gt; getSupperClass() </li><li>Class&lt; ? &gt;[] getInterfaces()</li></ul><p><strong>提示：</strong>getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，不论访问权限，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象</p><p><strong>其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。<br>这三个类的常用API如下：</strong>  </p><ul><li>String getName() 返回一个用于描述域名、构造器或方法的字符串  </li><li>Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象  </li><li>Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)<br>返回一个用于描述方法抛出异常类型的Class对象数组  </li><li>int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值  </li><li>Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组  </li><li>Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象  </li></ul><p><strong>java.lang.reflect.Modifier类的常用API如下</strong>  </p><ul><li>static String toString(int modifiers)<br>返回修饰符对应的字符串描述</li><li>static boolean isAbstract(int modifiers)  </li><li>static boolean isFinal(int modifiers)</li><li>static boolean isInterface(int modifiers)</li><li>static boolean isNative(int modifiers)</li><li>static boolean isPrivate(int modifiers)</li><li>static boolean isProtected(int modifiers)</li><li>static boolean isPublic(int modifiers)</li><li>static boolean isStatic(int modifiers)</li><li>static boolean isStrict(int modifiers)</li><li>static boolean isSynchronized(int modifiers)</li><li>static boolean isVolatile(int modifiers)<br>上述方法检测修饰符是否是某一特定修饰符<br>java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义   </li></ul><p><strong>下面是一个检测类内部结构的例子</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">import</span> java.lang.Class;</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">String name;</div><div class="line"><span class="keyword">if</span>(args.length &gt; <span class="number">0</span>) </div><div class="line">name = args[<span class="number">0</span>];</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">System.out.println(<span class="string">"Enter class name (e.g. java.util.Date)"</span>);</div><div class="line">name = in.next();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Class&lt;?&gt; c1 = Class.forName(name);</div><div class="line">Class&lt;?&gt; superc1 = c1.getSuperclass();</div><div class="line">String modifiers = Modifier.toString(c1.getModifiers());</div><div class="line"><span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) </div><div class="line">System.out.print(modifiers + <span class="string">" "</span> );</div><div class="line">System.out.print(<span class="string">"class "</span> + name);</div><div class="line"><span class="keyword">if</span>(superc1 != <span class="keyword">null</span> &amp;&amp; superc1 != Object.class)</div><div class="line">System.out.print(<span class="string">"  extends "</span>  +  superc1.getSimpleName());</div><div class="line">System.out.print(<span class="string">"\n&#123;\n"</span>);</div><div class="line">printFields(c1);</div><div class="line">System.out.println();</div><div class="line">printConstructors(c1);</div><div class="line">System.out.println();</div><div class="line">printMethods(c1);</div><div class="line">System.out.println(<span class="string">"&#125;"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(ClassNotFoundException e)</div><div class="line">&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.exit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class&lt;?&gt; c1)</span> </span>&#123;</div><div class="line">Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Constructor&lt;?&gt; c : constructors) &#123;</div><div class="line">String name = c.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(c.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = c.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class&lt;?&gt; c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Method[] methods = c1.getDeclaredMethods();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Method m :methods) &#123;</div><div class="line">Class&lt;?&gt; retType = m.getReturnType();</div><div class="line">String name = m.getName();</div><div class="line"></div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(m.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">" "</span>);</div><div class="line">System.out.print(retType.getSimpleName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</div><div class="line">Class&lt;?&gt;[] paramTypes = m.getParameterTypes();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; paramTypes.length;j++) &#123;</div><div class="line"><span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">System.out.print(<span class="string">", "</span>);</div><div class="line">System.out.print(paramTypes[j].getSimpleName());</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">");"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class&lt;?&gt;  c1)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">Field[] Fields = c1.getDeclaredFields();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(Field f : Fields) &#123;</div><div class="line">Class&lt;?&gt; type = f.getType();</div><div class="line">String name = f.getName();</div><div class="line">System.out.print(<span class="string">"     "</span>);</div><div class="line">String modifiers = Modifier.toString(f.getModifiers());</div><div class="line"><span class="keyword">if</span>(modifiers.length() &gt; <span class="number">0</span>)</div><div class="line">System.out.print(modifiers + <span class="string">"  "</span>);</div><div class="line">System.out.println(type.getSimpleName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5-在运行时使用反射分析对象"><a href="#5-在运行时使用反射分析对象" class="headerlink" title="5.在运行时使用反射分析对象"></a>5.在运行时使用反射分析对象</h3><p>　　反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。<br>　　查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Employee harry = <span class="keyword">new</span> Empolyee(<span class="string">"Harry Hacker"</span>,<span class="number">35000</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">1989</span>);</div><div class="line">Class&lt;Employee&gt; c1 = harry.getClass();</div><div class="line">Field f = c1.getDeclaredField(<span class="string">"name"</span>); <span class="comment">//返回某一个特定域</span></div><div class="line">f.setAccessible(<span class="keyword">true</span>); <span class="comment">//由于name是私有域，必须先设置为可访问</span></div><div class="line">Object v = f.get(harry);</div></pre></td></tr></table></figure><p>　　上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value  </p><p><strong>下面是一些相关API</strong><br>在java.lang.reflect.Field中：  </p><ul><li>Object get(Object obj)<br>返回obj对象中用Field对象表示的域值</li><li>xxx getXxx(Object obj)<br>返回obj对象的基本类型的域的值</li><li>void set(Object obj,Object newValue)<br>用一个新值设置obj对象中Field对象表示的域    </li></ul><p>在java.lang.Class中：  </p><ul><li>Field getField(String name)<br>返回指定名称的公有域  </li><li>Field getDeclaredField(String name)  </li><li>返回指定名称的声明的域  </li></ul><p>在java.lang.reflect.AccessibleObject中：  </p><ul><li>void setAccessible(boolean flag)<br>为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置  </li><li>boolean isAccessible()<br>返回反射对象的可访问标志的值  </li><li>static void setAccessible(AccessibleObject[] array,boolean flag)<br>批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 </li></ul><h3 id="6-使用反射编写泛型数组代码"><a href="#6-使用反射编写泛型数组代码" class="headerlink" title="6.使用反射编写泛型数组代码"></a>6.使用反射编写泛型数组代码</h3><p>　　java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Employee[] a = <span class="keyword">new</span> Employee[<span class="number">100</span>];</div><div class="line">a = Arrays.copyOf(a,<span class="number">2</span> * a.length);</div></pre></td></tr></table></figure></p><p>　　我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a,<span class="keyword">int</span> newLength)&#123;</div><div class="line">Object[] newArray = <span class="keyword">new</span> Object[newLength];</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(a.length,newLength);</div><div class="line">    <span class="keyword">return</span> newArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>　　上述代码存在一个错误，即使用了<code>new Object[newLength]</code>创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。<br><strong>为了解决这个问题，下面提供java.lang.reflect.Array中的API</strong>  </p><ul><li>static Object get(Object array,int index)<br>返回对象数组某个位置上的元素</li><li>static xxx getXxx(Object array,int index)<br>(xxx是基本数据类型)返回基本类型数组某个位置上的值 </li><li>static void set(Object array,int index,Object newValue)<br>设置对象数组某个位置上的元素</li><li>static void setXxx(Object array,int index,xxx newValue)<br>(xxx是基本数据类型)设置基本类型数组某个位置上的值 </li><li>static int getLength(Object array)<br>返回数组的长度  </li><li>static Object newInstance(Class componentType,int length)  </li><li><p>static Object newInstance(Class componentType,int[] length)<br>返回一个具有给定类型、给定维数的新数组  </p><p>下面给出正确的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a,<span class="keyword">int</span> newLength)</span></span>&#123;</div><div class="line">&#123;</div><div class="line">Class c1 = a.getClass();<span class="comment">//获取a数组的类对象</span></div><div class="line">    <span class="keyword">if</span>(!c1.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//确认是一个数组</span></div><div class="line">    Class componentType = c1.getComponentType();</div><div class="line">    <span class="comment">//获取数组类型</span></div><div class="line">    <span class="keyword">int</span> length = Array.getLength(a);</div><div class="line">    Object newArray = Array.newInstance(componentType,newLength);</div><div class="line">    System.arraycopy(a,<span class="number">0</span>,newArray,<span class="number">0</span>,Math.min(length,newLength));</div><div class="line">    <span class="keyword">return</span> newArray;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">a = (<span class="keyword">int</span>[]) goodCopyOf(a,<span class="number">10</span>);</div></pre></td></tr></table></figure><p>　　为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型 </p><h3 id="7-调用任意方法"><a href="#7-调用任意方法" class="headerlink" title="7.调用任意方法"></a>7.调用任意方法</h3><p>　　通过反射还可以调用任意方法，这是通过Method类的invoke方法实现的，方法签名是:<code>Object invoke(Object obj,Object... args)</code>,Object obj表示调用方法的对象，Object…args表示方法的参数列表。<br>如果方法是静态方法，将第一个参数设置为null;如果方法是非静态无参方法，第二个参数列表可以忽略。<br>　　例如：<code>String n = (String)m1.invoke(harry);</code>(m1表示Employee类的getName方法)。如果方法m1的返回值是void，则invoke方法返回null，否则返回具体类型。如果返回值是基本类型，invoke方法会返回其包装器类型,可以利用自动开箱将其还原为基本数据类型。例如:<code>double s = (Double)m2.invoke(harry);</code>(m2表示Employee类的getSalary方法)<br>getMethods方法和getDeclaredMethods会返回一个Method对象列表，如果要得到特定的Method对象，可以调用Class类的getMethod方法，其签名是Method getMethod(String Methodname,Class…parameterTypes)。<br>例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method m1 = Employee.class.getMethod(<span class="string">"getName"</span>);  </div><div class="line">Method m2 = Employee.class.getMethod(<span class="string">"raiseSalary"</span>,<span class="keyword">double</span>.class);</div></pre></td></tr></table></figure></li></ul><p>　　下面给出一个调用任意方法打印函数表的程序(以自定义的square和Math.sqrt方法为例)：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTableTest</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">Method square =         MethodTableTest.class.getMethod(<span class="string">"square"</span>,<span class="keyword">double</span>.class);</div><div class="line">    Method sqrt = Math.class.getMethod(<span class="string">"sqrt"</span>,<span class="keyword">double</span>.class);</div><div class="line">    </div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,square);</div><div class="line">    printTable(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>,sqrt);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from,<span class="keyword">double</span> to,<span class="keyword">int</span> n,Method f)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    System.out.println(f);</div><div class="line">    <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> x = from;x &lt;= to;x += dx)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">try</span></div><div class="line">      &#123;</div><div class="line">         <span class="keyword">double</span> y = (Double)f.invoke(<span class="keyword">null</span>,x);</div><div class="line">         System.out.printf(<span class="string">"%10.4f | %10/4f\n"</span>,x,y);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">catch</span>(Exception e)</div><div class="line">      &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p> <strong>invoke方法如果提供了错误的参数，会抛出一个异常，所以要提供一个异常处理器</strong><br> 建议在有必要的时候才使用invoke方法，有如下原因:<br> 1.invoke方法的参数和返回值必须是Object类型，意味着必须进行多次类型转换，这样会使编译器错过检查代码的机会，等到测试阶段才发现错误，找到并改正会更加困难<br> 2.通过反射调用方法比直接调用方法要明显慢一些</p><p><strong>特别重申：</strong>建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的执行速度更快，更易于维护。    </p><h3 id="8-通过反射了解泛型本质"><a href="#8-通过反射了解泛型本质" class="headerlink" title="8.通过反射了解泛型本质"></a>8.通过反射了解泛型本质</h3><p>来看下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">Class c1 = list.getClass();</div><div class="line">Class c2 = list1.getClass();</div><div class="line">System.out.println(c1 == c2); <span class="comment">//true</span></div><div class="line"><span class="comment">/*反射的操作都是编译之后的操作，编译之后会发生类型擦除，即ArrayList&lt;String&gt;被擦除为ArrayList，所以c1 == c2结果为true*/</span></div></pre></td></tr></table></figure></p><p>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，编译之后就会发生类型擦除，所以绕过编译泛型就无效了</p><p>验证：我们可以通过方法的反射来操作，绕过编译<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Method m = c2.getMethod(<span class="string">"add"</span>, Object.class);</div><div class="line">m.invoke(list1, <span class="number">20</span>);<span class="comment">//绕过编译操作就绕过了泛型</span></div><div class="line">System.out.println(list1.size());</div><div class="line">System.out.println(list1);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">  e.printStackTrace();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p> 推荐博客：  </p><ul><li><a href="http://www.cnblogs.com/absfree/p/5277665.html" target="_blank" rel="external">Java核心技术点之反射</a>  </li><li><a href="http://www.cnblogs.com/luoxn28/p/5686794.html" target="_blank" rel="external">深入理解Java反射</a></li><li><a href="http://blog.csdn.net/liujiahan629629/article/details/18013523" target="_blank" rel="external">Java中的反射机制</a></li><li><a href="http://www.importnew.com/9078.html" target="_blank" rel="external">Java反射教程</a></li><li><a href="http://www.cnblogs.com/rollenholt/archive/2011/09/02/2163758.html" target="_blank" rel="external">Java反射详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。  &lt;/p&gt;
&lt;h3 id=&quot;1-什么是反射？&quot;&gt;&lt;a href=&quot;#1-什么是反射？&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java学习总结之继承和多态</title>
    <link href="http://habitdiary.cn/2017/10/12/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://habitdiary.cn/2017/10/12/Java学习总结之继承和多态/</id>
    <published>2017-10-12T15:18:55.000Z</published>
    <updated>2018-03-17T02:21:04.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父类与子类"><a href="#父类与子类" class="headerlink" title="父类与子类"></a>父类与子类</h3><p>在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。  </p><h4 id="继承有如下几个关键点"><a href="#继承有如下几个关键点" class="headerlink" title="继承有如下几个关键点"></a>继承有如下几个关键点</h4><p>1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法<br>2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们<br>3.不是所有的“是一种”(is-a)关系都该用继承来建模<br>4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承<br>5.Java中类与类的继承是单一继承  </p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super关键字有两种作用：<br><strong>1.调用父类的构造方法</strong><br>因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。<br>形式是<code>super()</code>或<code>super(arguments)</code>，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条<code>super()</code><br>有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。  </p><p><strong>2.调用父类的方法</strong><br>在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用<code>super.方法名</code>来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，<code>super.super.方法名</code>是不合法的。  </p><h3 id="构造方法链"><a href="#构造方法链" class="headerlink" title="构造方法链"></a>构造方法链</h3><p>在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Faculty</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">       <span class="keyword">new</span> Faculty();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Faculty</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"(4) Performs Faculty's tasks"</span>);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">this</span>(<span class="string">"(2) Invoke Employee's overloaded constructor"</span>);</div><div class="line">        System.out.println(<span class="string">"(3) Perfoms Employee's tasks"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String s)</span></span>&#123;</div><div class="line">  System.out.println(s);</div><div class="line">    &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"(1) Performs Person's tasks"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>打印结果为:<br>(1) Performs Person’s tasks<br>(2) Invoke Employee’s overloaded constructor<br>(3) Performs Employee’s tasks<br>(4) Performs Faculty’s tasks  </p><p>我们可以知道：子类的构造方法的第一条语句要么是<strong>super语句(包括编译器隐式插入的)</strong>,要么是<strong>this语句</strong>，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类  </p><p>注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。  </p><h3 id="方法重载与重写"><a href="#方法重载与重写" class="headerlink" title="方法重载与重写"></a>方法重载与重写</h3><p><strong>重载</strong><br>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型和访问修饰符可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同)  </p><p><strong>重写</strong><br>方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。<br>为了避免错误，可以使用重写注解，在要重写的方法前加上<code>@Override</code>，该注解会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。</p><p><strong>关于重写的几点注意</strong><br>1.仅当实例方法是可访问的，它才能被覆盖<br>2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法<br>3.尽管重写一般用于方法，属性其实也可以重写，即子类可以定义和父类同名的属性，子类的属性会覆盖父类的属性。</p><p>方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。<br>注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>多态机制的底层实现技术是<strong>动态绑定</strong>，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。</p><p>对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。  </p><p>静态绑定(前期绑定)：<br>在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。</p><p>动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。<br>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p><p>简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。</p><h3 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h3><p>假设下面要调用x.f(args)，方法调用的过程为：<br>1） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(int)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。<br>2） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。<br>3） 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为private方法、构造器不能被继承，更谈不上重写，而static方法和final方法虽然能被继承，但不能被重写。<br>4) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。  </p><p>每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。<br>方法表示例(Manager继承自Employee)：  </p><p>Employee:<br>getName() -&gt; Employee.getName()<br>getSalary() -&gt; Employee.getSalary()<br>getHireDay() -&gt; Employee.getHireDay()<br>raiseSalary(double) -&gt; Employee.raiseSalary(double)  </p><p>Manager:<br>getName() -&gt; Employee.getName()//继承的方法<br>getSalary() -&gt; Manager.getSalary()//重写的方法<br>getHireDay() -&gt; Employee.getHireDay()//继承的方法<br>raiseSalary(double) -&gt; Employee.raiseSalary(double)//继承的方法<br>setBonus(double) -&gt; Manager.setBonus(double)//新增的方法  </p><h3 id="内联优化"><a href="#内联优化" class="headerlink" title="内联优化"></a>内联优化</h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联优化所有的final方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高50%。如果确定一个类不会被派生或一个方法不会被重写，建议使用final关键字修饰。  </p><h3 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h3><p>和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。<br>我们可以通过<code>instanceof</code>运算符来检测一个对象是否是某个类或接口的实例，其返回值是boolean类型的。<br>注意:<br>1.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();<br>2.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。  </p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出<code>public class xxx extends Object</code>,在Java中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。<br>下面介绍Object类中的几个重要方法及重写规范：  </p><h4 id="1-equals方法"><a href="#1-equals方法" class="headerlink" title="1) equals方法"></a>1) equals方法</h4><p>Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。  </p><p>equals方法的原型是public boolean equals(Object obj),默认实现是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</div><div class="line">&#125;</div><div class="line">```    </div><div class="line">调用它的语法是`object1.equals(object2)`，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。    </div><div class="line">比如类Employee定义了数据域：<span class="keyword">private</span> String name,<span class="keyword">private</span> <span class="keyword">double</span> salary,<span class="keyword">private</span> LocalDate hireDay  </div><div class="line">equals方法重写如下：  </div><div class="line">```java </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//快速检测引用是否相等，相等返回ture</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//检测引用是否为空，为空返回false  </span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(getClass() != obj.getClass())  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     <span class="comment">//检测是否属于同一个类，不是返回false  </span></div><div class="line">        </div><div class="line">    Empolyee other = (Employee) obj;<span class="comment">//向下转型  </span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> name.equals(other.name)</div><div class="line">      &amp;&amp; salary == other.salary</div><div class="line">      &amp;&amp; hireDay.equals(other.hireDay);</div><div class="line">      <span class="comment">//逐一比较数据域,有一个不等返回就false，否则返回true</span></div><div class="line">```  </div><div class="line">**进一步改进：**  </div><div class="line">*改进一*  </div><div class="line">上述的第<span class="number">4</span>步检测，可以改为  </div><div class="line">```java</div><div class="line"><span class="keyword">return</span> Objects.equals(name,other.name)</div><div class="line">   &amp;&amp; salary == other.salary</div><div class="line">   &amp;&amp; Objects.equals(hireDay,other.hireDay);</div><div class="line">```  </div><div class="line">其中Objects.equals方法可以防备name 或 hireDay 可能为<span class="keyword">null</span>的情况，如果两个参数都为<span class="keyword">null</span>，Objects(a,b)返回<span class="keyword">true</span>;如果其中一个为<span class="keyword">null</span>，返回<span class="keyword">false</span>;如果两个参数都不为<span class="keyword">null</span>,调用a.equals(b)。Objects类在java.util包中。  </div><div class="line"></div><div class="line">在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。  </div><div class="line">比如Manager类继承自Employee，在父类的基础上增加了<span class="keyword">private</span> <span class="keyword">double</span> bonus：  </div><div class="line">```java</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">super</span>.equals(obj)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Manager other = (Manager) obj;</div><div class="line">        <span class="keyword">return</span> bonus == other.bonus;</div><div class="line">    &#125;</div><div class="line">```  </div><div class="line">*改进二*  </div><div class="line">上述代码的第<span class="number">3</span>步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用<span class="keyword">instanceof</span>进行检测，比如雇员的ID作为相等的概念，就可以用xxx <span class="keyword">instanceof</span> Employee进行检测，并将Empolyee.equals声明为<span class="keyword">final</span>。  </div><div class="line"></div><div class="line">**equals方法要满足下面的特性**  </div><div class="line"><span class="number">1</span>. 自反性: 对于任何非空引用，x.equals(x)应该返回<span class="keyword">true</span>  </div><div class="line"><span class="number">2</span>. 对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同  </div><div class="line"><span class="number">3</span>. 传递性：对于任何引用x、y和z,如果x.equals(y)返回<span class="keyword">true</span>，y.equals(z)返回<span class="keyword">true</span>，那么x.equals(z)也应该返回<span class="keyword">true</span>  </div><div class="line"><span class="number">4</span>. 一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果  </div><div class="line"><span class="number">5</span>. 对于任何非空引用x,x.equals(<span class="keyword">null</span>)应该返回<span class="keyword">false</span></div><div class="line"></div><div class="line">**下面我们给出编写一个完美的equals方法的建议**：  </div><div class="line"><span class="number">1</span>) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测  </div><div class="line"><span class="number">2</span>) 检测引用是否为空，如果为空，不必再检测，直接返回不等  </div><div class="line"><span class="number">3</span>) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:`<span class="keyword">if</span>(getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>`;如果所有子类都拥有统一的语义(父类决定相等)，就使用<span class="keyword">instanceof</span>检测：`<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> ClassName) <span class="keyword">return</span> <span class="keyword">false</span>)`  </div><div class="line"><span class="number">4</span>) 将obj向下转型为相应类的类型变量  </div><div class="line"><span class="number">5</span>) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测    </div><div class="line">**数组对象用静态的Arrays.equals方法判等**</div><div class="line"></div><div class="line">拓展：[Integer判断相等，到底该用==还是equals](http:<span class="comment">//www.jianshu.com/p/9cb9c61b0986)  </span></div><div class="line"></div><div class="line">当我们在方法里调用equals方法时，建议写字符串常量.equals(参数)的形式。比如：  </div><div class="line">```java</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">function</span><span class="params">(String str)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"hello world"</span>.equals(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样可以防止str为null而抛出空指针异常，而根据equals()方法的对称性，这种调换并不会影响方法的功能。</p><h4 id="2-hashCode方法"><a href="#2-hashCode方法" class="headerlink" title="2) hashCode方法"></a>2) hashCode方法</h4><p>散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。<br>String类使用下列算法计算散列码：  </p><pre><code class="java"><span class="keyword">int</span> hash = <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length();i++){    hash = <span class="number">31</span> * hash + charAt(i);}</code></pre><p>由于hashCode方法定义在Object类中，方法原型是<code>public int hashCode()</code>,因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。<br><strong>如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。</strong><br>hashCode方法应该返回一个整型数值(可以是负数),<strong>并合理地组合实例域的散列码</strong>，以便能让各个不同的对象产生的散列码更均匀。<br>例如，下面是Employee类的hashCode方法  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * name.hashCode()      + <span class="number">11</span> * <span class="keyword">new</span> Double(salary).hashCode()      + <span class="number">13</span> * hireDay.hashCode();</code></pre><p><strong>进一步改进</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> <span class="number">7</span> * Objects.hashCode(name)      + <span class="number">11</span> * Double.hashCode(salary)      + <span class="number">13</span> * Objects.hashCode(hireDay);</code></pre><p><strong>从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()</strong><br>其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象    </p><p><strong>还有更简单的做法</strong>  </p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>{    <span class="keyword">return</span> Objects.hash(name,salary,hireDay); }</code></pre><p><strong>Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID</strong>  </p><h4 id="3-toString方法"><a href="#3-toString方法" class="headerlink" title="3) toString方法"></a>3) toString方法</h4><p>方法原型是<code>public String toString()</code>,用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：<code>类名@对象十六进制内存地址</code>的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似<code>[I@1a46e30</code>的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。<br>toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。<br>当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。  </p><h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如：  </p><pre><code class="java"><span class="keyword">int</span> actualSize = . . .;Employee[] staff = <span class="keyword">new</span> Employee[actualSize];</code></pre><p>但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。<br>ArrayList是一个采用<strong>类型参数</strong>的<strong>泛型类</strong>,声明方式为<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;()</code>,从Java SE 7开始，可以省去右边的类型参数，即<code>ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()</code><br>在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于<code>ArrayList&lt;Object&gt;</code>,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。<br>ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。  </p><h4 id="ArrayList类的常用API"><a href="#ArrayList类的常用API" class="headerlink" title="ArrayList类的常用API"></a>ArrayList类的常用API</h4><ul><li><code>ArrayList&lt;E&gt;()</code> 构造一个初始容量为10的空列表  </li><li><code>ArrayList&lt;E&gt;(int initialCapacity)</code>构造一个具有指定初始容量的空列表  </li><li>boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true  </li><li>void add(int index, E element) 将指定的元素插入此列表中的指定位置。 </li><li>int size() 返回此列表中的元素数。  </li><li>void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。  </li><li>E get(int index) 返回此列表中指定位置上的元素。  </li><li>E remove(int index) 移除此列表中指定位置上的元素并返回该元素。  </li><li>boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。  </li><li>void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。  </li><li>boolean isEmpty() 如果此列表中没有元素，则返回 true  </li><li>boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。  </li><li>void clear() 移除此列表中的所有元素。  </li><li>Object clone() 返回此 ArrayList 实例的浅表副本。  </li><li>trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。  </li></ul><h4 id="对于数组列表有用的方法"><a href="#对于数组列表有用的方法" class="headerlink" title="对于数组列表有用的方法"></a>对于数组列表有用的方法</h4><p><strong>1.数组和ArrayList互相转换</strong>  </p><p>数组转ArrayList:  </p><pre><code class="java">String[] array = {<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>};ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array));</code></pre><p>ArrayList转数组:  </p><pre><code class="java">String[] array = <span class="keyword">new</span> String[list.size()];list.toArray(array);</code></pre><h4 id="2-Collections类"><a href="#2-Collections类" class="headerlink" title="2.Collections类"></a>2.Collections类</h4><p>Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。</p><p><strong>ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。</strong>  </p><h3 id="final关键字总结"><a href="#final关键字总结" class="headerlink" title="final关键字总结"></a>final关键字总结</h3><p>final关键字在不同语句中有不同的作用：<br>1) <strong>修饰类变量或成员变量</strong> 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。只能在定义时、构造方法中或构造代码块中赋值。<br>2）<strong>修饰方法的局部变量，即常量</strong> final修饰的局部变量只要在使用前被赋值即可，不要求在定义时即赋值，但赋值后不可改变。<br>3) <strong>修饰方法</strong> 表示该方法不能被重写，注意final不能修饰构造方法。<br>4) <strong>修饰类</strong> 表示该类不能被扩展</p><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><h4 id="1-将公共操作和域放在超类"><a href="#1-将公共操作和域放在超类" class="headerlink" title="1.将公共操作和域放在超类"></a>1.将公共操作和域放在超类</h4><h4 id="2-不要使用受保护的域"><a href="#2-不要使用受保护的域" class="headerlink" title="2.不要使用受保护的域"></a>2.不要使用受保护的域</h4><p>protected机制并不能够带来更好的保护，其原因主要有两点:<br>第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。<br>第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。<br>不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的  </p><h4 id="3-使用继承实现-“is-a”-关系"><a href="#3-使用继承实现-“is-a”-关系" class="headerlink" title="3.使用继承实现 “is-a” 关系"></a>3.使用继承实现 “is-a” 关系</h4><h4 id="4-除非所有继承的方法都有意义，否则不要使用继承"><a href="#4-除非所有继承的方法都有意义，否则不要使用继承" class="headerlink" title="4.除非所有继承的方法都有意义，否则不要使用继承"></a>4.除非所有继承的方法都有意义，否则不要使用继承</h4><p>比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。  </p><h4 id="5-在覆盖方法时，不要改变预期的行为"><a href="#5-在覆盖方法时，不要改变预期的行为" class="headerlink" title="5.在覆盖方法时，不要改变预期的行为"></a>5.在覆盖方法时，不要改变预期的行为</h4><h4 id="6-使用多态，而非类型信息"><a href="#6-使用多态，而非类型信息" class="headerlink" title="6.使用多态，而非类型信息"></a>6.使用多态，而非类型信息</h4><p>即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为</p><h4 id="7-不要过多地使用反射"><a href="#7-不要过多地使用反射" class="headerlink" title="7.不要过多地使用反射"></a>7.不要过多地使用反射</h4><p>反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;父类与子类&quot;&gt;&lt;a href=&quot;#父类与子类&quot; class=&quot;headerlink&quot; title=&quot;父类与子类&quot;&gt;&lt;/a&gt;父类与子类&lt;/h3&gt;&lt;p&gt;在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派
      
    
    </summary>
    
    
      <category term="Java" scheme="http://habitdiary.cn/tags/Java/"/>
    
  </entry>
  
</feed>
