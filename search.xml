<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之虚拟机锁优化策略]]></title>
    <url>%2F2018%2F03%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之虚拟机类加载机制]]></title>
    <url>%2F2018%2F03%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类的生命周期一个类从加载进内存到卸载出内存为止，一共经历7个阶段：加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化——&gt;使用——&gt;卸载。其中，类加载包括5个阶段： 加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化。在类加载的过程中，以下3个过程称为连接： 验证——&gt;准备——&gt;解析。因此，JVM的类加载过程也可以概括为3个过程： 加载——&gt;连接——&gt;初始化。C/C++在运行前需要完成预处理、编译、汇编、链接；而在Java中，类加载(加载、连接、初始化)是在程序运行期间完成的。 在程序运行期间进行类加载会稍微增加程序的开销，但随之会带来更大的好处——提高程序的灵活性。Java语言的灵活性体现在它可以在运行期间动态扩展，所谓动态扩展就是在运行期间动态加载和动态连接。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。从最基础的Applet、JSP到相对复杂的OSGi技术，都使用了Java语言运行期类加载的特性。 类加载的时机我们已经知道，类加载的过程包括：加载、验证、准备、解析、初始化。其中加载、验证、准备、初始化的开始顺序是依次进行的，这些步骤开始之后的过程可能会有重叠。而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。 类加载过程中“初始化”开始的时机加载、验证、准备阶段要求在初始化阶段之前开始，但对于它们开始的具体时机，Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”：1、遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是: 使用new关键字实例化对象的时候 读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候 调用一个类的静态方法的时候 2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。4、当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。5、当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 主动引用与被动引用对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。 被动引用的场景示例示例一：通过子类引用父类的静态字段，不会导致子类初始化12345678910111213141516171819package cn.habitdiary;public class SuperClass&#123; public static int value = 123; static&#123; System.out.println("SuperClass init!"); &#125;&#125;public class SubClass extends SuperClass&#123; static&#123; System.out.println("SubClass init!"); &#125;&#125;public class NotInitialization&#123; public static void main(String[]args)&#123; System.out.println(SubClass.value); &#125;&#125; 输出结果：SuperClass init!原因分析：本示例看似满足初始化时机的第一条：当要获取某一个类的静态成员变量的时候如果该类尚未初始化，则对该类进行初始化。但对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段属于间接引用，只会触发父类的初始化而不会触发子类的初始化。 示例二：通过数组定义来引用类，不会触发此类的初始化12345public class NotInitialization&#123; public static void main(String[]args)&#123; SuperClass[] sca = new SuperClass[10]; &#125;&#125; 输出结果：无输出原因分析：这个过程看似满足初始化时机的第一条：遇到new创建对象时若类没被初始化，则初始化该类。运行之后发现没有输出“SuperClass init!”，说明并没有触发类cn.habitdiary.SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为 [Lcn.habitdiary.SuperClass 的类的初始化阶段。对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。这个类代表了一个元素类型为cn.habitdiary.SuperClass的一维数组，数组中应有的属性和方法(用户可直接使用的只有被修饰为public的length属性和clone()方法)都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法，而C/C++直接翻译为对数组指针的移动。在Java语言中，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。简言之，现在通过new要创建的是一个SuperClass数组对象，而非SuperClass类对象，因此也属于间接引用，不会初始化SuperClass类。 示例三：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化12345678910111213package cn.habitdiary;public class ConstClass&#123; public static final String HELLOWORLD="hello world"; static&#123; System.out.println("ConstClass init!"); &#125;&#125;public class NotInitialization&#123; public static void main(String[]args)&#123; System.out.println(ConstClass.HELLOWORLD); &#125;&#125; 输出结果：hello world原因分析：本示例看似满足类初始化时机的第一个条件：获取一个类静态成员变量的时候若类尚未初始化则初始化类。这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但HELLOWORLD是被final修饰的常量，在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了引用它的类（这里是NotInitialization类）的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。 接口的初始化接口和类都需要初始化，接口和类的初始化过程基本一样，不同点在于：类初始化时，如果发现父类尚未被初始化，则先要初始化父类，然后再初始化自己；但接口初始化时，并不要求父接口已经全部初始化，有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。另外，接口中不能使用“static{}”语句块。 类加载的过程接下来我们详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。 加载注意：“加载”是“类加载”过程的第一步，千万不要混淆。 加载时JVM做了什么？在加载过程中，JVM主要做3件事情： 通过一个类的全限定名来获取这个类的二进制字节流，即class文件：在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化时机的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，存储在方法区中。 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口。接下来程序在运行过程中所有对该类的访问都通过这个类对象，也就是这个Class类型的类对象是提供给外界访问该类的接口。 从哪里加载？1、从压缩包中读取，如：Zip、Jar、War、Ear等。2、从网络中获取，这种场景最典型的应用就是Applet。3、由其他文件动态生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。4、从数据库中读取，将二进制字节流存储至数据库中，然后在加载时从数据库中读取。有些中间件(如SAP Netweaver)会这么做，用来实现代码在集群间分发。5、运行时计算生成,这种场景使用得最多的就是动态代理技术,在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为*$Proxy的代理类的二进制字节流。 类和数组加载过程的区别？一个非数组类的加载阶段(准确地说，是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式(即重写一个类加载器的loadClass()方法)。如果数组的组件类型(Component Type，指的是数组去掉一个维度的类型)是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识(这点很重要，一个类必须与类加载器一起确定唯一性)。如果数组的组件类型不是引用类型(例如int[]数组)，Java虚拟机将会把数组C标记为与引导类加载器关联。数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之类文件结构]]></title>
    <url>%2F2018%2F03%2F21%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[什么是JVM的“无关性”？Java具有平台无关性，也就是任何操作系统都能运行Java代码。之所以能实现这一点，是因为Java运行在Java虚拟机之上，不同的操作系统都拥有各自的Java虚拟机，这些虚拟机都可以载入和执行字节码(Byte Code)。程序编译结果从二进制本地机器码(Native Code)转变为与操作系统和机器指令集无关的、平台中立的字节码(Byte Code)。因此Java能实现“一次编写，处处运行”。而JVM不仅具有平台无关性，还具有语言无关性。平台无关性是指任何操作系统都能运行Java代码，而语言无关性是指Java虚拟机能运行除Java以外的代码！实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。简而言之，JVM只认识class文件，它并不管何种语言生成了class文件，只要class文件符合JVM的规范就能运行。因此目前已经有Clojure、Groovy、JRuby、Jython、Scala等语言能够在JVM上运行。它们有各自的语法规则，不过它们的编译器都能将各自的源码编译成符合JVM规范的class文件，从而能够借助JVM运行它们。 纵观Class文件结构class文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全是连续的0和1。class文件中的所有内容被分为两种类型：无符号数和表。无符号数：它表示class文件中的值，这些值没有任何类型，但有不同的长度。根据这些值长度的不同分为：u1、u2、u4、u8，分别代表1字节的无符号数、2字节的无符号数、4字节的无符号数、8字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。表：表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以_info结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。 class文件的组织结构1、魔数2、本文件的版本信息3、常量池4、访问标志5、类索引6、父类索引7、接口索引集合8、字段表集合9、方法表集合 魔数每个Class文件的头4个字节称为魔数(Magic Number),它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。魔数的作用就相当于文件扩展名，使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动，不安全，因此在class文件中标示文件类型比较合适。class文件的魔数是16进制的 0xCAFEBABE (咖啡宝贝)，非常具有浪漫主义色彩。 版本信息紧接着魔数的4个字节是版本号。它表示该class中使用的是哪个版本的JDK。在高版本的JVM上能够运行低版本的class文件，但在低版本的JVM上无法运行高版本的class文件，即使该class文件中没有用到任何高版本JDK的特性也无法运行！ 常量池什么是常量池？紧接着版本号之后的就是常量池。常量池中存放两种类型的常量。字面量：字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用：符号引用是我们定义的各种名字，包括了下面三类常量：1、类和接口的全限定名(Fully Qualified Name)2、字段的名称和描述符(Descriptor)3、方法的名称和描述符 常量池的特点 常量池长度不固定：常量池的大小是不固定的，因此常量池开头放置一个u2类型的无符号数，用来存储当前常量池的容量。JVM根据这个值就知道常量池的头尾。注：这个值是从1开始的，若为5表示池中有4个常量。 常量池中的常量用表来表示：常量池开头有个常量池容量计数器，接下来就全是一个个常量了，只不过常量都是由一张张二维表构成，除了记录常量的值以外，还记录当前常量的相关信息。 常量池是class文件的资源仓库 常量池是与该class中其它部分关联最多的部分 常量池是class文件中空间占用最大的部分之一 常量池中常量的类型常量池中的常量大体上分为：字面量 和 符号引用。在此基础上，根据常量的数据类型不同，又可以被细分为14种常量类型。这14种常量类型都有各自的二维表示结构。每种常量类型的头1个字节都是tag，用于表示当前常量属于14种类型中的哪一个。 访问标志在常量池之后是2字节的访问标志。访问标志是用来表示这个class文件是类还是接口、是否被public修饰、是否被abstract修饰、是否被final修饰等。由于这些标志都由是/否表示，因此可以用0/1表示。访问标志为2字节，可以表示16位标志，但JVM目前只定义了8种，未定义的直接写0。 类索引、父类索引、接口索引集合类索引、父类索引、接口索引集合是用来表示当前class文件所表示类的名字、父类名字、接口的名字。它们按照顺序依次排列，类索引和父类索引各自使用一个u2类型的无符号常量，这个常量指向CONSTANT_Class_info类型的常量，该常量的bytes字段记录了本类、父类的全限定名。由于一个类的接口可能有好多个，因此需要用一个集合来表示接口索引，它在类索引和父类索引之后。这个集合开头入口的第一项是一个u2类型的数据，即接口计数器(interfaces_count)，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0,后面接口的索引表不再占用任何字节。否则，接下来就是接口的名字索引。 字段表的集合什么是字段表集合？字段表(field_info)用于描述接口或者类中声明的变量。字段(field)包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的信息有：字段的作用域(public、private、protected修饰符)、是实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符)、字段数据类型(基本类型、对象、数组)、字段名称。上述这些信息中,各个修饰符都是布尔值,要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。 字段表结构的定义 access_flags：字段的访问标志。在Java中，每个成员变量都有一系列的修饰符，和上述class文件的访问标志的作用一样，只不过成员变量的访问标志与类的访问标志稍有区别。 name_index：本字段名字的索引。指向一个CONSTANT_Class_info类型的常量，这里面存储了本字段的名字等信息。 descriptor_index：描述符。用于描述本字段在Java中的数据类型等信息（下面详细介绍）。 attributes_count：属性表集合的长度。 attributes：属性表集合。到descriptor_index为止是字段表的固定信息，光有上述信息可能无法完整地描述一个字段，因此用属性表集合来存放额外的信息，比如一个字段的值（下面会详细介绍）。很明显,在实际情况中,ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所决定的。什么是描述符？成员变量（包括静态成员变量和实例变量）和 方法都有各自的描述符。 对于字段而言，描述符用于描述字段的数据类型； 对于方法而言，描述符用于描述字段的数据类型、参数列表、返回值。在描述符中，基本数据类型用大写字母表示，对象类型用“L对象类型的全限定名”表示。对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为:“[[Ljava/lang/String”，一个整型数组“int[]”将被记录为“[I”。用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String”，方法intindexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。 字段表集合的注意点1、一个class文件的字段表集合中不能出现从父类/接口继承而来字段2、一个class文件的字段表集合中可能会出现没有人为定义的字段。如编译器会自动地在内部类的class文件的字段表集合中添加外部类对象的成员变量，供内部类访问外部类。3、Java中只要两个字段名字相同就无法通过编译。但在JVM规范中，允许两个字段的名字相同但描述符不同的情况，并且认为它们是两个不同的字段。 方法表集合什么是方法表集合？Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)、属性表集合(attributes)等。因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。 方法表集合的注意点1、如果本class没有重写父类的方法，那么本class文件的方法表集合中是不会出现父类/父接口的方法表2、本class的方法表集合可能出现没有人为定义的方法 编译器在编译时会在class文件的方法表集合中加入类构造器&lt;Clinit&gt;和实例构造器&lt;init&gt;。3、重载一个方法需要有相同的简单名称和不同的特征签名。JVM的特征签名和Java的特征签名有所不同：Java特征签名：方法参数在常量池中的字段符号引用的集合JVM特征签名：方法参数 + 返回值。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F03%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[概述观察Java内存运行时区域的各个部分，其中程序计数器、Java虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。然而，堆和方法区中的内存清理工作就没那么容易了。 堆和方法区所有线程共享，并且都在JVM启动时创建，一直得运行到JVM停止时。因此它们没办法根据线程的创建而创建、线程的结束而释放。堆中存放JVM运行期间的所有对象，虽然每个对象的内存大小在加载该对象所属类的时候就确定了，但究竟创建多少个对象只有在程序运行期间才能确定。方法区中存放类信息、静态成员变量、常量。类的加载是在程序运行过程中，当需要创建这个类的对象时才会加载这个类。因此，JVM究竟要加载多少个类也需要在程序运行期间确定。这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，本文后续讨论中的“内存”分配与回收也仅指Java堆和方法区的内存。 对象已死吗？在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”(即不可能再被任何途径使用的对象)。下面介绍两种判断对象是否存活的算法： 引用计数算法给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。但主流的Java虚拟机里面没有选用引用计数算法来管理内存，因为这种算法存在一个缺陷，即它无法解决对象之间相互循环引用的问题：举个简单的例子，对象objA和objB都有字段instance，赋值令objA.instance = objB 及 objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。 可达性分析算法在主流的商用程序语言(Java、C#、Lisp)的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。如下图所示,对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。 在Java语言中，可作为GC Roots的对象包括下面几种:1、虚拟机栈(栈帧中的本地变量表)中引用的对象。2、本地方法栈中JNI(即一般说的Native方法)引用的对象。3、方法区中类静态属性引用的对象。4、方法区中常量引用的对象。 回收无效对象的过程即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。具体步骤如下： 1）判断该对象是否覆盖了finalize()方法若已覆盖该方法，并该对象的finalize()方法还没有被执行过，那么就会将对象放入F-Queue队列中；若未覆盖该方法，则直接释放对象内存。 2）执行F-Queue队列中的finalize()方法虚拟机会以较低的优先级执行这些finalize()方法，所谓的“执行”是指虚拟机会触发这个方法，但不会确保所有的finalize()方法都会执行结束。一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃，此时虚拟机就直接停止执行，将该对象清除。 3）对象重生或死亡finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 注意：强烈不建议使用finalize()函数进行任何操作！如果需要释放资源，请使用try-finally。因为finalize()不确定性大，开销大，无法保证顺利执行。 Java引用种类无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前,Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这4种引用强度依次逐渐减弱。 强引用我们平时所使用的引用就是强引用。 A a = new A(); 也就是通过关键字new创建的对象所关联的引用就是强引用。 只要强引用存在，该对象永远也不会被回收。 软引用软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生OutOfMemeryError之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出OutOfMemeryError。软引用的生命周期比强引用短一些。 弱引用弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 方法区的内存回收很多人认为方法区(或者HotSpot虚拟机中的永久代)是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 如何判定废弃常量？清除废弃的常量和清除对象类似，只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。 如何判定废弃的类？清除废弃类的条件较为苛刻：1、该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。2、加载该类的ClassLoader已经被回收。3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾收集算法现在我们知道了判定一个对象是无效对象、判定一个类是废弃类、判定一个常量是废弃常量的方法，也就是知道了垃圾收集器会清除哪些数据，那么接下来介绍如何清除这些数据。 标记-清除算法最基础的收集算法是“标记-清除”(Mark-Sweep)算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如下图所示： 复制算法为了解决效率问题，一种称为“复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。这种算法避免了碎片空间，但内存被缩小了一半。 而且每次都需要将有用的数据全部复制到另一片内存上去，效率不高。复制算法的执行过程如下图所示：注意：在复制的时候会将存活对象复制到一片连续的空间上，因为复制算法的内存分配是通过“指针碰撞”方式实现的。 解决空间利用率问题现在的商业虚拟机都采用这种收集算法来回收新生代。在新生代中，由于大量的对象都是“朝生夕死”，也就是一次垃圾收集后只有少量对象存活，所以并不需要按照1:1的比例来划分内存空间，我们将新生代内存划分成三块：Eden、Survior1、Survior2，内存大小分别是8:1:1，每次分配内存时，只使用Eden和其中一块Survivor。比如先使用Eden+Survior1，当发现Eden+Survior1的内存即将满时，JVM会发起一次Minor GC，清除掉废弃的对象，并将所有存活下来的对象复制到另一块Survior2中。那么，接下来就使用Survior2+Eden进行内存分配。也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存会被“浪费”。通过这种方式，只需要浪费10%的内存空间即可实现带有压缩功能的垃圾收集方法，避免了内存碎片的问题。但是，当一个对象要申请内存空间时，发现Eden+Survior中剩下的空间无法放置该对象，此时需要进行Minor GC，如果MinorGC过后空闲出来的内存空间仍然无法放置该对象，那么此时就需要将对象转移到老年代中，这种方式叫做“分配担保”。 什么是分配担保？当JVM准备为一个对象分配内存空间时，发现此时Eden+Survior中空闲的区域无法装下该对象，那么就会触发Minor GC，对该区域的废弃对象进行回收。但如果Minor GC过后只有少量对象被回收，仍然无法装下新对象，那么此时需要将Eden+Survior中的所有对象都转移到老年代中，然后再将新对象存入Eden区。这个过程就是“分配担保”。 标记-整理算法标记-整理算法是一种老年代的垃圾收集算法。老年代中的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，因此如果选用“复制”算法，每次需要复制大量存活的对象，会导致效率很低。而且，在新生代中使用“复制”算法，当Eden+Survior中都装不下某个对象时，可以使用老年代的内存进行“分配担保”，而如果在老年代使用该算法，那么在老年代中如果出现Eden+Survior装不下某个对象时，没有其他区域给他作分配担保。因此，老年代中一般使用“标记-整理”算法。根据老年代的特点，有人提出了另外一种“标记-整理”(Mark-Compact)算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如下图所示： 分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并不是一种具体的方法，而是一种思想，即根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 内存分配与回收策略对象优先在Eden分配目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代。在新生代中为了防止内存碎片问题，因此垃圾收集器一般都选用“复制”算法。因此，堆内存的新生代被进一步分为：Eden区＋Survior1区＋Survior2区。每次创建对象时，首先会在Eden区中分配。若Eden区已满，则在Survior1区中分配。若Eden区＋Survior1区剩余内存太少，导致对象无法放入该区域时，则会触发Minor GC，对该区域的废弃对象进行回收。但如果Minor GC过后只有少量对象被回收，仍然无法装下新对象，就会启用“分配担保”，将当前Eden区＋Survior1区中的对象转移到老年代中，然后再将新对象存入Eden区。新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁,一般回收速度也比较快。Minor GC触发条件：当Eden区满时，触发Minor GC。老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。Full GC触发条件：1）调用System.gc()时，系统建议执行Full GC，但是不必然执行2）老年代空间不足3）方法区空间不足4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存5）由Eden区、Survivor1区向Survivor2区复制时，对象大小大于Survivor2可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 大对象直接进入老年代所谓的大对象是指,需要大量连续内存空间的Java对象,最典型的大对象就是那种很长字符串以及数组。当发现一个大对象在Eden区＋Survior1区中存不下的时候就需要分配担保机制把当前Eden区＋Survior1区的所有对象都复制到老年代中去。 我们知道，一个大对象能够存入Eden区＋Survior1区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及到大量的复制，就会造成效率低下。 因此，对于大对象我们直接把他放到老年代中去，从而就能避免大量的复制操作。 那么，什么样的对象才是“大对象”呢？通过-XX:PretrnureSizeThreshold参数设置大对象该参数用于设置大小超过该参数的对象被认为是“大对象”，直接进入老年代。注意：该参数只对Serial和ParNew收集器有效。 生命周期较长的对象进入老年代老年代用于存储生命周期较长的对象，那么我们如何判断一个对象的年龄呢？新生代中的每个对象都有一个年龄计数器，当新生代发生一次Minor GC后，存活下来的对象的年龄就加一，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。使用-XXMaxTenuringThreshold设置新生代的最大年龄设置该参数后，只要超过该参数的新生代对象都会被转移到老年代中去。 动态对象年龄判定如果当前新生代的Survior中，年龄相同的对象的内存空间总和超过了Survior内存空间的一半，那么所有年龄相同的对象和超过该年龄的对象都被转移到老年代中去。无需等到对象的年龄超过MaxTenuringThreshold才被转移到老年代中去。 “分配担保”策略详解当垃圾收集器准备要在新生代发起一次Minor GC时，首先会检查老年代中最大的连续空闲区域的大小是否大于新生代中所有对象的大小，也就是老年代中目前能够将新生代中所有对象全部装下。若老年代能够装下新生代中所有的对象，那么此时进行Minor GC没有任何风险，然后就进行Minor GC。若老年代无法装下新生代中所有的对象，那么此时进行Minor GC是有风险的，垃圾收集器会进行一次预测：根据以往MinorGC过后存活对象的平均数来预测这次MinorGC后存活对象的平均数。如果以往存活对象的平均数小于当前老年代最大的连续空闲空间，那么就进行MinorGC，虽然此次MinorGC是有风险的。如果以往存活对象的平均数大于当前老年代最大的连续空闲空间，那么就对老年代进行一次Full GC，通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。这个过程就是分配担保。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java虚拟机之Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 概述对于从事C/C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”又是从事最基础工作的“劳动人民”——既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。 运行时数据区域(JVM内存模型)Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java 虚拟机（Java Virtual Machine=JVM）的内存空间主要分为五个部分，分别是：1、程序计数器2、Java 虚拟机栈3、本地方法栈4、堆5、方法区如下图所示： 程序计数器什么是程序计数器？程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。 程序计数器的作用程序计数器有两个作用：1、在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。2、由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。因此，每条线程都需要有一个独立的程序计数器来记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 注意如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空(Undefined)。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈什么是Java虚拟机栈？与程序计数器一样,Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 堆和栈浅谈经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack)，这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型,它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小。 可能出现的异常Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。OutOfMemoryError： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。StackOverFlowError和OutOfMemoryError的异同：StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 本地方法栈本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样,本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 堆什么是堆？堆是用来存放对象的内存空间。 几乎所有的对象都存储在堆中。 堆的特点1、线程共享对于大多数应用来说,Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 2、内存回收和内存分配的主要场所Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”(GarbageCollected Heap)。从内存回收的角度来看,由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又分为Eden空间、Survivor1空间、Survivor2空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 3、内存空间的不连续性和可扩展性根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的,也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常。 方法区什么是方法区？方法区(Method Area)与Java堆一样，是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑分区，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 方法区的特点1、线程共享方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。2、永久代方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为永久代。3、内存回收效率低相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是：针对常量池的回收和对类型的卸载。一般来说,这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。4、Java虚拟机规范对方法区的要求比较宽松Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。 运行时常量池方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。其中常量存储在运行时常量池中。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用。当这个类被Java虚拟机加载后，class文件中的常量进入方法区的运行时常量池中。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。运行时常量池和Class文件常量池的区别1、Java虚拟机对Class文件每一部分(自然也包括常量池)的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。2、运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 直接内存直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。显然，本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存，肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。当内存不足就会抛出OutOfMemoryError异常。 各内存区域的总结1、Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。2、Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。3、堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。4、程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法栈。并且他们的生命周期和所属的线程一样。 而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。 对象的创建Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象(例如克隆、反序列化)通常仅仅是一个new关键字而已，而在虚拟机中，对象(文中讨论的对象限于普通Java对象，不包括数组和Class对象等)的创建又是怎样一个过程呢? 当虚拟机遇到一条含有new的指令时，会进行一系列对象创建的操作：1）检查常量池中是否有即将要创建的这个对象所属的类的符号引用 若常量池中没有这个类的符号引用，说明这个类还没有被定义，抛出ClassNotFoundException 若常量池中有这个类的符号引用，则进行下一步工作 2）进而检查这个符号引用所代表的类是否已经被JVM加载 若该类还没有被加载，就找该类的class文件，并加载进方法区 若该类已经被JVM加载，则准备为对象分配内存 3）根据方法区中该类的信息确定该类所需的内存大小一个对象所需的内存大小是在这个对象所属类被定义完就能确定的，且一个类所生产的所有对象的内存大小是一样的。JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 4）从堆中划分一块对应大小的内存空间给新的对象分配堆中内存有两种方式： 指针碰撞：如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。 空闲列表：如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List)。 综上所述：JVM选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时,系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。 5）为对象中的成员变量赋上初始值(默认初始化) 6）设置对象头中的信息 7）调用对象的构造函数进行初始化 此时，整个对象的创建过程就完成了。 对象的内存布局一个对象从逻辑角度看，它由成员变量和成员函数构成，从物理角度来看，对象是存储在堆中的一串二进制数，这串二进制数的组织结构如下。对象在内存中分为三个部分：1、对象头2、实例数据3、对齐补充 对象头HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。另外，如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 实例数据实例数据就是成员变量的值，其中包含父类的成员变量和本类的成员变量。这部分的存储顺序会受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)，从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true(默认为true)，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 对齐补充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或者2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 访问对象的过程我们知道，引用类型的变量中存放的是一个地址，那么根据地址类型的不同，对象有不同的访问方式：1、句柄访问方式：堆中分配出一块叫做“句柄池”的内存空间，用于存放对象实例数据与类型数据各自的具体地址信息。引用类型的变量存放的是该对象在句柄池中的地址。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。 2、直接指针访问方式：引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 HotSpot采用直接指针方式访问对象，因为它只需一次寻址操作，从而性能比句柄访问方式快一倍。但它需要额外的策略存储对象在方法区中类信息的地址。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之并发]]></title>
    <url>%2F2018%2F02%2F01%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[多任务操作系统的多任务指的是在同一刻运行多个程序的能力。例如，在编辑或下载邮件的同时可以打印文件。今天，人们很可能有单台拥有多个 CPU 的计算机, 但是 , 并发执行的进程数目并不是由 CPU 数目制约的。操作系统将 CPU 的时间片分配给每一个进程，给人并行处理的感觉。 并行与并发并行：多个cpu或者多台机器同时执行一段处理逻辑，是真正的同时运行。并发：如果只有一个CPU，如何做到多个进程同时运行呢？我们先来看操作系统的一些相关概念。大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，即把CPU的执行时间分为很多小块，每一小块的时间相等且固定，我们把任务执行的这一小块时间叫做时间片。任务正在执行时的状态叫运行状态，一个任务执行一小段时间后会被强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来，每个任务在CPU的调度下轮流执行。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。下面是时间片以及CPU轮转调度的示意图： 进程进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。 进程具有的特征：动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；并发性：任何进程都可以同其他进程一起并发执行；独立性：进程是系统进行资源分配和调度的一个独立单位；结构性：进程由程序、数据和进程控制块三部分组成。 线程在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。简言之，线程是比进程还要小的运行单位，可以看作是子程序，一个进程包含一个或多个线程。 主线程JVM调用main()所产生的线程。 当前线程当前正在运行的进程，可通过Thread.currentThread()来获取当前线程。 后台线程(守护线程)指为其他线程提供服务的线程，也称为守护线程。比如JVM的垃圾回收、内存管理等线程都是守护线程。当所有前台线程(用户线程)都结束，程序只剩下后台线程的时候，JVM就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。可以通过isDaemon()和setDaemon()方法来判断一个线程是否为后台线程和设置一个线程为后台线程。守护线程有时会被初学者错误地使用，他们不打算考虑关机(shutdown)动作。但这是很危险的。守护线程应该永远不去访问固有资源, 如文件、数据库, 因为它会在任何时候甚至在一个操作的中间发生中断。比如一个守护线程在操作资源的时候，如果所有用户线程都退出了，JVM将直接杀死该守护线程而无法执行finally块中的关闭资源的语句。 来看一个例子：12345678910111213141516171819202122232425262728293031class DemoThread implements Runnable &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.currentThread().sleep(1000); System.out.println("我是非守护线程"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;; &#125; &#125;public class Main &#123; public static void main(String[] args) &#123; threadStart(); &#125; public static void threadStart()&#123; DemoThread dt = new DemoThread(); Thread thread = new Thread(dt); thread.setDaemon(true); thread.start(); &#125; &#125; 结果：1、当直接启动时，不会打印出内容2、当去掉thread.setDaemon(true)时，会打印出“我是非守护线程”。 原因分析：当thread被设置为守护线程时，主线程是前台线程，执行完之后就直接结束，JVM直接杀死thread，这个守护线程中的内容就不会继续执行下去；当去掉那一行时，thread就默认为前台线程，jvm会等所有前台线程执行完之后才会结束，thread线程就打印出内容 前台线程(用户线程、非守护线程)是指接受后台线程服务的线程，其实前台后台线程是联系在一起。由前台线程创建的线程默认也是前台线程。 单线程只包含一个线程的程序，即主线程(主方法所在线程)。 多线程可以同时运行一个以上线程的程序。在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制。当选择下一个线程时，操作系统考虑线程的优先级。 下面是单线程和多线程的关系示意图： 进程和线程的区别与关系1.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆、栈、程序计数器PC等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见。共享内存空间使线程之间的通信比进程之间的通信更有效、更容易，但也更具风险。2.创建一个新进程或进程之间的切换会有较大的开销，线程则更”轻量级”，创建、撤销、切换一个线程比启动一个新进程的开销要小得多。3.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线。4.进程是操作系统进行资源分配和调度的最小单位，线程是程序执行的最小单位。 线程的状态 新建状态: 使用 new 关键字创建一个 Thread 类或其子类的线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序调用它的start()方法启动这个线程，随后线程便进入了就绪状态。 就绪状态(可运行状态): 当线程对象调用了start()方法之后，该线程并不是立即开始运行，而是进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度，获取CPU使用权后才进入运行状态。 运行状态: 如果就绪状态的线程获取 CPU 使用权，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。处于运行状态的线程如果CPU的时间片用完或者调用了yield()方法都会转化为就绪状态。而如果线程调用了sleep()方法、join()方法、wait()方法、获取synchronized同步锁失败或发出了I/O请求(比如等待用户输入)，线程都会进入阻塞状态。 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态(注意阻塞状态无法直接转入运行状态，阻塞解除只能转入就绪状态！)。可以分为三种：1)等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待队列，即进入等待阻塞状态(wait()会释放线程持有的锁)，当调用notice()或noticeAll()方法线程重新转入就绪状态。2)同步阻塞：也称锁池状态，线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)进入同步阻塞状态，当其他线程释放该锁，并且线程调度器允许本线程持有它的时候，线程重新转入就绪状态。3)其他阻塞：通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 请求完毕(比如用户输入完毕)，线程重新转入就绪状态。 死亡状态(终止状态):一个线程执行完毕或者异常终止，该线程就切换到终止状态。其他四个状态都可以通过调用stop()方法来进入死亡状态，但stop()方法已经过时了，不建议使用。 线程的生命周期即前面提到的线程的五个状态之间的转化，可以通过调用Thread类的方法来影响线程的生命周期。 下面是线程生命周期的示意图： Thread类Thread类是一个线程类，位于java.lang包下。它实现了Runnable接口。1、构造方法2、常量3、常见方法更多见大牛博客JAVA线程-Thread类的方法 Runnable接口 只有一个方法run(); Runnable是Java中用于实现线程的接口 任何实现线程功能的类都必须实现该接口 创建线程创建线程主要有三种方式：一、继承Thread类创建线程类继承Thread类的方法尽管被列为一种多线程实现方式，但Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。 下面是使用这种方法创建线程的具体步骤：（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。（2）创建Thread子类的实例，即创建了线程对象。（3）调用线程对象的start()方法来启动该线程。 来看下面的一个例子：1234567891011121314151617package cn.habitdiary.thread;class MyThread extends Thread&#123; public void run()&#123; System.out.println(getName()+"该线程正在执行！"); //通过getName()获取线程名 &#125;&#125;public class ThreadTest &#123; public static void main(String[] args) &#123; System.out.println("主线程1"); MyThread mt=new MyThread(); mt.start();//启动线程 System.out.println("主线程2"); &#125;&#125; 在上述代码中，我们就通过创建一个继承自Thread类的子类MyThread的对象来创建了一个线程mt，此时该程序中共包含3个线程，一个是mt，一个是主方法所在的主线程，一个是垃圾收集器线程。三条输出语句的打印次序是随机的，这是因为某个线程何时获得CPU的使用权是CPU轮转调度的结果。值得注意的是，在Java中，每次程序运行至少启动2个线程。一个是主线程，一个是垃圾收集器线程。因为当执行一个程序的时候，实际上都会启动一个JVM，启动一个JVM就是在操作系统中启动了一个进程。我们通过下面的循环输出语句可以令这种线程间的时间片轮转调度更明显：123456789101112131415161718192021package cn.habitdiary.thread1;class MyThread extends Thread&#123; public MyThread(String name)&#123; super(name); &#125; public void run()&#123; for(int i=1;i&lt;=10;i++)&#123; System.out.println(getName()+"正在运行"+i); &#125; &#125;&#125;public class ThreadTest &#123; public static void main(String[] args) &#123; MyThread mt1=new MyThread("线程1"); MyThread mt2=new MyThread("线程2"); mt1.start(); mt2.start(); &#125;&#125; 运行结果如下：可以看到线程的打印语句随机交替出现，这就证明了线程获得CPU使用权是随机的。注意：1、不要直接调用Thread类或Runnable对象的run方法，如果直接调用run方法，只会执行同一个线程中的任务，而不会启动新的线程。启动线程的唯一方法就是通过Thread类的start()实例方法，这个方法将创建一个执行run方法的新线程。2、不要重复启动同一个线程，比如重复两次调用mt.start(),程序会抛出一个IllegalThreadStateException异常。3、这种继承Thread类创建线程类的方法已不再推荐，应该将要并行运行的任务与运行机制解耦合。如果有很多个任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池来解决这个问题，有关内容参看博客后面的内容。 二、通过实现Runnable接口创建线程类我们使用这种方法创建线程的频率更高。提供这种方式的原因有如下：1.Java不支持多继承，如果自定义类已经继承另一个类，就无法继承Thread，此时，必须实现Runnable接口。2.我们有时不打算重写Thread类的其他方法。 下面是使用这种方法创建线程的具体步骤：（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。（2）创建 Runnable实现类的实例，并依此实例作为Thread的构造方法Thread(Runnable target)的target参数来创建Thread对象，该Thread对象才是真正的线程对象。（3）调用线程对象的start()方法来启动该线程。 来看下面一个例子：123456789101112131415161718192021222324252627282930package cn.habitdiary.runnable;class PrintRunnable implements Runnable &#123; int i = 1; @Override public void run() &#123; while (i &lt;= 10) System.out.println(Thread.currentThread().getName() +"正在运行" + (i++)); /*无法直接调用getName()方法，而是要通过 Thread.currentThread()先获取当前线程的 对象，再在其上调用getName()方法*/ &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; PrintRunnable pr = new PrintRunnable(); Thread t1 = new Thread(pr); t1.start(); //PrintRunnable pr1 = new PrintRunnable(); Thread t2 = new Thread(pr); t2.start(); &#125;&#125; 在这段代码中，t1和t2共享PrintRunnable对象的成员变量i，所以语句被两个线程一共交替打印了十次。如果两个线程的pr是不同的PrintRunnable对象，则两个线程交替着各打印十次语句。这就是多个线程共享资源的简单例子。 注意：由于Runnable只有一个抽象方法，是一个函数式接口，所以我们也可以通过匿名内部类或lambda表达式的方式来简化上述创建线程的步骤。 三、通过Callable和Future创建线程 下面是使用这种方法创建线程的具体步骤：（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值，Callable接口是一个泛型接口。（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值，它是一个泛型类。（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 示例代码：12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.habitdiary.thread;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableThreadTest implements Callable&lt;Integer&gt;&#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++)&#123; System.out.println(Thread.currentThread().getName()+ " 的循环变量i的值"+i); if(i==20)&#123; new Thread(ft,"有返回值的线程").start(); &#125; &#125; try&#123; System.out.println("子线程的返回值："+ft.get()); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (ExecutionException e)&#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception&#123; int i; for(i = 0;i &lt; 100;i++)&#123; System.out.println(Thread.currentThread().getName() +" "+i); &#125; return i; &#125;&#125; 四、创建线程的三种方式的对比 1)采用实现Runnable、Callable接口的方式创建多线程优势：1.线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。2.在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。3.线程池只能放入实现Runable或callable类的线程，不能直接放入继承Thread的类。 劣势：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 2)使用继承Thread类的方式创建多线程优势：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。劣势：线程类已经继承了Thread类，所以不能再继承其他父类。且继承Thread不适合线程间进行资源共享。 线程调度1、线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。JVM提供了10个线程优先级，即1到10的整数，超出这个范围会抛出异常，但它们与常见的操作系统都不能很好的映射，比如Windows只有7个优先级。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类里三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。主线程的优先级为5。默认情况下，一个线程继承它的父线程的优先级。Thread类中提供了三个常量来表示优先级，分别为：Thread.MIN_PRIORITY(等价于1)Thread.MAX_PRIORITY(等价于10)Thread.NORM_PRIORITY(等价于5)每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于操作系统环境和CPU的调度方式的，不能保证线程执行的顺序，即优先级高的线程呢不一定先执行。例如虽然设置了优先级，但启动线程start()有先后顺序等影响了线程的执行顺序。初级程序员常常过度使用线程优先级，不要将程序构建为功能的正确性依赖于优先级。如果确实要使用优先级，应该避免初学者常犯的一个错误。如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。每当调度器决定运行一个新线程时,首先会在具有高优先级的线程中进行选择,尽管这样会使低优先级的线程完全饿死。 Thread类提供了改变和获取某线程优先级的方法 2、线程休眠线程休眠是使线程让出CPU使用权的最简单做法，某线程休眠的时候，会将CPU交给其他线程，以便轮换执行，而它自身进入阻塞状态，休眠一定时间后，线程会苏醒，进入就绪状态等待执行。线程的休眠方法是Thread.sleep(long millis)和Thread.sleep(long millis,int nanos)，均为静态方法，millis参数设定睡眠的时间，以毫秒为单位。调用sleep休眠的哪个线程呢？在哪个线程中调用sleep，哪个线程就休眠。来看一个例子，线程1休眠后，让出CPU，线程2执行，线程2执行完后，线程2休眠，让出CPU供线程1执行(此时线程1已经休眠结束，在就绪状态)，如此循环执行，直到结束。 12345678910111213141516171819202122232425262728293031323334 package Thread; public class SleepTest &#123; public static void main(String[] args)&#123; Thread t1=new MyThread_1(); Thread t2=new Thread(new MyRunnable1()); t1.start(); t2.start(); &#125; &#125;class MyThread_1 extends Thread&#123; public void run()&#123; for(int i=0;i&lt;3;i++)&#123; System.out.println("线程1第"+i+"次执行！"); try&#123; Thread.sleep(500); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;class MyRunnable1 implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;3;i++)&#123; System.out.println("线程2第"+i+"次执行！"); try&#123; Thread.sleep(500); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 结果如下： 注意：调用sleep()方法时必须处理可能抛出的InterruptedException，一般用try-catch块即可。 sleep方法的应用场景：可以实现计时器效果或定期刷新数据的效果，但是由于线程在苏醒之后不会直接进入运行状态，而是进入就绪状态等待获取CPU使用权，所以同一线程两次执行的时间间隔会略大于休眠时间，不能保证精确定时。 我是彩蛋: 了解了线程休眠，我们就可以写出传说中的睡眠排序了hhh，参考大牛博客排序算法–睡眠排序、面条排序、猴子排序 (非常严肃) 3、线程加入join方法，重载形式如下：在当前线程中调用要加入的线程的join()方法，则当前线程转入阻塞状态，转而执行新加入的线程，即新加入的线程被优先执行，抢占了CPU资源，直到该进程运行结束(如果调用带参的join方法，则超出时限该进程就会让出CPU)，当前线程再由阻塞转为就绪状态。可以认为join方法的作用是父线程等待子线程执行完成后再执行，换句话说是将异步执行的线程合并为同步执行的线程。 下面是一个例子：12345678910111213141516171819202122232425package com.imooc.join;class MyThread extends Thread&#123; public void run()&#123; for(int i=1;i&lt;=500;i++) System.out.println(getName()+"正在执行"+i+"次！"); &#125;&#125;public class JoinDemo &#123; public static void main(String[] args) &#123; MyThread mt=new MyThread(); mt.start(); try &#123; mt.join(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for(int i=1;i&lt;=20;i++)&#123; System.out.println("主线程运行第"+i+"次！"); &#125; System.out.println("主线程运行结束！"); &#125;&#125; 注意：join方法也会抛出InterruptedException，要进行异常处理。 4、线程让步让步使用Thread.yield()方法，yield方法为静态方法，功能是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。让出的时间和让出给哪个线程都是不可设定的，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程。例子：一个线程先让步，让另一个线程先执行，然后再执行该线程。12345678910111213141516171819202122232425package cn.habitdiary.thread;public class YieldTest &#123; public static void main(String[] args)&#123; Thread t1=new MyThread(); Thread t2=new Thread(new MyRunnable()); t2.start(); t1.start(); &#125; &#125; class MyThread extends Thread&#123; public void run()&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println("线程1第"+i+"次执行！"); &#125; &#125; &#125; class MyRunnable implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;10;i++)&#123; System.out.println("线程2第"+i+"次执行！"); Thread.yield(); &#125; &#125; &#125; sleep()和yield()的区别 sleep()使当前线程进入阻塞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。 sleep 方法使当前运行中的线程休眠一段时间，进入阻塞状态，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。 另外，sleep 方法允许较低优先级的线程获得运行机会，但 yield()方法执行时，当前线程仍处在就绪状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较高优先级的线程没有调用 sleep() 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有较高优先级的线程运行结束，才有机会运行。 5、未捕获异常处理器线程同步在大多数实际的多线程应用中, 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象, 并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？可以想象,线程彼此踩了对方的脚。根据各线程访问数据的次序，可能会产生讹误的对象。这样一个情况通常称为竞争条件(race condition)。 我们先来看一个银行存取款的例子。 Bank类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package cn.habitdiary.bank;public class Bank &#123; private String account;// 账号 private int balance;// 账户余额 public Bank(String account, int balance) &#123; this.account = account; this.balance = balance; &#125; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public int getBalance() &#123; return balance; &#125; public void setBalance(int balance) &#123; this.balance = balance; &#125; @Override public String toString() &#123; return "Bank [账号：" + account + ", 余额：" + balance + "]"; &#125; // 存款 public void saveAccount() &#123; // 获取当前的账号余额 int balance = getBalance(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 修改余额，存100元 balance += 100; // 修改账户余额 setBalance(balance); // 输出存款后的账户余额 System.out.println("存款后的账户余额为：" + balance); &#125; public void drawAccount() &#123; /* 在不同的位置处添加sleep方法来模拟方法在执行过程因为 时间片轮转而发生暂停的情况*/ // 获得当前的帐户余额 int balance = getBalance(); // 修改余额，取200 balance = balance - 200; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 修改帐户余额 setBalance(balance); System.out.println("取款后的帐户余额：" + balance); &#125;&#125; SaveAccount类1234567891011package cn.habitdiary.bank;//存款public class SaveAccount implements Runnable&#123; Bank bank; public SaveAccount(Bank bank)&#123; this.bank=bank; &#125; public void run()&#123; bank.saveAccount(); &#125;&#125; DrawAccount类12345678910111213package com.imooc.bank;//取款public class DrawAccount implements Runnable&#123; Bank bank; public DrawAccount(Bank bank)&#123; this.bank=bank; &#125; @Override public void run() &#123; bank.drawAccount(); &#125; &#125; Test类123456789101112131415161718192021222324package com.imooc.bank;public class Test &#123; public static void main(String[] args) &#123; // 创建帐户，给定余额为1000 Bank bank=new Bank("1001",1000); //创建线程对象 SaveAccount sa=new SaveAccount(bank); DrawAccount da=new DrawAccount(bank); Thread save=new Thread(sa); Thread draw=new Thread(da); save.start(); draw.start(); try &#123; draw.join(); save.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(bank); &#125;&#125; 我们把程序设计为账户初始金额1000元，存100元，取200元，余额应该为900元。但输出结果如下： 这样的银行系统给人极不可靠的感觉，我们来分析一下原因：由于存取款方法都对同一个数据balance进行操作，很可能在执行存款方法的SaveAccount线程运行到balance += 100时被剥夺了CPU使用权，所以还没来得及修改账户余额，而其中的balance局部变量为1100。此时转入执行取款方法的DrawAccount线程，由于账户余额未被修改还是1000，当这个线程运行到balance = balance + 200;时，balance局部变量为800，此时线程可能又转入SaveAccount线程，继续执行setBalance方法把账户余额设置为1100元并打印输出，之后又回到DrawAccount把账户余额设置为800元再打印输出，于是造成了混乱。混乱的可能还不只如此，这里我们引入一个原子性的概念。在Java中，对基本数据类型的变量的读取和简单赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。比如下面4条赋值语句：1）x = 10 2）x = y 3）x++ 4）x = x + 2只有1)是原子性操作，2)要先读取y的值并放入寄存器，再赋值给内存中的x，3)和4)则都要先读取x的值。所以一条非原子性的Java语句由多条指令组成，它在执行过程中的任何一个时间点都可能被其他线程打断。所以上述问题的发生的原因就在于存取款方法不是原子性的，它们在执行的过程中可能被其他线程在随机时间点打断，而这些方法操作的又是同一个数据，所以造成了数据更新延迟、更新的数据被覆盖等讹误。 为了解决这一问题达到线程同步的目的。我们需要引入锁。多线程的锁，其实本质上就是给一块内存空间的访问添加访问权限，因为Java中是没有办法直接对某一块内存进行操作的，又因为Java是面向对象的语言，一切皆对象，所以具体的表现就是某一个对象承担锁的功能，每一个对象都可以是一个锁。现在的Java语言中，提供了2种锁，一种是语言特性提供的内置锁，还有一种是java.util.concurrent.locks 包中的显式锁。我们来一一介绍： 1、内置锁内置锁是用语言特性实现的锁，即使用 synchronized 关键字，又叫同步锁、互斥锁，Java的所有对象都有一个同步锁，甚至每个类的class对象也对应一个同步锁。我们先引入一个临界区的概念，临界区是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。Java提供了同步机制。当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已有其他线程进入临界区。如果没有其他线程进入临界区，它就可以进入临界区，即获得了该同步锁；如果已有线程进入了临界区，即同步锁被其他线程占用，它就被同步机制挂起，直到进入的线程离开这个临界区并释放锁，JVM允许它持有锁才能进入临界区。如果在等待进入临界区的线程不止一个，JVM会随机选择其中的一个，其余的将继续等待。使用synchronized内置锁的好处在于，无论线程是执行完临界区代码正常退出还是抛出异常，JVM都会自动释放锁。 synchronized 修饰的对象包括以下几种： 修饰一个代码块被修饰的代码块称为同步代码块，其作用的范围(临界区)是大括号{}括起来的代码，锁住的对象是括号里的obj对象。例如：123456789101112synchronized(obj) /*obj是同步锁锁住的对象,如果是this， 就表示锁住当前对象*/ &#123; System.out.println("我是同步代码块"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 修饰一个非静态方法被修饰的方法称为同步方法，临界区是整个方法，锁住的对象是调用这个方法的对象。例如：123456789101112public synchronized void Method() &#123; System.out.println("我是同步方法1"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 下面使用同步代码块的写法是等价的，临界区是整个方法，锁住的也是调用方法的对象：1234567891011121314public void Method() &#123; synchronized(this)&#123; System.out.println("我是同步方法2"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;在 修改一个类其临界区是synchronized后面大括号括起来的部分，作用的对象是这个类的所有对象。1234567891011synchronized(Test.class)&#123; System.out.println(＂我修饰Test类＂); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 修饰一个静态方法其临界区是整个静态方法，锁住的对象是这个类的所有对象。例如：12345678910111213public class Test&#123; public static synchronized void Method()&#123; System.out.println("我修饰静态方法"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下面使用同步代码块的写法是等价的，临界区是整个静态方法，锁住的对象也是这个类的所有对象。12345678910111213141516public void Method()&#123; synchronized (Test.class) &#123; System.out.println(＂我修饰静态方法＂); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 对象锁(方法锁)和类锁根据锁住的是对象还是类，我们把同步锁分为对象锁(方法锁)和类锁。对象锁就是方法锁，是用于非静态方法或者一个对象实例上的;类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。也就是说，对象锁只是锁住了一个对象的代码段，防止多个线程同时执行同一对象的同一代码段，但多个线程访问不同对象的这一代码段不受干扰。而类锁则可以锁住同一个类的所有实例对象，它起到了全局锁的作用，真正锁住了代码段。 例子见大牛博客：synchronized锁住的是代码还是对象 注意： 我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。原因是基于以上的思想，锁的代码段过长，其他线程等待进入临界区的时间会很长。 学习了synchronized关键字，我们就可以解决银行转账的讹误了！只要用给setAccount()和drawAccount()加锁即可。 使用内置锁的缺点：内置锁在采取的是无限等待的策略，一旦开始等待，就既不能中断也不能取消，容易产生饥饿与死锁的问题。在线程调用notify方法时，会随机选择相应对象的等待队列的一个线程将其唤醒，而不是按照FIFO(先入先出)的方式，如果有强烈的公平性要求，就无法满足。 2、显式锁java.util.concurrent.locks 包中提供了可重入锁(ReentrantLock)，是一种递归无阻塞的同步机制。它是一种显式锁，需要显式进行 lock 以及 unlock 操作。 用 ReentrantLock 保护代码块的基本结构如下 :123456789myLock.lock() ; // myLock是一个ReentrantLock对象try&#123; //被同步的临界区&#125;finally&#123;myLock.unlock(); //即使异常抛出也要关闭锁&#125; 这一结构确保任何时刻只有一个线程进人临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock 语句。当其他线程调用 lock 时，它们被阻塞，直到第一个线程释放锁对象。 可重入锁：又称递归锁，可重入是指一个线程可以重复获得已持有的锁。即一个线程获得了某个对象的锁，此时这个对象还没有释放，当这个线程再次想获得这个对象的锁的时候还是可以获得的。synchronized和ReentrantLock都是可重入的。应用场景：1、递归调用一个带锁的方法2、在一个带锁的方法里嵌套调用另一个需要同一个对象的锁的方法。如果锁是不可重入的，那么内部方法将无法获得外部方法的锁，一直等待外部方法释放该锁，于是造成了死锁。 每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计加1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个ReentrantLock锁住的方法或synchronized方法/块时，计数器会递减，直到计数器为0才释放该锁。 注意：1.把解锁操作置于 finally 子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。2.如果使用锁，就不能使用带资源的 try 语句。首先，解锁方法名不是 close。不过，即使将它重命名，带资源的 try 语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享的那个变量 (而不是新变量)。 条件对象通常, 线程进人临界区，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程，我们在条件对象上可以调用Condition类的await(),signal(),signalAll()方法，它们的功能分别对应Object类的wait(),notify(),notifyAll()方法，但前者一般和ReentrantLock配合使用，后者和synchronized块配合使用。我们来介绍Java 库中条件对象的实现。下面是条件对象相关的API 我们来看一个满足账户余额充足条件才能取款的例子。1234567891011121314151617181920212223242526272829class Bank&#123; private Condition sufficientFunds; //条件对象 private Lock bankLock = new ReentrantLock(); //锁对象 private int balance;//账户余额 ... public Bank() &#123; ... sufficientFunds = bankLock.newCondition(); //获得该锁的条件对象 &#125; public void drawAccount(int amount) &#123; bankLock.lock(); try &#123; while(balance &lt; amount) sufficientFunds.await(); //saveAccount ... sufficientFunds.signalAll(); &#125; finally &#123; bankLock.unlock(); &#125; &#125; 我们一般使用类似结构检测条件是否满足：12while(!(ok to proceed)) condition.await(); 线程中断当线程的 run 方法执行方法体中最后一条语句后，或者出现了在方法中没有捕获的异常时, 线程将终止。在 Java 的早期版本中，还有一个 stop 方法, 其他线程可以调用它终止线程。但是，这个方法现在已经被弃用了。没有可以强制线程终止的方法。然而,interrupt方法可以用来请求终止线程。当对一个线程调用 interrupt 方法时, 线程的中断状态将被置位。这是每一个线程都具有的 boolean 标志。每个线程都应该不时地检査这个标志，以判断线程是否被中断。要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用 islnterrupted 方法:1234while (!Thread.currentThread().isInterrupted() &amp;&amp; more work to do)&#123;do more work&#125; 但是，如果线程被阻塞，就无法检测中断状态。这是产生 InterruptedException 异常的地方。当在一个被阻塞的线程 (调用 sleep 或 wait)上调用 interrupt 方法时, 阻塞调用将会被 InterruptedException 异常中断。没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是, 更普遍的情况是, 线程将简单地将中断作为一个终止的请求。这种线程的 run 方法具有如下形式：123456789101112131415Runnable r= () -&gt; &#123; try&#123; ... while (!Thread.currentThread().isInterrupted &amp;&amp; more work to do)&#123; do more work &#125; &#125; catch(InterruptedException e)&#123; // thread was interruputed during sleep or wait &#125; finally&#123; cleanup,if required &#125;// exiting the run method terminates the thread&#125;; 如果在每次工作迭代之后都调用 sleep 方法 (或者其他的可阻塞方法，isInterrupted 检测既没有必要也没有用处。如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并拋出InterruptedException。因此,如果你的循环调用sleep,不要检测中断状态。相反,要如下所示捕获InterruptedException异常:123456789101112131415Runnable r= () -&gt; &#123; try&#123; ... while (more work to do)&#123; do more work Thread.sleep(delay); &#125; &#125; catch(InterruptedException e)&#123; // thread was interruputed during sleep or wait &#125; finally&#123; cleanup,if required &#125;// exiting the run method terminates the thread&#125;; 注意：有两个非常类似的方法, interrupted 和isInterrupted。Interrupted 方法是一个静态方法，它检测当前的线程是否被中断。而且，调用 interrupted 方法会清除该线程的中断状态。另一方面，isInterrupted 方法是一个实例方法，可用来检验是否有线程被中断。调用这个方法不会改变中断状态。 在很多发布的代码中会发现 InterruptedException 异常被抑制在很低的层次上，像这样：123456void mySubTask()&#123; ... try &#123; sleep(delay) ; &#125; catch(InterruptedException e) &#123; &#125; // Don't ignore! ...&#125; 不要这样做！如果不认为在 catch 子句中做这一处理有什么好处的话，仍然有两种合理的选择: 在 catch 子句中调用 Thread.currentThread().interrupt() 来设置中断状态。于是，调用者可以对其进行检测。 12345678910void mySubTask()&#123; ... try &#123; sleep(delay);&#125; catch(InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; ...&#125; 或者, 更好的选择是, 用 throws InterruptedException 标记你的方法, 不采用 try 语句块捕获异常。于是，调用者(或者 最终的 run 方法)可以捕获这一异常。 123456void mySubTask() throws InterruptedException&#123; ... sleep(delay); ...&#125; 下面是与线程中断有关的API 线程间通信有时我们需要在线程之间进行通信，如上面银行的例子，如果账户余额不足，就要通知取款的线程暂停取款，等存款的线程把钱存入银行后再取款。 线程等待和线程通知我们来了解几个用于同步方法和同步代码块中进行线程间通信的常用方法。它们都是Object类的final方法，都只能在同步方法或同步代码块中调用，否则将抛出一个IllegalMonitorStateException。 wait方法wait()方法导致进入该同步方法或同步代码块的线程进入等待阻塞状态，并释放它持有的同步锁，它有三个重载的方法。1.void wait()导致进入该方法的线程进入等待状态，直到它被通知或者被中断。2.wait(long millis) 设定一个超时间隔，如果在规定时间内没有被通知或中断，线程将被唤醒，millis是毫秒数。3.wait(long millis,int nanos) 设定一个超时间隔，如果在规定时间内没有被通知或中断，线程将被唤醒，millis是毫秒数，nanos是纳秒数。 如果在等待阻塞状态线程被中断会抛出一个InterruptedException异常。 notify方法在同步方法或同步代码块调用该方法后，JVM会随机选择一个在该对象上调用wait方法的的线程，解除其阻塞状态。 notifyAll方法在同步方法或同步代码块调用该方法后，会解除所有在该对象上调用wait方法的线程的阻塞状态。 注意：线程被唤醒只是从等待阻塞状态进入了就绪状态，可以参与锁的竞争，但并不代表它已经获得了锁。 sleep方法和wait方法的区别最简单的区别是，wait方法只能用于同步方法或同步代码块，而sleep方法可以直接调用。而更深层次的区别在于sleep方法只是暂时让出CPU的执行权，并不释放同步锁。而wait方法则会释放锁。sleep()必须捕获异常，wait()不用捕获异常。一个调用了sleep()或wait()方法的线程如果调用interrupt()方法请求中断，都会立即抛出InterruptedException。 生产者-消费者模型下面使用wait()和notifyAll()配合实现一个经典的生产者-消费者模型，即一个线程生产，一个线程消费。12345678910111213141516171819202122232425262728293031323334353637//Queue.javapackage cn.habitdiary.queue;public class Queue &#123; private int n; boolean flag=false; public synchronized int get() &#123; if(!flag)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; System.out.println("消费："+n); flag=false;//消费完毕，容器中没有数据 notifyAll(); return n; &#125; public synchronized void set(int n) &#123; if(flag)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("生产："+n); this.n = n; flag=true;//生产完毕，容器中已经有数据 notifyAll(); &#125; &#125; 123456789101112131415161718192021222324//Producer.javapackage cn.habitdiary.queue;public class Producer implements Runnable&#123; Queue queue; Producer(Queue queue)&#123; this.queue=queue; &#125; @Override public void run() &#123; int i=0; while(true)&#123; queue.set(i++); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223//Consumer.javapackage cn.habitdiary.queue;public class Consumer implements Runnable&#123; Queue queue; Consumer(Queue queue)&#123; this.queue=queue; &#125; @Override public void run() &#123; while(true)&#123; queue.get(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 1234567891011package cn.habitdiary.queue;public class Test &#123; public static void main(String[] args) &#123; Queue queue=new Queue(); new Thread(new Producer(queue)).start(); new Thread(new Consumer(queue)).start(); &#125;&#125; 线程死锁如果最后一个活动线程在解除其他线程的阻塞状态之前就调用了wait()或await()，那么它也被阻塞，没有任何线程可以解除其他线程的阻塞，所有的线程都在互相等待，那么程序就发生了死锁。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之核心API]]></title>
    <url>%2F2018%2F01%2F30%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%A0%B8%E5%BF%83API%2F</url>
    <content type="text"><![CDATA[概述Java 的核心 API 是非常庞大的，这给开发者来说带来了很大的方便。所谓的 API 就是一些已经写好、可直接调用的类库。Java 里有非常庞大的 API，其中有一些类库是我们必须得掌握的，只有熟练掌握了 Java 一些核心的 API，我们才能更好的使用 Java。 参考资料：实验楼JDK 核心 API下面我们以包为单位对开发中常用的核心API进行总结。 java.lang包在程序中，java.lang 包并不需要像其他包一样需要import关键字进行引入。系统会自动加载，所以我们可以直接取用其中的所有类。下面我们就来详细地学习一下 java.lang 包吧。 包装类Java 是一种面向对象语言，Java 中的类把方法与数据连接在一起，构成了自包含式的处理单元。但在 Java 中不能定义基本数据类型(primitive type)对象，这样存在一个问题：即基本数据类型不具备对象特性，就不能进行对象化交互。为了能将基本类型视为对象进行处理，并能连接相关的方法，Java 为每个基本类型都提供了包装类。如 int 型数值的包装类 Integer，boolean 型数值的包装类 Boolean 等，这样便可以把这些基本类型转换为对象来处理了。下面将介绍Java 中提供的各种包装类。在这八个类名中，除了Integer类和Character类，其它六个类的类名和基本数据类型一致，只是类名的首字母大写，这八种包装类都是被final关键字修饰的，没有无参的构造方法，且是不可变的。其实还有两个包装类，但它们没有对应的基本数据类型，即java.math包中的BigInteger类和BigDecimal类，主要应用于高精度的运算，BigInteger 支持任意精度的整数，BigDecimal 支持任意精度带小数点的运算，它们没有被final关键字修饰。关于这两个类我们将在java.math包中进行详细介绍。 基本类型与包装类型的异同:1、在 Java 中，一切皆对象，但八大基本类型却不是对象。2、声明方式的不同，基本类型无需通过 new 关键字来创建，而包装类型需 new 关键字。3、存储方式及位置的不同，基本类型是直接存储变量的值保存在栈中能高效的存取，包装类型需要通过引用指向实例，具体的实例保存在堆中。4、初始值的不同，包装类型的初始值为 null，基本类型的的初始值视具体的类型而定，比如 int 类型的初始值为 0，boolean 类型为 false。5、使用方式的不同，比如与集合类合作使用时只能使用包装类型。 Number类在八种包装类中，数值包装类(除了Character和Boolean，它们的直接父类是Object)以及之后会介绍的java.math包中的BigInteger类和BigDecimal类都有一个共同的抽象父类，即Number类。在学习包装类之前，我们先来学习Number类。抽象类 Number 是父类,Number 的子类必须提供将表示的数值转换成 byte / double / float / long / int / short 的方法。Number 类的方法被 Number 的各子类所实现,常用方法如下: Integer类1、构造方法有两种:a) 以 int 型变量作为参数创建 Integer 对象,实例代码如下:1Integer number=new Integer(7); b) 以 String 型变量作为参数创建 Integer 对象,实例代码如下:1Integer number=new Integer(“7”); 2、常用方法:需要注意的是Integer也存在除了intValue()之外的其他xxxValue()方法，可以把Integer类型的对象转换为任意基本数值类型，这是从Number类继承的方法。还有，parseInt()方法有多个重载方法，可以把字符串转换为不同进制的基本数据类型。 3、常用的常量:a) MAX_VALUE: 表示 int 型可取的最大值b) MIN_VALUE: 表示 int 型可取的最小值c) SIZE:表示以二进制补码形式表示 int 值的位数d) TYPE: 表示基本类型 Class 实例 4、基本数据类型、包装类、字符串三者之间的转换：a)基本数据类型和包装类之间的转换我们先来认识两个概念：装箱与拆箱。装箱：把基本数据类型转换成包装类，分为自动装箱和手动装箱。拆箱：把包装类转换成基本数据类型，分为自动拆箱和手动拆箱。下面通过代码来演示：12345678910111213141516171819202122232425262728293031323334 //装箱：把基本数据类型转换成包装类 //自动装箱 int t1 = 2; Integer t2 = t1; //手动装箱 //1、构造方法 Integer t3 = new Integer(t1); //2、包装类的valueOf() Integer t4 = Integer.valueOf(t1); //拆箱：把包装类转换成基本数据类型 //自动拆箱 int t4 = t2; //手动拆箱 int t5 = t2.intValue();``` b)基本数据类型和字符串之间的转换 直接看代码： ```java //基本数据类型转换为字符串 int t1=2; String t2=Integer.toString(t1); //也可直接用'+'进行字符串连接，会自动调用toString() //字符串转换为基本数据类型 //1、包装类的parseInt int t3=Integer.parseInt(t2); /*2、包装类的valueOf()先将字符串转换为包装类， 再通过自动拆箱完成基本类型转换*/ int t4=Integer.valueOf(t2); c)包装类和字符串之间的转换123456789//包装类转换为字符串Integer t1 = 10;String t2 = t1.toString();//字符串转换为包装类 //1、构造方法 Integer t3 = new Integer("10");//2、包装类的valueOf()Integer t4 = Integer.valueOf("10"); 5、包装类对象间的比较我们先来看下面的代码：12345678910111213141516171819202122232425262728293031package wrap;public class WrapperTest &#123; public static void main(String[] args) &#123; Integer one=new Integer(100); Integer two=new Integer(100); System.out.println("one==two的结果："+(one==two));//1 false Integer three=100;//自动装箱 //自动装箱时隐式调用Integer three=Integer.valueOf(100); System.out.println("one==three的结果"+(one==three));//2 false System.out.println("three==100的结果："+(three==100));//3 自动拆箱 true //Integer four=100; Integer four=Integer.valueOf(100); System.out.println("three==four的结果："+(three==four));//4 true Integer five=200; System.out.println("five==200的结果："+(five==200));//5 true Integer six=200; System.out.println("five==six的结果："+(five==six));//6 false Double d1=Double.valueOf(100); System.out.println("d1==100的结果："+(d1==100));//7 true Double d2=Double.valueOf(100); System.out.println("d1==d2的结果："+(d1==d2));//8 false &#125;&#125; 我们先来引入一个对象池的概念，Java的内存空间主要分为栈、堆、常量池(对象池)，对象池可以认为是Java提供的缓存技术。当我们调用Integer的valueOf()方法且传入的参数在-128~127之间时(注意自动装箱的原理实际上就是编译器隐式调用了这个方法)，会首先在常量池中查找是否存在该对象，如果不存在，就在常量池中创建该对象，并让存在于栈中的Integer引用变量指向它;如果对象池中已经存在这个对象就直接让栈中的Integer引用变量指向它。 我们来逐一解释输出的结果：1处结果为false，因为每次使用new关键字，会在堆上新开辟一块内存空间，所以用==判断结果一定为false。2处结果为false，因为one指向的是堆上开辟的空间，而three自动装箱，会在对象池里创建对象，并指向对象池的对应空间，所以==判断结果为false。3处结果为true，因为当包装类和基本数据类型进行比较时会自动拆箱，相当于比较100==100,结果自然是true。4处结果为true，因为前面three自动装箱已经隐式调用valueOf方法并在对象池中创建过一个100的Integer对象(100在-128~127之间，所以会在对象池中创建该对象)，所以当four再次调用valueOf方法时会在对象池中进行寻找，找到该对象后four也指向该对象，所以three和four指向的是同一个对象，结果为true。5处结果为true，原因同3,不赘述。6处结果为false，这是因为200不在-128~127的范围，不能使用对象池。7处结果为true，自动拆箱，即比较100.0==100，结果为true。8处结果为false，因为在包装类中，Double和Float不存在对象池。 最后提醒：比较包装类的值不要使用==，此时并不会对两个包装类进行自动拆箱，而是和其他类型对象比较一样比较其地址，所以比较值还是使用equals或compareTo方法！！！ Boolean类Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean类型的对象只包含一个类型为 boolean 的字段。此外,此类还为 boolean 和String 的相互转换提供了许多方法,并提供了处理 boolean 时非常有用的其他一些常量和方法。1、构造方法:a) 创建一个表示 value 参数的 boolean 对象,实例如下:1Boolean b = new Boolean(true); b)以 String 变量作为参数,创建 boolean 对象。此时,如果传入的字符串不为 null,且忽略大小写后的内容等于”true”,则生成 Boolean 对象值为 true,反之为 false。1234Boolean b1 = new Boolean("ok"); System.out.println(b1); //输出falseBoolean b2=new Boolean("TRUE");System.out.println(b2); //输出true 2、常用方法:3、常用的常量:a) TRUE:对应基值 true 的 Boolean 对象;b) FALSR:对应基值 false 的 Boolean 对象;c) TYPE:表示基本类型 Class 实例 Byte类Byte 类将基本类型为 byte 的值包装在一个对象中,一个 byte 类型的对象只包含一个类型为 byte 的对象。此外,该类还为 byte 和 String 之间相互转换提供方法,并提供了一些处理 byte 时非常有用的常量。1、构造方法Byte 类提供了两种构造方法的重载形式来创建 BYTE 类对象:a) Byte (byte value) 通过这种方法创建的 byte 对象,可表示指定的 byte值。如：1Byte b = new Byte(45); b) Byte(String str) 通过这种方法创建的 byte 对象,可表示 String 参数指定的 byte 值，例:1Byte mybyte = new Byte("12"); 2、常用方法3、常用的常量a) MIN_VALUE: 最小值b) MAX_VALUE: 最大值c) SIZE: 二进制d) TYPE: 表示基本类型 byte 的 class 实例 Character类Character 类在对象中包装一个基本类型为 char 的值。一个 Character 对象包含类型为 char 的单个字段。1、构造方法Character 类的构造方法的语法如下:1Character(char value) 2、常用方法还有isDigit(ch)、isLetter(ch)、isLetterOrDigit(ch)等方法分别返回一个布尔值表示ch是否是数字字符、ch是否是字母、ch是否是字母或者数字。 Double类Double 和 Float 包装类是对 double、float 基本类型的封装,他们都是 Number 类的子类,又都是对小数进行操作,所以常用基本方法相同,Double 类在对象中包装一个基本类型为 double 的值,每个 double 类都包含一个 double 类型的字段。1、 构造方法Double 类提供了两种构造方法来获得 Double 类对象a) Double(double value): 基于 double 参数创建 Double 类对象;b) Double(String str): 构造一个新分配的 Double 对象,表示用字符串表示的 Double 类型的浮点值2、常用方法 Math类我们在编程的过程中，经常需要对一些数字进行数学操作，如初等指数、对数、平方根和三角函数，其实 java.lang 里的 Math 类包含了用于执行基本数学运算的方法。我们就来学习一下吧！1、构造方法Math类的构造方法是private的，这样设计的意图是不让使用者创建Math类的对象，也就是说，Math类的所有方法都是静态方法。另外Math类是final的，设计为不能被继承。2、常用方法 String类1、构造方法2、常用方法(方法很多，勤查API) 特别关注：1)字符串的替换和分隔replace、replaceFirst、replaceAll、split等方法。2)依照模式匹配、替换和分隔(正则表达式)matches方法配合正则表达式。更多拓展还应学习java.util.regex 包里的Pattern类和Matcher类。3)字符串与字符数组之间的转换字符串转字符数组使用toCharArray()方法，字符数组转字符串使用字符串的构造方法String(char[])或valueOf(char[])。4)字符串与字符和数值之间的转换字符串转字符和数值使用包装类的parseXXX()方法或valueOf(String)方法，字符和数值转字符串可以使用’+’直接连接，也可以使用String类的valueOf方法。5)格式化字符串使用String类的静态format方法，可以格式化字符串。 3、等于运算符与equals方法的区别equals比较的是String对象的内容，==比较的是String对象的引用。值得注意的是，String类型变量看似存储了一个字符串，但它仍然属于引用类型变量，所以String类型变量存在于栈中，而实际的字符串对象存在于堆中或常量池中。String类型变量存储的是String对象的引用，String对象存储的才是字符串值。4、String对象的存储我们首先来看看Java中的内存分布。如果我们用String str = &quot;Hello world&quot;的形式创建字符串，会首先在常量池寻找是否存在这样的字符串常量，如果没有，就创建并让字符串变量指向它;如果有，就直接让字符串变量指向它。而如果使用String str = new str(&quot;Hello world&quot;)的形式，就在堆上重新开辟一块内存空间并让字符串变量指向它。示意图如下：5、String类的不可变性String类是不可变类，即String对象一旦被创建，其内容是不可变的。1234567891011121314151617package com.imooc.string;public class StringDemo6 &#123; public static void main(String[] args) &#123; //String的不可变性 //String对象一旦被创建，则不能修改，是不可变的 //所谓的修改其实是创建了新的对象，所指向的内存空间不变 String s1="imooc"; String s2="hello,"+s1; //s2指向"hello,imooc" s1="hello,"+s1; //s1不再指向imooc所在的内存空间，而是指向了"hello,imooc" System.out.println("s1="+s1);//s1=hello,imooc System.out.println("s2="+s2); //s2=hello,imooc &#125;&#125; StringBuilder类 &amp; StringBuffer类由于String类的不可变性，String在操作字符串时可能会产生很多冗余的中间字符串变量。所以，当需要频繁操作字符串时，建议使用StringBuilder类或StringBuffer类，这两个类是可变类。StringBuilder类和StirngBuffer类的区别两者除了StringBuffer修改缓冲区的方法是同步的，其他用法基本相同。而由于StringBuffer类是多线程安全的，所以在单线程程序中StringBuilder性能略高。所以建议在单线程情况下使用StringBuilder，多线程情况下使用StringBuffer。 由于两者的构造方法和常见方法基本相同，所以我们以StringBuffer为例进行介绍：1、构造方法2、常见方法 Class类详见Java学习总结之反射 Object类掌握Object类的九个方法：equals(),hashCode(),getClass(),toString(),clone(),finalize(),notify(),notifyAll(),wait()(三个重载方法)详见 Java学习总结之继承和多态 和 Java学习总结之并发 System类详见Java学习总结之Java IO系统 Enum类详见Java学习总结之Java基本程序设计结构 Thread类详见Java学习总结之并发 java.math包java.math包主要包含BigInteger类和BigDecimal类，主要应用于高精度的运算，BigInteger 支持任意精度的整数，BigDecimal 支持任意精度带小数点的运算。不要混淆java.math包和java.lang包中的Math类。 BigInteger类1、构造方法2、常见方法3、常量 BigDecimal类 1、构造方法2、常见方法3、常量 java.util包 Date类Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间。1.构造方法2.常用方法 1.获取当前日期时间Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：1234567891011import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); &#125;&#125; 2.日期比较Java使用以下三种方法来比较两个日期： 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。 3.使用 SimpleDateFormat 格式化日期SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：123456789101112131415import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat ("E yyyy.MM.dd 'at' hh:mm:ss a zzz"); /*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年， MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。*/ System.out.println("Current Date: " + ft.format(dNow)); &#125;&#125; 注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。运行结果如下:Current Date: Wed 2016.11.09 at 08:23:19 AM UTC 日期和时间的格式化编码时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下： 4.使用printf格式化日期见博文 Java学习总结之Java基本程序设计结构 的printf部分 5.解析字符串为时间SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：12345678910111213141516171819202122import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd"); String input = args.length == 0 ? "1818-11-11" : args[0]; System.out.print(input + " Parses as "); Date t; try &#123; t = ft.parse(input); System.out.println(t); &#125; catch (ParseException e) &#123; System.out.println("Unparseable using " + ft); &#125; &#125;&#125; 以上实例编译运行结果如下:java DateDemo1818-11-11 Parses as Wed Nov 11 00:00:00 GMT 1818java DateDemo 2007-12-012007-12-01 Parses as Sat Dec 01 00:00:00 GMT 2007 6.Calendar类我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢?答案是使用 Calendar 类。Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。1) 构造方法创建一个代表系统当前日期的Calendar对象123Calendar c = Calendar.getInstance();/*默认是当前日期,返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象*/ 创建一个指定日期的Calendar对象使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。123//创建一个代表2009年6月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2009, 6 - 1, 12); Calendar类对象字段类型Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想 Calendar类对象信息的设置Set设置如：1Calendar c1 = Calendar.getInstance(); 调用：1234public final void set(int year,int month,int date)c1.set(2009, 6 - 1, 12);/*把Calendar对象c1的年月日分别设这为：2009、6、12,注意月份是从0开始的！*/ 利用字段类型设置如果只设定某个字段，例如日期的值，则可以使用如下set方法：1public void set(int field,int value) 把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算1c1.set(Calendar.DATE,10); 把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算1c1.set(Calendar.YEAR,2008); 其他字段属性set的意义以此类推 Add设置1Calendar c1 = Calendar.getInstance(); 把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算1c1.add(Calendar.DATE, 10); 把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算1c1.add(Calendar.DATE, -10); 其他字段属性的add的意义以此类推 Calendar类对象信息的获得12345678910111213141516Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);/* 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）*/int day = c1.get(Calendar.DAY_OF_WEEK); 7.GregorianCalendar类Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。 下面列出GregorianCalendar对象的几个构造方法： 这里是 GregorianCalendar 类提供的一些有用的方法列表： 实例12345678910111213141516171819202122232425262728293031323334import java.util.*; public class GregorianCalendarDemo &#123; public static void main(String args[]) &#123; String months[] = &#123; "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"&#125;; int year; // 初始化 Gregorian 日历 // 使用当前时间和日期 // 默认为本地时间和时区 GregorianCalendar gcalendar = new GregorianCalendar(); // 显示当前时间和日期的信息 System.out.print("Date: "); System.out.print(months[gcalendar.get(Calendar.MONTH)]); System.out.print(" " + gcalendar.get(Calendar.DATE) + " "); System.out.println(year = gcalendar.get(Calendar.YEAR)); System.out.print("Time: "); System.out.print(gcalendar.get(Calendar.HOUR) + ":"); System.out.print(gcalendar.get(Calendar.MINUTE) + ":"); System.out.println(gcalendar.get(Calendar.SECOND)); // 测试当前年份是否为闰年 if(gcalendar.isLeapYear(year)) &#123; System.out.println("当前年份是闰年"); &#125; else &#123; System.out.println("当前年份不是闰年"); &#125; &#125;&#125; 运行结果如下：Date: Apr 22 2009Time: 11:25:27当前年份不是闰年 Random类Java 实用工具类库中的类 java.util.Random 提供了产生各种类型随机数的方法。它可以产生 int、long、float、double 以及 Gaussian 等类型的随机数。这也是它与 java.lang.Math 中的方法 Random() 最大的不同之处，后者只产生 double 型的随机数。1、构造方法2、常见方法123456789101112131415161718192021//该方法是设定基值seedpublic synchronized void setSeed(long seed)//该方法是产生一个整型随机数 public int nextInt()//该方法是产生一个long型随机数public long nextLong()//该方法是产生一个Float型随机数public float nextFloat() //该方法是产生一个Double型随机数public double nextDouble()//该方法是产生一个double型的Gaussian随机数public synchronized double nextGaussian()/*synchronized 是 Java 语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码*/ Scanner类详见Java学习总结之Java基本程序设计结构 Arrays类详见Java学习总结之Java基本程序设计结构 集合框架详见Java学习总结之集合 java.io包详见Java学习总结之Java IO系统]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之设计模式]]></title>
    <url>%2F2018%2F01%2F30%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式概述设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 提出者设计模式是由GOF(四人帮，Gang of Four)提出的。在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则： 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用设计模式在软件开发中的两个主要用途。 开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的七大原则1、单一职责原则（SRP：Single Responsibility Principle）所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。 2、开闭原则（OCP：Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 3、里氏代换原则（LSP：Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 4、依赖倒转原则（DIP：Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 5、接口隔离原则（ISP：Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 6、迪米特法则，又称最少知道原则（DP：Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 7、合成复用原则（CRP：Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 下面我们将通过Java实例来总结常用的设计模式。创建型模式1、工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 步骤 1创建一个接口。Shape.java123public interface Shape &#123; void draw();&#125; 步骤 2创建实现接口的实体类。Rectangle.java1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; Square.java1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; Circle.java1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。ShapeFactory.java123456789101112131415161718public class ShapeFactory &#123; /*使用 getShape 方法获取形状类型的对象， 在实际操作中建议把CIRCLE等定义为常量*/ public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125;&#125; 步骤 4使用该工厂，通过传递类型信息来获取实体类的对象。FactoryPatternDemo.java123456789101112131415161718192021222324public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 步骤 5验证输出。Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method. 使用反射机制可以解决每次增加一个产品时，都需要增加一个对象实现工厂接口的缺点。注意要使用完整包名，也可以使用Properties文件做映射。123456789101112131415161718public class ShapeFactory &#123; public Shape getShapeByClassName(String className) &#123; Shape obj = null; try &#123; obj = (Shape)Class.forName(clazz.getName()).newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 工厂模式的实际应用 2、抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。 为了方便引进抽象工厂模式，引进一个新概念：产品族（Product Family）。所谓产品族，是指位于不同产品等级结构，功能相关联的产品组成的家族。如图：图中一共有四个产品族，分布于三个不同的产品等级结构中。同一个产品族是同一个工厂生产的，而不同等级结构来自不同的工厂。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。所谓的抽象工厂是指一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。如果用图来描述的话，如下图： 介绍意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：主要解决接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 上图的描述用产品族描述如下： 实现我们来举这样一个例子，QQ秀有不同的装扮，分为男孩和女孩，而男孩又分为圣诞男孩和新年男孩，女孩分为圣诞女孩和新年女孩。那么就可以有一个抽象工厂生产男孩和女孩。两个具体的工厂分别生产圣诞系列的男孩和女孩、新年系列的男孩和女孩。同一系列的男孩和女孩是一个产品族，而不同系列构成不同的产品等级。 步骤 1为男孩创建一个接口。Boy.java123public interface Boy &#123; public void drawMan();&#125; 步骤 2创建实现接口的实体类。MCBoy.java12345678public class MCBoy implements Boy &#123; @Override public void drawMan() &#123; System.out.println("-----------------圣诞系列的男孩子--------------------"); &#125;&#125; HNBoy.java12345678public class HNBoy implements Boy &#123; @Override public void drawMan() &#123; System.out.println("-----------------新年系列的男孩子--------------------"); &#125;&#125; 步骤 3为女孩创建一个接口Girl.java123public interface Girl &#123; public void drawWomen();&#125; 步骤 4创建实现接口的实体类。MCGirl.java12345678public class MCGirl implements Girl &#123; @Override public void drawWomen() &#123; System.out.println("-----------------圣诞系列的女孩子--------------------"); &#125;&#125; HNGirl.java123456789public class HNGirl implements Girl &#123; @Override public void drawWomen() &#123; // TODO Auto-generated method stub System.out.println("-----------------新年系列的女孩子--------------------"); &#125;&#125; 步骤 5创建生产男孩女孩的抽象工厂接口PersonFactory.java123456public interface PersonFactory &#123; //男孩接口 public Boy getBoy(); //女孩接口 public Girl getGirl(); &#125; 步骤 6创建生产圣诞和新年系列的具体工厂MCFactory.java12345678910111213public class MCFctory implements PersonFactory &#123; @Override public Boy getBoy() &#123; return new MCBoy(); &#125; @Override public Girl getGirl() &#123; return new MCGirl(); &#125;&#125; HNFactory.java12345678910111213public class HNFactory implements PersonFactory &#123; @Override public Boy getBoy() &#123; return new HNBoy(); &#125; @Override public Girl getGirl() &#123; return new HNGirl(); &#125;&#125; 步骤 7使用工厂生产AbstractFactoryPatternDemo.java1234567891011121314public class AbstractFactoryPatternDemo&#123; public static void main(String[] args)&#123; MCFactory mcFactory = new MCFactory(); HNFactory hnFactory = new HNFactory(); Boy mcBoy = mcFactory.getBoy(); Girl mcGirl = mcFactory.getGirl(); Boy hnBoy = hnFactory.getBoy(); Girl hnGirl = hnFactory.getGirl(); mcBoy.drawMan(); mcGirl.drawWomen(); hnBoy.drawMan(); hnGirl.drawWomen(); &#125;&#125; 步骤 8验证输出—————–圣诞系列的男孩子——————–—————–圣诞系列的女孩子——————–—————–新年系列的男孩子——————–—————–新年系列的女孩子——————– 注意：抽象工厂也可以运用反射，只不过反射的不再是产品类，而是不同的具体工厂类。 3、单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。注意：1、单例类只能有一个实例。2、单例类必须自己创建自己的唯一实例，而不是在外部随意地new对象。3、单例类必须给所有其他对象提供这一实例。 介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决：一个全局使用的类频繁地创建与销毁。何时使用：当想控制实例数目，节省系统资源的时候。如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。优点： 1、在内存里只有一个实例，减少了内存的开销。2、避免频繁的创建和销毁实例，提高性能（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。缺点：1、扩展比较困难，没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。2、如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失。使用场景： 1、当多个实例存在可能引起程序逻辑错误，如要求生产唯一序列号。 2、对系统内资源要求统一读写，如读写配置信息，又如WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，但同时又需要用到该对象，比如 I/O 与数据库的连接等。注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。步骤 1创建一个 Singleton 类。123456789101112131415161718SingleObject.javapublic class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 步骤 2从 singleton 类获取唯一的对象。123456789101112131415SingletonPatternDemo.javapublic class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 步骤 3验证输出。1Hello World! 单例模式的几种实现方式单例模式的实现有多种方式，如下所示：1、懒汉式，线程不安全是否 Lazy 初始化：是是否多线程安全：否实现难度：易描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。假设开始线程1进入，判断instance为空，在将要创建实例时，时间片切换，线程2又进来了，同样判断instance为空，创建了实例，这是CPU调度回到线程1，继续创建实例。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。代码实例：123456789101112public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; /*懒汉式标志：Lazy 初始化, 在外部第一次请求使用该类对象时才实例化，是时间换空间的模式*/ instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。2、懒汉式，线程安全是否 Lazy 初始化：是是否多线程安全：是实现难度：易描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。代码实例：1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; //加同步锁 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式是否 Lazy 初始化：否是否多线程安全：是实现难度：易描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。代码实例：123456789public class Singleton &#123; private static Singleton instance = new Singleton(); /*饿汉式标志：在类加载时直接初始化， 是空间换时间的模式*/ private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁/双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起是否 Lazy 初始化：是是否多线程安全：是实现难度：较复杂描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。这种方法既能保证线程安全又能提高了效率。假设线程1进入方法，instance为空，进入同步代码块，时间片切换，线程2进来，instance为空，在同步代码块外被阻塞，因为此时线程1正在里面。cup切换，线程1执行创建实例，当2再进入代码块后，此时instace不为空，直接返回instance。当再有线程进来，instance不为空，不用执行同步代码块，提高了效率。代码实例：1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 5、登记式/静态内部类是否 Lazy 初始化：是是否多线程安全：是实现难度：一般描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。代码实例：123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 6、枚举JDK 版本：JDK1.5 起是否 Lazy 初始化：否是否多线程安全：是实现难度：易描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。代码实例：12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 4.建造者模式5.原型模式结构型模式6.适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 介绍意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 实现我们来看这样一个例子，笔记本(Laptop)需要三相插座(ThreePlugIf)充电，但是只有一个国标二相插座(GBTwoPlug),我们可以使用一个适配器来使用二相插座给笔记本充电。 (1)使用组合方式实现对象适配器把“被适配者”作为一个对象组合到适配器类中，以修改目标接口包装“被适配者”。ThreePlugIf.java12345678/* * 三相插座接口 */public interface ThreePlugIf &#123; //使用三相电流供电 public void powerWithThree();&#125; GBTwoPlug.java1234567public class GBTwoPlug &#123; //使用二相电流供电 public void powerWithTwo()&#123; System.out.println("使用二相电流供电"); &#125;&#125; TwoPlugAdapter.java1234567891011121314151617/* * 二相转三相的插座适配器 */public class TwoPlugAdapter implements ThreePlugIf &#123; private GBTwoPlug plug; public TwoPlugAdapter(GBTwoPlug plug)&#123; this.plug = plug; &#125; @Override public void powerWithThree() &#123; System.out.println("通过转化"); plug.powerWithTwo(); &#125;&#125; Laptop.java1234567891011121314151617181920public class Laptop &#123; private ThreePlugIf plug; public Laptop(ThreePlugIf plug)&#123; this.plug = plug; &#125; //使用插座充电 public void charge()&#123; plug.powerWithThree(); &#125; public static void main(String[] args) &#123; GBTwoPlug two = new GBTwoPlug(); ThreePlugIf three = new TwoPlugAdapter(two); Laptop lp = new Laptop(three); lp.charge(); &#125;&#125; 验证输出：通过转化使用二相电流供电 分析：Laptop需要一个实现ThreePlugIf接口的对象来使用三相电流供电，我们就传入一个实现了该接口的适配器，看似调用了powerWithThree()方法，实际上是调用了组合在适配器里的GBTwoPlug的powerWithTwo()方法。 (2)使用继承方式实现类适配器继承“被适配者”并实现目标接口。TwoPlugAdapterExtends.java12345678910111213/* * 采用继承方式的插座适配器 */public class TwoPlugAdapterExtends extends GBTwoPlug implements ThreePlugIf &#123; @Override public void powerWithThree() &#123; System.out.println("借助继承适配器"); this.powerWithTwo(); &#125;&#125; Laptop.java1234567891011121314151617181920public class Laptop &#123; private ThreePlugIf plug; public Laptop(ThreePlugIf plug)&#123; this.plug = plug; &#125; //使用插座充电 public void charge()&#123; plug.powerWithThree(); &#125; public static void main(String[] args) &#123; three = new TwoPlugAdapterExtends(); lp = new Laptop(three); lp.charge(); &#125;&#125; 验证输出：借助继承适配器使用二相电流供电 两种方法比较，组合适配可以适配”被适配者”的任何子类(根据多态机制可以给适配器中的GBTwoPlug赋予GBTwoPlug的任何子类的引用)，但继承适配是为单一的类服务的(已经继承了GBTwoPlug，不能再继承它的子类)，只能适配”被适配者”。 7.桥接模式8.过滤器模式9.组合模式10.装饰器模式11.外观模式12.享元模式13.代理模式在代理模式（Proxy Pattern）中，代理对象为其他对象提供代理以控制对被代理对象的访问。代理对象起到中介作用，可去掉功能服务或增加额外的服务，这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景：1、远程代理。为不同地理的对象提供局域网代表对象。比如通过远程代理监控分店的库存和销售情况。2、虚拟代理。根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建。3、Copy-on-Write 代理。4、保护（Protect or Access）代理。即控制对一个对象的访问权限。比如论坛游客和用户的权限。5、Cache代理。6、防火墙（Firewall）代理。7、同步化（Synchronization）代理。8、智能引用（Smart Reference）代理。提供对目标对象额外的服务。 注意事项： 菜鸟版JAVA设计模式—适配器模式，装饰模式，代理模式异同 实现我们来看这样一个例子，一辆车有行驶的功能，现在通过代理模式新增记录行驶时间的功能。 代理模式分类静态代理代理和被代理对象在代理之前是确定的。它们都实现相同的接口或者继承相同的抽象类。 1) 通过继承的方式实现静态代理 步骤 1定义Moveable接口 Moveable.java12345package com.imooc.proxy;public interface Moveable &#123; void move();&#125; 步骤 2定义Car类实现Moveable接口 Car.java123456789101112131415161718package com.imooc.proxy;import java.util.Random;public class Car implements Moveable &#123; @Override public void move() &#123; //实现开车 try &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println("汽车行驶中...."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 步骤 3定义代理类Car2类继承被代理类Car，并增加记录时间功能 12345678910111213141516package com.imooc.proxy;public class Car2 extends Car &#123; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println("汽车开始行驶...."); super.move(); long endtime = System.currentTimeMillis(); System.out.println("汽车结束行驶.... 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); &#125; &#125; 步骤 4定义测试类12345678910111213package com.imooc.proxy;public class Client &#123; /** * 测试类 */ public static void main(String[] args) &#123; Moveable m = new Car2(); m.move(); &#125;&#125; 2) 通过聚合的方式实现静态代理 步骤 1定义Moveable接口 Moveable.java12345package com.imooc.proxy;public interface Moveable &#123; void move();&#125; 步骤 2定义Car类实现Moveable接口 Car.java123456789101112131415161718package com.imooc.proxy;import java.util.Random;public class Car implements Moveable &#123; @Override public void move() &#123; //实现开车 try &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println("汽车行驶中...."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 步骤 3定义代理类Car3类实现Moveable接口并聚合被代理类Car，增加记录时间功能 12345678910111213141516171819package com.imooc.proxy;public class Car3 implements Moveable &#123; private Car car; public Car3(Car car) &#123; this.car = car; &#125; @Override public void move() &#123; long starttime = System.currentTimeMillis(); System.out.println("汽车开始行驶...."); car.move(); long endtime = System.currentTimeMillis(); System.out.println("汽车结束行驶.... 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); &#125;&#125; 步骤 4定义测试类1234567891011121314package com.imooc.proxy;public class Client &#123; /** * 测试类 */ public static void main(String[] args) &#123; Car car = new Car(); Moveable m = new Car3(car); m.move(); &#125;&#125; 比较两种实现静态代理的方式，会发现随着功能的扩展，使用继承的方式的代理类数量会膨胀，难以维护，而使用聚合的方式更加灵活。所以，聚合比继承更适合代理模式。 动态代理在上面的例子中我们会发现一个问题，如果想要对自行车、火车等进行记录时间的代理，还需要创建自行车代理类、火车代理类等，如果有很多类需要代理，会造成代理类膨胀。而动态代理能动态产生代理，实现对不同类,不同方法的代理。 1) 通过JDK实现动态代理JDK提供了动态代理的API。代理对象不需要实现目标接口，但目标对象必须实现目标接口。代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)，JDK动态代理也叫做接口代理。 我们用动态代理来实现上面的例子 步骤 1定义Moveable接口 Moveable.java12345package com.imooc.proxy;public interface Moveable &#123; void move();&#125; 步骤 2定义Car类实现Moveable接口 Car.java123456789101112131415161718package com.imooc.proxy;import java.util.Random;public class Car implements Moveable &#123; @Override public void move() &#123; //实现开车 try &#123; Thread.sleep(new Random().nextInt(1000)); System.out.println("汽车行驶中...."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 步骤 3定义代理类TimeHandler实现InvocationHandler接口，聚合被代理类对象target 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.imooc.jdkproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class TimeHandler implements InvocationHandler &#123; public TimeHandler(Object target) &#123; super(); this.target = target; &#125; private Object target; //target对象是聚合在代理类里的目标对象(被代理对象) /* * 参数： * proxy 代理对象 * method 被代理对象的方法 * args 方法的参数 * * 返回值： * Object 方法的返回值 * */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long starttime = System.currentTimeMillis(); System.out.println("汽车开始行驶...."); method.invoke(target); //被代理的target对象调用method方法，args为null可以不写 long endtime = System.currentTimeMillis(); System.out.println("汽车结束行驶.... 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); return null; &#125; //获取代理对象 public Object getProxy() &#123; /** static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler) * loader 被代理类(Car)的类加载器 * interfaces 被代理类(Car)实现的接口 * 通过获取Car的类对象获取loader和interfaces * h 实现了InvocationHandler接口的代理类对象 */ return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; &#125; &#125; 步骤 4定义测试类 12345678910111213141516171819202122232425package com.imooc.jdkproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import com.imooc.proxy.Car;import com.imooc.proxy.Moveable;public class Test &#123; /** * JDK动态代理测试类 */ public static void main(String[] args) &#123; // 实例化目标对象 Car car = new Car(); // 实例化InvocationHandler InvocationHandler h = new TimeHandler(car); // 获取代理对象 Moveable m = (Moveable)h.getProxy(); // 调用代理方法 m.move(); &#125;&#125; 上面步骤 3可以直接定义一个动态代理工厂类ProxyFactory，把InvocationHandler作为ProxyFactory的匿名内部类。即： ProxyFactory.java123456789101112131415161718192021222324252627282930313233343536package com.imooc.jdkproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class TimeHandler implements InvocationHandler &#123; public TimeHandler(Object target) &#123; super(); this.target = target; &#125; private Object target; //获取代理对象 public Object getProxyInstance() &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long starttime = System.currentTimeMillis(); System.out.println("汽车开始行驶...."); method.invoke(target); //被代理的target对象调用method方法，args为null可以不写 long endtime = System.currentTimeMillis(); System.out.println("汽车结束行驶.... 汽车行驶时间：" + (endtime - starttime) + "毫秒！"); return null; //方法无返回值,返回null &#125; &#125;); &#125; &#125; 拓展： Java的三种代理模式 InvocationHandler中invoke方法中的第一个参数proxy的用途 java中Proxy(代理与动态代理) java静态代理和动态代理 深入理解Java反射 JDK动态代理的简易实现实现功能：通过Proxy的newProxyInstance返回代理对象 （1）声明一段源码（动态产生代理）（2）编译源码（JDK Compiler API），产生新的类（代理类）（3）将这个类load到内存当中，产生一个新的对象（代理对象）（4）return代理对象具体见慕课视频：模拟JDK动态代理实现思路分析总结：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用JDK动态代理 2) 使用cglib实现动态代理上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候就可以使用以目标对象子类的方式类实现代理，这种方法就叫做Cglib代理。 Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。 JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现。 Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)。 Cglib子类代理实现方法:1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可。2.引入功能包后,就可以在内存中动态构建子类。3.代理的类不能为final,否则报错。4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法。 Train.java123456789/** * 目标对象,没有实现任何接口 */public class Train &#123; public void move() &#123; System.out.println("火车行驶中..."); &#125;&#125; ProxyFactory.java123456789101112131415161718192021222324252627282930313233343536373839404142/** * Cglib子类代理工厂，实现MethodInterceptor接口 * 设置Cglib子类的父类为目标对象的类 * 对Train在内存中动态构建一个子类对象 * 重写intercept方法对目标父类的方法调用进行拦截 */public class ProxyFactory implements MethodInterceptor&#123; //维护目标对象 private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.创建加强器，用来创建动态代理类 Enhancer en = new Enhancer(); //2.为加强器指定要代理的业务类（即为下面生成的代理类指定父类） en.setSuperclass(target.getClass()); //3.设置回调：在调用目标方法时，CgLib会回调intercept方法进行拦截，来实现你自己的代理逻辑 en.setCallback(this); //4.创建动态代理类对象并返回 return en.create(); &#125; `/** * 拦截所有目标父类方法的调用 * obj 目标类的实例 * method 目标方法的反射对象 * args 方法的参数 * proxy 代理类的实例 */ @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("日志开始..."); //代理类调用父类的方法 proxy.invokeSuper(obj, args); System.out.println("日志结束..."); return null; //方法无返回值，返回null &#125;&#125; Client.java123456789101112131415161718/** * 测试类 */public class Client &#123; @Test public void test()&#123; //目标对象 Train target = new Train(); //代理对象 Train proxy = (Train)new ProxyFactory(target).getProxyInstance(); //执行代理对象的方法 proxy.move(); &#125;&#125; 行为型模式14.责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 介绍意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 4.JAVA 的异常链机制 优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 注意事项：在 JAVA WEB 中遇到很多应用。 实现我们以销售楼盘为例，客户是Customer类，发送一个折扣请求给责任链。责任链由楼盘各级人员组成，都继承自PriceHandler抽象类，自底向上为Sales(销售)、Lead(销售小组长)、Manager(销售经理)、Director(销售总监)、VicePresident(销售副总裁)、CEO(首席执行官)。沿着责任链，能批准折扣的力度依次上升。 步骤 1 创建PriceHandler抽象类PriceHandler.java12345678910111213141516171819202122package com.imooc.pattern.cor.handler;/* * 价格处理人，负责处理客户折扣申请 */public abstract class PriceHandler &#123; /* * 直接后继，用于传递请求 */ protected PriceHandler successor; public void setSuccessor(PriceHandler successor) &#123; this.successor = successor; &#125; /* * 处理折扣申请 */ public abstract void processDiscount(float discount);&#125; 步骤 2 创建PriceHandler的具体类Sales.java123456789101112131415161718package com.imooc.pattern.cor.handler;/* * 销售， 可以批准5%以内的折扣 */public class Sales extends PriceHandler &#123; @Override public void processDiscount(float discount) &#123; if(discount &lt;= 0.05)&#123; System.out.format("%s批准了折扣：%.2f%n", this.getClass().getName(), discount); &#125;else&#123; successor.processDiscount(discount); &#125; &#125;&#125; Lead.java123456789101112131415161718package com.imooc.pattern.cor.handler;/* * 销售小组长， 可以批准15%以内的折扣 */public class Lead extends PriceHandler &#123; @Override public void processDiscount(float discount) &#123; if(discount&lt;=0.15)&#123; System.out.format("%s批准了折扣:%.2f%n",this.getClass().getName(),discount); &#125;else&#123; successor.processDiscount(discount); &#125; &#125;&#125; Manager.java123456789101112131415161718package com.imooc.pattern.cor.handler;/* * 销售经理， 可以批准30%以内的折扣 */public class Manager extends PriceHandler &#123; @Override public void processDiscount(float discount) &#123; if(discount&lt;=0.3)&#123; System.out.format("%s批准了折扣:%.2f%n",this.getClass().getName(),discount); &#125;else&#123; successor.processDiscount(discount); &#125; &#125;&#125; Director.java123456789101112131415161718package com.imooc.pattern.cor.handler;/* * 销售总监， 可以批准40%以内的折扣 */public class Director extends PriceHandler &#123; @Override public void processDiscount(float discount) &#123; if(discount&lt;=0.4)&#123; System.out.format("%s批准了折扣:%.2f%n",this.getClass().getName(),discount); &#125;else&#123; successor.processDiscount(discount); &#125; &#125;&#125; VicePresident.java12345678910111213141516171819package com.imooc.pattern.cor.handler;/* * 销售副总裁， 可以批准50%以内的折扣 */public class VicePresident extends PriceHandler &#123; @Override public void processDiscount(float discount) &#123; if(discount&lt;=0.5)&#123; System.out.format("%s批准了折扣:%.2f%n",this.getClass().getName(),discount); &#125;else&#123; successor.processDiscount(discount); &#125; &#125;&#125; CEO.java12345678910111213141516171819package com.imooc.pattern.cor.handler;/* * CEO， 可以批准55%以内的折扣 * 折扣超出55%， 就拒绝申请 */public class CEO extends PriceHandler &#123; @Override public void processDiscount(float discount) &#123; if(discount&lt;=0.55)&#123; System.out.format("%s批准了折扣:%.2f%n",this.getClass().getName(),discount); &#125;else&#123; System.out.format("%s拒绝了折扣:%.2f%n", this.getClass().getName(),discount); &#125; &#125;&#125; 步骤 3 创建PriceHandlerFactory类1234567891011121314151617181920212223242526package com.imooc.pattern.cor.handler;public class PriceHandlerFactory &#123; /* * 创建PriceHandler的工厂方法，类似于构建链表并返回表头 */ public static PriceHandler createPriceHandler() &#123; PriceHandler sales = new Sales(); PriceHandler lead = new Lead(); PriceHandler man = new Manager(); PriceHandler dir = new Director(); PriceHandler vp = new VicePresident(); PriceHandler ceo = new CEO(); sales.setSuccessor(lead); lead.setSuccessor(man); man.setSuccessor(dir); dir.setSuccessor(vp); vp.setSuccessor(ceo); return sales; &#125;&#125; 步骤 4 创建Customer类1234567891011121314151617181920212223242526272829303132333435363738package com.imooc.pattern.cor;import java.util.Random;import com.imooc.pattern.cor.handler.PriceHandler;import com.imooc.pattern.cor.handler.PriceHandlerFactory;/* * 客户，请求折扣 */public class Customer &#123; private PriceHandler priceHandler; public void setPriceHandler(PriceHandler priceHandler) &#123; this.priceHandler = priceHandler; &#125; public void requestDiscount(float discount)&#123; priceHandler.processDiscount(discount); &#125; public static void main(String[] args)&#123; Customer customer = new Customer(); customer.setPriceHandler(PriceHandlerFactory.createPriceHandler()); Random rand = new Random(); for(int i=1;i&lt;=100;i++)&#123; System.out.print(i+":"); customer.requestDiscount(rand.nextFloat()); &#125; &#125; &#125; 15.命令模式16.解释器模式17.迭代器模式18.中介者模式19.备忘录模式20.观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象，被通知的对象会做出各自的反应。观察者模式属于行为型模式。 介绍意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，进行广播通知，所有的依赖对象（观察者对象）都将得到通知并做出各自的反应。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 优点： 1、观察者和被观察者是抽象耦合的，被观察者只知道观察者接口，不知道具体的观察者类，实现了被观察者类和具体观察者类的解耦。 2、建立一套触发机制，实现了动态联动。3、支持广播通信。 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 使用场景： 1、一个抽象模型有两个方面，其中一个方面的操作(观察者)依赖于另一个方面状态的变化(被观察者)。 2、如果在更改一个对象的时候，需要同时连带改变其他对象，而且不知道究竟有多少对象需要被连带改变。 3、当一个对象必须通知其他对象，而又希望这个对象和其他被通知的对象是松散耦合的。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 实现观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 观察者模式实现的两种方式1) 推模型目标对象主动向观察者推送目标的详细信息，推送的信息通常是目标或目标对象的全部数据。一般这种模型的实现中，会把目标对象想要推送的信息通过update方法传递给观察者。步骤 1创建 Subject 类(目标类、被观察者类)Subject.java12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class Subject &#123; private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; notifyAllObservers(state); &#125; public void attach(Observer observer)&#123; observers.add(observer); &#125; public void detach(Observer observer)&#123; observers.remove(observer); &#125; public void notifyAllObservers(int state)&#123; for (Observer observer : observers) &#123; observer.update(state); &#125; &#125; &#125; 步骤 2创建 Observer 类 Observer.java123public abstract class Observer &#123; public abstract void update(int state); //传递要推送的信息，观察者只能接收到目标推送的数据&#125; 步骤 3创建实体观察者类 BinaryObserver.java1234567public class BinaryObserver extends Observer&#123; @Override public void update(int state) &#123; System.out.println( "Binary String: " + Integer.toBinaryString(state)); &#125;&#125; OctalObserver.java1234567public class OctalObserver extends Observer&#123; @Override public void update(int state) &#123; System.out.println( "Octal String: " + Integer.toOctalString(state)); &#125;&#125; HexaObserver.java1234567public class HexaObserver extends Observer&#123; @Override public void update(int state) &#123; System.out.println( "Hex String: " + Integer.toHexString(state).toUpperCase()); &#125;&#125; 步骤 4使用 Subject 和实体观察者对象 ObserverPatternDemo.java123456789101112131415public class ObserverPatternDemo &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); Observer o1 = new HexaObserver(); Observer o2 = new OctalObserver(); Observer o3 = new BinaryObserver(); subject.attach(o1); subject.attach(o2); subject.attach(o3); System.out.println("First state change: 15"); subject.setState(15); System.out.println("Second state change: 10"); subject.setState(10); &#125;&#125; 步骤 5验证输出 First state change: 15Hex String: FOctal String: 17Binary String: 1111Second state change: 10Hex String: AOctal String: 12Binary String: 1010 2) 拉模型目标对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于观察者从目标对象中拉数据。一般这种模型的实现中，会把目标对象自身的引用通过update方法传递给观察者。步骤 1创建 Subject 类(目标类、被观察者类) Subject.java12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class Subject &#123; private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; notifyAllObservers(); &#125; public void attach(Observer observer)&#123; observers.add(observer); &#125; public void detach(Observer observer)&#123; observers.remove(observer); &#125; public void notifyAllObservers()&#123; for (Observer observer : observers) &#123; observer.update(this); &#125; &#125; &#125; 步骤 2创建 Observer 类 Observer.java12345public abstract class Observer &#123; /*传递目标对象自身的引用，观察者可自己选择 从目标对象中拉哪些数据*/ public abstract void update(Subject message);&#125; 步骤 3创建实体观察者类 BinaryObserver.java12345678public class BinaryObserver extends Observer&#123; @Override public void update(Subject message) &#123; int state = message.getState(); System.out.println( "Binary String: " + Integer.toBinaryString(state)); &#125;&#125; OctalObserver.java12345678public class OctalObserver extends Observer&#123; @Override public void update(Subject message) &#123; int state = message.getState(); System.out.println( "Octal String: " + Integer.toOctalString(state)); &#125;&#125; HexaObserver.java12345678public class HexaObserver extends Observer&#123; @Override public void update(Subject message) &#123; int state = message.getState(); System.out.println( "Hex String: " + Integer.toHexString(state).toUpperCase()); &#125;&#125; 步骤 4使用 Subject 和实体观察者对象 ObserverPatternDemo.java123456789101112131415public class ObserverPatternDemo &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); Observer o1 = new HexaObserver(); Observer o2 = new OctalObserver(); Observer o3 = new BinaryObserver(); subject.attach(o1); subject.attach(o2); subject.attach(o3); System.out.println("First state change: 15"); subject.setState(15); System.out.println("Second state change: 10"); subject.setState(10); &#125;&#125; 步骤 5验证输出 First state change: 15Hex String: FOctal String: 17Binary String: 1111Second state change: 10Hex String: AOctal String: 12Binary String: 1010 两种模型的区别：1) 推模型由目标对象决定推送的信息，观察者不能获取推送信息之外目标对象的其他信息，较为被动。拉模型虽然仍是目标对象主动推送信息，但推送的是整个目标对象的引用，观察者可以选择性接收目标对象的信息。2) 推模型一般用于目标对象知道观察者需要的数据;而拉模型则用于目标对象不知道观察者需要的数据，因此把自身传递给观察者，由观察者来取值。3) 推模型会使观察者对象难以复用。拉模型下，update方法的参数是目标对象本身，基本上可以适应各种情况的需要。 利用Java提供的观察者实现Java提供了观察者模式的实现，有关类和接口是java.util包的Observable类和Observer接口。和自己实现对比：1.不需要自己定义观察者和目标接口了，JDK帮忙定义了2.具体的目标实现里面不需要再维护观察者的注册信息了，这个在Java中的Observable类里面已经帮忙实现好了。3.触发通知的方式有一点变化，要先调用setChanged方法,这个是Java为了帮助实现更精确的触发控制而实现的功能。4.具体观察者的实现里面，update方法其实能同时支持推模型和拉模型，这个是Java在定义的时候，就已经考虑进去的了。 实现方法：1、让具体Subject实现类继承Observable目标父类，Observable意为可被观察的，所以让具体目标类继承它。2、让具体观察者实现类实现Observer接口，Observer意为观察者，所以让具体观察者实现类实现它。 步骤 1创建具体目标对象实现类继承Observable类Subject.java123456789101112131415161718192021222324import java.util.Observable;public class Subject extends Observable &#123; private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; //通知观察者之前必须调用setChanged() this.setChanged(); /*通知所有观察者，既传递目标对象引用给观察者， * 也传递参数给观察者update的第二个参数*/ this.notifyObservers(Integer.valueOf(state)); /* 重载方法的无参方法notifyObservers() * 通知所有观察者，但只是传递目标对象引用给观察者， * 观察者update的第二个参数为null * */ &#125;&#125; 步骤 2创建观察者的具体实现类实现Observer接口BinaryObserver.java1234567891011121314151617181920212223import java.util.Observable;import java.util.Observer;public class BinaryObserver implements Observer &#123; /** * Observable o是目标对象传递的引用，用于拉模型 * Object arg是目标对象主动推送的信息，用于推模型 * 如果目标对象使用带参的notifyObservers方法， * 则即可推也可拉;如果使用无参的notifyObservers方法， * 则只能拉 */ @Override public void update(Observable o, Object arg) &#123; //1.推的方式 System.out.println( "推模型：Binary String: " + Integer.toBinaryString(((Integer)arg).intValue())); //2.拉的方式 System.out.println( "拉模型：Binary String: " + Integer.toBinaryString(((Subject)o).getState())); &#125;&#125; HexaObserver.java1234567891011121314import java.util.Observable;import java.util.Observer;public class HexaObserver implements Observer &#123; @Override public void update(Observable o, Object arg) &#123; System.out.println( "推模型：Hex String: " + Integer.toHexString(((Integer)arg).intValue()).toUpperCase()); System.out.println( "拉模型：Hex String: " + Integer.toHexString(((Subject)o).getState()).toUpperCase()); &#125;&#125; OctalObserver.java1234567891011121314import java.util.Observable;import java.util.Observer;public class OctalObserver implements Observer &#123; @Override public void update(Observable o, Object arg) &#123; System.out.println( "推模型：Octal String: " + Integer.toOctalString(((Integer)arg).intValue())); System.out.println( "拉模型：Octal String: " + Integer.toOctalString(((Subject)o).getState())); &#125;&#125; 步骤 3创建测试类ObserverPatternDemo.java1234567891011121314151617import java.util.Observer;public class ObserverPatternDemo &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); Observer o1 = new HexaObserver(); Observer o2 = new BinaryObserver(); Observer o3 = new OctalObserver(); subject.addObserver(o1); //注册观察者 subject.addObserver(o2); subject.addObserver(o3); System.out.println("First state change: 15"); subject.setState(15); System.out.println("Second state change: 10"); subject.setState(10); &#125;&#125; 步骤 4验证输出First state change: 15推模型：Octal String: 17拉模型：Octal String: 17推模型：Binary String: 1111拉模型：Binary String: 1111推模型：Hex String: F拉模型：Hex String: FSecond state change: 10推模型：Octal String: 12拉模型：Octal String: 12推模型：Binary String: 1010拉模型：Binary String: 1010推模型：Hex String: A拉模型：Hex String: A 区别对待观察者模式之前的观察者模式是目标对象无条件通知所有观察者对象，然而有时需要在特定条件下对特定的观察者进行通知。这是就需要观察者模式的变形 —— 区别对待观察者模式。具体实现只要修改Subject类的notifyAllObservers方法,对Observer的身份做特定判断，然后有条件的推送信息即可。 21.状态模式22.空对象模式23.策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：抽象出行为的共性作为一个策略接口，各种策略类实现这个接口。在调用这个行为的类中通过组合持有这个接口的对象，通过这个策略接口对象代理具体的行为。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 实现我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 步骤 1创建一个接口。Strategy.java123public interface Strategy &#123; public int doOperation(int num1, int num2);&#125; 步骤 2创建实现接口的实体类。OperationAdd.java123456public class OperationAdd implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125; OperationSubstract.java123456public class OperationSubstract implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 - num2; &#125;&#125; OperationMultiply.java123456public class OperationMultiply implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 * num2; &#125;&#125; 步骤 3创建 Context 类。Context.java123456789101112public class Context &#123; private Strategy strategy;//组合一个策略接口对象 public Context(Strategy strategy)&#123; this.strategy = strategy; &#125; public int executeStrategy(int num1, int num2)&#123; return strategy.doOperation(num1, num2); //用策略接口对象代理具体实现 &#125;&#125; 步骤 4使用 Context 来查看当它改变策略 Strategy 时的行为变化。StrategyPatternDemo.java123456789101112public class StrategyPatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(new OperationAdd()); System.out.println("10 + 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println("10 - 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println("10 * 5 = " + context.executeStrategy(10, 5)); &#125;&#125; 步骤 5验证输出。10 + 5 = 1510 - 5 = 510 * 5 = 50 24.模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 介绍意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：准备一个抽象类，将部分逻辑以具体方法的形式实现，然后声明一些抽象方法交由子类实现剩余逻辑，用钩子方法给予子类更大的灵活性。最后将方法汇总为一个final的模板方法。 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 优点： 1、封装性好，封装不变部分，扩展可变部分。 2、复用性好，提取公共代码，便于维护。 3、屏蔽细节，行为由父类控制，子类实现。 缺点：1、每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。2、Java的单继承使得继承了其他父类子类难以实现对模板基类的继承。 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。在模板方法内的步骤中，通用的方法在抽象基类里提供实现，特定的方法定义为抽象方法，延迟到子类中实现。 实现我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。 步骤 1创建一个抽象类，它的模板方法被设置为 final。Game.java12345678910111213141516171819public abstract class Game &#123; abstract void initialize(); //如果子类通用，可以在抽象基类实现，不必定义为抽象方法 abstract void startPlay(); abstract void endPlay(); //模板,定义为final，防止被子类重写 public final void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125; 步骤 2创建扩展了上述类的实体类。Cricket.java1234567891011121314151617public class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println("Cricket Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Cricket Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Cricket Game Started. Enjoy the game!"); &#125;&#125; Football.java1234567891011121314151617public class Football extends Game &#123; @Override void endPlay() &#123; System.out.println("Football Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Football Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Football Game Started. Enjoy the game!"); &#125;&#125; 步骤 3使用 Game 的模板方法 play() 来演示游戏的定义方式。TemplatePatternDemo.java12345678910public class TemplatePatternDemo &#123; public static void main(String[] args) &#123; Game game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); &#125;&#125; 步骤 4验证输出。Cricket Game Initialized! Start playing.Cricket Game Started. Enjoy the game!Cricket Game Finished!Football Game Initialized! Start playing.Football Game Started. Enjoy the game!Football Game Finished! 如果想要灵活选择模板中的某一步骤是否出现，可以添加一个钩子方法：比如在泡饮品的模板方法中，烧水——倒入饮品冲剂——加水——加调料。如果有的饮品不想要调料，可以在模板方法中把加调料放在if语句中，if的条件是一个返回值为boolean类型的方法，比如isCustomerWantsCondiments(),提供一个空的或者默认返回true的实现，称为钩子方法。子类可以根据需要重写该钩子方法选择要不要加调料。 25.访问者模式J2EE模式26.MVC 模式27.业务代表模式28.组合实体模式29.数据访问对象模式30.前端控制器模式31.拦截过滤器模式32.服务定位器模式33.传输对象模式参考资料：菜鸟教程之设计模式]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下shell脚本对拍]]></title>
    <url>%2F2017%2F12%2F02%2FLinux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E5%AF%B9%E6%8B%8D%2F</url>
    <content type="text"><![CDATA[在算法竞赛中，我们常常会遇到一道题一直WA的情况，这时我们不得不自己造样例，这会耗费大量时间，而且还不一定能快速确定样例的答案。所以，如果时间充足，可以写一个对拍程序。对拍程序需要四个文件：1.我们已经写好但WA的待测试文件，记为code.cpp2.一个纯暴力程序(复杂度高但能保证答案一定正确)，记为std.cpp3.一个数据生成器(用srand函数和rand函数产生随机数即可)，记为data.cpp4.一个用于比较输出的shell脚本,记为duipai.sh对拍程序，顾名思义，就是随机生成数据给两个程序分别跑一遍，看看对不对的上。 我们以一个计算1到n的和的程序为例，我们都知道计算1到n的暴力方法是用循环加和，简便方法则是使用等差数列求和公式。 下面是待测试程序code.cpp(等比数列求和,当然这里没有WA)12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;n * (n + 1) / 2&lt;&lt;endl; return 0;&#125; 下面是暴力求和程序std.cpp123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int ans = 0; for(int i = 1;i &lt;= n;i++)&#123; ans += i; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 然后是随机数据生成器data.cpp1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; srand(time(0)); int n = 100; while(n--)&#123; int k = rand() % 10 + 1; //生成100个[1,10]的随机数 cout&lt;&lt;k&lt;&lt;endl; &#125; return 0;&#125; rand函数和srand函数的用法有点忘了，参见：有关rand()，srand()产生随机数学习总结 最后是duipai.sh123456789101112#!/bin/bashwhile true; do ./data &gt; data.in ./std &lt;data.in &gt;std.out ./code &lt;data.in &gt;code.out if diff std.out code.out; then printf "AC\n" else printf "Wa\n" exit 0 fidone 这个程序的意思是运行三个可执行文件，比较std.out code.out是否相同，相同输出”AC”，不相同输出错误信息，并输出”WA”且退出。 下面开始跑对拍，先用g++编译三个cpp文件，g++ code.cpp -o code,g++ std.cpp -o std,g++ data.cpp -o data。g++ code.cpp -o code表示将code.cpp编译并连接生成一个名为code的可执行文件，如果不加 -o 选项，所有cpp文件都默认生成一个名为a.out的可执行文件。通过./a.out可以运行这个可执行文件,./表示当前目录。如果加上 -c 选项，如g++ -c code.cpp -o code则只编译不连接，会产生一个obj文件而不是exe文件。 编译完成后，输入sh duipai.sh即得结果。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jsoup简易爬取POJ题面]]></title>
    <url>%2F2017%2F12%2F01%2F%E4%BD%BF%E7%94%A8jsoup%E7%AE%80%E6%98%93%E7%88%AC%E5%8F%96POJ%E9%A2%98%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[最近校创的项目终于立项啦！一直在等答辩通知，结果无需答辩直接立项2333。马上和队友开始着手项目，目标是做一个基于习题推荐的算法分类学习平台，简单来说就是一个根据用户历史做题情况自动推荐相应难度或类型题目的Online Judge。作为ACM校队的弱菜，正好造福一下学弟学妹ORZ当然，作为一个新兴的OJ，肯定是没有题目来源的，所以我们把罪恶的双手(嘘~)伸向了一些目前主流的OJ。我们需要用爬虫技术爬取这些OJ的题面，并提取总提交数和通过数来计算AC率，从而把AC率作为题目难度的一个指标，以便后续实现题目推荐。之前没有写过爬虫，队友告诉我Java可以用jsoup库很方便地解析html网页的元素。于是粗略学习了jsoup,再配合一点CSS选择器的知识，这对于一般的html网页的爬取就够用了，下面是几个学习的网站：jsoup Cookbook(中文版)CSS 选择器 我分到的是POJ，打开Problems，选择第一道题，即A+B Problem。查看网页的源代码发现TABLE标签之后的table标签恰好包括了所有我需要的信息(POJ真友好啊)，将爬到的内容重定向到一个html文件，我们就得到了题面。核心代码只有几行，不多说上代码：12345678910111213141516171819202122232425262728293031323334353637import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;import java.util.Iterator;import java.util.List;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.nodes.Node;import org.jsoup.select.Elements;public class Crawler &#123; public static void main(String[] args) throws IOException &#123; for(int pid = 1000;pid &lt;= 1100;pid++) &#123; Document doc = Jsoup.connect("http://poj.org/" +"problem?id=" + pid).get(); Elements text = doc.select("TABLE+table"); //选择TABLE标签之后的table标签 text.select(".ptt").attr("align", "center"); //题目没有居中，添加居中属性 Elements image = text.select("img"); for(Element e:image) &#123; String href = e.attr("src"); e.attr("src","http://poj.org/"+href); &#125; /*图片在poj服务器上，必须修改图片路径为 绝对路径，否则无法显示*/ System.setOut(new PrintStream(new FileOutputStream("problem"+pid+".html"))); System.out.println(text); //重定向输出到html文件 &#125; &#125; &#125; 耐心等待爬取题目编号为1000到1100的题目,显示如下：用浏览器打开problem1000.html，效果如下：大功告成！！！]]></content>
      <tags>
        <tag>Java</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之Java IO系统]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[概述Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。 FileJAVA中IO操作有相应步骤，以文件操作为例，主要操作流程如下：1.使用File类打开一个文件2.通过字节流或字符流的子类，指定输出的位置3.进行读/写操作4.关闭输入/输出 那么我们先来介绍一下File类Java文件类在Java.io包中，它以抽象的方式代表文件名和目录路径名。该类主要用于获取文件和目录的属性，文件和目录的创建、查找、删除、重命名等,但不能进行文件的读写操作。File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。 通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。File(File parent, String child) 通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。File(String pathname) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。File(String parent, String child) 通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。File(URI uri) 注意：1.在各个操作系统中，路径的分隔符是不一样的，例如：Windows中使用反斜杠：”\“，Linux|Unix中使用正斜杠：”/“。在使用反斜杠时要写成”\\“的形式，因为反斜杠要进行转义。如果要让Java保持可移植性，应该使用File类的静态常量File.pathSeparator。2.构建一个File实例并不会在机器上创建一个文件。不管文件是否存在，都可以创建任意文件名的File实例。可以调用File实例上的exists()方法来判断这个文件是否存在。通过后续的学习我们会知道，当把一个输出流绑定到一个不存在的File实例上时，会自动在机器上创建该文件，如果文件已经存在，把输出流绑定到该文件上则会覆盖该文件，但这些都不是在创建File实例时进行的。 创建File对象成功后，可以使用以下列表中的方法操作文件。 下面给出一个使用File类的实例：123456789101112131415161718192021import java.io.File;public class DirList &#123; public static void main(String args[]) &#123; String dirname = "/java"; File f1 = new File(dirname); if (f1.isDirectory()) &#123; System.out.println( "Directory of " + dirname); String s[] = f1.list(); for (int i=0; i &lt; s.length; i++) &#123; File f = new File(dirname + "/" + s[i]); if (f.isDirectory()) &#123; System.out.println(s[i] + " is a directory"); &#125; else &#123; System.out.println(s[i] + " is a file"); &#125; &#125; &#125; else &#123; System.out.println(dirname + " is not a directory"); &#125; &#125;&#125; 小贴士：lastModified()方法返回的是从时间戳(1970年1月1日0时0分0秒)到当前的毫秒数，返回值类型是long，可以用Date类对它进行包装使其更易读。 Java中的目录创建目录：File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 mkdirs()方法创建一个文件夹和它的所有父文件夹。下面的例子创建 “/tmp/user/java/bin”文件夹： 12345678910import java.io.File; public class CreateDir &#123; public static void main(String args[]) &#123; String dirname = "/tmp/user/java/bin"; File d = new File(dirname); // 现在创建目录 d.mkdirs(); &#125;&#125; mkdirs是递归创建文件夹，允许在创建某文件夹时其父文件夹不存在,从而一同创建;mkdir必须满足路径上的父文件夹全都存在注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。读取目录：一个目录其实就是一个 File 对象，它包含其他文件和文件夹。如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容： 12345678910111213141516171819202122import java.io.File; public class DirList &#123; public static void main(String args[]) &#123; String dirname = "/tmp"; File f1 = new File(dirname); if (f1.isDirectory()) &#123; System.out.println( "目录 " + dirname); String s[] = f1.list(); for (int i=0; i &lt; s.length; i++) &#123; File f = new File(dirname + "/" + s[i]); if (f.isDirectory()) &#123; System.out.println(s[i] + " 是一个目录"); &#125; else &#123; System.out.println(s[i] + " 是一个文件"); &#125; &#125; &#125; else &#123; System.out.println(dirname + " 不是一个目录"); &#125; &#125;&#125; 删除目录或文件：删除文件可以使用 java.io.File.delete() 方法。以下代码会删除目录/tmp/java/，即便目录不为空。测试目录结构：123/tmp/java/|-- 1.log|-- test deleteFolder是一个递归函数，类似于DFS思想123456789101112131415161718192021222324import java.io.File; public class DeleteFileDemo &#123; public static void main(String args[]) &#123; // 这里修改为自己的测试目录 File folder = new File("/tmp/java/"); deleteFolder(folder); &#125; //删除文件及目录 public static void deleteFolder(File folder) &#123; File[] files = folder.listFiles(); if(files!=null) &#123; for(File f: files) &#123; if(f.isDirectory()) &#123; deleteFolder(f); &#125; else &#123; f.delete(); &#125; &#125; &#125; folder.delete(); &#125;&#125; RandomAccessFileRandomAccessFile不同于File，它提供了对文件内容的访问，可以读写文件且支持随机访问文件的任意位置。RandomAccessFile读写用到文件指针，它的初始位置为0,可以用getFilePointer()方法获取文件指针的位置。下面是RandomAccessFile常用的方法。 public int read(int x) throws IOException 方法只读取一个字节，也就是x的低八位。1234567891011121314151617181920212223242526import java.io.File ;import java.io.RandomAccessFile ;public class RandomAccessFileDemo01&#123; // 所有的异常直接抛出，程序中不再进行处理 public static void main(String args[]) throws Exception&#123; File f = new File("d:" + File.separator + "test.txt") ; // 指定要操作的文件 RandomAccessFile rdf = null ; // 声明RandomAccessFile类的对象 rdf = new RandomAccessFile(f,"rw") ;// 读写模式，如果文件不存在，会自动创建 String name = null ; int age = 0 ; name = "zhangsan" ; // 字符串长度为8 age = 30 ; // 数字的长度为4 rdf.writeBytes(name) ; // 将姓名写入文件之中 rdf.writeInt(age) ; // 将年龄写入文件之中 name = "lisi " ; // 字符串长度为8 age = 31 ; // 数字的长度为4 rdf.writeBytes(name) ; // 将姓名写入文件之中 rdf.writeInt(age) ; // 将年龄写入文件之中 name = "wangwu " ; // 字符串长度为8 age = 32 ; // 数字的长度为4 rdf.writeBytes(name) ; // 将姓名写入文件之中 rdf.writeInt(age) ; // 将年龄写入文件之中 rdf.close() ; // 关闭 &#125;&#125;; 写完之后，开始读取数据。写的时候可以将一个字符串写入，读的时候需要一个个的以字节的形式读取出来。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.File ;import java.io.RandomAccessFile ;public class RandomAccessFileDemo02&#123; // 所有的异常直接抛出，程序中不再进行处理 public static void main(String args[]) throws Exception&#123; File f = new File("d:" + File.separator + "test.txt") ; // 指定要操作的文件 RandomAccessFile rdf = null ; // 声明RandomAccessFile类的对象 rdf = new RandomAccessFile(f,"r") ;// 以只读的方式打开文件 String name = null ; int age = 0 ; byte b[] = new byte[8] ; // 开辟byte数组 // 读取第二个人的信息，意味着要空出第一个人的信息 rdf.skipBytes(12) ; // 跳过第一个人的信息 for(int i=0;i&lt;b.length;i++)&#123; b[i] = rdf.readByte() ; // 读取一个字节 &#125; name = new String(b) ; // 将读取出来的byte数组变为字符串 age = rdf.readInt() ; // 读取数字 System.out.println("第二个人的信息 --&gt; 姓名：" + name + "；年龄：" + age) ; // 读取第一个人的信息 rdf.seek(0) ; // 指针回到文件的开头 for(int i=0;i&lt;b.length;i++)&#123; b[i] = rdf.readByte() ; // 读取一个字节 &#125; name = new String(b) ; // 将读取出来的byte数组变为字符串 age = rdf.readInt() ; // 读取数字 System.out.println("第一个人的信息 --&gt; 姓名：" + name + "；年龄：" + age) ; rdf.skipBytes(12) ; // 跳过第二个人的信息 for(int i=0;i&lt;b.length;i++)&#123; b[i] = rdf.readByte() ; // 读取一个字节 &#125; name = new String(b) ; // 将读取出来的byte数组变为字符串 age = rdf.readInt() ; // 读取数字 System.out.println("第三个人的信息 --&gt; 姓名：" + name + "；年龄：" + age) ; rdf.close() ; // 关闭 &#125;&#125;; 结果如下： 流在Java程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。流涉及的领域很广：标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等。流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。先上一个Java IO流类层次图，如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据：是不是被吓到了？没关系，我们将通过一个个例子来学习这些功能。 IO流分类1.按操作数据类型分：字符流和字节流字符流：Java中的字符流处理的最基本的单元是2字节的Unicode码元(char)，它通常用来处理文本数据，如字符、字符数组或字符串等。所谓Unicode码元，也就是一个Unicode代码单元，范围是0x0000~0xFFFF。在以上范围内的每个数字都与一个字符相对应，Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。然而与存储在内存中不同，存储在磁盘上的数据通常有着各种各样的编码方式。使用不同的编码方式，相同的字符会有不同的二进制表示。实际上字符流是这样工作的： 输出字符流：把要写入文件的字符序列(实际上是Unicode码元序列)转为指定编码方式下的字节序列，然后再写入到文件中。 输入字符流：把要读取的字节序列按指定编码方式解码为相应字符序列(实际上是Unicode码元序列从)从而可以存在内存中。 也就是说，所有的文件在硬盘或在传输时都是以字节的方式进行的，包括图片等都是按字节的方式存储的，而字符是只有在内存中才会形成。 字节流：Java中的字节流处理的最基本单位为单个字节(byte)，它通常用来处理二进制数据,如果要得到字节对应的字符需要强制类型转换。 两者比较：1.字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性较好，如果要操作中文数据等，用字符流。2.字符流只用来处理文本数据，字节流还可以用来处理媒体数据，如视频、音频、图片等。3.字符流的两个抽象基类为Reader和Writer，字节流的两个抽象基类为InputStream和OutputStream。它们的具体子类名以基类名为后缀进行扩展。4.字节流在操作的时候不会用到缓冲区(内存)，是直接对文件本身操作的，而字符流在操作的时候使用缓冲区。 以向一个文件输出”Hello world!”为例，我们分别使用字节流和字符流进行输出，且在使用完之后都不关闭流。 使用字节流不关闭执行：123456789101112131415161718192021222324252627import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class IOPractice &#123; public static void main(String[] args) throws IOException &#123; // 第1步：使用File类找到一个文件 File f = new File("/home/xiejunyu/"+ "桌面/text.txt"); // 第2步：通过子类实例化父类对象 OutputStream out = new FileOutputStream(f); // 通过对象多态性进行实例化 // 第3步：进行写操作 String str = "Hello World!"; // 准备一个字符串 byte b[] = str.getBytes(); // 字符串转byte数组 out.write(b); // 将内容输出 // 第4步：关闭输出流 // out.close(); // 此时没有关闭 &#125; &#125; 此时没有关闭字节流操作，但是文件中也依然存在了输出的内容，证明字节流是直接操作文件本身的。 使用字符流不关闭执行：1234567891011121314151617181920212223import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class IOPractice &#123; public static void main(String[] args) throws IOException &#123; // 第1步：使用File类找到一个文件 File f = new File("/home/xiejunyu/桌面/test.txt"); // 第2步：通过子类实例化父类对象 Writer out = new FileWriter(f); // 第3步：进行写操作 String str = "Hello World!"; // 准备一个字符串 out.write(str); // 将内容输出 // 第4步：关闭输出流 // out.close(); // 此时没有关闭 &#125; &#125; 程序运行后会发现文件中没有任何内容，这是因为字符流操作时使用了缓冲区，而在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果程序没有关闭字符流，缓冲区中的内容是无法输出的，所以得出结论：字符流使用了缓冲区，而字节流没有使用缓冲区。如果想让缓冲区中的内容输出，要么关闭流强制刷新缓冲区，要么调用flush方法冲刷缓冲区。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源(如文件或数据库)，则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。在字符流的操作中，所有的字符都是在内存中形成的，在输出前会将所有的内容暂时保存在内存之中，所以使用了缓冲区暂存数据。 建议：1.虽然不关闭字节流不影响数据的输出，且后续JVM会自动回收这部分内存，但还是建议在使用完任何流对象之后关闭流。2.使用流对象都要声明或抛出IOException3.在创建一个文件时，如果目录下有同名文件将被覆盖4.在写文件时，如果文件不存在，会在创建输出流对象并绑定文件时自动创建文件，不必使用File的exists方法提前检测4.在读取文件时，必须使用File的exists方法提前检测来保证该文件已存在，否则抛出FileNotFoundException 2.按流向分：输入流和输出流输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络等)，即是将数据源读入到程序的通信通道。输入流主要包括两个抽象基类：InputStream(字节输入流)和Reader(字符输入流)及其扩展的具体子类。输出流：程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道。输出流主要包括两个抽象基类：OutputStream(字节输出流)和Writer(字符输出流)及其扩展的具体子类。 3.按功能分：节点流和处理流按照流是否直接与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两类。节点流：程序用于直接操作目标设备所对应的类叫节点流。(低级流)处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据，这个间接流类就是处理流。处理流可以看成是对已存在的流进行连接和封装的流。(高级流) 注意：在使用到处理流对流进行连接和封装时，读写完毕要关闭所有出现的流，包括节点流和处理流。 (1) 节点流 File 文件流。对文件进行读、写操作：FileReader、FileWriter、FileInputStream、FileOutputStream。 Memory 流。向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。向内存字符串读写数据：StringReader、StringWriter、StringBufferInputStream。 Pipe管道流：实现管道的输入和输出(进程间通信)： PipedReader与PipedWriter、PipedInputStream与PipedOutputStream。 (1) 处理流 Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。 Filtering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。 Converting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换(Stream到Reader)：InputStreamReader、OutputStreamWriter。 Object Serialization 对象流 ：ObjectInputStream、ObjectOutputStream。 DataConversion数据流：按基本数据类型读、写(处理的数据是Java的基本类型)：DataInputStream、DataOutputStream 。 Counting计数流：在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。 Peeking Ahead预读流： 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream。 Printing打印流： 包含方便的打印方法 ：PrintWriter、PrintStream。 读取控制台输入在Java中，从控制台输入有三种方法： 1.使用标准输入流对象System.inSystem.in是System中内置的InputStream类对象，它的read方法一次只读入一个字节数据，返回0 ~ 255的一个byte值,一般用来读取一个字符，需要强制类型转换为char类型，而我们通常要取得一个字符串或一组数字，故这种方法不常用。下面给出这种方法的一个例子：1234567891011public class CharTest&#123;public static void main(String[] args) &#123; try&#123; System.out.print("Enter a Char:"); char i = (char)System.in.read(); System.out.println("Yout Enter Char is:" + i); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 使用这种方法必须提供try-catch块或者在main方法首部声明IOException异常，因为System.in是一个流对象 2.使用Scanner类Scanner类功能十分强大，可以读入字符串、整数、浮点数、布尔类型值等等。下面是例子：1234567891011121314public class ScannerTest&#123;public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); System.out.println("ScannerTest, Please Enter Name:"); String name = sc.nextLine(); //读取字符串型输入 System.out.println("ScannerTest, Please Enter Age:"); int age = sc.nextInt(); //读取整型输入 System.out.println("ScannerTest, Please Enter Salary:"); float salary = sc.nextFloat(); //读取float型输入 System.out.println("Your Information is as below:"); System.out.println("Name:" + name +"\n" + "Age:"+age + "\n"+"Salary:"+salary); &#125; &#125; 注意：1.用nextXXX()读入XXX类型的数据，XXX可以是除了char外的所有基本数据类型，还可以是BigInteger或BigDecimal，其中凡是整型类型的数据还可以指定radix(进制)，可以用next()和nextLine()读取一个字符串或一行字符2.next()和nextLine()的区别：next() 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串，除非用useDelimeter方法修改分隔符。 nextLine() 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 3.可以用循环配合hasNextXXX方法判断输入是否继续4.Scanner类没有直接提供读取一个字符的方法，如果要读取一个字符，有三种方法，一是读入一个字符串后取字符串的第一个字符，二是使用System.in的read方法，三是使用字符流读入 更多Scanner的用法之前已经在Java学习总结之Java基本程序设计结构中总结过了，不再赘述。 3.使用BufferedReader对象可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。下面是创建 BufferedReader 的基本语法：12BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 其中，System.in是一个InputStream对象(字节流)，使用InputStreamReader作为桥梁，将字节流转换为字符流，然后再使用BufferedReader进行进一步包装。BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符(读入一个用0~65535之间的整数表示的字符，需要强制类型转换为char类型，如果已到达流末尾，则返回 -1)，或者用 readLine() 方法读取一个字符串。下面是例子：1234567891011121314public static void main(String[] args)&#123;//必须要处理java.io.IOException异常 BufferedReader br = new BufferedReader(new InputStreamReader (System.in )); //java.io.InputStreamReader继承了Reader类 String read = null; System.out.print("输入数据："); try &#123; read = br.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("输入数据："+read); &#125; 下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。12345678910111213141516171819// 使用 BufferedReader 在控制台读取字符 import java.io.*; public class BRRead &#123; public static void main(String args[]) throws IOException &#123; char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println("输入字符, 按下 'q' 键退出。"); // 读取字符 do &#123; c = (char) br.read(); System.out.println(c); &#125; while(c != 'q'); &#125;&#125; 下面的程序读取和显示字符行直到你输入了单词”end”。1234567891011121314151617// 使用 BufferedReader 在控制台读取字符import java.io.*;public class BRReadLines &#123; public static void main(String args[]) throws IOException &#123; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; System.out.println("Enter lines of text."); System.out.println("Enter 'end' to quit."); do &#123; str = br.readLine(); System.out.println(str); &#125; while(!str.equals("end")); &#125;&#125; 在ACM等算法竞赛中，我们常常也会使用Java，在输入数据时有以下几点注意：1.hasXXX等价于C++中读到文件末尾(EOF)2.使用BufferedReader输入会比Scanner输入快十倍左右! 控制台输出控制台的输出由 print() 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类的一个对象。PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。PrintStream 定义 write() 的最简单格式如下所示：void write(int byteval)该方法将 byteval 的低八位字节写到流中,即System.out的write方法一次只能写一个字节(类比System.in的read方法一次只能读取一个字节)。下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：1234567891011import java.io.*; // 演示 System.out.write().public class WriteDemo &#123; public static void main(String args[]) &#123; int b; b = 'A';//向上类型转换 System.out.write(b); System.out.write('\n'); &#125;&#125; 注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。 字节流(OutputStream、InputStream)字节流主要是操作byte类型的数据，以byte数组为准，主要操作类是OutputStream、InputStream。由于文件读写最为常见，我们先讨论两个重要的字节流 FileInputStream(文件输入流) 和 FileOutputStream(文件输出流)，分别是抽象类InputStream和OutputStream的具体子类： FileInputStream该流用于从文件读取数据，它的对象可以用关键字 new 来创建。有多种构造方法可用来创建对象。可以使用字符串类型的文件名来创建一个输入流对象来读取文件：1InputStream f = new FileInputStream("C:/java/hello"); 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：12File f = new File("C:/java/hello");InputStream in = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。下面是一个例子：12345678public static void main(String[] args) throws IOException&#123; InputStream f = new FileInputStream ("/home/xiejunyu/桌面/test.txt"); int c = 0; while((c = f.read()) != -1) //这里也可以先用available方法得到可读的字节数 System.out.println((char)c);&#125; 当我们需要创建一个byte[]来保存读取的字节时，如果数组太小，无法完整读入数据，如果太大又会造成内存浪费。可以使用File类的length方法得到文件的数据字节数，从而有效确定byte数组的大小。12345678910111213141516public static void main(String[] args) &#123; // 创建一个FileInputStream对象 try &#123; FileInputStream fis = new FileInputStream("/home/xiejunyu/桌面/test.txt"); byte[] b=new byte[100]; fis.read(b,0,5); /*把字节从文件读入b数组，从b数组的0位置开始存放， 读取5个字节*/ System.out.println(new String(b)); fis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 注意: 每调用一次read方法,当前读取在文件中的位置就会向后移动一个字节或者移动byte[]的长度(read的两个重载方法)，已经到文件末尾会返回-1，可以通过read方法返回-1判断是否读到文件末尾，也可以使用available方法返回下一次可以不受阻塞读取的字节数来读取。FileInputStream不支持mark和reset方法进行重复读取。BufferedInputStream支持此操作。 FileOutputStream该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。有两个构造方法可以用来创建 FileOutputStream 对象。使用字符串类型的文件名来创建一个输出流对象：1OutputStream f = new FileOutputStream("C:/java/hello") 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：12File f = new File("C:/java/hello");OutputStream f = new FileOutputStream(f); 之前的所有操作中，如果重新执行程序，则肯定会覆盖文件中的已有内容，那么此时就可以通过FileOutputStream向文件中追加内容，FileOutputStream的另外一个构造方法：1public FileOutputStream(File file,boolean append) 在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。程序代码如下：12File f = new File("C:/java/hello");OutputStream f = new FileOutputStream(f,true); 创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。当有一个字符串时，可以用getBytes方法转为byte数组用于字节流的输出。 下面是一个演示 InputStream 和 OutputStream 用法的例子：123456789101112131415161718192021222324import java.io.*; public class FileStreamTest&#123; public static void main(String args[])&#123; try&#123; byte bWrite[] = "ABC".getBytes(); OutputStream os = new FileOutputStream("/home/xiejunyu/桌面/test.txt"); for(int x=0; x &lt; bWrite.length ; x++)&#123; os.write(bWrite[x] ); // writes the bytes &#125; os.close(); InputStream is = new FileInputStream("/home/xiejunyu/桌面/test.txt"); int size = is.available(); for(int i=0; i&lt; size; i++)&#123; System.out.print((char)is.read() + " "); &#125; is.close(); &#125;catch(IOException e)&#123; System.out.print("Exception"); &#125; &#125;&#125; 上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*; public class fileStreamTest2&#123; public static void main(String[] args) throws IOException &#123; File f = new File("a.txt"); FileOutputStream fop = new FileOutputStream(f); // 构建FileOutputStream对象,文件不存在会自动新建;如果存在会覆盖原文件 OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8"); // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk writer.append("中文输入"); // 写入到缓冲区 writer.append("\r\n"); //换行 writer.append("English"); // 刷新缓冲区,写入到文件,如果下面已经没有写入的内容了,直接close也会写入 writer.close(); //关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉 fop.close(); // 关闭输出流,释放系统资源 FileInputStream fip = new FileInputStream(f); // 构建FileInputStream对象 InputStreamReader reader = new InputStreamReader(fip, "UTF-8"); // 构建InputStreamReader对象,编码与写入相同 StringBuffer sb = new StringBuffer(); while (reader.ready()) &#123; sb.append((char) reader.read()); // 转成char加到StringBuffer对象中 &#125; System.out.println(sb.toString()); reader.close(); // 关闭读取流 fip.close(); // 关闭输入流,释放系统资源 &#125;&#125; 以上例子证明：在对多国语言的支持上，字符流表现更优，此时应使用字符流而不是字节流。 还可以用InputStream和OutputStream配合进行文件的复制，即读取原件数据，写入副本文件。复制有两种实现方式：实现一：将源文件中的内容全部读取进来，之后一次性的写入到目标文件实现二：边读边写 在实际开发中建议使用边读边写的方式，代码如下：123456789101112131415161718192021public static void main(String[] args) &#123; // 文件拷贝 try &#123; FileInputStream fis=new FileInputStream("happy.gif"); FileOutputStream fos=new FileOutputStream("happycopy.gif"); int n=0; byte[] b=new byte[1024]; while((n=fis.read(b))!=-1)&#123; /*循环读取，每次1024个字节，最后一次可能不满1024。 后面的字节覆盖前面的字节，不必担心数组溢出。*/ fos.write(b,0,n); //n是实际读取到的字节数，如果写fos.write(b)，会造成最后一次数组未满的情况也写1024个字节，从而造成副本比原件略大 &#125; fis.close(); fos.close(); &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; 实际上边读边写也分为三种方式：1.批量拷贝(循环读取，每次读入一个byte数组)2.缓冲拷贝(使用缓冲流)3.批量+缓冲拷贝(循环批量读取到字节数组中，然后使用缓冲输出流写入到文件) 第三种方式是最快的。 注意：InputStream的int read()方法读取一个字节，并用这个字节填充整型的低八位并返回，OutputStream的void write(int x)写入x的低八位，如果要写入一个int，需要移位并写4次。读写基本数据类型建议使用DataInputStream和DataOutputStream。 字符流(Writer、Reader)Java提供了两个操作字符的字符流基类，分别是Writer和Reader。先来了解两个用于读写文件的字符流FileReader(字符输入流)和FileWriter(字符输出流)： FileReaderFileReader类从InputStreamReader类继承而来。该类按字符读取流中数据。可以通过以下几种构造方法创建需要的对象。在给定从中读取数据的 File 的情况下创建一个新 FileReader。1FileReader(File file) 在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。1FileReader(FileDescriptor fd) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。1FileReader(String fileName) 创建FIleReader对象成功后，可以参照以下列表里的方法操作文件。 FileWriterFileWriter 类从 OutputStreamWriter 类继承而来。该类按字符向流中写入数据。可以通过以下几种构造方法创建需要的对象。在给出 File 对象的情况下构造一个 FileWriter 对象。1FileWriter(File file) 在给出 File 对象的情况下构造一个 FileWriter 对象。1FileWriter(File file, boolean append) 构造与某个文件描述符相关联的 FileWriter 对象。1FileWriter(FileDescriptor fd) 在给出文件名的情况下构造 FileWriter 对象，它具有指示是否挂起写入数据的 boolean 值。1FileWriter(String fileName, boolean append) 创建FileWriter对象成功后，可以参照以下列表里的方法操作文件。字符流的操作比字节流操作方便一点，就是可以直接输出字符串。不在用再像之前那样进行字节转换操作了。使用字符流默认情况下依然是覆盖已有的文件，如果想追加的话，则直接在FileWriter上增加一个可追加的标记即可。 下面的例子演示了FileReader和FileWriter的使用123456789101112131415161718192021import java.io.*;public class FileRead&#123; public static void main(String args[])throws IOException&#123; File file = new File("Hello1.txt"); // 创建文件 file.createNewFile(); // creates a FileWriter Object FileWriter writer = new FileWriter(file); // 向文件写入内容 writer.write("This\n is\n an\n example\n"); writer.flush(); writer.close(); //创建 FileReader 对象 FileReader fr = new FileReader(file); char [] a = new char[50]; fr.read(a); // 从数组中读取内容 for(char c : a) System.out.print(c); // 一个个打印字符 fr.close(); &#125;&#125; 字节-字符转换流(OutputStreamWriter、InputStreamReader)在整个IO包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流-字符流的转换类。 InputStreamReaderInputStreamReader是字节流通向字符流的桥梁，它使用指定的charset读取字节并将其解码为字符。它拥有一个InputStream类型的变量，并继承了Reader，使用了对象的适配器模式，如图所示：根据InputStream的实例创建InputStreamReader的方法有4种：1.根据默认字符集创建InputStreamReader(InputStream in)2.使用给定字符集创建InputStreamReader(InputStream in, Charset cs)3.使用给定字符集解码器创建InputStreamReader(InputStream in, CharsetDecoder dec)4.使用指定字符集名字符串创建InputStreamReader(InputStream in, String charsetName) 后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。注意：在对文件进行读写操作时，默认使用的是项目的编码，如果要读写其他编码方式的文件，要在构造输入输出流时指定对应的编码。这一般通过字节-字符转换流完成。 每次调用InputStreamReader中的一个read()方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。共有3个可用的read()方法： int read(); //读取单个字符int read(char[] cbuf, int offset, int length);//将字符读入数组中的某一部分boolean ready(); //判断此流是否已经准备好用于读取 使用字符流的形式读取字节流的文件，代码如下：123456789101112131415import java.io.* ;public class InputStreamReaderDemo01&#123; public static void main(String args[]) throws Exception&#123; File f = new File("d:" + File.separator + "test.txt") ; Reader reader = new InputStreamReader (new FileInputStream(f)) ; // 将字节流变为字符流 char c[] = new char[1024] ; int len = reader.read(c) ; // 读取 reader.close() ; // 关闭 System.out.println(new String(c,0,len)) ; &#125;&#125;; OutputStreamWriterOutputStreamWriter是字符流通向字节流的桥梁，可使用指定的charset将要写入流中的字符编码成字节。因此，它拥有一个OutputStream类型的变量，并继承了Writer，使用对象的适配器模式,如图所示：根据OutputStream的实例创建OutputStreamWriter的方法有4种： 1.根据默认字符集创建OutputStreamReader(OutputStream out) 2.使用给定字符集创建OutputStreamReader(OutputStream out, Charset cs) 3.使用给定字符集解码器创建OutputStreamReader(OutputStream out, CharsetDecoder dec) 4.使用指定字符集名字符串创建OutputStreamReader(OutputStream out, Stroutg charsetName) 后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。 每次调用write()方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给write()方法的字符没有缓冲。共有3个可用的write()方法：void write(char[] cbuf, int off, int len); //写入字符数组的某一部分void write(int c); //写入单个字符void write(String str, int off, int len); //写入字符串的某一部分 例如：将字节的文件输出流，以字符的形式输出。代码如下：1234567891011import java.io.* ;public class OutputStreamWriterDemo01&#123; public static void main(String args[]) throws Exception&#123; File f = new File("d:" + File.separator + "test.txt"); Writer out = new OutputStreamWriter (new FileOutputStream(f)) ; // 字节流变为字符流 out.write("hello world!!") ; // 使用字符流输出 out.close() ; &#125;&#125;; 特别说明：OutputStreamWriter是字符流到字节流的桥梁，这不表示OutputStreamWriter接收一个字符流并将其转换为字节流，恰恰相反，其接收的OutputStream是一个字节流，而它本身是一个字符流。那为什么说它是字符流到字节流的桥梁呢？我们以文件操作为例，之前已经提到，在内存中数据是以字符形式存在的，而在文件中数据是以字节形式保存的。所以在内存中的字符数据需要通过OutputStreamWriter变为字节流才能保存在文件之中，读取的时候需要将读入的字节流通过InputStreamReader变为字符流。但OutputStreamWriter和InputStreamReader都是字符流，也就是说，OutputStreamWriter以字符输出流形式操作了字节的输出流，但实际上还是以字节的形式输出。而InputStreamReader，虽然以字符输入流的形式操作，但实际上还是使用的字节流输入，也就是说，传输或者是从文件中读取数据的时候，文件中真正保存的数据永远是字节。 输入流和输出流要指定相同的字符集才能避免乱码！ FileWriter和FileReader的说明从JDK文档中可以知道FileOutputStream是OutputStream的直接子类，FileInputStream也是InputStream的直接子类，但是在字符流文件的两个操作类却有一些特殊，FileWriter并不直接是Writer的子类，而是转换流OutputStreamWriter的子类，而FileReader也不直接是Reader的子类，而是转换流InputStreamReader的子类，那么从这两个类的继承关系就可以清楚的发现，不管是是使用字节流还是字符流实际上最终都是以字节形式操作输出流的。 缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)缓冲流是一系列处理流(包装流)，目的是为了提高I/O效率，它们为I/O提供了内存缓冲区，这是一种常见的性能优化，增加缓冲区的两个目的：(1)允许Java的I/O一次不只操作一个字符，这样提高了整个系统的性能(2)由于有缓冲区，使得在流上执行skip、mark和reset方法都成为可能。如果没有缓冲区，每次调用 read() 或 write()方法都会对文件进行读或写字节，在文件和内存之间发生字节和字符的转换，这是极其低效的。 BufferedReaderBufferedReader是一个包装类，是为了提高读效率提供的，其可以接收一个Reader,然后用readLine()逐行读入字符流，直到遇到换行符为止（相当于反复调用Reader类对象的read()方法读入多个字符）。因此，建议用 BufferedReader 包装所有其 read() 操作可能开销很高的 Reader（如 FileReader 和 InputStreamReader),如： markSupported 判断该输入流能支持 mark 和 reset 方法。mark 用于标记当前位置，readlimit 制定可以重新读取的最大字节数，如果标记后读取的字节数不超过 readlimit 可以用 reset 回到标志位置重复读取。 BufferedWriter同理建议用BfferedWriter包装所有其write()操作可能开销很高的Writer(如FileWriter和OutputStreamWriter) BufferedInputStreamBufferedInputStream用于包装其他较为缓慢的InputStream构造方法摘要 BufferedInputStream(InputStream in)创建一个使用默认大小输入缓冲区的缓冲字节输入流 BufferedInputStream(InputStream in, int size)创建一个使用指定大小输入缓冲区的缓冲字节输入流 方法摘要 public int read();从该输入流中读取一个字节 public int read(byte[] b,int off,int len);从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。 BufferedOutputStreamBufferedOutputStream用于包装其他较为缓慢的OutputStream构造方法摘要 BufferedOutputStream(OutputStream out);创建一个使用默认大小输入缓冲区的缓冲字节输出流 BufferedOutputStream(OutputStream out,int size);创建一个使用默认大小输入缓冲区的缓冲字节输出流 方法摘要 public void write(int b);向输出流中输出一个字节 public void write(byte[] b,int off,int len);将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。 public void flush();刷新此缓冲的输出流。这迫使所有缓冲的输出字节被写出到底层输出流中。 其他（1）缓冲输入流BufferedInputSTream除了支持read和skip方法意外，还支持其父类的mark和reset方法;（2）BufferedReader提供了一种新的ReadLine方法用于读取一行字符串（以\r或\n分隔）;（3）BufferedWriter提供了一种新的newLine方法用于写入一个行分隔符;（4）对于输出的缓冲流，BufferedWriter和BufferedOutputStream，写出的数据会先在缓冲区(由缓冲流提供的一个字节数组，是不可见的)中缓存，直到缓冲区满了会自动写数据到输出流，如果缓冲区未满，可以使用flush方法将会使缓冲区的数据强制写出。关闭输出流也会造成缓冲区中残留的数据被写出。注意BufferedReader和BufferedInputStream没有flush方法，因为flush只用于输出到文件时。 打印流(PrintStream、PrintWriter)在整个IO包中，打印流是输出信息最方便的类，主要包含字节打印流(PrintStream)和字符打印流(PrintWriter)。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等。相较OutputStream在输出时的各种麻烦(比如要将String转为byte[]才能输出)打印流中可以方便地进行输出。 PrintStream1、public PrintStream(File file) throws FileNotFoundException//构造方法 通过一个File对象实例化PrintStream类 2、public PrintStream(OutputStream out)//构造方法 接收OutputStream对象，实例化PrintStream类 3、public PrintStream printf(Locale l, String format, Object …arg)//普通方法 根据指定的Locale进行格式化输出 4、public PrintStream printf(String format,Object … arg)//普通方法 根据本地环境进行格式化输出 5、public void print(boolean b)//普通方法 此方法被重载很多次，输出任意数据 6、public void println(boolean b)//普通方法 此方法被重载很多次，输出任意数据后换行 打印流的好处：在PrintStream中定义的构造方法中可以清楚的发现有一个构造方法可以直接接收OutputStream类的实例，这是因为与OutputStream相比起来，PrintStream可以更加方便的输出数据，这就好比将OutputStream重新包装了一下，使之输出更加方便。 PrintWriter构造方法 //使用指定文件创建不具有自动行刷新的新 PrintWriterpublic PrintWriter(File file); //创建具有指定文件和字符集且不带自动刷行新的新 PrintWriterpublic PrintWriter(File file,String csn); //根据现有的 OutputStream 创建不带自动行刷新的新PrintWriterpublic PrintWriter(OutputStream out); //通过现有的 OutputStream 创建新的 PrintWriter(具有自动行刷新)public PrintWriter(OutputStream out,boolean autoFlush); //创建具有指定文件名称且不带自动行刷新的新PrintWriterpublic PrintWriter(String fileName); //创建具有指定文件名称和字符集且不带自动行刷新的PrintWriterpublic PrintWriter(String fileName,String csn); //创建新 PrintWriter(具有自动行刷新)public PrintWriter(Writer out,boolean autoFlush) 常用方法//打印boolean值public void print(boolean b)//打印 boolean 值，然后终止该行public void println(boolean x) //打印字符public void print(char c)//打印字符，然后终止该行public void println(char x) //打印字符数组public void print(char[] s)//打印字符数组，然后终止该行public void println(char[] x) //打印 double 精度浮点数public void print(double d)//打印 double 精度浮点数,然后终止该行public void println(double x) //打印一个浮点数public void print(float f)//打印浮点数，然后终止该行public void println(float x) //打印整数public void print(int i)//打印整数，然后终止该行public void println(int x) //打印 long 整数public void print(long l)//打印 long 整数，然后终止该行public void println(long x) //打印对象public void print(Object obj)//打印 Object，然后终止该行public void println(Object x) //打印字符串。如果参数为 null，则打印字符串 “null”public void print(String s)//打印 String，然后终止该行public void println(String x) //通过写入行分隔符字符串终止当前行public void println() //使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区public PrintWriter format(Locale l,String format,Object… args) //使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区public PrintWriter format(String format,Object… args) //将指定字符添加到此 writerpublic PrintWriter append(char c)//将指定的字符序列添加到此 writerpublic PrintWriter append(CharSequence csq)//将指定字符序列的子序列添加到此 writerpublic PrintWriter append(CharSequence csq,int start,int end) //写入字符数组public void write(char[] buf)//写入字符数组的某一部分public void write(char[] buf,int off,int len)//写入单个字符public void write(int c)//写入字符串public void write(String s)//写入字符串的某一部分public void write(String s,int off,int len) 提示：由于BufferedWriter没有PrintWriter使用灵活，所以在实际的操作中，我们往往会使用PrinterWriter/BufferedReader这种组合。 内存操作流之前的程序中，输出输入都是在内存和文件之间进行的，当然，输入输出也可以不访问文件，只在内存中进行。也就是把数据的输入源和输出目的地从文件改成了byte数组、char数组或字符串。 字节数组流(ByteArrayInputStream、ByteArrayOutputStream)ByteArrayInputStream的主要功能是完成将byte数组的内容写入到内存之中，而ByteArrayOutputStream的主要功能是将内存中的数据输出到byte数组。 ByteArrayInputStream字节数组输入流从内存中的一个字节数组读取字节到内存，这个字节数组就是数据的输入源。创建字节数组输入流对象有以下几种方式。接收字节数组作为参数创建：12ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] b); 另一种创建方式是接收一个字节数组，和两个整型变量 off、len，off表示第一个读取的字节，len表示读取字节的长度,即将字节数组中从off开始的len个字节读入该输入流。12ByteArrayInputStream bArray = newByteArrayInputStream(byte []b,int off,int len) 成功创建字节数组输入流对象后，可以参见以下列表中的方法，对流进行读操作或其他操作。 ByteArrayOutputStream字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中，可以用toByteArray()得到该字节数组，也可以用toString()得到缓冲区内容转换得到的字符串。创建字节数组输出流对象有以下几种方式。下面的构造方法创建一个32字节（默认大小）的缓冲区。1OutputStream bOut = new ByteArrayOutputStream(); 另一个构造方法创建一个大小为n字节的缓冲区。1OutputStream bOut = new ByteArrayOutputStream(int n) 成功创建字节数组输出流对象后，可以参见以下列表中的方法，对流进行写操作或其他操作。下面的例子演示了ByteArrayInputStream 和 ByteArrayOutputStream的使用：12345678910111213141516171819202122232425import java.io.* ;public class ByteArrayDemo01&#123; public static void main(String args[])&#123; String str = "HELLOWORLD" ; // 定义一个字符串，全部由大写字母组成 ByteArrayInputStream bis = null ; // 内存输入流 ByteArrayOutputStream bos = null ; // 内存输出流 bis = new ByteArrayInputStream(str.getBytes()) ; // 向内存中输入内容 bos = new ByteArrayOutputStream() ; // 准备从内存ByteArrayInputStream中读取内容 int temp = 0 ; while((temp=bis.read())!=-1)&#123; char c = (char) temp ; // 读取的数字变为字符 bos.write(Character.toLowerCase(c)) ; // 将字符变为小写 &#125; // 所有的数据就全部都在ByteArrayOutputStream中 String newStr = bos.toString() ; // 取出内容 try&#123; bis.close() ; bos.close() ; &#125;catch(IOException e)&#123; e.printStackTrace() ; &#125; System.out.println(newStr) ; &#125;&#125; 字符数据流(CharArrayReader、CharArrayWriter)CharArrayReader、CharArrayWriter和ByteArrayInputStream、ByteArrayOutputStream类似，只不过后者是字节数组输入流，而前者是字符数组输入流。CharArrayReader构造方法摘要 CharArrayReader(char buf[]);使用传入的buf构造CharArrayReader CharArrayReader(char buf[], int offset, int length);使用传入的buf的一部分构造CharArrayReader 方法摘要 void close(); 关闭此流 void mark(int readAheadLimit); 标记当前流读取的位置 void markSupport(); 检测此流是否支持标记 int read(); 读取一个字符、并以整数形式返回 int read(char[] b, int off, int len); 将buf中len个字符读取到下标从off开始的b中、返回读取的字符个数 boolean ready(); 查看CharArrayReader是否可读。 void reset(); 将此流开始位置重置到最后一次调用mark是流的读取位置 long skip(long n); 丢弃buf中n个字符、返回实际丢弃的字符个数 CharArrayWriter构造方法摘要 public CharArrayWriter()使用默认的buf大小创建CharArrayWriter。 public CharArrayWriter(int initialSize)使用指定的buf大小创建CharArrayWriter。 方法摘要 CharArrayWriter append(CharSequence csq)将一串有序字符序列写入buf中 CharArrayWriter append(CharSequence csq, int start, int end)将一串有序字符序列的一部分写入buf中 CharArrayWriter append(char c) 将一个字符写入buf中 void close() 关闭此流（没有效果，因为不访问文件） void flush() flush此流（没有效果，因为不访问文件） void reset() 清空buf、重头开始 int size() 查看当前buf中字符总数 char[] toCharArray() 将buf中内容转换成char[] String toString() 将buf中字符转换成String返回 void write(int c) 写入一个字符。 void write(char c[], int off, int len)将一个char[]的一部分写入buf中、若buf满、扩容。 void write(String str, int off, int len)将一个字符串写入buf中、满自动扩容 void writeTo(Writer out)将buf中现有的字节写入到另一个输出字符流out中 例子：123456789101112131415161718192021public static void main(String[] args) throws IOException &#123; String str = "Hello world!"; // 构建字符输入流 CharArrayReader reader = new CharArrayReader(str.toCharArray()); // 从字符输入流读取字符 char[] chars = new char[1024]; int len = reader.read(chars); System.out.println(new String(chars, 0, len)); &#125; //构建字符输出流 CharArrayWriter writer = new CharArrayWriter(1024 * 1024); // 将字符串写入到CharArrayWriter String msg = "hello world！！！22121"; writer.write(msg.toCharArray()); System.out.println(writer.toString()); writer.close(); 字符串流(StringReader、StringWriter)字符串流和字符数据流基本一样，只是把char[]数组换成了String，在此不赘述。 合并流(SequenceInputStream、SequenceOutputStream)SequenceInputStream有些情况下，当我们需要从多个输入流中向程序读入数据。此时，可以使用合并流，将多个输入流合并成一个SequenceInputStream流对象。SequenceInputStream会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。 合并流的作用是将多个源合并合一个源。 构造方法public SequenceInputStream(InputStream s1,InputStream s2)使用两个输入流对象实例化本类对象。 示例：1234567891011121314151617181920212223242526272829import java.io.File ;import java.io.SequenceInputStream ;import java.io.FileInputStream ;import java.io.InputStream ;import java.io.FileOutputStream ;import java.io.OutputStream ;public class SequenceDemo&#123; public static void main(String args[]) throws Exception &#123; // 所有异常抛出 InputStream is1 = null ; // 输入流1 InputStream is2 = null ; // 输入流1 OutputStream os = null ; // 输出流 SequenceInputStream sis = null ; // 合并流 is1 = new FileInputStream("d:" + File.separator + "a.txt"); is2 = new FileInputStream("d:" + File.separator + "b.txt"); os = new FileOutputStream("d:" + File.separator + "ab.txt"); sis = new SequenceInputStream(is1,is2) ; // 实例化合并流 int temp = 0 ; // 接收内容 while((temp=sis.read())!=-1)&#123; // 循环输出 os.write(temp) ; // 保存内容 &#125; sis.close() ; // 关闭合并流 is1.close() ; // 关闭输入流1` is2.close() ; // 关闭输入流2 os.close() ; // 关闭输出流 &#125;&#125;; SequenceOutputStream同SequenceInputStream,区别在于合并的是两个OutputStream，在此不赘述。 数据操作流(DataInputStream、DataOutputStream)DataInputStream数据输入流允许应用程序以与机器无关方式从底层输入流中读取Java 8种基本数据类型，方法命名为readXxx。下面的构造方法用来创建数据输入流对象。1DataInputStream dis = new DataInputStream(InputStream in); 另一种创建方式是接收一个字节数组，和两个整形变量 off、len，off表示第一个读取的字节，len表示读取字节的长度。1DataInputStream dis = new DataInputStream(byte[] a,int off,int len); DataOutputStream数据输出流允许应用程序以与机器无关方式将Java 8种基本数据类型写到底层输出流,方法命名为writeXxx。下面的构造方法用来创建数据输出流对象。1DataOutputStream out = new DataOutputStream(OutputStream out); 创建对象成功后，可以参照以下列表给出的方法，对流进行写操作或者其他操作。下面的例子演示了DataInputStream和DataOutputStream的使用，该例从文本文件test.txt中读取5行，并转换成大写字母，最后保存在另一个文件test1.txt中。123456789101112131415161718192021import java.io.*;public class Test&#123; public static void main(String args[])throws IOException&#123; DataInputStream d = new DataInputStream(new FileInputStream("test.txt")); DataOutputStream out = new DataOutputStream(new FileOutputStream("test1.txt")); String count; while((count = d.readLine()) != null)&#123; String u = count.toUpperCase(); System.out.println(u); out.writeBytes(u + " ,"); &#125; d.close(); out.close(); &#125;&#125; 对象流(ObjectInputStream、ObjectOutputStream)对象序列化对象序列化，就是把一个对象变为二进制的数据流的一种方法，通过对象序列化可以方便的实现对象的传输或存储。 注意：Serializable接口和Cloneable接口一样是一个标记接口，即没有任何方法的接口。但只有一个类实现了Serializable接口，它才能被序列化为二进制流进行传输，否则会抛出NotSerializableException异常。一个类如果实现了Serializable接口，其子类也都可以序列化。 定义一个可被序列化的类：12345678910111213import java.io.Serializable ;public class Person implements Serializable&#123; private String name ; private int age ; public Person(String name,int age)&#123; this.name = name ; this.age = age ; &#125; public String toString()&#123; return "姓名：" + this.name + "；年龄：" + this.age ; &#125;&#125;; 以后此类的对象就可以被序列化了。变为二进制byte流。 serialVersionUID在对象进行序列化或反序列化操作的时候，要考虑JDK版本的问题，如果序列化的JDK版本和反序列化的JDK版本不统一则就有可能造成异常。所以在序列化操作中引入了一个serialVersionUID的常量，可以通过此常量来验证版本的一致性，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现版本不一致的异常。 在上述的Person类中添加private static final long serialVersionUID = 1L;即可 对象的序列化和反序列化要想完成对象的输入或输出，还必须依靠对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）,使用对象输出流输出序列化对象的过程，即把Java对象转换为字节序列的过程，也称为序列化，而使用对象输入流读入的过程，即把字节序列恢复为Java对象的过程，也称为反序列化。 ObjectOutputStream(序列化)常用构造方法：public ObjectOutputStream(OutputStream out) //接收一个字节输出流对象 常用方法：public final void writeObject(Object obj) //把一个对象写入输出流 例子：12345678910public class SerDemo01&#123; public static void main(String args[]) throws Exception &#123; File f = new File("D:" + File.separator + "test.txt") ; // 定义保存路径 ObjectOutputStream oos = null ; // 声明对象输出流 OutputStream out = new FileOutputStream(f) ; // 文件输出流 oos = new ObjectOutputStream(out) ; oos.writeObject(new Person("张三",30)) ; // 保存对象 oos.close() ; // 关闭 &#125; &#125;; 对象序列化的真正内容：由于堆中只保存对象的非静态属性，方法和静态属性保存在静态区。所以序列化的实际是对象的非静态属性。 ObjectInputStream(反序列化)常用构造方法：public ObjectInputStream(InputStream in) //接收一个字节输入流对象常用方法：public final Object readObject() //把输入流读出对象 例子：12345678910public class SerDemo01&#123; public static void main(String args[]) throws Exception &#123; File f = new File("D:" + File.separator + "test.txt") ; ObjectInputStream ois = null ; InputStream in = new FileOutputStream(f); ois = new ObjectInStream(in) ; Person person = (Person)ois.readObject(); oos.close() ; &#125;&#125;; transient关键字当使用Serializable接口实现序列化操作时，如果一个对象中的某个属性不希望被JVM默认序列化的话，则可以使用transient关键字进行声明。如果用transient声明一个实例变量，当对象存储时，它的值不需要维持，而会保持默认值。换句话来说就是，用transient关键字标记的成员变量不参与JVM的默认序列化过程。 更多序列化知识见：Java序列化心得（一）：序列化设计和默认序列化格式的问题Java序列化心得（二）：自定义序列化Java IO操作——对象序列化（Serializable接口、ObjectOutputStream、以及与Externalizable接口的用法和区别） 拓展：ArrayList源码中对序列化的实现就是默认序列化和自定义序列化混合，只对底层数组的有效元素进行序列化，多余空间不必序列化，从而提高了性能。 在对子类进行反序列化的操作时，没有实现Serializable接口的父类的构造方法会被自顶向下调用。 压缩流在日常的使用中经常会使用到像WinRAR或WinZIP这样的压缩文件，通过这些软件可以把一个很大的文件进行压缩以方便传输。在JAVA中 为了减少传输时的数据量也提供了专门的压缩流，可以将文件或文件夹压缩成ZIP、JAR、GZIP等文件的格式。具体见大牛博客：http://blog.csdn.net/u013087513/article/details/52151227 管道流(PipedOutputStream、PipedInputStream)管道流的作用是可以进行两个线程间的通讯，分为管道输出流(PipedOutputStream)、管道输入流(PipedInputStream)如果要想进行管道输出，则必须把输出流连在输入流之上，在PipedOutputStream中有一个方法用于连接管道：public void connect(PipedInputStream snk) throws IOException 例子如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.* ;class Send implements Runnable&#123; // 线程类 private PipedOutputStream pos = null ; // 管道输出流 public Send()&#123; this.pos = new PipedOutputStream() ; // 实例化输出流 &#125; public void run()&#123; String str = "Hello World!!!" ; // 要输出的内容 try&#123; this.pos.write(str.getBytes()) ; &#125;catch(IOException e)&#123; e.printStackTrace() ; &#125; try&#123; this.pos.close() ; &#125;catch(IOException e)&#123; e.printStackTrace() ; &#125; &#125; public PipedOutputStream getPos()&#123; // 得到此线程的管道输出流 return this.pos ; &#125;&#125;class Receive implements Runnable&#123; private PipedInputStream pis = null ; // 管道输入流 public Receive()&#123; this.pis = new PipedInputStream() ; // 实例化输入流 &#125; public void run()&#123; byte b[] = new byte[1024] ; // 接收内容 int len = 0 ; try&#123; len = this.pis.read(b) ; // 读取内容 &#125;catch(IOException e)&#123; e.printStackTrace() ; &#125; try&#123; this.pis.close() ; // 关闭 &#125;catch(IOException e)&#123; e.printStackTrace() ; &#125; System.out.println("接收的内容为：" + new String(b,0,len)) ; &#125; public PipedInputStream getPis()&#123; return this.pis ; &#125;&#125;public class PipedDemo&#123; public static void main(String args[])&#123; Send s = new Send() ; Receive r = new Receive() ; try&#123; s.getPos().connect(r.getPis()) ; // 连接管道 &#125;catch(IOException e)&#123; e.printStackTrace() ; &#125; new Thread(s).start() ; // 启动线程 new Thread(r).start() ; // 启动线程 &#125;&#125; 回退流(PushbackInputStream和PushbackReader)在Java IO中所有的数据都是采用顺序的读取方式，即对于一个输入流来讲都是采用从头到尾的顺序读取的，如果在输入流中某个不需要的内容被读取进来，则只能通过程序将这些不需要的内容处理掉，为了解决这样的处理问题，在Java中提供了一种回退输入流(PushbackInputStream、PushbackReader),可以把读取进来的某些数据重新回退到输入流的缓冲区之中。 回退流分为字节回退流和字符回退流，我们以字节回退流PushbackInputStream为例。 对于回退操作来说，提供了三个unread()的操作方法，这三个操作方法与InputStream类中的read()方法是一一对应的。 例子如下，内存中使用ByteArrayInputStream，把内容设置到内存之中： 1234567891011121314151617181920212223 import java.io.ByteArrayInputStream ;import java.io.PushbackInputStream ;public class PushInputStreamDemo&#123; public static void main(String args[]) throws Exception &#123; // 所有异常抛出 String str = "www.baidu.com" ; // 定义字符串 PushbackInputStream push = null ; // 定义回退流对象 ByteArrayInputStream bai = null ; // 定义内存输入流 bai = new ByteArrayInputStream(str.getBytes()) ; // 实例化内存输入流 push = new PushbackInputStream(bai) ; // 从内存中读取数据 System.out.print("读取之后的数据为：") ; int temp = 0 ; while((temp=push.read())!=-1)&#123; // 读取内容 if(temp=='.')&#123; // 判断是否读取到了“.” push.unread(temp) ; // 放回到缓冲区之中 temp = push.read() ; // 再读一遍 System.out.print("（退回"+(char)temp+"）") ; &#125;else&#123; System.out.print((char)temp) ; // 输出内容 &#125; &#125; &#125;&#125;; 选择合适的IO流1.首先，明确IO流中有两个主要的体系，即 InputStream、OutputStream和Reader、Writer。其次，明确数据的来源和数据将要到达的目的地。 2.明确将要操作的数据是否是纯文本数据。如果数据源是纯文本数据选Reader;数据源不是纯文本数据选择InputStream。如果数据目的地是纯文本数据就选择Writer;如果不是则选择OutputStream。 3.明确具体的设备。即数据源是从哪个设备来的：是硬盘就加File;是键盘用System.in(是一个InputStream对象);是内存用数组;是网络用Socket流。同样目的是哪个设备：是硬盘就加File;是键盘用System.out(是一个PrintStream对象);是内存用数组;是网络用Socket流。 4.明确是否还需要其他额外功能呢，例如：①是否需要较高的效率，即是否需要使用缓冲区，是就加上Buffered;②是否需要转换，是就使用转换流，InputStreamReader 和OutputStreamWriter。 例子： System类对IO的支持(out、err、in)System类的常量System表示系统类，实际上在Java中也对IO给予了一定的支持1、public static final PrintStream out//常量 对应系统标准输出，一般是显示器2、public static final PrintStream err//常量 错误信息输出3、public static final InputStream in//常量 对应标准输出，一般是键盘 使用static final关键字声明的变量是全局常量，只要是常量，则所有的单词字母必须全部大写，按照现在的标准：System.OUT —&gt; System.out System.out使用System.out输出的时候就是将输出的位置定义在了显示器之中。FileOutputStream是定位在文件里，而System.out是定位在屏幕上输出。PrintStream就是OutputStream的子类。123456789101112131415161718import java.io.OutputStream ;import java.io.IOException ;public class SystemDemo01&#123; public static void main(String args[])&#123; OutputStream out = System.out ;// 此时的输出流是向屏幕上输出 try&#123; out.write("hello world!!!".getBytes()) ; // 向屏幕上输出 &#125;catch(IOException e)&#123; e.printStackTrace() ; // 打印异常 &#125; try&#123; out.close() ; // 关闭输出流 &#125;catch(IOException e)&#123; e.printStackTrace() ; &#125; &#125;&#125; System.errSystem.err 表示的是错误的标准输出，如果程序中出现了错误的话，则直接使用System.err进行输出即可。程序如下：1234567891011public class SystemDemo02&#123; public static void main(String args[])&#123; String str = "hello" ; // 声明一个非数字的字符串 try&#123; System.out.println(Integer.parseInt(str)) ; // 转型 &#125;catch(Exception e)&#123; System.err.println(e) ; &#125; &#125;&#125;; 使用System.out输出错误如下：1234567891011public class SystemDemo03&#123; public static void main(String args[])&#123; String str = "hello" ; // 声明一个非数字的字符串 try&#123; System.out.println(Integer.parseInt(str)) ; // 转型 &#125;catch(Exception e)&#123; System.out.println(e) ; &#125; &#125;&#125;; System.out 和System.err 的区别：System.out和System.err都是PrintStream的实例化对象，而且通过代码可以发现，两者都可以输出错误信息，但是一般来讲System.out是将信息显示给用户看，是正常的信息显示，而System.err的正好相反是不希望用户看到的，会直接在后台打印，是专门显示错误的。一般来讲，如果要输出错误信息的时候最好不要使用System.out而是直接使用System.err 这一点只能从其概念上划分。 System.inSystem.in实际上是一个键盘的输入流，其本身是InputStream类型的对象。那么，此时就可以利用此方式完成从键盘读取数据的功能。InputStream对应的是输入流，输入流的话肯定是从指定位置读取的，之前使用的是FileInputStream，是从文件中读取的。 123456789101112import java.io.InputStream ;public class SystemDemo04&#123; public static void main(String args[]) throws Exception &#123; // 所有异常抛出 InputStream input = System.in ; // 从键盘接收数据 byte b[] = new byte[1024] ; // 开辟空间，接收数据 System.out.print("请输入内容：") ; // 提示信息 int len = input.read(b) ; // 接收数据 System.out.println("输入的内容为：" + new String(b,0,len)) ; input.close() ; // 关闭输入流 &#125;&#125;; 但是以上的操作存在如下问题：问题一：指定了输入数据的长度，如果现在输入的数据超过了长度范围，只能输入部分的数据。问题二：如果byte数组是奇数的话，则还可能出现中文乱码的情况，因为一个字符是两个字节。 可以通过标志位的方式避免指定byte数组大小来解决。实例如下：12345678910111213141516171819import java.io.InputStream ;public class SystemDemo05&#123; public static void main(String args[]) throws Exception &#123; // 所有异常抛出 InputStream input = System.in ; // 从键盘接收数据 StringBuffer buf = new StringBuffer() ; // 使用StringBuffer接收数据 System.out.print("请输入内容：") ; // 提示信息 int temp = 0 ; // 接收内容 while((temp=input.read())!=-1)&#123; char c = (char) temp ; // 将数据变为字符 if(c=='\n')&#123; // 退出循环，输入回车表示输入完成 break ; &#125; buf.append(c) ; // 保存内容 &#125; System.out.println("输入的内容为：" + buf) ; input.close() ; // 关闭输入流 &#125;&#125; 但这种方法读取中文还是会乱码，这是因为每读取一个字节就将其转为字符，字母和数字都是占1个字节 可以正常显示。但是如果是中文的话，就相当于每读取到一个字节就是半个字符就进行转化，所以导致乱码的错误。最好的输入方式是将全部输入的数据暂时存放在一块内存之上，之后一次性的从内存中读取数据，这样所有数据就整体只读了一次，则不会造成乱码，而且也不会受到长度的限制。 上述功能可以通过BufferedReader实现。 输入输出重定向从之前的操作中知道System.out、System.err、System.in三个常量的作用，但是通过System类也可以改变System.in的输入流来源，以及System.out和System.err两个输出流的输出位置。1、public static void setOut(PrintStream out)//普通方法 重定向标准输出流2、public static void setErr(PrintStream err)//普通方法 重定向标准错误输出流3、public static void setIn(InputStream in)//普通方法 重定向标准输入流 为System.out输出重定向1234567891011121314import java.io.File ;import java.io.FileOutputStream ;import java.io.PrintStream ;public class SystemDemo06&#123; public static void main(String args[]) throws Exception &#123; System.setOut( new PrintStream( new FileOutputStream("d:" + File.separator + "red.txt"))) ; // System.out输出重定向 System.out.print("hello") ; // 输出时，不再向屏幕上输出 System.out.println(",world") ; &#125;&#125;; System.out是希望用户看得到信息，一旦有错误，最好保存起来。12345678910111213141516171819202122import java.io.File ;import java.io.FileOutputStream ;import java.io.PrintStream ;public class SystemDemo07&#123; public static void main(String args[])&#123; String str = "hello" ; // 声明一个非数字的字符串 try&#123; System.out.println(Integer.parseInt(str)) ; // 转型 &#125;catch(Exception e)&#123; try&#123; System.setOut( new PrintStream( new FileOutputStream("d:" + File.separator + "err.log"))) ; // 输出重定向 &#125;catch(Exception e1)&#123; &#125; System.out.println(e) ; &#125; &#125;&#125;; 通过此操作就可以完成错误的重定向，保存错误日志。 为System.err重定向利用System.err向屏幕上输出信息，此时，为了方便起见，使用内存操作流。12345678910111213import java.io.ByteArrayOutputStream ;import java.io.PrintStream ;public class SystemDemo08&#123; public static void main(String args[]) throws Exception&#123; // 所有异常抛出 ByteArrayOutputStream bos = null ; // 声明内存输出流 bos = new ByteArrayOutputStream() ; // 实例化 System.setErr(new PrintStream(bos)) ; // 输出重定向 System.err.print("hello") ; // 错误输出，不再向屏幕上输出 System.err.println("world") ; // 向内存中输出 System.out.println(bos) ; // 输出内存中的数据 &#125;&#125;; 一般不建议去修改System.err的输出位置，因为这样的信息都不太希望用户可以看见。 为System.in重定向默认情况下System.in是指键盘输入，也可以通过setIn()方法，将其输入流的位置改变，例如，现在从文件中读取。123456789101112131415import java.io.FileInputStream ;import java.io.InputStream ;import java.io.File ;public class SystemDemo09&#123; public static void main(String args[]) throws Exception&#123; // 所有异常抛出 System.setIn(new FileInputStream("d:" + File.separator + "demo.txt")) ; // 设置输入重定向 InputStream input = System.in ; // 从文件中接收数据 byte b[] = new byte[1024] ;// 开辟空间，接收数据 int len = input.read(b) ; //接收 System.out.println("输入的内容为：" + new String(b,0,len)) ; input.close() ; // 关闭输入流 &#125;&#125;; 总结三个常量的使用： System.out是希望用户可以看见的信息。用IDE(Eclipse)的话错误信息使用黑颜色显示的。 System.err 是不希望用户可以看见的信息。则在IDE中将以红色的文字显示错误信息。 System.in 对应键盘输入。 以上三个常量的输入、输出都可以重定向，但是一般建议只修改setOut的重定向。 System.in读取的时候会出现中文乱码的问题，则可以通过BufferedReader完成读取功能。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用telnet发送HTTP请求报文]]></title>
    <url>%2F2017%2F11%2F19%2F%E4%BD%BF%E7%94%A8telnet%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[我们可以使用telnet给特定的Web服务器发送HTTP请求报文，得到服务器的HTTP相应报文。 比如，打开终端输入下面命令： telnet www.baidu.com 80 //Web服务器ip或域名、端口GET https://www.baidu.com/ HTTP/1.1//请求行：方法字段、URL字段、HTTP版本字段Host: www.baidu.com //首部行 在输入最后一个首部行之后连续按两次回车，这就打开一个到主机 www.baidu.com 的80端口的TCP连接，并发送一个HTTP请求报文。你将会看到一个携带包括百度主页的HTML基本文件的相应报文(HTML文件，即对象被封装在相应报文的实体体中)。如果只是想看一下HTTP协议的报文行，而不是获取对象本身的话，可以用HEAD代替GET。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用telnet登录SMTP服务发送邮件]]></title>
    <url>%2F2017%2F11%2F19%2F%E4%BD%BF%E7%94%A8telnet%E7%99%BB%E5%BD%95SMTP%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在看《计算机网络自顶向下方法》，初步了解了SMTP协议。尝试用telnet登录SMTP服务给自己的qq邮箱发送了一封邮件，中间踩了很多坑，现在把具体步骤总结如下： 1.打开终端，输入telnet,回车 2.输入o smtp.139.com 25,此处o是open的缩写,以139邮箱为例,25表示SMTP服务器时刻监听的端口号,登录SMTP服务器。服务器返回220 localhost richmail system v10(2eff5a1190ba8e2-ea850)表示成功 3.输入HELO xxx,和服务器打招呼,xxx可以是任意内容,确认服务器应答,服务器返回250 localhost richmail system v10(2eff5a1190ba8e2-ea850)表示成功 4.输入auth login,请求登录,服务器返回334 dXNlcm5hbWU6,334是成功的状态码,后面是 username: 的base64码,可以在网上找到编码和解码工具 5.输入转换为base64码后的发送邮箱的用户名,不用带邮件域名，服务器返回334 UGFzc3dvcmQ6，334是成功的状态码，后面是 password: 的base64码 6.输入转换为base64码后的发送邮箱的密码,服务器返回235 Authentication successful表示登录成功 7.输入MAIL FROM:&lt;发件人邮箱地址&gt;，告诉服务器发信人的地址,服务器返回250 Mail OK表示成功 8.输入RCPT TO:&lt;收件人邮箱地址&gt;，告诉服务器收信人的地址,服务器返回250 Mail OK表示成功 9.输入DATA,开始写邮件,服务器返回354 End data with .提示邮件以一个单独占有一行的.结束 10.邮件格式如下:123456To:收件人邮箱地址From:发件人邮箱地址Subject:邮件主题 //前三行是首部行 //首部行和报文体之间要有一个空行 邮件正文 //报文体． //结束邮件的标志 服务器返回250 ok表示发送成功，如果要继续发送，则返回步骤7重复即可。 11.发送完所有邮件之后输入QUIT,关闭TCP连接 下面是成功接收的邮件 注意几个坑：1.发件方使用的是139邮箱，尝试qq邮箱和163邮箱开启了SMTP服务也不成功，可能是基于安全性考虑进行了限制2.收件方邮箱如果有反垃圾机制，应该事先关闭，否则会拒绝接收邮件]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之异常处理]]></title>
    <url>%2F2017%2F11%2F08%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[引言在程序运行过程中(注意是运行阶段，程序可以通过编译)，如果JVM检测出一个不可能执行的操作，就会出现运行时错误。例如，使用一个越界的下标访问数组，程序就会产生一个ArrayIndexOutOfBoundsException的运行时错误。如果程序需要输入一个整数的时候用户输入了一个double值，会得到一个InputMismatchException的运行时错误。在Java中，运行时错误会作为异常抛出。异常就是一种对象，表示阻止正常进行程序执行的错误或者情况。如果异常没有被处理，那么程序就会非正常终止。人们在遇到错误时会感觉不爽。如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序了，为了避免这类事情的发生，至少应该做到以下几点： 向用户通告错误 保存所有的工作结果 允许用户以妥善的形式退出程序 Java使用一种称为异常处理的错误捕获机制处理，从而使程序继续运行或优雅终止。 异常处理概述异常处理使得程序可以处理非预期的情景，并且继续正常的处理。我们来看一个读取两个整数并显示它们商的例子：12345678910public class Quotient&#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); System.out.println(number1 + " / " + number2 + " is " + (number1 / number2)); &#125;&#125; 如果number2为0,就会产生一个运行时错误，因为不能用一个整数除以0(注意，一个浮点数除以0不会产生异常)。我们可以添加一个if语句来测试第二个数据：12345678910111213public class Quotient&#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); if(number2 != 0) System.out.println(number1 + " / " + number2 + " is " + (number1 / number2)); else System.out.println("Divisor cannot be zero"); &#125;&#125; 为了介绍异常处理，我们使用一个方法来实现两个整数求商的操作：12345678910111213141516public class QuotientWithMethod &#123; public static int quotient(int number1,int number2) &#123; if(number2 == 0) &#123; System.out.println("Divisor cannot be zero"); System.exit(0); &#125; return number1 / number2; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); int result = quotient(number1,number2); System.out.println(number1 + " / " + number2 + " is " + result); 但上述代码有一个问题：当number2为0时，程序在quotient方法内终止。但不应该让一个方法来终止程序 —— 应该由方法的调用者决定是否终止程序，即方法只需要通知其调用者有运行时错误产生，而不应该自己做决定。下面使用异常处理的方法，让quotient方法抛出一个异常，使其被调用这捕获和处理：12345678910111213141516171819202122232425public class QuotientWithException &#123; public static int quotient(int number1,int number2) &#123; if (number2 == 0) throw new ArithmeticException("Divisor cannot be zero"); return number1 / number2; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); try&#123; int result = quotient(number1,number2); System.out.println(number1 + " / " + number2 + " is " + result); &#125; catch(ArithmeticException ex) &#123; System.out.println("Exception: an integer " + "cannot be divided by zero"); &#125; System.out.println("Execution continues ..."); &#125;&#125; 我们可以看到，上面的代码能使方法抛出一个异常给调用者，并由调用者处理该异常。如果不这么做，被调用的方法本身必须处理异常或者终止程序。但是库方法在设计时通常无法确定在出错时要进行什么操作，最好的做法就是将检测出的错误作为异常抛出给调用者处理，查阅API我们也会发现库方法会对其可能抛出的异常进行说明。异常处理的最根本优势就是将检测错误(由被调用的方法完成)从处理错误(由调用方法完成)中分离出来。当然，如果运行时错误发生在main方法中，就不必抛出异常了，可以考虑提供一个异常处理器对异常进行捕获和处理。 异常类型异常是对象，而对象都采用类来定义。在 Java 程序设计语言中， 异常对象都是派生于 Throwable 类的一个实例。稍后还可以看到，如果 Java 中内置的异常类不能够满足需求，用户可以创建自己的异常类。 下面是Java中的异常层次结构： 可以看到，Throwable是所有异常类的根类，所有异常类都直接或间接继承自 Throwable。但在下一层立即分解为两个分支：Error 和 Exception。Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。这种情况很少出现。在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像 I/O 错误这类问题导致的异常属于其他异常。有一条相当有道理的规则：如果出现 RuntimeException，那么就一定是你的问题。也就是说，RuntimeException是可以在编程时避免的。比如，可以通过检测数组下标是否越界来避免IndexOutOfBoundsException，可以通过在使用变量前检测是否为null杜绝NullPointerException。 免检异常：又称非受查异常(Unchecked Exception)，RuntimeException、Error以及它们的子类都称为免检异常。意思是编译器不会强制检查程序是否处理或声明了异常。如果想让使用某方法的程序员注意到方法可能抛出的免检异常，可以给该方法加上文档注释。必检异常：又称受查异常(Checked Exception)，除了免检异常的其他异常都是必检异常，意思是编译器会强制程序员检查并通过try-catch语句处理它们，或者在方法头进行声明，否则无法通过编译。 关于异常处理的更多知识异常处理器是通过从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到的。即如果某方法的异常没有在该方法内被捕获和处理，就会被抛出给它的调用者，并在调用者中搜寻相应的异常处理器，如果还没有找到就继续上抛，如果在整个方法调用链中异常都没有被捕获处理，该异常会被抛给JVM，JVM会终止程序并打印错误信息。Java的异常处理模型基于三种操作： 声明异常 抛出异常 捕获异常 声明异常一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如，一段读取文件的代码知道有可能读取的文件不存在， 或者内容为空，因此， 试图处理文件信息的代码就需要通知编译器可能会抛出 IOException 类的异常。方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出异常。每个方法只需声明所有它可能抛出的必检异常类型，这称为声明异常。无需声明免检异常，因为免检异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)。可以声明多个异常，用逗号隔开即可：1public void myMethod() throws Exception1, Exception2,... 当然，从前面的示例中可以知道：除了声明异常之外， 还可以捕获异常。这样会使异常不被抛到方法之外，也不需要 throws 规范。稍后，将会讨论如何决定一个异常是被捕获，还是被抛出让其他的处理器进行处理。下面有一些规则： 在方法定义处声明的异常类型可以是方法内抛出异常的类型及其父类型。 如果在子类中重写了父类的一个方法，子类方法中声明的受查异常必须是父类所声明异常的同类或子类(也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常) 如果在超类方法中没有声明/抛出异常，子类也不能声明/抛出异常 抛出异常检测到错误的程序可以创建一个合适的异常类型的实例并抛出它，这就称为抛出异常。下面有一个例子，方法的参数必须是非负的，如果传入一个负参数，程序就创建一个IllegalArgumentException实例并抛出它：123IllegalArgumentException ex = new IllegalArgumentException("Wrong Argument");throw ex; 或者1throw new IllegalArgumentException("Wrong Argument"); 第一种写法创建了一个异常对象并赋给一个异常类引用变量，并抛出它;第二种写法则直接抛出一个匿名异常对象。Java库中每个异常类一般至少有两个构造方法：一个无参构造方法和一个带可描述这个异常的String参数的构造方法。如上述就使用了带参数的构造方法并传入了”Wrong Argument”的异常描述。可以通过在异常对象上调用getMessage()获取异常描述字符串。抛出异常的三个步骤： 找到一个合适的异常类 创建这个类的一个对象 将对象抛出 注意：这里所说抛出异常是指我们在编写程序时用throw关键字显式抛出异常，但是在很多情况下，异常是由库方法抛出的，throw关键字被封装在库方法中，对用户是不可见的，此时用户程序中是没有显式的throw关键字的。 我们使用throw关键字手动抛出异常有两种基本方案：1、在throw语句外加上对应异常的try-catch块，即自己抛出的异常自己捕获处理。2、在含有throw语句的方法声明处通过throws关键字声明对应的异常，由方法的调用者来处理这个异常。 捕获异常当抛出一个异常时，可以提供try-catch语句来捕获和处理它，如下所示：12345678910111213try &#123; statements; // Statements that may throw exceptions &#125; catch(Exception exVar1) &#123; handler for exception1; &#125; catch(Exception exVar2) &#123; handler for exception2; &#125; ... catch(Exception exVarN) &#123; handler for exceptionN; &#125; 可以为一个try块提供多个catch语句，因为一个try块可能抛出多种不同类型的异常。如果在执行try块的过程中没有出现异常，则跳过catch子句。如果try块中的某条语句抛出一个异常，Java就会跳过try块中剩余的语句，然后开始查找合适的处理异常的代码，即异常处理器。可以从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到这个处理器。从第一个到最后一个逐个检查catch块，判断在catch块中的异常类变量是否是该异常对象的类型。如果是，就将该异常对象赋值给所声明的变量，然后执行catch块中的代码。如果没有发现异常处理器，Java会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来查找处理器。如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息。寻找处理器的过程称为捕获异常。注意：如果一个catch块可以捕获一个父类的异常对象，它就能捕获那个父类的所有子类的异常对象。在catch块中异常被指定的顺序是非常重要的，如果父类异常的catch块在子类异常的catch块之前，就会导致编译错误。道理很简单，如果将父类异常的catch块放在子类异常的catch块之前，则子类异常对象一定会被父类异常的catch块捕获，子类异常的catch块就失去了意义。因为我们无法保证所编写的catch块涵盖了try块中可能出现的所有异常类型，所以建议在多重catch块的最后添加所有异常的父类Exception的异常处理器来保证try块中出现的任何异常被捕获。对于使用同样的处理代码处理多个异常的情况，可以使用多捕获特征简化异常的代码编写，如：123catch(Exception1 | Exception2 | ... | ExceptionN ex) &#123; // Same code for handling these exceptions&#125; 小提示：对于InputMismatchedException，要在catch块中吸收错误输入，否则该错误输入将被下一条读取语句读取。 创建自定义异常类在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。在这种情况下，我们可以通过派生Exception类或其子类来创建自定义的异常类。下面给出一个例子，当半径为负时，setRadius方法会抛出一个异常：1234567891011public class InvalidRadiusException extends Exception &#123; private double radius; public InvalidRadiusException(double radius) &#123; super("Invalid radius " + radius); this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125; 可见异常类里可定义数据域和访问器，使外界能访问到导致异常的非法参数。注意：建议不要让自定义的异常类继承RuntimeException及其子类，这样会使自定义的异常类称为免检异常，最好使自定义的异常类必检，这样编译器就可以在程序中强制捕获或声明这些异常。 从异常中获取信息异常对象中包含了关于异常的有价值的信息，可以利用Throwable类中的实例方法获取有关的信息，如下所示： Throwable() 无参构造器 Throwable(String message) 带描述异常信息字符串的构造器 String getMessage() 返回一个描述该异常对象信息的字符串 String toString() 返回三个字符串的连接：1) 异常类的全名; 2) “: “ 一个冒号和一个空格 3) getMessage(方法) void printStackTrace() 在控制台上打印 Throwable对象和它的调用堆栈信息 同样Exception和RuntimeException也有类似的方法堆栈轨迹(stack trace)是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。类似于数据结构中的栈，一个方法被调用就会入栈，即最先被调用的方法(main方法)在栈底，后被调用的方法在栈顶。当一个方法调用结束，就会出栈，也是栈顶方法先出栈，最后main方法也调用完毕，整个方法栈被销毁，程序结束。Throwable的printStackTrace方法就是这样从上到下打印了方法栈，栈顶是产生异常的方法，栈底是main方法。比如下面的代码访问了数组的-1下标，抛出一个ArrayIndexOutOfBoundsException：123456789public class TestException &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,3,4,5&#125;; printArrayElement(array,-1); &#125; public static void printArrayElement(int[] a,int index) &#123; System.out.println(a[index]); &#125;&#125; 打印的堆栈轨迹是：一种更灵活的方法是getStackTrace()，它会得到一个StackTraceElement对象的一个数组，每个元素都是方法堆栈中的一个方法，其API如下： 再次抛出异常与异常链当异常被捕获之后，可以在catch子句中重新抛出异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用的子系统，那么，用于表示子系统的异常类型可能会产生多种解释。ServletException就是这样一个异常类型的例子。执行servlet的代码可能不想知道发生错误的细节原因，但希望明确地知道servlet是否有问题。同原始异常一起抛出一个新异常(带有附加信息)，这称为异常链。下面给出了抛出异常链的基本方法：123456789try &#123; access the database&#125;catch(SQLException e)&#123; Throwable se = new ServletException("database error: " + e.getMessage());&#125; 不过，我们发现原始异常被改变了。有一种更好的处理方法，可以将原始异常设置为新异常的”原因”：12345678910try &#123; access the database&#125;catch(SQLException e)&#123; Throwable se = new ServletException("database error"); se.initCause(e); throw se;&#125; 当捕获到异常时，就可以使用下面的这条语句重新得到原始异常：1Throwable e = se.getCause(); 强烈建议使用这种包装技术，这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。也可以使用带有包装功能的构造方法来封装原始异常并抛出该新异常。 finally子句当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有的异常。但是，这种解决方案比较乏味，这是因为需要在两个地方清除所分配的资源。一个在正常的代码中；另一个在异常代码中。Java 有一种更好的解决方案，这就是 finally 子句。无论异常是否产生，finally子句总是会被执行,即使在到达finally子句之前有一个return语句，finally块还是会执行。唯一使finally子句不执行的方法是在finally子句前使用System.exit(1)方法，这个方法的作用是终止正在运行的JVM，参数为0表示程序正常终止，非0表示异常终止。在try块(或try-catch块)和finally块之间不能有其他任何代码。finally子句常用于在抛出异常时关闭资源，比如关闭文件和关闭与数据库的连接。比如下面的代码：12345678910111213141516171819InputStream in = new FileInputStream(. . .);try&#123;//1code that might throw exceptions//2&#125;catch (IOException e)&#123;// 3show error message// 4&#125;finally&#123;// 5in.close();&#125;//6 在上面的代码中，有下列3种情况会执行finally子句：1) 代码没有抛出异常。在这种情况下，程序首先执行 try 语句块中的全部代码，然后执行 finally 子句中的代码。随后，继续执行 try 语句块之后的下一条语句。也就是说，执行标注的1、2、5、6处2) 抛出一个在 catch 子句中捕获的异常。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try语句块中的所有代码，直到发生异常为止。此时，将跳过 try语句块中的剩余代码，转去执行与该异常匹配的 catch 子句中的代码， 最后执行 finally 子句中的代码。 如果 catch 子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6 处的语句。 如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。在这里， 执行标注1、 3、 5 处的语句。3) 代码抛出了一个异常，但这个异常不是由 catch 子句捕 获的。在这种情况下，程序将执行 try 语句块中的所有语句，直到有异常被抛出为止。此时，将跳过 try 语句块中的剩余代码，然后执行 finally 子句中的语句，并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。try 语句可以只有 finally 子句，而没有 catch 子句。例如，下面这条 try 语句：123456789 InputStream in = . .try&#123;code that might throw exceptions&#125;finally&#123;in.close();&#125; 无论在 try 语句块中是否遇到异常，finally 子句中的 in.close()语句都会被执行。当然,如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 catch 子句捕获。强烈建议解耦合 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。例如：12345678910111213141516InputStream in = . . .;try&#123; try &#123; code that might throw exceptions &#125; finally &#123; in.close(); &#125;&#125;catch (IOException e)&#123;show error message&#125; 内层的 try 语句块只有一个职责，就是确保关闭输入流。外层的 try 语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚， 而且还具有一个功能，就是将会报告 finally 子句中出现的错误。注意：当 finally 子句包含 return 语句时，将会出现一种意想不到的结果„ 假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值。请看一个复杂的例子：123456789101112public static int f(int n)&#123; try &#123; int r = n * n; return r; &#125; finally &#123; if (n == 2) return 0; &#125;&#125; 如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句然而，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值4。有时候， finally 子句也会带来麻烦。例如， 清理资源的方法也有可能抛出异常。假设希望能够确保在流处理代码中遇到异常时将流关闭。123456789InputStream in = . . .;try&#123;code that might throw exceptions&#125;finally&#123;in.close();&#125; 现在，假设在 try 语句块中的代码抛出了一些非 IOException 的异常，这些异常只有这个方法的调用者才能够给予处理。执行 finally 语句块，并调用 close 方法。而 close 方法本身也有可能抛出 IOException 异常。当出现这种情况时， 原始的异常将会丢失，转而抛出 close 方法的异常。这会有问题， 因为第一个异常很可能更有意思。如果你想做适当的处理，重新抛出原来的异常， 代码会变得极其繁琐。 如下所示：12345678910111213141516171819202122232425InputStream in = . . .;Exception ex = null;try&#123; try &#123; code that might throw exceptions &#125; catch (Exception e) &#123; ex = e; throw ex; &#125;&#125;finally&#123; try &#123; in.close()； &#125; catch (Exception e) &#123; if (ex = null) throw e; &#125;&#125; 上面的代码太繁琐，在 Java SE 7中提供了一种更便捷的方法。 带资源的try语句对于以下代码模式:123456789open a resourcetry&#123; work with the resource&#125;finally&#123; close the resource&#125; 假设资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。AutoCloseable 接口有一个方法：1void close() throws Exception 另外，还有一个 Closeable 接口。这是 AutoCloseable 的子接口， 也包含一个 close方法。不过，这个方法声明为抛出一个 IOException。带资源的 try 语句（try-with-resources) 的最简形式为：123try (声明和创建资源)&#123; 使用资源来处理文件;&#125; try块退出时，会自动调用 res.close()。下面给出一个典型的例子， 这里要读取一个文件中的所有单词：12345try (Scanner in = new Scanner(new FileInputStream(7usr/share/dict/words")), "UTF-8")&#123; while (in.hasNext()) System.out.println(in.next());&#125; 这个块正常退出时， 或者存在一个异常时， 都会调用 in.close() 方法， 就好像使用了finally块一样。还可以指定多个资源,例如：123456try (Scanner in = new Scanne(new FileInputStream("7usr/share/dict/words"), "UTF-8");PrintWriter out = new PrintWriter("out.txt"))&#123; while (in.hasNext()) out.println(in.next().toUpperCase());&#125; 不论这个块如何退出， in 和 out 都会关闭。如果你用常规方式手动编程，就需要两个嵌套的 try/finally语句。前面已经看到，如果 try 块抛出一个异常， 而且 close 方法也抛出一个异常，这就会带来一个难题。带资源的 try 语句可以很好地处理这种情况。原来的异常会重新抛出，而 close方法抛出的异常会”被抑制”。这些异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。 如果对这些异常感兴趣， 可以调用 getSuppressed 方法，它会得到从 close 方法抛出并被抑制的异常列表。你肯定不想采用这种常规方式编程。只要需要关闭资源， 就要尽可能使用带资源的 try语句。 使用异常机制的技巧1.异常处理不能代替简单的测试异常处理需要初始化新的异常对象，需要调用栈返回，而且还需要沿着方法调用链来传播异常以找到它的异常处理器，所以，异常处理通常需要更多的时间和资源。如果能在发生异常的方法中处理异常，就不需要抛出异常。在个别方法中的简单错误最好进行局部处理，无须抛出异常。例如：123456try &#123; System.out.println(refVar.toString());&#125;catch(NullPointerException ex) &#123; System.out.println("refVar is null");&#125; 最好用下面的代码代替：1234if (refVar != null) System.out.println(refVar.toString());else System.out.println("refVar is null"); 只有在异常不可预料的情况下才抛出异常，简单的情况不应该使用异常机制。 1.不要过分细化异常很多程序员习惯将每一条语句都分装在一个独立的 try 语句块中。123456789101112131415161718192021PrintStream out;Stack s;for (i = 0;i &lt; 100; i++)&#123; try &#123; n = s.pop(); &#125; catch (EmptyStackException e) &#123; // stack was empty &#125; try &#123; out.writelnt(n); &#125; catch (IOException e) &#123; // problem writing to file &#125;&#125; 这种编程方式将导致代码量的急剧膨胀。首先看一下这段代码所完成的任务。在这里，希望从栈中弹出 100 个数值， 然后将它们存入一个文件中。如果栈是空的， 则不会变成非空状态；如果文件出现错误， 则也很难给予排除。出现上述问题后，这种编程方式无能为力。因此，有必要将整个任务包装在一个 try语句块中，这样，当任何一个操作出现问题时，整个任务都可以取消。12345678910111213141516try&#123; for (i = 0; i &lt; 100; i++) &#123; n = s.pop(); out.writelnt(n); &#125;&#125;catch (IOException e)&#123; // problem writing to file&#125;catch (EmptyStackException e)&#123; // stack was empty&#125; 这段代码看起来清晰多了。这样也满足了异常处理机制的其中一个目标，将正常处理与错误处理分开。 3.利用异常层次结构不要只抛出 RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。不要只捕获 Thowable 异常， 否则，会使程序代码更难读、 更难维护。考虑受查异常与非受查异常的区别。 已检查异常本来就很庞大，不要为逻辑错误抛出这些异常。（例如， 反射库的做法就不正确。 调用者却经常需要捕获那些早已知道不可能发生的异常。）将一种异常转换成另一种更加适合的异常时不要犹豫。例如， 在解析某个文件中的一个整数时，捕获NumberFormatException 异 常，然后将它转换成 IOException 或 MySubsystemException 的子类。 4.不要压制异常在 Java 中，往往强烈地倾向关闭异常。如果编写了一个调用另一个方法的方法，而这个方法有可能 100 年才抛出一个异常， 那么， 编译器会因为没有将这个异常列在 throws 表中产生抱怨。而没有将这个异常列在 throws 表中主要出于编译器将会对所有调用这个方法的方法进行异常处理的考虑。因此，应该将这个异常关闭：123456789public Image loadImage(String s)&#123; try &#123; // code that threatens to throw checked exceptions &#125; catch (Exception e) &#123;&#125; // so there&#125; 现在，这段代码就可以通过编译了。除非发生异常，否则它将可以正常地运行。即使发生了异常也会被忽略。如果认为异常非常重要，就应该对它们进行处理。 5.在检测错误时，”苛刻”要比放任更好当检测到错误的时候，有些程序员担心抛出异常。在用无效的参数调用一个方法时，返回一个虚拟的数值， 还是抛出一个异常， 哪种处理方式更好？ 例如， 当栈空时，Stack.pop 是返回一个 null, 还是抛出一个异常？ 我们认为：在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一个 NullPointerException 异常更好。 6.不要羞于传递异常很多程序员都感觉应该捕获抛出的全部异常。如果调用了一个抛出异常的方法，例如，FilelnputStream 构造器或 readLine 方法，这些方法就会本能地捕获这些可能产生的异常。其实， 传递异常要比捕获这些异常更好：123456public void readStuff(String filename) throws IOException// not a sign of shame!&#123;InputStream in = new FilelnputStream(filename);. . .&#125; 让高层次的方法通知用户发生了错误， 或者放弃不成功的命令更加适宜。规则 5、6 可以归纳为”早抛出，晚捕获” 使用断言在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此，可以将这些检测删掉，并在其他测试需要时将它们粘贴回来，这是一件很乏味的事。 1.断言的概念假设确信某个属性符合要求，并且代码的执行依赖于这个属性。例如，需要计算：1double y = Math.sqrt(x); 我们确信，这里的 X 是一个非负数值。原因是：X 是另外一个计算的结果，而这个结果不可能是负值；或者 X 是一个方法的参数，而这个方法要求它的调用者只能提供一个正整数。然而，还是希望进行检查，以避免让“不是一个数”的数值参与计算操作。当然，也可以抛出一个异常：1if (x &lt; 0) throw new IllegalArgumentException("x &lt; 0"); 但是这段代码会一直保留在程序中，即使测试完毕也不会自动地删除。如果在程序中含有大量的这种检查，程序运行起来会相当慢。断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。Java 语言引人了关键字 assert。这个关键字有两种形式：assert 条件;和assert 条件：表达式;这两种形式都会对条件进行检测，如果结果为 false, 则在第一种形式中会抛出一个 AssertionError 异常。在第二种形式中，表达式将被传人 AssertionError 的构造器，并转换成一个消息字符串,在打印异常信息时会随之显示出来。注意：“表达式”部分的唯一目的是产生一个消息字符串。AssertionError 对象并不存储表达式的值，因此，不可能在以后得到它。正如 JDK 文档所描述的那样：如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。要想断言 x 是一个非负数值，只需要简单地使用下面这条语句：assert x &gt;= 0;或者将 x 的实际值传递给 AssertionError 对象， 从而可以在后面显示出来：assert x &gt;= 0 : x; 2.启用和禁用断言在默认情况下，断言被禁用。可以在运行程序时用-enableassertions 或 -ea 选项启用：1java -enableassertions MyApp 需要注意的是，在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器(class loader) 的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。也可以在某个类或整个包中使用断言，例如：java -ea:MyClass -ea:com.mycompany.mylib... MyApp 这条命令将开启 MyClass 类以及在 com.mycompany.mylib 包和它的子包中的所有类的断言。选项 -ea 将开启默认包中的所有类的断言。 也可以用选项 -disableassertions 或 -da 禁用某个特定类和包的断言：java -ea:... -da:MyClass MyApp有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。然而，启用和禁用所有断言的 -ea 和 -da 开关不能应用到那些没有类加载器的”系统类”上。对于这些系统类来说，需要使用 -enablesystemassertions/-esa 开关启用断言。在程序中也可以控制类加载器的断言状态。有关这方面的内容请参看本文末尾的 API 注释。还可以在eclipse里开启断言，只要Run -&gt; Run Configurations -&gt; Arguments页签 -&gt; VM arguments文本框中加上断言开启的标志:-enableassertions 或者-ea 就可以了。 3.使用断言完成参数检查在 Java 语言中，给出了3种处理系统错误的机制： 抛出一个异常 日志 使用断言 什么时候应该选择使用断言呢？ 请记住下面几点： 断言失败是致命的、 不可恢复的错误。 断言检查只用于开发和测阶段(这种做法有时候被戏称为“ 在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”)。 因此，不应该使用断言向程序的其他部分通告发生了可恢复性的错误，或者，不应该作为程序向用户通告问题的手段。断言只应该用于在测试阶段确定程序内部的错误位置。下面看一个十分常见的例子：检查方法的参数。是否应该使用断言来检查非法的下标值或null 引用呢？ 要想回答这个问题， 首先阅读一下这个方法的文档。假设实现一个排序方法。123456789101112131415/**Sorts the specified range of the specified array in ascending numerical order.The range to be sorted extends from fromlndex, inclusive, to tolndex, exclusive.@param a the array to be sorted.@param fromlndex the index of the first element (inclusive) to be sorted.@param tolndex the index of the last element (exclusive) to be sorted.©throws IllegalArgumentException if fromlndex &gt; tolndex©throws ArraylndexOutOfBoundsException if fromlndex &lt; 0 or tolndex &gt; a.length*/static void sort(int[] a, int fromlndex, int tolndex) 文档指出，如果方法中使用了错误的下标值，那么就会抛出一个异常。这是方法与调用者之间约定的处理行为。如果实现这个方法，那就必须要遵守这个约定，并抛出表示下标值有误的异常。因此，这里使用断言不太适宜。是否应该断言 a 不是 null 呢？ 这也不太适宜。当 a 是 null 时，这个方法的文档没有指出应该采取什么行动。在这种情况下，调用者可以认为这个方法将会成功地返回，而不会抛出一个断言错误。然而，假设对这个方法的约定做一点微小的改动：1@param a the array to be sorted (must not be null) 现在，这个方法的调用者就必须注意：不允许用 null 数组调用这个方法，并在这个方法的开头使用断言：assert a != null;计算机科学家将这种约定称为前置条件(Precondition)。最初的方法对参数没有前置条件， 即承诺在任何条件下都能够给予正确的执行。修订后的方法有一个前置条件，即 a 非空。如果调用者在调用这个方法时没有提供满足这个前置条件的参数， 所有的断言都会失败，并且这个方法可以执行它想做的任何操作。事实上，由于可以使用断言，当方法被非法调用时， 将会出现难以预料的结果。有时候会拋出一个断言错误， 有时候会产生一个 null 指针异常， 这完全取决于类加载器的配置。 4.为文档假设使用断言很多程序员使用注释说明假设条件。看一下下面的示例：123456if (i % 3 == 0) . . .else if (i % 3 = 1) . . .else // (i % 3 == 2) . . . 在这个示例中，使用断言会更好一些。123456789if (i % 3 == 0) . . .else if (i % 3 == 1) . . .else&#123; assert i % 3 == 2; . . .&#125; 当然，如果再仔细地考虑一下这个问题会发现一个更有意思的内容。i%3 会产生什么结果？如果 i 是正值，那余数肯定是 0、 1 或 2。如果 i 是负值，则余数则可以是 -1 和-2。然而，实际上都认为 i 是非负值， 因此， 最好在 if 语句之前使用下列断言：assert i &gt;= 0;无论如何，这个示例说明了程序员如何使用断言来进行自我检查。前面已经知道，断言是一种测试和调试阶段所使用的战术性工具; 而日志记录是一种在程序的整个生命周期都可以使用的策略性工具。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之集合]]></title>
    <url>%2F2017%2F10%2F23%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java集合框架Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Java只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、Bitset和Enumeration接口，其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，但要想建立一个全面的集合类库还需要大量的时间和高超的技能。后来，经过艰难的抉择，设计人员设计出了一组功能完善的数据结构，下面我们来进入集合框架的学习。 使用集合的场景 集合接口与具体实现分离Java集合类库将接口与实现分离。比如队列接口，其指出可以在队列的尾部添加元素，在队头删除元素，并可以查找队列中元素的个数等。队列接口的最简形式可能类似下面这样：123456public interface Queue&lt;E&gt;&#123; void add(E element); E remove(); int size();&#125; 但这个接口并没有说明队列的具体实现，实际上，队列的实现主要有两种方式：一是使用循环数组，二是使用链表。如果需要一个循环数组队列，可以使用ArrayDeque类;如果需要一个链表队列，就直接使用LinkedList类。这两个类都实现了Queue接口。当我们使用队列时，一旦创建了集合就不用关心究竟使用了哪种实现，因此，只有在构建集合时，使用具体的类才有意义。用两种具体类实现Queue接口：12Queue&lt;E&gt; q = new ArrayDeque&lt;&gt;();Queue&lt;E&gt; q = new LinkedList&lt;&gt;(); 注意：一般情况下循环数组比链表更高效，但它是一个有界集合，即容量有限，超过一定范围会进行扩容，降低效率。所以如果处理的数据量较小，优先使用循环数组，但如果程序要收集的对象数量没有上限，最好使用链表实现。在研究API时会发现一组名字以Abstract开头的类，例如，AbstractQueue。这些类是为类库设计者设计的，如果想要实现自己的队列类，会发现扩展AbstractQueue类比实现Queue接口中的所有方法轻松得多。 Collection接口在Java类库中，集合类的基本接口是Collection接口，其常用API如下： boolean add(E e)将一个元素添加到集合中。如果由于这个调用改变了集合，返回true。 boolean addAll(Collection&lt;? extends E&gt; other)将other集合中的所有元素都添加到这个集合。如果由于这个调用改变了集合，返回true。 void clear() 移除这个集合中的所有元素。 boolean contains(Object obj)如果这个集合包含了一个与obj相等的对象，返回true。 boolean containsAll(Collection&lt;?&gt; other)如果这个集合包含other集合中的所有元素，返回 true。 boolean isEmpty() 如果这个集合没有元素，返回 true。 Iterator&lt;E&gt; iterator()返回一个用于访问集合中每个元素的迭代器。 boolean remove(Object obj)从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true。 boolean removeAll(Collection&lt;?&gt; other)从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true。 boolean retainAll(Collection&lt;?&gt; other)仅保留这个集合中那些也包含在other集合里的元素 int size() 返回这个集合的元素数。 Object[] toArray() 返回这个集合的对象数组。 &lt;T&gt; T[] toArray(T[] arrayToFill)返回这个集合的对象数组。如果arrayToFill足够大，就将集合的元素填入这个数组中，剩余空间补null;否则，分配一个新数组，其成员类型和arrayToFill一样，其长度等于集合的大小，并填充集合元素。 default boolean removeIf(Predicate&lt;? super E&gt; filter)从这个集合中删除filter返回true的所有元素。如果这个调用改变了集合，返回true 注意：在使用Object[] toArray()时不能把返回的Object[]数组成强制类型转换其他类型的数组，因为所有数组类型的父类都是Object，甚至Object[]的父类也是Object，所以这种向下类型转换是错误的,会抛出一个ClassCastException 12Integer[] array = (Integer[])a.toArray();// ErrorObject[] array = a.toArray();// Right 或者使用 1Integer[] array = a.toArray(new Integer[10]); removeIf函数的参数是一个函数式接口Predicate，表示布尔值函数，可以传递一个lambda表达式描述要删除的元素的特征。例如下面的代码可以删除列表中的所有偶数： 1a.removeIf(e -&gt; e %2 == 0); 同队列，Java也给类库设计者提供了一个AbstractCollection类，其提供了一些例行方法，可以让实现者更容易实现自己的集合类。 迭代器 Collection接口的Iterator&lt;E&gt; iterator()方法可以返回一个迭代器，它是一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。 Iterator接口包含4个方法： 123456public interface Iterator&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemaining(Consumer&lt;? super E&gt; action); C++的STL中的迭代器是根据数组索引建模的，即迭代器指向指定位置的元素。但Java中的迭代器应该理解为位于两个元素之间，其起始位置在所有元素之前。调用next方法，迭代器会越过一个元素并且返回被越过的元素。通过next方法可以逐个访问集合中的每个元素，但是如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此,需要在每次调用next方法之前调用hasNext方法。如果迭代器还有剩余供访问的元素，这个方法就返回true。如果要想查看一个集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复调用next方法，例如： 1234567Collection&lt;String&gt; c = . . .;Iterator&lt;String&gt; iter = c.iterator();while(iter.hasNext())&#123;String element = iter.next(); do something with element&#125; “for-each”循环可以更简练地表示同样的操作： 1234for(String element: c)&#123; do something with element&#125; 编译器简单地将”for-each”循环翻译为带有迭代器的循环，”for-each”循环可以和任何实现了Iterable接口的对象一起工作，这个接口只包含一个抽象方法： 1234public interface Iterable&lt;E&gt;&#123; Interator&lt;E&gt; iterator();&#125; Iterable接口表示实现它的类是可以迭代的(即可以返回一个迭代器对象)，Collection接口扩展了Iterable接口，所以对于标准类库中的任何集合都可以使用”for-each”循环 Java SE 8提供了一种更简便的方式，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式(它会处理一个元素)。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止,例如： 1iter.forEachRemaining(element -&gt; do something with element); 元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次索引加1.如果访问HashSet中的元素，每个元素将会以某种随机的次序出现。但这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说没有影响。 Iterator接口的remove方法将会删除上一次调用next方法时返回的元素，也就是说，如果要删除某个元素，必须先用next方法越过它： 123Iterator&lt;String&gt; it = c.iterator();it.next();// skip over the first elementit.remove(); // now remove it 如果在调用remove方法之前没有调用next方法会抛出一个IllegalStateException。如果想删除两个相邻的元素，不能直接连续调用两次remove：12it.remove();it.remove();//Error 必须先越过要删除的元素：123it.remove();it.next();it.remove();//OK 所以删除元素必须在刚越过该元素时就进行，否则”过了这个村就没这个店了” 集合框架中的接口Java集合框架为不同类型的集合定义了大量接口，如下图所示： 集合有两个基本接口：Collection和Map。Collection用于保存一个元素序列，Map用于表示键值对之间的映射关系。在Collection中插入元素使用boolean add(E element),获取元素使用迭代器访问;在Map中插入元素使用V put(K key,V value),通过key获取value使用V get(K key)List是一个有序集合，允许有null值存在。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，使用一个整数索引访问。前者称为顺序访问，后者称为随机访问。List的重要API如下：1234567891011121314* ListIterator&lt;E&gt; listIterator() 返回一个列表迭代器，以便用来访问列表中的元素 * ListIterator&lt;E&gt; listIterator(int index) 返回一个列表迭代器，以便用来访问列表中的元素， 初始位置在索引为index元素的前面，索引从0开始 * void add(int i,E element) 在给定位置添加一个元素 * E remove(int i) 删除给定位置的元素并返回这个元素 * E get(int i) 获取给定位置的元素 * E set(int i, E element) 用新元素取代给定位置的元素，并返回原来那个元素 * int indexOf(Object element) 返回与指定元素相等的元素 在列表中第一次出现的位置，如果没有这样的元素返回-1 * int lastIndexOf(Object element) 返回与指定元素相等的元素 在列表中最后一次出现的位置，如果没有这样的元素返回-1 我们发现List接口提供了多个用于随机访问的方法：1234void add(int i,E element)void remove(int index)E get(int index)E set(int index,E element) 当我们给List接口选择具体实现类时，需要考虑顺序访问和随机访问哪种情况更多，如果随机访问占操作的大多数，应该使用数组或动态列表ArrayList实现List接口，否则应该使用链表LinkedList实现List接口。为了避免对链表进行随机访问，Java定义了一个标记接口RandomAccess，这个接口不包含任何方法，但可以用来测试一个特定的集合是否支持高效的随机访问：12345678if(c instanceof RandomAccess)&#123; use random access algorithm&#125;else&#123; use sequential access algorithm&#125; 不建议在LinkedList实现的List列表中使用get、set等随机访问方法，此时应该通过一个ListIterator顺序访问列表。ListIterator接口是Iterator的一个子接口，它是一种更灵活的迭代器，只用于List。下面是ListIterator的重要API： void add(E newElement) 在当前位置前添加一个元素 void set(E newElement) 用新元素取代next或previous上次访问的元素。 boolean hasPrevious() 当反向迭代列表时，还有可供访问的元素，返回true E previous() 返回前一个对象，如果已经到达了列表的头部，就抛出一个NoSuchElementException int nextIndex() 返回下次调用next方法时将返回元素的索引 int previous() 返回下次调用previous方法时将返回元素的索引 并发修改：如果在一个迭代器修改集合时，另一个迭代器对它进行遍历，一定会出现混乱。例如：123456List&lt;String&gt; list = . . .;ListIterator&lt;String&gt; iter1 = list.ListIterator();ListIterator&lt;String&gt; iter2 = list.ListIterator();iter1.next();iter1.remove();iter2.next();//throws ConcurrentModificationException 上述代码中iter2迭代器在遍历链表时，iter1修改了链表结构，iter2会检测到这种变化，抛出一个ConcurrentModificationException。为了避免出现并发修改异常，请遵循下述简单规则：可以根据需要给容器附加许多迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读也写的迭代器。通过调用AbstractCollection类的toString方法可以打印出集合中的所有元素。Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集(Set)的add方法不允许增加重复的元素,允许有null值，当然只允许一个null值。要适当定义equals方法：只要两个集包含同样的元素就认为是相等的，而不要求有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集试图的方法。最后，Java SE 6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集和映射的方法，TreeSet和TreeMap实现了这些接口。 具体的集合下面是Java库中的具体集合和集合框架中的类 LinkedListLinkedList是链表类，相较于数组以及动态的ArrayList类，能够更高效地从集合的中间位置插入、删除元素，Java中的LinkedList类是双向链接的。除了实现了Collection接口和List接口之外，LinkedList还提供了以下API： LinkedList() 构造一个空链表 LinkedList(Collection&lt;? extends E&gt; elements)构造一个链表，并将集合中的所有元素添加到这个链表中 void addFirst(E element) 将某个元素添加到列表的头部 void addLast(E element) 将某个元素添加到列表的尾部 E getFirst 返回列表头部的元素 E getLast 返回列表尾部的元素 E removeFirst() 删除并返回列表头部的元素 E removeLast() 删除并返回列表尾部的元素 ArrayListArrayList是动态数组列表，适用于常常要随机访问元素的情况。下面给出ArrayList的常用API： ArrayList&lt;E&gt;() 构造一个初始容量为10的空列表 ArrayList&lt;E&gt;(int initialCapacity)构造一个具有指定初始容量的空列表 boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true void add(int index, E element) 将指定的元素插入此列表中的指定位置。 int size() 返回此列表中的元素数。 void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。 E get(int index) 返回此列表中指定位置上的元素。 E remove(int index) 移除此列表中指定位置上的元素并返回该元素。 boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。 void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。 boolean isEmpty() 如果此列表中没有元素，则返回 true boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。 void clear() 移除此列表中的所有元素。 Object clone() 返回此 ArrayList 实例的浅表副本。 trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。 ArrayList和Vector的区别：Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vector对象，然而如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。所以建议在不需要同步的时候使用ArrayList，而不要使用Vector HashSet链表和数组可以按照人们的意愿排列元素的次序，但如果要查看某个元素，却忘记了它的位置，需要访问所有元素直到找到为止，将会消耗很多时间。HashSet是一种基于散列表的集，实现了Set接口，它无法控制元素的次序，但可以快速查找元素。散列表基于散列码，散列码由类的hashCode方法提供，用于将元素插入散列表的特定位置，hashCode和equals方法应该兼容，即使用equals方法返回true的两个对象应该有相同的散列码，一个自定义类如果重写了equals方法就必须要重写hashCode方法，以便于将该类的对象插入散列表中。否则HashSet无法知道插入的两个对象是否相同，无法保证集合元素的唯一性。这两个方法的重写在eclipse的source菜单里也有快捷添加选项。在Java中，散列表用链表数组实现，每个散列单元被称为桶。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，如果桶中没有元素，可以直接插入，如果已经有元素，即发生散列冲突，则需要将新元素和桶中已有的所有元素进行比较，如果桶中有元素和新元素相等，就不插入，反之插入。注意：在HashSet的一个桶中可以有多个不同元素，即使用链地址法解决冲突。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。这样，当我们在HashSet中查找某元素时，不必像在线性表中一样循环遍历整个表来比较，只需要根据散列规则找到对应的桶，对桶里的元素进行遍历比较即可。所以，从上面的分析我们可以得到equals方法和hashCode方法之间的关系：1、如果重写了equals方法，必须重写hashCode方法，因为两个对象的euqals方法如果返回true,它们的hashCode值一定要相同。2、如果两个对象的hashCode值相同，它们并不一定相同，比如HashSet中同一个桶中的对象就是发生了散列冲突的具有相同hashCode值的对象。它们的equals方法有可能返回false。 这就是为什么我们在HashSet使用时要同时重写这两个方法的原因，重写hashCode方法以进行桶间的查找，重写equals方法以进行同一个桶内对象的比较。在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。如果想更多地控制散列表的运行性能，就要指定一个初始桶数。通常将桶数设置为预计元素个数的75% ~ 150%,最好将桶数设置为一个素数,以防键的集聚。标准类库使用的桶数是2的幂，默认值为16,为散列表的大小提供的任何值都被自动转换为2的下一个幂。如果最初的估计过低，散列表太满，散列表会进行再散列，创建一个桶数更多的表。装填因子决定何时再散列，比如装填因子为0.75，当散列表中超过75%的位置已经填入了元素，这个表就会用双倍的桶数自动进行再散列，大多数情况装填因子为0.75是比较合理的。下面是HashSet的常用API： HashSet() 构造一个空散列集 HashSet(Collection&lt;? extends E&gt; elements)构造一个散列集，并将集合中的所有元素添加到这个散列集中 HashSet(int initialCapacity) 构造一个具有指定容量(桶数)的散列集 HashSet(int initialCapacity,float loadFactor) 构造一个具有指定容量和装填因子(一个0.0 ~ 1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集 特别要注意,在HashSet中没有get和set方法，因为HashSet是无序集，不存在索引概念，如果要访问HashSet中的元素应该使用迭代器，另外contains方法也被重新定义，可以快速查看某个元素是否出现在集中，此时不用查看集中的所有元素，只用通过散列码定位到一个桶，查看这个桶中的所有元素即可 如果要查找HashSet中符合某条件的对象，可以使用迭代器遍历或者使用foreach循环遍历HashSet。如果要删除符合某条件的对象，如果在for-each循环中边删除边遍历会抛出一个并发修改异常ConcurrentModificationException，此时有两种解决方案：1、如果只删除一个元素，就在remove之后break即可2、如果要删除多个元素，就先把要删除的元素添加到另一个集合中，循环结束后调用removeAll的求差集方法删除目标子集即可。 还可以使用迭代器遍历来避免这种情况。 TreeSetTreeSet和HashSet十分类似，不过当元素以任意顺序插入TreeSet时，TreeSet会保证元素是有序排列的。其底层是由红黑树实现的,每次将一个元素添加到树中，都被放置在正确的排序位置上。一个元素添加到树中比添加到散列表中慢，但是与检查数组或链表中的重复元素相比还是快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。如果对集合中的元素次序没有要求，应该使用HashSet而不是TreeSet，即使排序的花销不大，但也会影响效率。注意：要使用TreeSet，插入的元素必须可排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator从Java SE 6起,TreeSet类实现了Navigable接口，这个接口增加了几个便于定位元素以及反向遍历的方法。 下面是TreeSet的常用API： TreeSet() 构造一个空树集 TreeSet(Collection&lt;? extends E&gt; elements)构造一个空树集，并将集合中的所有元素添加到这个树集中 TreeSet(Comparator&lt;? super E&gt; comparator) 构造一个空树集 TreeSet(SortedSet&lt;E&gt; s)构造一个空树集，并将有序集中的所有元素添加到这个树集中，并使用与给定的有序集相同的比较器 下面是SortedSet的常用API： Comparator&lt;? super E&gt; comparator()返回用于对元素进行排序的比较器。如果元素用Comparable接口的compareTo方法进行比较则返回null E first() 返回有序集中的最小元素 E last() 返回有序集中的最大元素 下面是NavigableSet的常用API： E higher(E value) E lower(E value)返回大于value的最小元素或小于value的最大元素，如果没有这样的元素则返回null E ceiling(E value) E floor(E value)返回大于等于value的最小元素或小于等于value的最大元素，如果没有这样的元素则返回null E poolFirst() E pollLast()删除并返回这个集合中的最大元素或最小元素，这个集合为空时返回null Iterator&lt;E&gt; descendingIterator()返回一个按照递减顺序遍历集中元素的反向迭代器 队列与双端队列Deque(双端队列)接口继承自Queue(队列)接口，与之有所不同的是，双端队列可以在队列的头部和尾部添加或删除元素，但也不支持在队列中间添加或删除元素。和普通队列一样，双端队列也可以用ArrayDeque和LinkedList实现。 下面是Queue的常用API： boolean add(E element) boolean offer(E element)都是将一个元素入队并返回true，如果队列已满，前者会抛出一个IllegalStateException，后者则返回false E remove() E poll()都是将队头元素出队并返回，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null E element() E peek()都是取队头元素但不删除，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null 下面是Deque的常用API： void addFirst(E element) void addLast(E element) boolean offerFirst(E element) boolean offerLast(E element)都是将给定元素添加到双端队列的头部或尾部，如果队列满了，前两个方法会抛出一个IllegalStateException，后两个方法则返回false E removeFirst() E removeLast() E pollFirst() E pollLast()都是删除双端队列的头部或尾部并返回元素，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null E getFirst() E getLast() E peekFirst() E peekLast()都是返回双端队列的头部或尾部元素但不删除，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null 下面是ArrayDeque的常用API： ArrayDeque() 用默认初始容量16构造一个空队列 ArrayDeque(int initialCapacity) 用指定容量构造一个空队列 PriorityQueue在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先出队。优先队列具有最高级先出(first in, largest out)的行为特征。PriorityQueue的底层是通过堆(小根堆，将较小的元素设为最高优先级)实现的，堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。PriorityQueue是一个实现了Queue接口的具体类。和TreeSet一样，要实现排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator。 注意：方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。原因是PriorityQueue内部是一个堆，堆只能保证根具有最高的优先级，但整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历，也就是只能保证数组的第一个元素具有最高优先级。但如果将元素依次出队，出队顺序可以保证是有序的，这是因为在每一次出队后堆会进行调整，将下一个优先级最高的元素移动到根。 下面是PriorityQueue的常用API： PriorityQueue() 构造一个空优先队列 PriorityQueue(int initialCapacity)用指定容量构造一个空优先队列 PriorityQueue(int initialCapacity,Comaparator&lt;? super E&gt; c)用指定容量构造一个空优先队列,并指定比较器对元素进行排序 映射集(Set)是一个集合，它可以快速查找现有元素。但是，有时我们知道某些键的信息，并想要查找与之对应的元素。映射(map)数据结构就是为此设计的，map用来存放键值对(Key-value)，key-value以Entry类型的对象实例存在，Entry对象是无序排列的。允许使用null键和null值(当然只允许有一个null键)，提供键(Key)就能快速查找到值(Value)。Key不允许重复，每个Key最多只能映射到一个Value。Java类库为映射提供了两个实现：HashMap和TreeMap，这两个类都实现了Map接口。HashMap(散列映射)对键进行散列，键值对是无序的。TreeMap(树映射)用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。与集一样，HashMap比TreeMap快一些，如果不需要按照排列顺序访问键，就最好选择散列。 下面是Map接口的常用API： V get(Object key)获取并返回与键对应的值，如果没有在映射中找到这个键，返回null default V getOrDefault(Object key,V defaultValue)获取并返回与键对应的值，如果没有在映射中找到这个键，返回defaultValue V put(K key,V value)将键与对应的值关系插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象，并返回键对应的旧值，如果这个键以前没有出现过则返回null。键可以为null，但值不能为null V putAll(Map&lt;? extends K,? extends V&gt; entries)将给定映射中的所有条目添加到这个映射中 boolean containsKey(Object key)如果在映射中已经有这个键，返回true boolean containsValue(Object value)如果在映射中已经有这个值，返回true default void forEach(BiConsumer&lt;? super K,? super V&gt; action)对这个映射中的所有键值对应用这个动作，参数是一个函数式接口类型，可以传入一个lambda表达式,例如： 12scores.forEach((k,v) -&gt; System.out.println("key=" + k + ", value=" + v)); 下面是HashMap的常用API： HashMap() 构造一个空散列映射 HashMap(int initialCapacity) 用指定容量构造一个空散列映射 HashMap(int initialCapacity,float LoadFactor)用指定容量和装填因子构造一个空散列映射，默认的装填因子是0.75 下面是TreeMap的常用API： TreeMap() 构造一个空树映射 TreeMap(Comparator&lt;? super K&gt; c)构造一个空树映射，并使用一个指定的比较器对键进行排序 TreeMap(Map&lt;? extends K,? extends V&gt; entries) 构造一个空树映射，并将某个映射的所有条目添加到树映射中 TreeMap(SortedMap&lt;? extends K,? extends V&gt; entries)构造一个空树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器 下面是SortedMap的常用API： Comparator&lt;? super K&gt; comparator()返回对键进行排序的比较器。如果键是用Comparable接口的compareTo方法进行比较的，返回null K firstKey() K lastKey()返回映射中最小元素和最大元素 更新映射项假设我们要统计一个单词在文件中出现的次数，当得到一个单词时，我们将其计数器加1：1counts.put(word,counts.get(word) + 1); 但这可能会出错，如果word第一次出现，counts.get(word)会返回null，从而抛出一个NullPointerException。 为了避免这种情况，我们可以用getOrDefault方法来取代get方法，即：1counts.put(word,counts.getOrDefault(word,0) + 1); 另一种方法是首先调用putIfAbsent方法，这个方法会在映射中不存在word时插入键值对初始化word的值为0：12counts.putIfAbsent(word,0);counts.put(word,counts.get(word) + 1); 还可以做得更好,merge方法可以简化这个常见操作。如果键原先不存在，则下面的调用：1counts.merge(word,1,Integer::sum); 将把word和1关联，如果word存在，则会使用Integer::sum函数组合原值和1(也就是将原值和1求和) 映射视图集合框架不认为映射本身是一种集合，不过可以得到映射视图 —— 这是实现了Collection接口或某个子接口的对象。有三种视图：键集、值集合(不是一个集)、键值对集。键集和键值对集是集，因为一个映射中的键是唯一的，但值不能构成集，只能是值集合，因为一个映射中可以有多个相同的值。下面的方法可以从映射中返回这三种视图：123Set&lt;K&gt; keySet()Collection&lt;V&gt; values()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 需要说明的是，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口，所以可以向使用集合一样使用keySet 键值对是Map.Entry&lt;K,V&gt;类型的，可以使用entrySet()方法返回映射的键值对集，再通过循环对于每个键值对对象使用，例如：123456for(Map.Entry&lt;String,Employee&gt; entry: staff.entrySet())&#123; String k = entry.getKey(); Employee v = entry.getValue(); // do something with k,v&#125; getKey方法获取该键值对的键，getValue方法获取该键值对的值，setValue方法将键值对的值设置为新值并返回原值。当然查看键值对最高效的方法是使用forEach方法：123counts.forEach((k,v) -&gt; &#123; do something with k,v&#125;) 注意:可以在键集视图上调用迭代器的remove方法，结果会在映射中删除这个键和与它关联的值，但不能调用add方法，否则会抛出一个UnsupportedOperationException;可以在值集合视图删除元素，所删除的值和相应的键将从映射中删除，也不能增加元素;可以在键值对集合中删除元素，将从映射中删除相应的键值对，但也不能增加元素。总之，可删不可增。 WeakHashMap当一个映射中引用某个值的所有键都消亡，即没有任何途径引用这个值时，这个值成为了无用对象。但是垃圾回收器跟踪活动的对象，只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收。于是，长期存活的映射中可能会存在一些无用的值，此时需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用WeakHashMap。当对键的唯一应用来自散列条目时，这种数据结构会协助垃圾回收期协同工作一起删除键值对。下面是这种机制的内部运行情况。WeakHashMap使用弱引用保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种特定类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。 更多细节见：深入理解WeakHashMap LinkedHashSet &amp; LinkedHashMapLinkedHashSet和LinkedHashMap会按照元素插入顺序存放元素或键值对。当条目插入到表中时，就会并入到双向链表中。也可以使用LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)来构造一个按照元素访问顺序迭代键值对的LinkedHashMap。每次调用get或put，受到影响的条目将从当前位置删除，并放到条目链表的尾部(只有条目在链表中位置会受影响，而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中)。访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已满时，可以将迭代器加入到表中，并将前几个元素删除掉。这些是近期最少使用的几个元素。甚至可以让这一过程自动化。即构造一个LinkedHashMap的子类，然后覆盖下面的方法：1protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) 每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。例如，下面的高速缓存可以存放100个元素：1234567891011Map&lt;K, V&gt; cache = new LinkedHashMap&lt;&gt;(128, 0.75F, true)&#123; protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; 100; /*当元素个数 &lt;= 100，直接插入元素， 否则进行替换，删除“最近最少使用”的元素， 插入新元素*/ &#125;&#125;(); 另外，还可以对eldest条目进行评估，以此决定是否应该将它删除。例如，可以检查与这个条目一起存在的时间戳。 EnumSet &amp; EnumMapEnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1.EnumSet没有公共的构造器，可以使用静态工厂方法构造这个集，下面给出得到EnumSet的几个常用方法：例如：12345enum Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY); 可以使用Set接口的常用方法来修改EnumSetEnumMap是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时，需要在构造器中指定键类型：1EnumMap&lt;Weekday, Employee&gt; personInChange = new EnumMap&lt;&gt;(Weekday.class); 这样就构造了一个键为Weekday类型的空映射。 IdentityHashMap类IdentityHashMap有特殊的作用。在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。而且，在对两个对象进行比较时，IdentityHashMap类使用 == ，而不使用equals也就是说，不同的键对象，即使内容相同，也被视为不同的对象。在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况。 视图与包装器通过使用视图可以获取其他的实现了Collection接口或Map接口的对象，映射类的keySet方法就是这样一个示例。这个方法看似创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。然而事实并非如此，keySet方法返回一个实现了Set接口的类对象，这个类的方法对原映射进行操作。这样的集合称为视图。 轻量级集合包装器Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。例如：123Card[] cardDeck = new Card[52]; ... List&lt;Card&gt; cardList = Arrays.asList(cardDeck); 返回的对象不是ArrayList，而是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法(例如，与迭代器相关的add和remove方法)都会抛出一个UnsupportedOperationException。asList方法可以接收可变数目的参数，如：1List&lt;String&gt; names = Arrays.asList("Amy","Bob","Carl"); 这个方法调用Collections.nCopies(n,anObject)将返回一个实现了List接口的不可修改的对象，并给人一种包含n个元素，每个元素都像是一个anObject的错觉。例如，下面的调用将创建一个包含100个字符串的List，每个串都被设置为”DEFAULT”：1List&lt;String&gt; settings = Collections.nCopies(100,"DEFAULT"); 存储代价很小，可用于不需要修改元素的情况。这是视图技术的一种巧妙的应用。注意：Collections类包含很多使用的方法，这些方法的参数和返回值都是集合，不要将它和Collection接口混起来。 如果调用以下方法：1Collections.singleton(anObject); 将返回一个实现了Set接口的视图对象(与产生List视图的ncopies方法不同)，即一个不可修改的单元素集，而不需要付出建立数据结构的开销。singletonList方法与singletonMap方法类似。类似地，对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等等。特别是，集的类型可以推导得出：1Set&lt;String&gt; deepThoughts = Collections.emptySet(); 子范围可以为很多集合建立子范围视图。例如，假设有一个列表staff，想从中取出第10个-第19个元素。可以使用subList方法来获得一个列表的子范围视图：1List group2 = staff.subList(10,20); 第一个索引包含在内，第二个索引则不包含在内。可以将任何操作应用于子范围，该操作会影响整个列表。例如，可以删除整个子范围：1group2.clear(); 现在，staff列表中该范围的元素也被删除，并且group2为空。对于SortedSet和SortedMap，可以使用排序顺序而不是元素位置建立子范围。SortedSet接口声明了3个方法：123SortedSet&lt;E&gt; subSet(E from,E to)SortedSet&lt;E&gt; headSet(E to)SortedSet&lt;E&gt; tailSet(E from) 这些方法返回大于等于from且小于to的所有元素构成的子集。 SortedMap也有类似的方法：123SortedMap&lt;K, V&gt; subMap(K from,K to)SortedMap&lt;K, V&gt; headMap(K to)SortedMap&lt;K, V&gt; tailMap(K from) 返回映射视图，该映射包含键落在指定范围内的所有元素。Java SE 6引入的NavigableSet接口赋予子范围操作更多控制能力。可以指定是否包括边界：123NavigableSet&lt;E&gt; subSet(E from, boolean fromInclusive,E to,boolean toInclusive)NavigableSet&lt;E&gt; headSet(E to,boolean toInclusive)NavigableSet&lt;E&gt; tailSet(E from,boolean fromInclusive) 不可修改的视图 同步视图 受查视图 关于可选操作的说明 Collections内容较多，见Java核心技术卷一 P388 ~ P396，并查阅相关API 遗留的集合见Java核心技术 P396 ~ P402]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之泛型程序设计]]></title>
    <url>%2F2017%2F10%2F22%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[泛型程序设计泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，这是一个泛型程序设计的实例。实际上，在Java增加泛型类之前已经有一个ArrayList类，下面来研究泛型程序设计机制是如何演变的。 类型参数的好处在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayLists类只维护一个Object引用的数组：1234567public class ArrayList&#123; private Object[] elementData; . . . public Object get(int i) &#123; . . . &#125; public void add(Object o) &#123; . . . &#125;&#125; 这种方法有两个问题，我们以一个保存文件名的files数组列表为例：1) 当获取一个值时必须进行强制类型转换：123ArrayList files = new ArrayList();. . .String filename = (String)files.get(0); 2) 当添加一个值时不进行类型检查，可以添加任何类的对象：1files.add(new File(". . .")); 此调用在编译和运行时都不会出错，但如果将get的结果强制转换为String会产生一个错误 为了解决上述问题，引入了类型参数。ArrayList有一个类型参数用来指示元素类型：ArrayList&lt;T&gt; files = new ArrayList&lt;T&gt;();，注意前后两个T必须一致，不能是子类和父类！在Java SE 7及以后的版本，构造函数可以省略类型参数，即ArrayList&lt;T&gt; files = new ArrayList&lt;&gt;();这种方法有三个好处：1)get得到的值不必进行强制类型转换2)向数组列表中添加对象时会进行类型检查，如果不符合类型，无法通过编译，出现编译错误比类在运行时出现类的强制转换异常要好得多3)程序具有更好的可读性，比如ArrayList&lt;String&gt; files一看就是聚集了String对象的数组列表 定义简单的泛型类一个泛型类就是具有一个或多个类型变量的类，下面使用一个简单的Pair类作为例子：1234567891011public class Pair&lt;T&gt;&#123; private T first; private T second; public Pair() &#123;first = null; second = null&#125; public Pair(T first,T second) &#123;this.first = first; this.second = second&#125; public void setFirst(T newValue) &#123;first = newValue;&#125; public void setSecond(T newValue) &#123;second = newValue;&#125; &#125; Pair类引入了一个类型变量T，用尖括号括起来，并放在类名的后面。注意这里的T只是指定了一种类型，不代表类只有一个属性成员，而表示接下来类中出现的T都和尖括号里的类型保持一致,即类定义的类型变量指定方法返回类型以及域和局部变量的类型。泛型类可以有多个类型变量，如可以定义两个域类型不同的Pair类public class Pair&lt;T,U&gt; {. . .}类型变量命名规则：E表示集合的元素类型，K和V分别表示表的关键字和值的类型，T(需要时还可以用临近的字母U和S)表示“任意类型”。实际使用中将类定义尖括号里的T替换为具体类型，类中的T也会进行相应的替换，所以，泛型类可以看作普通类的工厂 泛型方法前面介绍了如何定义一个泛型类，下面我们来定义一个带有类型参数的简单泛型方法：1234567class ArrayAlg&#123; public static &lt;T&gt; T getMiddle(T...a) &#123; return a[a.length / 2]; &#125;&#125; 注意：1)类型变量放在修饰符(这里是public static)的后面，返回类型的前面2)泛型方法可以定义在普通类中，也可以定义在泛型类中3)当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：1String middle = ArrayAlg.&lt;String&gt;getMiddle("John","Q.","Public"); 我们注意到上面的泛型方法的参数必须是T类型，如果想要传入T类型的子类怎么办呢？我们可以把&lt;T&gt;改为&lt;? extends T&gt;，这样参数就可以接受T类型以及它的子类。类似的&lt;? super T&gt;则表示参数可以为T类型以及它的超类。 类型变量的限定有时，类或方法需要对类型变量加以约束。下面是一个典型的例子，我们要计算数组中的最小元素：123456789101112class ArrayAlg&#123; public static &lt;T&gt; T min(T[] a) &#123; if(a == null || a.length == 0) return null; T smallest = a[0]; for(int i = 1; i &lt; a.length;i++) if(smallest.compareTo(a[i]) &gt; 0) smallest = a[i]; return smallset; &#125;&#125; 我们会发现一个问题，smallest的类型为T，既可以是任何一个类的对象，如何保证T类型有compareTo方法呢？解决方法是限制T为实现了Comparable接口的类，即将泛型方法定义改为public static &lt;T extends Comparable&gt; T min(T[] a)注意：1)限定类时如果实现的是接口也用extends关键字，如上面的T extends Comparable2)只需要在尖括号里限定，之后的T不用再加限定 一个类型变量或通配符可以有多个限定，用’&amp;’分隔限定类型，用逗号分隔类型变量，例如：T extends Comparable &amp; Serializable 可以有多个接口限定和至多一个类限定，将标记接口(空接口)放在限定列表的末尾，如果用一个类作为限定，它必须是限定列表中的第一个 类型擦除对于虚拟机来说没有泛型类型，只有普通类和方法。无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。在编译时泛型类型会被转化为原始类型。原始类型就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(无限定类型的变量替换为Object)。例如，Pair&lt;T&gt;的原始类型如下：1234567891011public class Pair&#123; private Object first; private Object second; public Pair() &#123;first = null; second = null&#125; public Pair(Object first,Object second) &#123;this.first = first; this.second = second&#125; public void setFirst(Object newValue) &#123;first = newValue;&#125; public void setSecond(Object newValue) &#123;second = newValue;&#125; &#125; 因为T是一个无限定的参数变量，所以直接用Object替换如果是T是一个限定类型的参数变量，用限定列表中的第一个类型替换，比如T extends Comparable &amp; Serializable被替换为Comparable 翻译泛型表达式当泛型表达式编译时，编译器会将其编译为原始类型并加入强制类型转换。比如：12Pair&lt;Employee&gt; buddies = . . . ;Employee buddy = buddies.getFirst(); 编译器会把这个方法调用翻译为两条虚拟机指令： 对原始方法Pair.getFirst的调用 将返回的Object类型强制转换为Employee类型 当存入一个泛型域时编译器也会自动在字节码中插入强制类型转换。 翻译泛型方法类型擦除会发生一些问题，比如一个类subPair继承自类Pair&lt;String&gt;：1234class SubPair extends Pair&lt;String&gt; //继承一个泛型类 &#123; public void setFirst(String newValue)&#123;....&#125;//重写了父类的方法 &#125; Pair在编译的时候被类型擦除，Pair的setFirst方法变为了setFirst(Object newValue)，这样SubPair的setFirst(Stirng newValue)方法就无法覆盖父类中的setFirst(Object newValue)方法，因为参数不同，不是同一个方法。SubPair中会出现两个方法：12public void setFirst(String newValue)&#123;....&#125;public void setFirst(Object newValue)&#123;....&#125; 此时如果有如下测试代码：123SubPair p = new SubPair(. . .);Pair&lt;String&gt; pair = p;p.setFirst("Hello world"); 按理来说，这段测试代码应该不能通过编译，因为要实现多态的话，所调用的方法必须在子类中重写，但是在这里SubPair类并没有重写Pair类中的setFirst方法，只是单纯的继承而已，并且新加了一个参数不同的同名方法。但结果可以运行，因为为了解决这种类型擦除和多态的冲突，编译器会在SubPair类中生成一个桥方法，上述两个方法被编译器变成了这样：12345678public void setFirst(String newValue)&#123;....&#125; //子类定义的方法不变//编译器生成的桥方法 public void setFirst(Object newValue)&#123; setFirst((String) newValue); //桥内部调用的是子类中定义的setFirst(String newValue)方法&#125; 可以看出，这个桥方法实际上就是对超类中setFirst(Object newValue)的重写。这样做的原因是，当程序员在子类中写下setFirst(String newValue)方法时，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免类型擦除与多态发生冲突。详见博客：Java中的类型擦除与桥方法 约束与局限性在使用Java泛型时需要考虑一些限制。大多数限制都是由类型擦除引起的。 1.不能用基本类型实例化类型参数类型参数不能为基本类型。比如，没有Pair&lt;double&gt;只有Pair&lt;Double&gt;,其原因是类型擦除，因为擦除之后，Pair类含有Object类型的域，Object不能存储double值。 2.运行时类型查询只适用于原始类型使用instanceof查询一个对象是否属于某个泛型类会产生编译错误，比如：1if(a instanceof Pair&lt;String&gt;)//Error 同样的道理，getClass方法总是返回原始类型。例如：123Pair&lt;String&gt; stringPair = . . .;Pair&lt;Employee&gt; employeePair = . . .;if(stringPair.getClass() == employeePair.getClass()) //equal 其比较结果是true，因为两次调用getClass结果都返回Pair.class 3.不能创建参数化类型的数组不能实例化参数化类型的数组，例如：1Pair&lt;String&gt;[] table = new Pair&lt;String&gt; [10];//Error 最安全而有效的方法是使用ArrayList，即ArrayList&lt;Pair&lt;String&gt;&gt; 4.Varargs警告考虑下面的方法，它有可变长的泛型类型参数ts：123public static&lt;T&gt; void addAll(Collection&lt;T&gt; coll,T...ts)&#123; for(t : ts) coll.add(t); &#125; 现在如果调用：1234Collection&lt;Pair&lt;String&gt;&gt; table = . . .;Pair&lt;String&gt; pair1 = . . .;Pair&lt;String&gt; pair2 = . . .;addAll(table,pair1,pair2); JVM会为了可变长参数建立一个Pair数组，这违反了前面的规则。这里特别注意：Java不支持泛型类型的数组，但如果向参数个数可变的方法传递一个泛型类型的实例(即传递一个泛型类型对象的数组)这种规则有所放松，你只会得到一个警告，而不是错误。可以用@SuppressWarnings(&quot;unchecked&quot;)或用@SafeVarags标注addAll方法来抑制警告。即如下：12@SafeVarargspublic static&lt;T&gt; void addAll(Collection&lt;T&gt; coll,T...ts) 现在就可以提供泛型类型来调用这个方法了。 5.不能实例化类型变量不能使用像new T(…),new T[…]或T.class这样的表达式中的类型变量。例如，下面的Pair&lt;T&gt;构造器是非法的：1public Pair() &#123;first = new T();second = new T();&#125;//Error 类型擦除将T改变成Object，而且本意肯定不希望调用new Object()。在Java SE 8之后，最好的解决方法是让调用者提供一个构造器表达式。例如：1Pair&lt;String&gt; p = Pair.makePair(String::new); makePair方法接受一个Supplier&lt;T&gt;，这是一个函数式接口，表示一个无参数而且返回类型为T的函数：1234public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr)&#123; return new Pair&lt;&gt; (constr.get(),constr.get());&#125; 比较传统的解决方法是通过反射调用Class.newInstance方法来构造泛型对象。遗憾的是，细节有点复杂。不能调用：1first = T.class.newInstance();//Error 表达式T.class是不合法的，因为它会被类型擦除为Object.class。必须像下面这样设计API以便得到一个Class对象：12345public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; c1)&#123; try &#123;return new Pair&lt;&gt; (c1.newInstance(),c1.newInstance())&#125;; catch(Exception ex) &#123;return null;&#125;&#125; 这个方法可以按照下列方式调用：1Pair&lt;String&gt; p = Pair.makePair(String.class); 注意，Class类本身是泛型。例如,String.class是一个Class&lt;String&gt;的实例(事实上，它是唯一的实例)。因此,makePair方法能够推断除pair的类型。 6.不能构造泛型数组就像不能实例化一个泛型实例一样，也不能实例化数组。不过原因有所不同，毕竟数组会填充null值，构造时看上去是安全的。不过，数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除。例如，考虑下面的例子：1public static &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;T[] mm = new T[2];&#125;//Error 类型擦除会让这个方法永远构造Comparable[2]数组。如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object[],并且在屈原素时进行类型转换。例如，ArrayList可以这样实现:12345678public class ArrayList&lt;E&gt;&#123; private Object[] elements; . . . @SuppressWarnings("unchecked") public E get(int i) &#123; return (E) elements[i];&#125;//取元素时强制类型转换 public void set(int i,E e) &#123; elements[i] = e;&#125;//改变元素时不必强转&#125; 实际的实现没有那么清晰：123456public class ArrayList&lt;E&gt;&#123; private E[] elements; . . . public ArrayList() &#123;elements = (E[]) new Object[10];&#125;&#125; 这里的强制类型转换E[]是一个假象，而类型擦除使其无法察觉。由于 minmax 方法返回 T[] 数组，使得这一技术无法施展， 如果掩盖这个类型会有运行时错误结果。假设实现代码：123456public static &lt;T extends Comparable&gt; T[] minmax(T... a)&#123;Object[] mm = new Object[2];. . .return (T[]) mm; // compiles with warning&#125; 调用 String[] ss = ArrayAlg.minmax(“Tom”, “Dick”, “Harry”);编译时不会有任何警告。当 Object[] 引用赋给 Comparable[] 变量时，将会发生 ClassCastException异常。在这种情况下， 最好让用户提供一个数组构造器表达式：1String[] ss = ArrayAlg.minmax (String[]::new，"Tom", "Dick", "Harry"); 构造器表达式 String::new 指示一个函数，给定所需的长度，会构造一个指定长度的String数组。minmax方法使用这个参数生成一个有正确类型的数组：1234public static &lt;T extends Comparable〉T[] minmax(IntFunction&lt;T[]&gt; constr, T... a)&#123; T[] mm = constr.apply(2);&#125; 比较老式的方法是利用反射， 调用 Array.newInstance:12345public static &lt;T extends Comparable〉T[] minmaxfT... a)&#123;T[] mm = (T[]) Array.newlnstance (a.getClass().getComponentType() , 2); . . .&#125; ArrayList 类的 toArray 方法就没有这么幸运。它需要生成一个 T[] 数组， 但没有成分类型。因此， 有下面两种不同的形式：12Object[] toArray()T[] toArray(T[] result) 第二个方法接收一个数组参数。如果数组足够大,就使用这个数组。否则,用 result 的成分类型构造一个足够大的新数组。 7.泛型类的静态上下文中类型变量无效不能在静态域或方法中引用类型变量。例如， 下列高招将无法施展：123456789public class Singleton&lt;T&gt;&#123; private static T singlelnstance; // Error public static T getSinglelnstanceO // Error &#123; if (singleinstance == null) //construct new instance of T return singlelnstance; &#125;&#125; 8.不能抛出或捕获泛型类的实例既不能抛出也不能捕获泛型类对象。实际上， 甚至泛型类扩展 Throwable 都是不合法的。例如， 以下定义就不能正常编译：12public class Problem&lt;T&gt; extends Exception &#123; /* . . . */ &#125; // Error can't extend Throwable catch 子句中不能使用类型变量。例如， 以下方法将不能编译：1234567891011public static &lt;T extends Throwable〉void doWork(Class&lt;T&gt; t)&#123; try &#123; do work &#125; catch (T e) // Error can 't catch type variable &#123; Logger.global.info(...) &#125;&#125; 不过，在异常规范中使用类型变量是允许的。以下方法是合法的：12345678910111213public static &lt;T extends Throwable&gt; void doWork(T t) throws T // OK&#123; try &#123; do work &#125; catch (Throwable real Cause) &#123; t.initCause(real Cause); throw t; &#125; &#125; 9.可以消除对受查异常的检查Java 异常处理的一个基本原则是， 必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。关键在于以下方法：12345@SuppressWamings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable e) throws T&#123;throw (T) e;&#125; 假设这个方法包含在类 Block 中，如果调用Block.&lt;RuntimeException&gt;throwAs(t);编译器就会认为 t 是一个非受查异常。 以下代码会把所有异常都转换为编译器所认为的非受查异常：12345678try&#123; do work&#125;catch (Throwable t)&#123; Block.&lt;RuntimeException&gt;throwAs(t) ;&#125; 下面把这个代码包装在一个抽象类中。用户可以覆盖 body 方法来提供一个具体的动作。调用 toThread 时， 会得到 Thread 类的一个对象， 它的 run 方法不会介意受查异常。12345678910111213141516171819202122232425public abstract class Block&#123; public abstract void body() throws Exception; public Thread toThrea() &#123; return new Thread() &#123; public void run() &#123; try &#123; body(); &#125; catch (Throwable t) &#123; Block.&lt;RuntimeException&gt; throwAs(t); &#125; &#125; &#125;;&#125;@SuppressWamings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable e) throws T&#123;throw (T) e;&#125; 例如， 以下程序运行了一个线程， 它会拋出一个受查异常。12345678910111213141516public class Test&#123; public static void main(String[] args) &#123; new Block() &#123; public void body() throws Exception &#123; Scanner in = new Scanner(new File("ququx") ,"UTF-8"); while (in.hasNext()) System.out.println(in.next()); &#125; &#125; .toThread() .start(); &#125;&#125; 运行这个程序时， 会得到一个栈轨迹， 其中包含一个FileNotFoundException ( 当然,假设你没有提供一个名为 ququx 的文件)。这有什么意义呢？ 正常情况下， 你必须捕获线程 run 方法中的所有受查异常， 把它们”包装”到非受查异常中， 因为 run 方法声明为不抛出任何受查异常。不过在这里并没有做这种”包装”。我们只是抛出异常， 并”哄骗”编译器， 让它认为这不是一个受查异常。通过使用泛型类、 擦除和 @SuppressWarnings 注解， 就能消除 Java 类型系统的部分基本限制。 注意擦除后的冲突当泛型类型被擦除时，无法创建引发冲突的条件。下面是一个示例。假定像下面这样将equals 方法添加到 Pair 类中：1234public class Pair&lt;T&gt;&#123;public boolean equals(T value) &#123; return first.equals(value) &amp;&amp; second.equals(value); &#125;&#125; 考虑一个Pair&lt;String&gt;。从概念上讲，它有两个equals方法：12boolean equals(String) // defined in Pair&lt;T&gt;boolean equals(Object) // inherited from Object 但是，直觉把我们引入歧途。方法擦除boolean equals(T)，就是boolean equals(Object)与 Object.equals 方法发生冲突。当然，补救的办法是重新命名引发错误的方法。泛型规范说明还提到另外一个原则:”要想支持擦除的转换， 就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。”例如，下述代码是非法的：123class Employee implements Coinparab1e&lt;Emp1oyee&gt; &#123; . . . &#125;class Manager extends Employee implements Comparable&lt;Hanager&gt; &#123; . . . &#125; // Error Manager 会实现 Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt;, 这是同一接口的不同参数化。这一限制与类型擦除的关系并不十分明确。毕竟，下列非泛型版本是合法的。12class Employee implements Comparable &#123; . . . &#125;class Manager extends Employee implements Comparable &#123; . . . &#125; 其原因非常微妙， 有可能与合成的桥方法产生冲突。实现了 Comparable&lt;X&gt; 的类可以获得一个桥方法：1public int compareTo(Object other) &#123; return compareTo((X) other); &#125; 对于不同类型的 X 不能有两个这样的方法。 泛型类型的继承规则]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习之线段树]]></title>
    <url>%2F2017%2F10%2F18%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。 线段树是什么？有什么用？线段树类似区间树，它在各个节点保存一条线段(数组中的一段子数组)，主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。你可能会问：查询区间和可以用O(n)的复杂度预处理一个前缀和数组，然后就可以O(1)地查询某段区间和;查询区间最值，也就是RMQ问题，也可以用O(nlogn)的复杂度预处理ST表，然后O(1)地查询区间最值。那么为什么要使用线段树呢？线段树的精髓就在于它能在支持区间动态修改的前提下保持每个操作O(logn)的复杂度，这是其他两者做不到的。线段树能进行的操作主要有：1)单点更新，区间查询 2)区间更新，区间查询 3)区间更新，单点查询除了上述操作，线段树还可以解决区间染色和矩形面积交、面积并等问题。 线段树基本知识线段树的结构： 建立一个线段树的示意图(可以维护区间和或最值)： 单点修改后重新调整线段树： 区间查询区间最值： 线段树的结点关系: 线段树的代码实现下面给出建立线段树和进行各种操作的模板，关键点在代码的注释中有解释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*node：区间结点号 begin：该node的区间左边界 end：该node的区间右边界 left：查询区间的左边界 right：查询区间的右边界 pos：查询区间的点*/ /*线段树:求和或最值 单点更新,区间查询区间更新,单点查询(lazy标记表示本节点的信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。lazy初始为0,区间加上k给该区间管理的结点的lazy加k,push_down给子节点加(end-begin+1)*k)区间更新,区间查询 lson 2*noderson 2*node+1[begin,end][begin,mid] [mid+1,end] 其中mid为(begin+end)/2 */ #define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1) int segTree[maxn*4];int lazy[maxn*4];void pushUp(int node)&#123;//pushUp自底向上更新区间和与最值 segTree[node]=segTree[lson]+segTree[rson];//segTree[node]=max(segTree[lson],segTree[rson]) &#125;void pushDown(int node,int begin,int end)&#123;//pushDown自顶向下更新lazy数组和给结点加上lazy数组的值 if(!lazy[node]) return;//lazy[node]为0直接return segTree[lson]+=(mid-begin+1)*lazy[node]; segTree[rson]+=(end-mid)*lazy[node]; lazy[lson]+=lazy[node]; lazy[rson]+=lazy[node];//给左右孩子传递lazy,是+=不是=，因为孩子节点可能被多次延迟标记又没有向下传递 lazy[node]=0;//把父节点的lazy置为0 &#125;void build(int node,int begin,int end)&#123;//建树 lazy[node]=0; if(begin==end)&#123;//begin==end表示管理的是结点 scanf("%d",&amp;segTree[node]);//按照顺序输入结点，由于建树类似于树的先根遍历，所以建立的线段树的叶子结点从左到右的值就是输入的顺序 //segTree[node]=a[begin] 用于任意顺序输入,先将输入存入a数组,下标从1开始，begin = end = index return;//输入完成后要return，否则会继续访问左右孩子，可能越界 &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123;//单点更新 if(pos&lt;begin||pos&gt;end) return;//管理的区间不包含pos,直接return if(begin==end)&#123; segTree[node]+=k; return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125; int query(int node,int begin,int end,int left,int right)&#123;//区间查询 if(left&gt;end||right&lt;begin) return 0;//查询结点和区间没有公共点 if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node];//查询区间包含查询结点 pushDown(node,begin,end); int sum=0;//int maxx=-1 sum+=query(lson,begin,mid,left,right);//maxx=max(maxx,query(lson,begin,mid,left,right)) sum+=query(rson,mid+1,end,left,right);//maxx=max(maxx,query(rson,mid+1,end,left,right)) return sum;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123;//区间更新 if(left&gt;end||right&lt;begin) return;//结点和更新区间没有公共点 if(left&lt;=begin&amp;&amp;right&gt;=end)&#123;//更新区间包含结点 segTree[node]+=(end-begin+1)*k; lazy[node]+=k; return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125; 例题一、单点更新，区间查询HDU1166 敌兵布阵题目链接:http://acm.split.hdu.edu.cn/showproblem.php?pid=1166代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define maxn 50005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[maxn*4];int T,N,a,b;char command[10];void pushUp(int node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void build(int node,int begin,int end)&#123; if(begin==end)&#123; scanf("%d",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segTree[node]+=k; return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; int sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;int main()&#123; scanf("%d",&amp;T); int cas=1; while(T--)&#123; scanf("%d",&amp;N); build(1,1,N); printf("Case %d:\n",cas++); while(scanf("%s",command)!=EOF)&#123; if(command[0]=='E') break; scanf("%d%d",&amp;a,&amp;b); if(command[0]=='Q') cout&lt;&lt;query(1,1,N,a,b)&lt;&lt;endl; else if(command[0]=='A') update(1,1,N,a,b); else if(command[0]=='S') update(1,1,N,a,-b); &#125; &#125;&#125; HDU 1754 I Hate It题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1754代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define maxn 200005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[4*maxn];int N,M,A,B;char C[3];void pushUp(int node)&#123; segTree[node]=max(segTree[lson],segTree[rson]);&#125;void build(int node,int begin,int end)&#123; if(begin==end)&#123; scanf("%d",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segTree[node]=k;//直接修改 return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; int maxx=0; maxx=max(maxx,query(lson,begin,mid,left,right)); maxx=max(maxx,query(rson,mid+1,end,left,right)); return maxx;&#125;int main()&#123; while(scanf("%d%d",&amp;N,&amp;M)!=EOF)&#123; build(1,1,N); while(M--)&#123; scanf("%s%d%d",C,&amp;A,&amp;B); if(C[0]=='Q')&#123; printf("%d\n",query(1,1,N,A,B)); &#125; else&#123; update(1,1,N,A,B); &#125; &#125; &#125;&#125; 二、区间更新，区间查询POJ 3468 A Simple Problem with Integers题目链接:http://poj.org/problem?id=3468代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#define maxn 100005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;typedef long long ll;ll segTree[4*maxn];ll lazy[4*maxn];ll N,Q,A,B,C;char command[3];void pushUp(ll node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void pushDown(ll node,ll begin,ll end)&#123; if(!lazy[node]) return; segTree[lson]+=(mid-begin+1)*lazy[node]; segTree[rson]+=(end-mid)*lazy[node]; lazy[lson]+=lazy[node]; lazy[rson]+=lazy[node]; lazy[node]=0;&#125;void build(ll node,ll begin,ll end)&#123; lazy[node]=0; if(begin==end)&#123; scanf("%lld",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node); &#125;ll query(ll node,ll begin,ll end,ll left,ll right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; pushDown(node,begin,end); ll sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;void update(ll node,ll begin,ll end,ll left,ll right,ll k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segTree[node]+=(end-begin+1)*k; lazy[node]+=k; return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125;int main()&#123; scanf("%lld%lld",&amp;N,&amp;Q); build(1,1,N); while(Q--)&#123; scanf("%s",command); if(command[0]=='Q')&#123; scanf("%lld%lld",&amp;A,&amp;B); printf("%lld\n",query(1,1,N,A,B)); &#125; else&#123; scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;C); update(1,1,N,A,B,C); &#125; &#125;&#125; HDU 1698 Just A Hook题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1698代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define maxn 100005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[4*maxn];int lazy[4*maxn];int T,N,Q,X,Y,Z;void pushUp(int node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void build(int node,int begin,int end)&#123; lazy[node]=0; if(begin==end)&#123; segTree[node]=1; return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void pushDown(int node,int begin,int end)&#123; if(!lazy[node]) return; segTree[lson]=(mid-begin+1)*lazy[node];//+=改成=,直接更新到底部 segTree[rson]=(end-mid)*lazy[node]; lazy[lson]=lazy[node]; lazy[rson]=lazy[node]; lazy[node]=0;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segTree[node]=(end-begin+1)*k;//+=改成=,直接更新到底部 lazy[node]=k;//+=改成=,因为此时lazy即使没有下传也不叠加 return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; pushDown(node,begin,end); int sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;int main()&#123; scanf("%d",&amp;T); int cas=1; while(T--)&#123; scanf("%d%d",&amp;N,&amp;Q); build(1,1,N); while(Q--)&#123; scanf("%d%d%d",&amp;X,&amp;Y,&amp;Z); update(1,1,N,X,Y,Z); &#125; printf("Case %d: The total value of the hook is %d.\n",cas++,query(1,1,N,1,N)); &#125;&#125; 三、区间染色问题ZOJ 1610 Count the Colors题目链接:https://vjudge.net/problem/11553/origin代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)#define maxn 8005using namespace std;int col[maxn*4];//col[node]表示node管辖的区间的颜色 int sum[maxn];//表示某点的颜色 int res[maxn];void pushDown(int node)&#123; col[lson]=col[rson]=col[node]; col[node]=-1;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; col[node]=k; return; &#125; if(col[node]!=-1) pushDown(node); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k);&#125;//不用建树,直接在query里存储颜色即可，因为染色不用求区间和或者最值 void query(int node,int begin,int end,int left,int right)&#123; if(begin==end)&#123; sum[begin]=col[node];//存储每个点的颜色 return; &#125; if (col[node] != -1) pushDown(node); query(lson,begin,mid,left,right); query(rson,mid+1,end,left,right);&#125;int main()&#123; int n,x1,x2,c; while(scanf("%d",&amp;n)!=EOF)&#123; memset(col,-1,sizeof(col)); memset(sum,-1,sizeof(sum)); memset(res,0,sizeof(res)); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;x1,&amp;x2,&amp;c); if(x1==x2) continue;//为了保证R-1&gt;=L update(1,0,maxn-1,x1,x2-1,c);//为防止重叠,更新区间[L,R-1] /*注意begin=0 end=maxn-1 而不是begin=1 end=n 因为只是涂n次,不一定在1-n范围内涂 */ &#125; query(1,0,maxn-1,0,maxn-1); for(int i=0; i&lt;maxn; i++) &#123; while(i!=0&amp;&amp;sum[i]!=-1&amp;&amp;sum[i]==sum[i-1])//涂过同一颜色也加1 i++; res[sum[i]]++; &#125; for(int i=0; i&lt;maxn; i++) if(res[i]) printf("%d %d\n",i,res[i]); printf("\n"); &#125; return 0;&#125; POJ 2528 Mayor’s posters题目链接:http://poj.org/problem?id=2528代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/*解法：离散化，如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的 1 2 3 4 6 7 8 10 — — — — — — — — 1 2 3 4 5 6 7 8离散化 X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。但是只是这样简单的离散化是错误的，如三张海报为：1~10 1~4 6~10离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10第一张海报时：墙的1~4被染为1；第二张海报时：墙的1~2被染为2，3~4仍为1；第三张海报时：墙的3~4被染为3，1~2仍为2。最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3最终，1~2为2，3为1，4~5为3，于是输出正确结果3。*/ #include&lt;cstdio&gt; #include&lt;cstring&gt;#include&lt;algorithm&gt;#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;#define maxn 10005//不用建树,直接在query里记录hash即可，因为染色不用求区间和或者最值，也不用pushUp int m, li[maxn], ri[maxn];int poster[maxn&lt;&lt;3], col[maxn&lt;&lt;4], ans; //col记录当前该位置最上面一层的海报种类,即染色问题的颜色 //poster记录海报位置 bool hash[maxn];//hash用于标记某种种类的海报是否计算过,若已计算过标记为true,不再重复计算 void pushDown(int node) &#123; col[lson] = col[rson] = col[node];//类似lazy标记，向下传递后清空 col[node] = -1;&#125;void update(int node,int begin, int end,int left, int right, int k) &#123; if(left&gt;end||right&lt;begin) return; if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; col[node] = k; return; &#125; if(col[node] != -1) pushDown(node); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k);&#125;void query(int node,int begin,int end) &#123; if (begin == end) &#123; if (!hash[col[node]]) &#123; ans++; hash[col[node]] = true; &#125; return; &#125; if (col[node] != -1) pushDown(node); query(lson,begin,mid); query(rson,mid+1,end);&#125;int binarySearch(int ll, int hh, int xx) &#123; int mm; while (ll &lt;= hh) &#123; mm = (ll + hh) &gt;&gt; 1; if (poster[mm] == xx) return mm; else if (poster[mm] &gt; xx) hh = mm - 1; else ll = mm + 1; &#125; return -1;&#125;int main()&#123; int t, n, i; scanf ("%d", &amp;t); while (t--) &#123; memset(col, -1, sizeof (col));//-1表示没有染色 memset (hash, false, sizeof (hash));/*因为本题墙的长度为10000000,直接做会超时,而实际海报数量只有10000,考虑把每张海报左右两端的两段映射到小范围计算，所以考虑离散化,但传统离散化会出错,要如果有两个位置相邻的数字数值不相邻,考虑在中间插入一个比大的数小1的数*/ int cnt = 0; scanf ("%d", &amp;n); for (i = 1; i &lt;= n; i++) &#123; scanf ("%d %d", &amp;li[i], &amp;ri[i]); poster[++cnt] = li[i]; poster[++cnt] = ri[i]; &#125; sort(poster+1, poster+cnt+1); m = 1; for (i = 2; i &lt;= cnt; i++) &#123; if (poster[i] != poster[i-1]) poster[++m] = poster[i];//去重 &#125; for (i = m; i &gt; 1; i--) &#123; if (poster[i] - poster[i-1] &gt; 1) poster[++m] = poster[i] - 1;//在末尾加入要增加的点 &#125; sort(poster+1, poster+m+1);//重新排序 for (i = 1; i &lt;= n; i++) &#123; int l = binarySearch(1, m, li[i]);//在离散化后的poster数组里二分查找每一组的左右端点 int r = binarySearch(1, m, ri[i]); update(1,1,m,l,r,i); &#125; ans = 0; query(1, 1, m); printf("%d\n", ans); &#125; return 0;&#125; 四、矩形面积交/面积并HDU 1542 Atlantis(矩形面积并)题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1542代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt; #define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)#define maxn 2005using namespace std;int n;double y[maxn];//沿x轴扫描,沿y轴建树,线段树的结点是纵向的线段,最下面一层结点以排序后相邻的y1,y2为边界 struct LINE // 存储线段信息；&#123; double x; // 该线段的x坐标； double y_up,y_down; // 竖向线段的上下端点； int flag;//矩形的左边界为1,右边界为-1 &#125;line[maxn];struct node//线段树的结点,不再是单个点,是一个区间 &#123; double l,r; // 区间的左右边界,即某段扫描线的上下端点 double x; // 记录上一个横坐标位置，用于求面积； int cover; // 记录覆盖的线段数;即同一方向的线段数;由flag累加 bool flag; // 标记只有一个区间的节点,即在线段树最底层的结点,我们将一个个连续的区间离散化成一个结点；&#125;node[maxn&lt;&lt;2];bool cmp(LINE a,LINE b)&#123; return a.x&lt;b.x;&#125;void build(int rt,int l,int r) // 建树；&#123; node[rt].l=y[l]; // 维护区间； node[rt].r=y[r]; node[rt].x=-1; node[rt].flag=false; node[rt].cover=0; if(l+1==r)&#123; // 区间是连续的; node[rt].flag=true; // 标记为结点; return; &#125; build(lson,l,mid); build(rson,mid,r); // 因为将一个个连续区间离散成点，所以此处mid不需要+1；&#125;double Insert_query(int rt,double x,double l,double r,int flag) /*查询+更新x处（l,r）区间面积，l和r代表的是区间查询区间的边界，node[rt].l和node[rt].r代表的是结点边界*/&#123; if(l&gt;=node[rt].r||r&lt;=node[rt].l) return 0; // 该方向结点不包含所要查询的区间； if(node[rt].flag)&#123; // 找到只有一个区间的叶子结点； if(node[rt].cover&gt;0)&#123; double pre=node[rt].x; double ans=(x-pre)*(node[rt].r-node[rt].l); // 计算面积； node[rt].x=x; // 更新定位x位置，便于下次计算面积； node[rt].cover+=flag; // 更新覆盖的线段数； return ans; &#125; else&#123; node[rt].x=x; node[rt].cover+=flag; return 0;//没有产生面积并也要return 0 &#125; &#125; double ans1,ans2; ans1=Insert_query(lson,x,l,r,flag); ans2=Insert_query(rson,x,l,r,flag); return ans1+ans2;&#125;int main()&#123; int Case=0; double x1,x2,y1,y2; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int cnt=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); y[cnt]=y1; line[cnt].x=x1; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=1; // 表示左边线段； y[cnt]=y2; line[cnt].x=x2; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=-1; // 表示右边线段； &#125; sort(y,y+cnt); // 将所有高度由小到大排序，将区间建树表示 sort(line,line+cnt,cmp); // 因为扫描线从左到右扫描，所以按照横坐标从小到大排序后逐一插入线段树 build(1,0,cnt-1); double area=0; for(int i=0;i&lt;cnt;i++)&#123; area+=Insert_query(1,line[i].x,line[i].y_down,line[i].y_up,line[i].flag); &#125; printf("Test case #%d\nTotal explored area: %.2lf\n\n",++Case,area); &#125; return 0;&#125; HDU 1255 覆盖的面积(矩形面积交)题目链接:http://acm.split.hdu.edu.cn/showproblem.php?pid=1255代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)#define maxn 2005using namespace std;int T,N;double y[maxn];struct LINE&#123; double x; double y_up,y_down; int flag;&#125;line[maxn];struct node&#123; double l,r; double x; int cover; bool flag;&#125;node[maxn&lt;&lt;2];bool cmp(LINE a,LINE b)&#123; return a.x&lt;b.x;&#125;void build(int rt,int l,int r)&#123; node[rt].l=y[l]; node[rt].r=y[r]; node[rt].x=-1; node[rt].flag=false; node[rt].cover=0; if(l+1==r)&#123; node[rt].flag=true; return; &#125; build(lson,l,mid); build(rson,mid,r);&#125;double Insert_query(int rt,double x,double l,double r,int flag)&#123; if(l&gt;=node[rt].r||r&lt;=node[rt].l) return 0; if(node[rt].flag)&#123; if(node[rt].cover&gt;1)&#123; double pre=node[rt].x; double ans=(x-pre)*(node[rt].r-node[rt].l); node[rt].x=x; node[rt].cover+=flag; return ans; &#125; else&#123; node[rt].x=x; node[rt].cover+=flag; return 0; &#125; &#125; double ans1,ans2; ans1=Insert_query(lson,x,l,r,flag); ans2=Insert_query(rson,x,l,r,flag); return ans1+ans2;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; int cnt=0; scanf("%d",&amp;N); while(N--)&#123; double x1,y1,x2,y2; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); y[cnt]=y1; line[cnt].x=x1; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=1; y[cnt]=y2; line[cnt].x=x2; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=-1; &#125; sort(y,y+cnt); sort(line,line+cnt,cmp); build(1,0,cnt-1); double area=0; for(int i=0;i&lt;cnt;i++)&#123; area+=Insert_query(1,line[i].x,line[i].y_down,line[i].y_up,line[i].flag); &#125; printf("%.2lf\n",area); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之抽象类、接口、lambda表达式与内部类]]></title>
    <url>%2F2017%2F10%2F16%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它子类的共同特征。如果一个父类设计得非常抽象，以至于它没有任何具体的实例，这样的类称为抽象类，使用abstract关键字修饰。抽象类定义了相关子类的共同行为。 抽象方法如果一个方法非常抽象，只定义了方法，没有提供方法的具体实现，那么我们把它定义为一个抽象方法，它的具体实现由子类提供，即子类覆盖抽象方法提供方法体。抽象方法由abstract关键字修饰，只有方法头，没有花括号和方法体，以分号结尾。比如一个GeometricObject类定义了一个名为getArea的抽象方法，即public abstract double getArea(); 几点说明1.抽象方法应该定义为public，以便子类进行重写。2.抽象类的构造器应该定义为protected，因为抽象类不能通过new直接创建实例，其构造器只被子类调用。创建一个具体子类的实例时，它的父类的构造器被调用以初始化父类中定义的数据域。3.一个包含抽象方法的类必须定义为抽象类，一个不包含抽象方法的类也可以定义为抽象类(如果不想让某类创建实例，可以把它定义为抽象类)4.如果子类继承抽象类时没有覆盖其所有的抽象方法，即子类中仍有抽象方法，子类也应该定义为抽象的5.抽象方法是非静态的6.子类可以覆盖父类的方法并将它定义为abstract,这种情况很少见，但它在当父类方法实现在子类中变得无效时是很有用的，在这种情况下，子类必须定义为abstract7.即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object是具体的，但它的子类GeometricObject是抽象的。8.不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。下面的语句创建一个GeometricObject类型的数组是正确的：GeometricObject[] objects = new GeometricObject[10];然后可以创建一个具体子类的实例并把它的引用赋给数组，如：Objects[0] = new Circle(); 接口接口在很多方面都与抽象类很相似，但它的目的是指明相关或者不相关类的多个对象的共同行为，属性成员都是公共静态常量，成员方法都是公共抽象方法。例如，使用正确的接口，可以指明这些对象是可比较的、可克隆的。为了区分接口和类，Java采用Interface关键字定义接口。在一个java文件内，只能有一个public类或一个public接口，即public类和public接口不能同文件共存。接口没有构造器，没有实例域，也不能使用new操作符创建实例。接口没有构造器的原因有三点：1.构造器用于初始化成员变量，接口没有成员变量，不需要构造器2.类可以实现多个接口，如果多个接口都有构造方法，不好确定构造方法链的调用次序3.作为高度抽象的概念，接口不能实例化对象，也就不需要构造器 像常规类一样，每个接口都被编译为独立的字节码文件，可以作为引用变量的数据类型和类型转换的结果，可以使用instanceof关键字等。类实现接口用implements关键字，一个类可以实现多个接口，用逗号隔开即可，一个类必须实现它实现接口的所有方法，否则要定义为抽象类。一个接口可以继承多个接口，用extends关键字，此时实现类需要重写接口继承链上所有接口的所有抽象方法。如果接口在继承在多个父接口时，父接口中出现了重名的默认方法冲突，就要在该接口中提供一个同名默认方法来解决冲突。在定义接口中的数据域和方法时可以简写，例如：1234public interface T&#123; public static final int K = 1; public abstract void p(); &#125; 可简写成1234public interface T&#123; int K = 1; void p();&#125; 要注意接口中所有的数据域都是public static final，所有的方法都是public abstract，在定义接口中允许省略修饰符，但在子类重写方法时不可缺省public修饰符，否则方法的可见性会缩小为包内可见。接口只能使用public修饰符或缺省访问控制修饰符。如果在具体实现类中定义了和接口中常量同名的常量，那么用接口变量指向实现类引用时变量调用的常量仍然是接口中定义的常量。 静态方法从Java SE 8开始，允许在接口中增加静态方法，并给静态方法提供方法体实现，该静态方法只能通过接口名.静态方法来调用。实现语法只要在方法前面加static关键字即可，这理论上讲是可以的，但这有违于接口作为抽象规范的初衷。静态方法只能被具体实现类继承，不能在实现类中重写。 默认方法可以为接口方法提供一个默认方法体实现，在方法前加default修饰符即可，这样子类无需重写这个方法也能得到一个接口的默认实现。例如：12345678public interface Collection&#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 这样实现Collection的程序员就不用操心实现isEmpty方法了。当然，默认方法也可以被具体实现类重写。在实现类中调用默认方法要使用接口名.super.默认方法来调用。默认方法的一个重要用法是“接口演化”。以Collection接口为例，这个接口作为Java的一部分已经很多年了，假设很久以前定义了一个实现Collection接口的类Bag。后来在Collection接口中增加了一个stream方法，假设stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。如果不重新编译这个类，而是使用原先包含这个类的JAR文件，这个类仍能正常加载，正常构造实例，但如果在一个Bag实例上调用stream方法，会出现一个AbstractMethodError。但如果把stream方法定义为默认方法就可以解决这个问题，既可以重新编译也可以使用JAR文件加载类并调用stream方法。 解决默认方法的冲突如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生冲突。解决冲突规则如下：1) 超类和接口冲突。如果超类提供了一个具体方法，那么根据超类优先原则，同名而且有相同参数类型的默认方法会被忽略。2) 多接口之间冲突。如果一个实现类实现了多个接口，一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，此时就发生了接口冲突，必须在实现类中重写这个方法来解决冲突。 解决重名常量的冲突1）超类和接口冲突。如果一个类继承了一个超类和实现了若干接口，此时不像默认方法冲突一样有超类优先原则。只能通过在实现类中覆盖该常量来解决冲突。2）多接口之间冲突。如果一个类实现了多个接口，而这些接口又有重名常量，此时会发生冲突。必须用接口名.常量的方式来精确指明要使用的常量。 Comparable接口Comparable接口定义了compareTo方法，用于比较对象。当想使用Arrays类的sort方法对对象数组进行排序时，对象所属的类必须实现了Comparable接口。Comparable接口是一个带泛型的接口，定义为：123public interface Comparable&lt;E&gt;&#123; public int compareTo(E o); &#125; compareTo应该与equals保持一致，即当且仅当o1.equals(o2)为true时，o1.compareTo(o2) == 0成立。以下是compareTo方法的实现： 12345class Employee implements Comparable&lt;Employee&gt;&#123;public int compareTo(Employee other)&#123; return Double.compare(salary,other.salary); &#125;&#125; 在比较浮点数时可以使用Double的静态方法compare,这样就不必担心溢出或精度损失，类似的还有Integer.compare方法等 继承过程中的compareTo，如果由子类决定相等的概念，每个compare方法都应该在开始时检测：if(getClass() != other.getClass()) throw new ClassCastException()：如果父类决定相等的概念，应该在超类中提供一个compareTo方法，并将这个方法声明为final。 Comparator接口 Comparator接口意为”比较器”接口，是一个泛型接口，可用于自定义排序规则和大小比较等。要进行自定义排序，Arrays.sort方法有一个重载版本，需要提供一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。接口定义为： 1234public interface Comparator&lt;T&gt;&#123; int compare(T first,T second);&#125; 如果要按长度比较字符串，由于String是按字典序比较字符串，肯定不能让String类用两种方法实现compareTo方法 —— 况且String类也不由我们修改。此时可以定义如下实现Comparator的类： 123456class lengthComparator implements Comparator&lt;String&gt;&#123; public int compare(String first,String second)&#123; return first.length() - second.length(); &#125;&#125; 因为要调用compare方法，所以具体比较大小和排序时都要创建一个lengthComparator的实例： 大小比较 12Comparator&lt;String&gt; comp = new LengthComparator();if(comp.compare(words[i],words[j]) &gt; 0) ... 自定义排序 12String[] friends = &#123;"Peter","Paul","Mary"&#125;;Arrays.sort(friends,new LengthComparator()); Comparable接口和Comparator接口都可以用于自定义排序。但前者只能在定义要比较的类的同时实现，比如自定义的类，使用sort的不带比较器的方法排序。后者则可用于类的定义时或类已经设计完成但还想进行排序，因为它的实现是在要比较的类之外的，比如对Java类库中的类进行排序，无法修改类的定义，只好在外部定义一个实现了Comparator的比较器，并使用sort带比较器的方法排序。下面对于一个学生类的两个关键字进行排序，先按分数从高到低排序，分数相同按年龄从小到大排序。方法一：实现Comparable接口重写的compareTo方法为：123456789101112131415public int compareTo(Student stu)&#123; if(this.score&gt;stu.score)&#123; return -1 ; &#125;else if(this.score &lt; stu.score)&#123; return 1 ; &#125;else&#123; if(this.age&gt;stu.age)&#123; return 1 ; &#125;else if(this.age &lt; stu.age)&#123; return -1 ; &#125;else&#123; return 0 ; &#125; &#125; &#125; 方法二：实现Comparator接口重写的compare方法为：123456789101112131415public int compare(Student stu1,Student stu2)&#123; if(stu1.score&gt;stu2.score)&#123; return -1 ; &#125;else if(stu1.score&lt;stu2.score)&#123; return 1 ; &#125;else&#123; if(stu1.age&gt;stu2.age)&#123; return 1 ; &#125;else if(stu1.age&lt;stu2.age)&#123; return -1 ; &#125;else&#123; return 0 ; &#125; &#125; &#125; 自定义排序总结：无论是重写compare方法还是compareTo方法，对大于、小于、等于三种情况都要有返回值，否则无法通过编译。在compareTo方法中，规定 this.xxx &gt; o.xxx 返回 1,this.xxx == o.xxx 返回0,this.xxx &lt; o.xxx 返回-1是升序排列，反之就是降序排列。在compare方法中,规定o1.xxx &gt; o2.xxx返回1,o1.xxx == o2.xxx返回0,o1.xxx &lt; o2.xxx返回 -1是升序排列，反之就是降序排列。技巧：如果要比较的属性也实现了Comparable接口，就可以调用它的compareTo方法。如果要降序排列，就交换compareTo的参数顺序即可。如果要比较的类是基本数据类型，可以返回差值，如果差值不是int类型，就转换为int类型。 Cloneable接口 首先，我们考虑为一个包含对象引用的变量建立副本会发生什么，例如： 123Employee original = new Employee("John Public",50000);Employee copy = original;copy.ratseSalary(10); //original的salary也被改变 原变量和副本都会指向同一个对象，这说明，任何一个变量的改变都会影响到另一个变量。如果有一个对象original，希望创建一个对象copy使得其初始状态与original相同，但是之后它们各自回有自己不同的状态，这种情况下就可以使用克隆，例如：12Employee copy = original.clone();copy.raiseSalary(10); //original的salary不会被改变 Object类中的clone方法将原始对象的每个数据域复制给目标对象，如果一个数据域是基本数据类型，复制的就是它的值，如果是引用类型，复制的就是它的引用，这种克隆称为浅复制,即original != copy,但original.hireDay == copy.hireDay。这有时是不符合我们要求的，我们不希望在改变某个对象的引用类型的数据域时影响到另一个对象，这时我们需要深复制,即如果数据域是引用类型，复制的是对象的内容而不是引用。无论是浅复制还是深复制，我们都需要先实现Cloneable接口，否则会产生一个必检异常。Cloneable接口的定义是：123public interface Cloneable&#123;&#125; 我们发现这个接口是空的，一个带空体的接口称为标记接口。一个标记接口既不包括常量也不包括方法，它用来表示一个类拥有的某些特定的属性，其惟一的作用是允许在类型查询中使用instanceof关键字。但如果一个请求克隆的对象不实现这个接口，会产生CloneNotSupportedException，即使clone的默认(浅拷贝)实现能够满足要求，还是要实现这一接口。在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone方法，这个方法是从Object类继承的，这个接口只是作为一个标记。 Object类中提供的原始clone方法的方法头是protected native Object clone() throws CloneNotSupportedException,关键字native表明这个方法不是用Java写的，但它是JVM针对自身平台实现的。关键字protected限定方法只能在同一个包内或在其子类中访问。由于这个原因：必须在要实现克隆的子类中覆盖这个方法并把可见性修饰父改为public。下面给出一个浅复制的例子：12345678class Employee implements Cloneable&#123; public Employee clone() throws CloneNotSupportedException &#123; return (Employee) super.clone(); &#125; . . .&#125; 下面给出一个深复制的例子： 12345678910class Employee implements Cloneable&#123; public Employee clone() throws CloneNotSupportedException &#123; . . . Employee cloned = (Employee) super.clone; cloned.hireDay = (Date)hireDay.clone(); return cloned; &#125;&#125; 我们注意到Object类的clone方法的返回值类型是Object，而Employee类的clone方法返回值类型是Employee，这叫做协变返回类型，即子类在重写父类方法时可以返回父类返回值类型的子类型。clone方法声明异常也可以改成捕获异常，如：123456789public Employee clone()&#123; try &#123; Employee cloned = (Employee) super.clone(); . . . &#125; catch(CloneNotSupportedException e)&#123; return null;&#125; &#125; 复制数组的四种方法1.申请一个新数组，遍历原数组逐一复制元素2.使用System类的静态方法arraycopy3.使用数组对象.clone返回一个数组克隆的引用4.使用Arrays类的copyOf方法 接口和抽象类区别：1.接口所有的变量必须是public static final;抽象类的变量无限制2.接口没有构造方法，不能用new操作符实例化;抽象类有构造方法，由子类通过构造方法链调用，不能用new操作符实例化3.接口所有方法必须是公共抽象实例方法(Java SE 8开始允许定义静态方法)，抽象类无限制4.一个类只可以继承一个父类，但可以实现多个接口5.所有的类有一个共同的根Object类，接口没有共同的根6.抽象类和子类的关系应该是强的“是一种”关系(strong is-a relationship),而接口和子类的关系是弱的”是一种”关系(weak is-a relationship)。接口比抽象类更灵活，因为实现接口的子类只需要具有统一的行为即可，不需要都属于同一个类型的类。 接口与回调 回调是一种常见的程序设计模式。回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口。 见博客：Java回调机制(CallBack)详解 内部类 内部类，或者称为嵌套类，是一个定义在另一个类范围中的类。一个内部类可以如常规类一样使用。通常，在一个类只被它的外部类所使用的时候，才将它定义为内部类，内部类机制主要用于设计具有互相协作关系的类集合。比如： 12345678910111213141516//OuterClass.java: inner class demopublic class OuterClass &#123; private int data; /** A method in the outer class */ public void m()&#123; //Do something &#125; // An inner class class InnerClass &#123; /** A method in the inner class */ public void mi()&#123; data++; m(); &#125; &#125; &#125; 为什么要使用内部类，主要原因有三： 1.内部类可以访问包含它的外部类的所有数据域(包括私有数据域)和方法，没有必要将外部类对象的引用传递给内部类的构造方法,内部类有一个指向外部类对象的隐式引用，如果显式写出，外部类的引用是OuterClass.this 2.内部类可以对同一个包中的其他类隐藏起来 3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷 内部类具有一下特征： 1) 一个成员内部类被编译成一个名为OuterClassName$InnerClassName的类。例如，一个定义在Test类中的成员内部类A被编译成Test$A.class 2) 一个内部类可以使用可见性修饰符(public、private、protected、default)所定义，和应用于一个类中成员的可见性规则一样 3) 一个内部类可以被定义为static，一个static的内部类可以使用外部类的名字访问,一个static内部类不能访问外部类中的非静态成员 4) 内部类对象通常在外部类中创建，但是你也可以从另外一个类中来创建一个内部类的对象。如果内部类是非静态的，你必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类对象：OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 如果内部类是静态的，使用下面语法来创建一个内部类对象:OuterClass.InnerClass innerObject = new OuterClass.InnerClass();。 一般建议在外部类中定义一个用于获取内部类对象的方法，以便于从外部类外获取内部类对象，比如： 123public InnerClass getInnerClass()&#123; return new InnerClass();&#125; 5) 内部类所有的静态域必须是final修饰的静态常量,不能有静态变量，也不能有静态方法 一个简单的内部类的用途是将相互依赖的类结合到一个主类中，这样做减少了源文件的数量(因为非内部类如果用public修饰必须放在不同的源文件中，而内部类可放在同一源文件中)，这样也使得类文件容易组织，因为它们都将主类名作为前缀。另外一个内部类的实际用途是避免类名冲突。 内部类对于定义处理器类非常有用，一个处理器类被设计为针对一个GUI组件创建一个处理器对象(比如，一个按钮)。处理器类不会被其他应用所共享，所以将它定义在主类里面作为一个内部类使用是恰如其分的。 广泛意义上的内部类一般来说包括四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。 成员内部类 成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： 1234567891011121314 class Circle &#123; private double radius = 0; public static int count =1; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125;&#125; 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员），但外部类想要访问内部类的成员属性和方法时必须先实例化内部类对象。 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类.this.成员变量 外部类.this.成员方法 局部内部类 可以把内部类定义在一个方法中，称为局部内部类，也叫方法内部类。局部内部类就像是方法里面的一个局部变量一样，不能有public、protected、private以及static修饰符。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，即对外部世界完全隐藏起来。即使外部类中的其他代码也不能访问它。除了其所在的方法之外，没有任何方法知道该局部类的存在。局部内部类只能访问被final修饰的局部变量。 局部内部类被编译器编译成一个OuterClassName$1InnerClassName的类。序号逐渐递增。 123456789101112131415161718 class People&#123; public People() &#123; &#125;&#125; class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 注意：上述代码中通过调用getWoman()获取了局部内部类Woman的引用，不能通过局部内部类引用.属性的方式来直接访问局部内部类的成员，所以我们一般会在该方法中直接调用局部内部类的方法进行某种操作，然后返回操作结果。 匿名内部类 有时我们在程序中对一个类只使用一次，此时就可以把类的定义和实例化对象整合在一起，来简化对于抽象类和接口实现的操作，这就是匿名内部类。 一个匿名内部类是一个没有名字的内部类，其语法如下： 12345new SuperClassName/InterfaceName()&#123; //implement or override methods in superclass or interface //Other methods if necessary &#125; 其含义是创建一个继承自SuperClass或实现Interface的类的实例，并在类块内重写父类或接口的抽象方法，应该将匿名内部类理解成一个匿名子类的匿名对象,而不是理解成一个类。 匿名内部类有如下特征： 1.没有可见性修饰符 2.没有构造方法(因为没有名字,无法命名构造方法),但可以有构造代码块，也可以调用父类的构造方法，即new SuperClassName()调用父类无参构造方法，new SuperClassName(args1,...)调用父类有参构造方法。如果实现的是接口，则不能有任何参数，但是小括号仍然不可缺省 3.必须总是从一个父类继承或者实现一个接口，但是它不能有显式的extends或者implements子句 4.必须实现父类或接口中的所有抽象方法 5.一个匿名内部类被编译成一个名为OuterClassName$n.class的类，例如：如果外部类Test有两个匿名内部类，分别被编译成Test$1.class和Test$2.class 应用一 下面的技巧称为“双括号初始化”，这里利用了内部类语法。假设你想构造一个数组列表，并将它传递到一个方法。 1234ArrayList&lt;String&gt; friends = new ArrayList&lt;String&gt;();friends.add("Harry");friends.add("Tony");invite(friends); 如果不再需要这个数组列表，最好让它作为一个匿名列表。语法如下： 1234567 invite(new ArrayList&lt;String&gt; &#123; &#123; add("Harry"); add("Tony"); &#125;&#125;); 注意这里的双括号，外括号建立了一个ArrayList的匿名子表，内括号则是一个对象构造块。 应用二 生成日志或调试消息时，通常希望包含当前类的类名，如： System.err.println(&quot;Something awful happened in &quot; + getClass()); 不过这对于静态方法并不凑效，因为调用getClass()调用的是this.getClass(),但静态方法里没有this，所以应该使用下面的表达式：new Object(){}.getClass().getEnclosingClass(),在这里，new Object(){} 会建立Object的一个匿名子类的匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类 静态内部类 有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象。为此，可以为内部类加上static关键字声明为静态内部类，以便取消产生的引用。静态内部类中的方法不能直接调用外部类的非静态成员属性和访问非静态方法，如果要调用和访问，必须实例化外部类对象。当静态内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是静态内部类的成员。如果要访问外部类的非静态同名成员，不能再使用外部类.this.成员的形式，而是要实例化外部类对象。如果要访问外部类的静态同名成员，可以通过外部类.成员的方式来访问。与常规内部类不同，静态内部类可以有静态变量和静态方法。可以通过外部类.内部类.静态成员方式来访问。 下面是一个使用静态内部类的典型例子。考虑一下计算一个数组中最大值和最小值的问题，当然，可以编写两个方法，一个计算最大值，一个计算最小值，在调用这两个方法的时候，数组被遍历两次，而如果数组只被遍历一次就可以计算出最大值和最小值，那么效率就大大提高了。通过一个方法就计算出最大值和最小值：这个方法需要返回两个数（max 和 min），为此可以定义一个Pair类来封装这种数据结构，但是Pair是个非常大众的名字，可能在其他地方定义过，会发生名字冲突，此时可以将Pair定义为ArrayAlg类的内部类ArrayAlg.Pair。又因为Pair没有必要访问外围类ArrayAlg的数据域或方法，应该定义为静态内部类。 下面给出代码： 12345678910111213141516171819202122232425262728293031323334353637383940 public class ArrayAlg&#123; //Pair类，起数据封装的作用 public static class Pair&#123; private double first; private double second; public Pair(double f, double s)&#123; first = f; second = s; &#125; public double getFirst()&#123; return first; &#125; public double getSecond()&#123; return second; &#125; &#125; public static Pair maxmin(double[] values)&#123; double min = Double.POSITIVE_INFNITY; double max = Double.NEGATIVE_INFNITY; for(double x : values)&#123; if(x&lt;min) min = x; if(x&gt;max) max = x; &#125; return new Pair(max,min); &#125; public static void main(String[] args)&#123; Test te = new Test(); double[] teArgs = new double[]&#123;2.13,100.0,11.2,34.5,67.1,88.9&#125;; Pair res = te.maxmin(teArgs); System.out.println("max = "+res.getFirst()); System.out.println("min = "+res.getSecond()); &#125;&#125; 特别注意：代码中的Pair类如果没有声明为static，就不能在静态方法minmax中构造Pair的实例，编译器会给出错误报告：没有可用的隐式ArrayAlg类型对象初始化内部类对象 lambda表达式 lambda表达式可以被看作使用精简语法的匿名内部类，编译器对待一个lambda表达式如同它是从一个匿名内部类创建的对象。它是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda表达式，可以用一种精简的方式表示使用回调或变量行为的代码。如果要编译器理解lambda表达式，其代替的匿名内部类实现的接口必须只包含一个抽象方法，这样的接口被称为函数式接口(功能接口、单抽象方法接口）。在底层，接受lambda表达式的方法会接受实现某函数式接口的类的对象，并在这个对象上调用接口的方法，所以可以把lambda表达式赋给函数式接口(lambda表达式实际是一个实现了该函数式接口的类的类型，这里用到了多态)，不能把lambda表达式赋给Object变量，因为Object不是一个函数式接口。 一个lambda表达式就是一个代码块，以及必须传入代码的变量规范。其基础语法是(expression只有一条语句，不用花括号，也不用分号结尾) 1(type1 param1, type2 param2, ...) -&gt; expression 或者(statements是多条语句，要花括号，每条语句之后要分号结尾) 1(type1 param1, type2 param2, ...) -&gt; &#123;statements;&#125; 一个参数的数据类型既可以显式声明，也可以由编译器隐式推断。如果只有一个参数，并且没有显式的数据类型，圆括号可以被省略。如： 123e -&gt; &#123;// Code for processing event e&#125; 即使lambda表达式没有参数，也要提供空括号，就像无参数方法一样： 1() -&gt; &#123;for(int i = 100;i &gt;=0 ;i--) System.out.println(i);&#125; 无需指定lambda表达式的返回类型，编译器会由上下文推断，例如： 1(String first,String second) -&gt; first.length() - second.length() 可以在需要int类型结果的上下文中使用 如果一个lambda表达式只在某些分支上返回一个值，而在另外一些分支不返回值，是不合法的。例如： 1(int x) -&gt; &#123;if(x &gt;= 0) return 1;&#125; Comparator接口是一个函数式接口，可以用lambda表达式实现自定义排序的简化： 12Arrays.sort(words,(first,second) -&gt; first.length() - second.length()); 函数式接口 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口。 如果自己设计了一个函数式接口，可以用@FunctionalInterface注解来标记这个接口，这样做有两个好处： 1.可以在你无意中增加一个非抽象方法时产生编译错误 2.javadoc页里会指出你的接口是一个函数式接口 方法引用 有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如，假设你希望只要出现一个定时器事件就打印这个事件对象，可以调用： 1Timer t = new Timer(1000,event -&gt; System.out.println(event)); 可以直接把println方法传递到Timer的构造器： 1Timer t = new Timer(1000,System.out::println); 表达式System.out::println是一个方法引用，它等价于lambda表达式x -&gt; System.out.println(x) 我们再看一个例子，假设要对字符串排序，而不考虑字母的大小写，可以调用Arrays.sort(strings,String::compareToIgnoreCase); 方法引用主要有三种情况： object::instanceMethod Class::staticMethod Class::instanceMethod 对于前两种情况，方法引用等价于提供方法参数的lambda表达式。比如：System.out::println等价于x -&gt; System.out.println(x)，Math::pow等价于(x,y) -&gt; Math.pow(x,y)。第三种情况的第一个参数会称成为调用方法的目标对象，其余参数成为方法参数，比如：String::compareToIgnoreCase等价于(x,y) -&gt; x.compareToIgnoreCase(y)可以在方法里使用this和super,this::equals等同于x -&gt; this.equals(x),super::greet等同于() -&gt; super.greet() 类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。 构造器引用构造器引用与方法引用类似，只不过方法名为new。例如Employee::new是Employee构造器的一个引用。至于是哪一个构造器取决于上下文，比如Function&lt;Integer,Employee&gt; func1 = Employee :: new;就相当于Function&lt;Integer,Employee&gt; func = x -&gt; new Employee(x);数组类型也有构造器引用，如int[]::new等价于lambda表达式x -&gt; new int[x] 处理lambda表达式我们之前提到，lambda表达式的重点是延迟执行，之所以希望以后再执行代码，有很多原因，如： 在一个单独的线程中运行代码 多次运行代码 在算法的恰当位置运行代码(例如，排序中的比较操作) 发生某种情况时执行代码(如，点击了一个按钮、数据到达等) 只在必要时才运行代码 下面是常用的函数式接口和基本类型的函数式接口： 下面来看一个简单的例子。假设你想要重复一个动作n次。将这个动作和重复次数传递给一个repeat方法：1repeat(10,() -&gt; System.out.println("Hello world")); 要接受这个lambda表达式，需要选择一个函数式接口。在这里，我们可以使用Runnable接口：12345public static void repeat(int n,Runnable action)&#123; for(int i = 0;i &lt; n;i++) action.run();&#125; 现在让这个例子更复杂一点，我们希望告诉这个动作它出现在那一次迭代中。为此需要选择一个合适的函数式接口，其中要包含一个方法。这个方法有一个int参数而且返回类型为void。处理int值的标准接口如下：1234public interface IntConsumer&#123; void accept(int value);&#125; 下面给出repeat方法的改进版本:1234public static void repeat(int n,IntConsumer action)&#123; for(int i = 0;i &lt; n;i++) action.accept(i);&#125; 可以如下调用它：1repeat(10,i -&gt; System.out.println("Countdown: " + (9 - i))); 大多数函数标准函数式接口都提供了非抽象方法来生成或合并函数。例如,Predicate.isEqual(a)等同于a::equals,不过如果a为null也能正常工作。已经提供了默认方法and、or和negate来合并谓词。例如,Predicate.isEqual(a).or(Predicate.isEqual(b))就等同于x -&gt; a.equals(x) || b.equals(x) 通过三种方式实现事件处理器1.内部类 12345678910111213141516171819202122232425262728293031323334353637383940 public class HandleEvent extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; HBox pane = new HBox(10); pane.setAlignment(Pos.CENTER); Button btOK = new Button("OK"); OKHandlerClass handler1 = new OKHandlerClass(); btOK.setOnAction(handler1); Button btCancel = new Button("Cancel"); CancelHandlerClass handler2 = new CancelHandlerClass(); btCancel.setOnAction(handler2); pane.getChildren().addAll(btOK,btCancel); Scene scene = new Scene(pane,100,50); primaryStage.setTitle("HandleEvent"); primaryStage.setScene(scene); primaryStage.show(); &#125; class OKHandlerClass implements EventHandler&lt;ActionEvent&gt;&#123; @Override public void handle(ActionEvent e) &#123; System.out.println("OK button clicked"); &#125; &#125; class CancelHandlerClass implements EventHandler&lt;ActionEvent&gt;&#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Cancel button clicked"); &#125; &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; 2.匿名内部类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class AnonymousHandlerDemo extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; HBox hBox = new HBox(); hBox.setSpacing(10); hBox.setAlignment(Pos.CENTER); Button btNew = new Button("New"); Button btOpen = new Button("Open"); Button btSave= new Button("Save"); Button btPrint = new Button("Print"); hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint); btNew.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process New"); &#125; &#125;); btOpen.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process Open"); &#125; &#125;); btSave.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process Save"); &#125; &#125;); btPrint.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process Print"); &#125; &#125;); Scene scene = new Scene(hBox,300,50); primaryStage.setTitle("AnonymousHandlerDemo"); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; 3.lambda表达式 123456789101112131415161718192021222324252627282930313233343536373839404142 import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class LambdaHandlerDemo extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; HBox hBox = new HBox(); hBox.setSpacing(10); hBox.setAlignment(Pos.CENTER); Button btNew = new Button("New"); Button btOpen = new Button("Open"); Button btSave= new Button("Save"); Button btPrint = new Button("Print"); hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint); btNew.setOnAction((ActionEvent e)-&gt;&#123;System.out.println("Process New");&#125;); btOpen.setOnAction((e)-&gt;&#123;System.out.println("Process Open");&#125;); btSave.setOnAction(e-&gt;&#123;System.out.println("Process Save");&#125;); btPrint.setOnAction(e-&gt;System.out.println("Process Print")); Scene scene = new Scene(hBox,300,50); primaryStage.setTitle("LambdaHandlerDemo"); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之反射]]></title>
    <url>%2F2017%2F10%2F14%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。 1.什么是反射？ 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制，在编写一些通用性较高的代码或者框架的时候使用。也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。 要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。 2.反射的作用 1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制 2.在运行时分析对象的数据域 3.实现通用的数组操作代码 4.利用Method对象，这个对象很像C++中的函数指针 3.Class类 我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。Class 类的实例表示正在运行的 Java 应用程序中的类或接口。在 Java 中，每个 Class 都有一个相应的 Class 对象，即对于每一个类，.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，用于表示这个类的类型信息，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是java.lang.Class类的一个实例，从中我们可以得出结论：万物皆对象，任何类型(包括基本类型，引用类型，void关键字等).class都是java.lang.Class的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于java.lang.Class类不存在公有构造器，它在每个类第一次被加载时由JVM自动调用，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。 在下面的讲解中，我们将以People类和Student类为例：1234567891011121314151617181920212223242526272829public class People &#123; private String name; private int age; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println(getName() + " " + getAge()); &#125;&#125; 123456789101112131415161718192021222324public class Student extends People &#123; private int grade; public Student(String name, int age) &#123; super(name, age); &#125; public Student(String name, int age, int grade) &#123; super(name, age); this.grade = grade; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; private void learn(String course) &#123; System.out.println(name + " learn " + course); &#125; &#125; 获取class对象有以下三种: 1) 可以通过类名.class得到相应类的Class对象，如: 1Class peopleClass = People.class; 2) 如果已知类的全限定名称(包含包名)，可以通过Class的forName静态方法得到类的Class对象，如： 12Class peopleClass = Class.forName("cn.habitdiary.People");//假设People类在cn.habitdiary包中 在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如: 1234567try&#123; String name = "xxx"; Class c1 = Class.forName(name); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; 3) 可以通过类的实例对象.getClass()得到相应类的Class对象，如: 12People people = new People("Steven"， 20);Class peopleClass = people.getClass(); 实例对象.getClass().getName() 可以获取当前对象的类的全限定名称(包含包名) 实例对象.getClass().getSimpleName()可以获取当前对象的类的底层类简称(不含包名) 实例对象.getClass().getCanonicalName()大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。 但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName() 对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的 Class 实例 三种方式的比较：1.调用Class.forName()方法，如果类没有加载就加载，加载时执行static语句，找不到就抛出异常，也可以理解为手动加载类的一种方法，它会自动初始化Class对象。 2.getClass()方法，在已经持有该类的对象时来获取Class引用。其Class对象已经被初始化。 3..class方式创建Class对象引用时，不会自动初始化Class对象。主要进行下面的步骤：1)加载，类加载器查找字节码（classpath）创建Class对象；2)链接，为静态域分配存储空间；3)初始化，其被延迟到静态方法或非常数静态域首次引用时。 总结：Java获得Class对象的引用的方法中，Class.forName()方法会自动初始化Class对象，而.class方法不会，.class的初始化被延迟到静态方法或非常数静态域的首次引用。 注意： 1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象。 2.Class类实际上是一个泛型类。 Class c = T.class实际上是Class&lt;T&gt; c = T.class。Class c = x.getClass()实际上是Class&lt;? extends T&gt; c = x.getClass()(T的x的声明类型，x.getClass()获得的是x的实际类型的Class对象)。但有时候我们不能提前确定class对象的类型,如Class c = Class.forName(&quot;T&quot;)实际上是Class&lt;?&gt; c = Class.forName(&quot;T&quot;)。 3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作，这可以用来判断两个对象属不属于同一个类。 4.getClass()方法返回的是对象实际类型的class对象，而不是声明类型的class对象。 5.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，前提要有无参的构造方法，newInstance()方法是通过调用无参构造方法来创建对象的。比如: 12String s = "java.util.Random";Object m = Class.forName(s).newInstance(); 如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。 类的静态加载和动态加载静态加载：在编译时就需要加载所有可能用到的类，比如new关键字就是静态加载类。动态加载：在运行时加载类。静态加载类的缺点是：比如用new创建了多个类的对象，其中某一个类不存在，则整个程序无法通过编译。而如果动态加载类，只要不使用不存在的类，其他类还可以正常使用。 比如123456789101112class Office&#123; public static void main(String[] args)&#123; //静态加载类 if("Word".equals(args[0]))&#123; Word w = new Word(); w.start(); &#125; if("Excel".equals(args[0])&#123; Excel e = new Excel(); e.start(); &#125; &#125; 上面的程序通过new关键字创建对象，是静态加载类，所以如果Word类和Excel类中缺少一个，另一个类即使存在也无法通过编译。 如果通过反射动态加载类可以解决这个问题，如下：1234567891011121314class OfficeBetter&#123; public static void main(String[] args)&#123; try&#123; //动态加载类,在运行时刻加载 Class c = Class.forName(args[0]); /*通过类类型,创建该类的对象,此时需要强制转换为Excel和Word的公有类型， 所以可以定义OfficeAble接口，让Excel和Word实现这个接口*/ OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; 由于是动态加载类，新增其他实现OfficeAble接口的类不必重新编译OfficeBetter类。 4.在运行时分析类的能力 下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。Java中为了支持反射机制主要提供了以下的类：java.lang.Classjava.lang.reflect.Fieldjava.lang.reflect.Constructorjava.lang.reflect.Methodjava.lang.reflect.Modifier java.lang.Class类的常用API如下： Field[] getFields() Field[] getDeclaredFields() Method[] getMethods() Method[] getDeclaredMethods() Constructor&lt; ? &gt;[] getConstructors() Constructor&lt; ? &gt;[] getDeclaredConstructors() Class&lt; ? &gt; getSupperClass() Class&lt; ? &gt;[] getInterfaces() 提示：getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，不论访问权限，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象 其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。这三个类的常用API如下： String getName() 返回一个用于描述域名、构造器或方法的字符串 Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象 Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)返回一个用于描述方法抛出异常类型的Class对象数组 int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值 Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组 Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象 java.lang.reflect.Modifier类的常用API如下 static String toString(int modifiers)返回修饰符对应的字符串描述 static boolean isAbstract(int modifiers) static boolean isFinal(int modifiers) static boolean isInterface(int modifiers) static boolean isNative(int modifiers) static boolean isPrivate(int modifiers) static boolean isProtected(int modifiers) static boolean isPublic(int modifiers) static boolean isStatic(int modifiers) static boolean isStrict(int modifiers) static boolean isSynchronized(int modifiers) static boolean isVolatile(int modifiers)上述方法检测修饰符是否是某一特定修饰符java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义 下面是一个检测类内部结构的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.lang.reflect.*;import java.lang.Class;import java.util.Scanner;public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if(args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date)"); name = in.next(); &#125; try &#123; Class&lt;?&gt; c1 = Class.forName(name); Class&lt;?&gt; superc1 = c1.getSuperclass(); String modifiers = Modifier.toString(c1.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " " ); System.out.print("class " + name); if(superc1 != null &amp;&amp; superc1 != Object.class) System.out.print(" extends " + superc1.getSimpleName()); System.out.print("\n&#123;\n"); printFields(c1); System.out.println(); printConstructors(c1); System.out.println(); printMethods(c1); System.out.println("&#125;"); &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class&lt;?&gt; c1) &#123; Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors(); for(Constructor&lt;?&gt; c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class&lt;?&gt;[] paramTypes = c.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class&lt;?&gt; c1) &#123; Method[] methods = c1.getDeclaredMethods(); for(Method m :methods) &#123; Class&lt;?&gt; retType = m.getReturnType(); String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getSimpleName() + " " + name + "("); Class&lt;?&gt;[] paramTypes = m.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class&lt;?&gt; c1) &#123; Field[] Fields = c1.getDeclaredFields(); for(Field f : Fields) &#123; Class&lt;?&gt; type = f.getType(); String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getSimpleName() + " " + name + ";"); &#125; &#125;&#125; 5.在运行时使用反射分析对象 反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。 查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如： 12345Employee harry = new Empolyee("Harry Hacker",35000,10,1,1989);Class&lt;Employee&gt; c1 = harry.getClass();Field f = c1.getDeclaredField("name"); //返回某一个特定域f.setAccessible(true); //由于name是私有域，必须先设置为可访问Object v = f.get(harry); 上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value 下面是一些相关API在java.lang.reflect.Field中： Object get(Object obj)返回obj对象中用Field对象表示的域值 xxx getXxx(Object obj)返回obj对象的基本类型的域的值 void set(Object obj,Object newValue)用一个新值设置obj对象中Field对象表示的域 在java.lang.Class中： Field getField(String name)返回指定名称的公有域 Field getDeclaredField(String name) 返回指定名称的声明的域 在java.lang.reflect.AccessibleObject中： void setAccessible(boolean flag)为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置 boolean isAccessible()返回反射对象的可访问标志的值 static void setAccessible(AccessibleObject[] array,boolean flag)批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 6.使用反射编写泛型数组代码 java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。12Employee[] a = new Employee[100];a = Arrays.copyOf(a,2 * a.length); 我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试:12345public static Object[] badCopyOf(Object[] a,int newLength)&#123; Object[] newArray = new Object[newLength]; System.arraycopy(a,0,newArray,0,Math.min(a.length,newLength); return newArray;&#125; 上述代码存在一个错误，即使用了new Object[newLength]创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。为了解决这个问题，下面提供java.lang.reflect.Array中的API static Object get(Object array,int index)返回对象数组某个位置上的元素 static xxx getXxx(Object array,int index)(xxx是基本数据类型)返回基本类型数组某个位置上的值 static void set(Object array,int index,Object newValue)设置对象数组某个位置上的元素 static void setXxx(Object array,int index,xxx newValue)(xxx是基本数据类型)设置基本类型数组某个位置上的值 static int getLength(Object array)返回数组的长度 static Object newInstance(Class componentType,int length) static Object newInstance(Class componentType,int[] length)返回一个具有给定类型、给定维数的新数组 下面给出正确的代码实现： 1234567891011public static Object goodCopyOf(Object a,int newLength)&#123;&#123; Class c1 = a.getClass();//获取a数组的类对象 if(!c1.isArray()) return null;//确认是一个数组 Class componentType = c1.getComponentType(); //获取数组类型 int length = Array.getLength(a); Object newArray = Array.newInstance(componentType,newLength); System.arraycopy(a,0,newArray,0,Math.min(length,newLength)); return newArray; &#125; 这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例: 12int[] a = &#123;1,2,3,4,5&#125;;a = (int[]) goodCopyOf(a,10); 为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型 7.调用任意方法 通过反射还可以调用任意方法，这是通过Method类的invoke方法实现的，方法签名是:Object invoke(Object obj,Object... args),Object obj表示调用方法的对象，Object…args表示方法的参数列表。如果方法是静态方法，将第一个参数设置为null;如果方法是非静态无参方法，第二个参数列表可以忽略。 例如：String n = (String)m1.invoke(harry);(m1表示Employee类的getName方法)。如果方法m1的返回值是void，则invoke方法返回null，否则返回具体类型。如果返回值是基本类型，invoke方法会返回其包装器类型,可以利用自动开箱将其还原为基本数据类型。例如:double s = (Double)m2.invoke(harry);(m2表示Employee类的getSalary方法)getMethods方法和getDeclaredMethods会返回一个Method对象列表，如果要得到特定的Method对象，可以调用Class类的getMethod方法，其签名是Method getMethod(String Methodname,Class…parameterTypes)。例如： 12Method m1 = Employee.class.getMethod("getName"); Method m2 = Employee.class.getMethod("raiseSalary",double.class); 下面给出一个调用任意方法打印函数表的程序(以自定义的square和Math.sqrt方法为例)： 12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.*;public class MethodTableTest&#123; public static void main(String[] args) &#123;Method square = MethodTableTest.class.getMethod("square",double.class); Method sqrt = Math.class.getMethod("sqrt",double.class); printTable(1,10,10,square); printTable(1,10,10,sqrt); &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from,double to,int n,Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for(double x = from;x &lt;= to;x += dx) &#123; try &#123; double y = (Double)f.invoke(null,x); System.out.printf("%10.4f | %10/4f\n",x,y); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; invoke方法如果提供了错误的参数，会抛出一个异常，所以要提供一个异常处理器 建议在有必要的时候才使用invoke方法，有如下原因: 1.invoke方法的参数和返回值必须是Object类型，意味着必须进行多次类型转换，这样会使编译器错过检查代码的机会，等到测试阶段才发现错误，找到并改正会更加困难 2.通过反射调用方法比直接调用方法要明显慢一些 特别重申：建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的执行速度更快，更易于维护。 8.通过反射了解泛型本质来看下面一段代码：123456ArrayList list = new ArrayList();ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;();Class c1 = list.getClass();Class c2 = list1.getClass();System.out.println(c1 == c2); //true/*反射的操作都是编译之后的操作，编译之后会发生类型擦除，即ArrayList&lt;String&gt;被擦除为ArrayList，所以c1 == c2结果为true*/ Java中集合的泛型，是防止错误输入的，只在编译阶段有效，编译之后就会发生类型擦除，所以绕过编译泛型就无效了 验证：我们可以通过方法的反射来操作，绕过编译12345678try &#123;Method m = c2.getMethod("add", Object.class);m.invoke(list1, 20);//绕过编译操作就绕过了泛型System.out.println(list1.size());System.out.println(list1);&#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 推荐博客： Java核心技术点之反射 深入理解Java反射 Java中的反射机制 Java反射教程 Java反射详解]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之继承和多态]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[父类与子类在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。 继承面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。 继承有如下几个关键点1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们3.不是所有的“是一种”(is-a)关系都该用继承来建模4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承5.Java中类与类的继承是单一继承 super关键字super关键字有两种作用：1.调用父类的构造方法因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。形式是super()或super(arguments)，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条super()有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。 2.调用父类的方法在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用super.方法名来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，super.super.方法名是不合法的。 构造方法链在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码：12345678910111213141516171819202122public class Faculty extends Employee&#123; public static void main(String[] args)&#123; new Faculty(); &#125; public Faculty()&#123; System.out.println("(4) Performs Faculty's tasks"); &#125; &#125;class Employee extends Person&#123; public Employee()&#123; this("(2) Invoke Employee's overloaded constructor"); System.out.println("(3) Perfoms Employee's tasks"); &#125; public Employee(String s)&#123; System.out.println(s); &#125; &#125; class Person&#123; public Person() &#123; System.out.println("(1) Performs Person's tasks"); &#125; &#125; 打印结果为:(1) Performs Person’s tasks(2) Invoke Employee’s overloaded constructor(3) Performs Employee’s tasks(4) Performs Faculty’s tasks 我们可以知道：子类的构造方法的第一条语句要么是super语句(包括编译器隐式插入的),要么是this语句，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类 注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。 方法重载与重写重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型和访问修饰符可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同) 重写方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。为了避免错误，可以使用重写注解，在要重写的方法前加上@Override，该注解会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。 关于重写的几点注意1.仅当实例方法是可访问的，它才能被覆盖2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法3.尽管重写一般用于方法，属性其实也可以重写，即子类可以定义和父类同名的属性，子类的属性会覆盖父类的属性。 方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。 多态Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。 动态绑定多态机制的底层实现技术是动态绑定，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。 对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。 静态绑定(前期绑定)：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。 动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。 简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。 理解方法调用假设下面要调用x.f(args)，方法调用的过程为：1） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(int)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。2） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。3） 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为private方法、构造器不能被继承，更谈不上重写，而static方法和final方法虽然能被继承，但不能被重写。4) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。 每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。方法表示例(Manager继承自Employee)： Employee:getName() -&gt; Employee.getName()getSalary() -&gt; Employee.getSalary()getHireDay() -&gt; Employee.getHireDay()raiseSalary(double) -&gt; Employee.raiseSalary(double) Manager:getName() -&gt; Employee.getName()//继承的方法getSalary() -&gt; Manager.getSalary()//重写的方法getHireDay() -&gt; Employee.getHireDay()//继承的方法raiseSalary(double) -&gt; Employee.raiseSalary(double)//继承的方法setBonus(double) -&gt; Manager.setBonus(double)//新增的方法 内联优化带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联优化所有的final方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高50%。如果确定一个类不会被派生或一个方法不会被重写，建议使用final关键字修饰。 对象类型转换和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。我们可以通过instanceof运算符来检测一个对象是否是某个类或接口的实例，其返回值是boolean类型的。注意:1.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();2.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。 Object类Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出public class xxx extends Object,在Java中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。下面介绍Object类中的几个重要方法及重写规范： 1) equals方法Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。 equals方法的原型是public boolean equals(Object obj),默认实现是:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public boolean equals(Object obj)&#123; return (this == obj);&#125;``` 调用它的语法是`object1.equals(object2)`，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。 比如类Employee定义了数据域：private String name,private double salary,private LocalDate hireDay equals方法重写如下： ```java public boolean equals(Object obj)&#123; if(this == obj) return true; //快速检测引用是否相等，相等返回ture if(obj == null) return false; //检测引用是否为空，为空返回false if(getClass() != obj.getClass()) return false; //检测是否属于同一个类，不是返回false Empolyee other = (Employee) obj;//向下转型 return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); //逐一比较数据域,有一个不等返回就false，否则返回true``` **进一步改进：** *改进一* 上述的第4步检测，可以改为 ```javareturn Objects.equals(name,other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay,other.hireDay);``` 其中Objects.equals方法可以防备name 或 hireDay 可能为null的情况，如果两个参数都为null，Objects(a,b)返回true;如果其中一个为null，返回false;如果两个参数都不为null,调用a.equals(b)。Objects类在java.util包中。 在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。 比如Manager类继承自Employee，在父类的基础上增加了private double bonus： ```java public boolean equals(Object obj)&#123; if(!super.equals(obj)) return false; Manager other = (Manager) obj; return bonus == other.bonus; &#125;``` *改进二* 上述代码的第3步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用instanceof进行检测，比如雇员的ID作为相等的概念，就可以用xxx instanceof Employee进行检测，并将Empolyee.equals声明为final。 **equals方法要满足下面的特性** 1. 自反性: 对于任何非空引用，x.equals(x)应该返回true 2. 对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同 3. 传递性：对于任何引用x、y和z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true 4. 一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果 5. 对于任何非空引用x,x.equals(null)应该返回false**下面我们给出编写一个完美的equals方法的建议**： 1) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测 2) 检测引用是否为空，如果为空，不必再检测，直接返回不等 3) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:`if(getClass() != obj.getClass()) return false`;如果所有子类都拥有统一的语义(父类决定相等)，就使用instanceof检测：`if(!(obj instanceof ClassName) return false)` 4) 将obj向下转型为相应类的类型变量 5) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测 **数组对象用静态的Arrays.equals方法判等**拓展：[Integer判断相等，到底该用==还是equals](http://www.jianshu.com/p/9cb9c61b0986) 当我们在方法里调用equals方法时，建议写字符串常量.equals(参数)的形式。比如： ```javapublic static boolean function(String str)&#123; return "hello world".equals(str);&#125; 这样可以防止str为null而抛出空指针异常，而根据equals()方法的对称性，这种调换并不会影响方法的功能。 2) hashCode方法散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。String类使用下列算法计算散列码： int hash = 0; for(int i = 0;i &lt; length();i++){ hash = 31 * hash + charAt(i); } 由于hashCode方法定义在Object类中，方法原型是public int hashCode(),因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。hashCode方法应该返回一个整型数值(可以是负数),并合理地组合实例域的散列码，以便能让各个不同的对象产生的散列码更均匀。例如，下面是Employee类的hashCode方法 public int hashCode(){ return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode(); 进一步改进 public int hashCode(){ return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); 从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象 还有更简单的做法 public int hashCode(){ return Objects.hash(name,salary,hireDay); } Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID 3) toString方法方法原型是public String toString(),用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：类名@对象十六进制内存地址的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似[I@1a46e30的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。 泛型数组列表在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如： int actualSize = . . .; Employee[] staff = new Employee[actualSize]; 但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。ArrayList是一个采用类型参数的泛型类,声明方式为ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;(),从Java SE 7开始，可以省去右边的类型参数，即ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于ArrayList&lt;Object&gt;,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。 ArrayList类的常用API ArrayList&lt;E&gt;() 构造一个初始容量为10的空列表 ArrayList&lt;E&gt;(int initialCapacity)构造一个具有指定初始容量的空列表 boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true void add(int index, E element) 将指定的元素插入此列表中的指定位置。 int size() 返回此列表中的元素数。 void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。 E get(int index) 返回此列表中指定位置上的元素。 E remove(int index) 移除此列表中指定位置上的元素并返回该元素。 boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。 void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。 boolean isEmpty() 如果此列表中没有元素，则返回 true boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。 void clear() 移除此列表中的所有元素。 Object clone() 返回此 ArrayList 实例的浅表副本。 trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。 对于数组列表有用的方法1.数组和ArrayList互相转换 数组转ArrayList: String[] array = {"red","green","blue"}; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array)); ArrayList转数组: String[] array = new String[list.size()]; list.toArray(array); 2.Collections类Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。 ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。 final关键字总结final关键字在不同语句中有不同的作用：1) 修饰类变量或成员变量 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。只能在定义时、构造方法中或构造代码块中赋值。2）修饰方法的局部变量，即常量 final修饰的局部变量只要在使用前被赋值即可，不要求在定义时即赋值，但赋值后不可改变。3) 修饰方法 表示该方法不能被重写，注意final不能修饰构造方法。4) 修饰类 表示该类不能被扩展 继承的设计技巧1.将公共操作和域放在超类2.不要使用受保护的域protected机制并不能够带来更好的保护，其原因主要有两点:第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的 3.使用继承实现 “is-a” 关系4.除非所有继承的方法都有意义，否则不要使用继承比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。 5.在覆盖方法时，不要改变预期的行为6.使用多态，而非类型信息即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为 7.不要过多地使用反射反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之对象与类]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[面向对象程序设计概述 面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。 传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。 对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。 类和对象 类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。 对象：由类构造的实例，一个类可以构造多个实例。 设计类的简单规则 先从设计类的数据域开始，再向类里添加方法。 类之间的关系1.依赖(Dependence) 假设A类的变化引起了B类的变化，则B类依赖于A类。依赖关系(Dependency) 是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。 在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 12345678910111213141516public class Driver &#123; public void drive(Car car) &#123; car.move(); &#125; …… &#125; public class Car &#123; public void move() &#123; ...... &#125; …… &#125; 依赖关系有如下三种情况： 1、A类是B类中某方法的局部变量； 2、A类是B类方法当中的一个参数； 3、A类向B类发送消息，从而影响B类发生变化； 2.泛化(Generalization) A是B和C的父类，B,C具有公共类（父类）A，说明A是B,C的一般化(也称泛化)。 泛化关系就是继承关系。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 123456789101112131415161718192021public class Person &#123; protected String name; protected int age; public void move() &#123; …… &#125; public void say() &#123; …… &#125; &#125; public class Student extends Person &#123; private String studentNo; public void study() &#123; …… &#125; &#125; 在UML当中，对泛化关系有三个要求： 1、子类与父类应该完全一致，父类所具有的属性、操作，子类应该都有 2、子类中除了与父类一致的信息以外，还包括额外的信息 3、可以使用父类的实例的地方，也可以使用子类的实例 3.关联(Association) 类之间的联系，如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单，再如篮球队员与球队之间的关联（下图所示）。 其中，关联两边的”employee”和“employer”标示了两者之间的关系，而数字表示两者的关系的限制，是关联两者之间的多重性。通常有“*”（表示所有，不限），“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”(表示n到m个都可以)，“m…*”（表示至少m个）。 关联关系(Association) 是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系。在UML类图中，用实线连接有关联的对象所对应的类，在使用Java、C#和C++等编程语言实现关联关系时，通常将一个类的对象作为另一个类的属性。在使用类图表示关联关系时可以在关联线上标注角色名。 双向关联: 默认情况下，关联是双向的。 12345678910public class Customer &#123; private Product[] products; …… &#125; public class Product &#123; private Customer customer; …… &#125; 单向关联: 类的关联关系也可以是单向的，单向关联用带箭头的实线表示。12345678910public class Customer &#123; private Address address; …… &#125; public class Address &#123; …… &#125; 自关联: 在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。 12345public class Node &#123; private Node subNode; …… &#125; 重数性关联: 重数性关联关系又称为多重性关联关系(Multiplicity)，表示一个类的对象与另一个类的对象连接的个数。在UML中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类的对象的个数。 123456789public class Form &#123; private Button buttons[]; …… &#125; public class Button &#123; … &#125; 4.聚合(Aggregation) 表示的是整体和部分的关系，整体与部分可以分开。聚合关系(Aggregation) 表示一个整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合关系。在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。 123456789101112131415161718public class Car &#123; private Engine engine; public Car(Engine engine) &#123; this.engine = engine; &#125; public void setEngine(Engine engine) &#123; this.engine = engine; &#125; …… &#125; public class Engine &#123; …… &#125; 如：电话机包括一个话筒;电脑包括键盘、显示器，一台电脑可以和多个键盘、多个显示器搭配，确定键盘和显示器是可以和主机分开的，主机可以选择其他的键盘、显示器组成电脑。 5.组合(Composition) 也是整体与部分的关系，但是整体与部分不可以分开。组合关系(Composition)也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。 1234567891011121314public class Head &#123; private Mouth mouth; public Head() &#123; mouth = new Mouth(); &#125; …… &#125; public class Mouth &#123; …… &#125; 如：公司和部门，部门是部分，公司是整体，公司A的财务部不可能和公司B的财务部对换，就是说，公司A不能和自己的财务部分开;人与人的心脏。 6.实现(Implementation) 实现是用来规定接口和实线接口的类或者构建结构的关系，接口是操作的集合，而这些操作就用于规定类或者构建的一种服务。 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所 声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。 123456789101112131415161718public interface Vehicle &#123; public void move(); &#125; public class Ship implements Vehicle &#123; public void move() &#123; …… &#125; &#125; public class Car implements Vehicle &#123; public void move() &#123; …… &#125; &#125; 对象与对象变量 对象是调用构造方法在堆上分配内存产生的(用new + 构造方法来调用)，而对象变量是在栈上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上创建了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。 存储区域1.创建的实例及成员变量（静、非静态）在堆中2.局部变量在栈中3.类的基本信息和方法定义在方法区 UML类图相关知识见http://www.uml.org.cn/oobject/201211231.asp 构造器 构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。 构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，因为它是用来创建实例的，所以它永远是实例方法，不能被static修饰。 构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。 建议在构造方法中调用各属性的set方法来初始化属性，而不是给属性直接赋值，这样set方法的合法性检查也会应用于构造方法。 在eclipse的source菜单里有添加构造器的快捷选项。 访问对象的数据和方法 在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。 引用数据域和null值 如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。 默认赋值规则 类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。 基本变量和引用变量的区别 基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。 没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。 静态/非静态变量、常量和静态/非静态方法静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。不要从构造器中传入参数来初始化静态域，最好使用set方法改变静态数据域。非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。非静态方法：又称实例方法，是依赖于具体对象的方法。关系：静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。在同一个类中： 对于静态方法，其他的静态或非静态方法都可以直接调用它。而对于非静态方法，其他的非静态方法是可以直接调用它的。但是其他静态方法只有通过创建对象才能调用它。 工厂方法静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：12345NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.gerPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x));// prints $0.10System.out.println(percentFormatter.format(x));//prints 10% 使用静态工厂方法的原因主要有两个：1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类 可见性修饰符public修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public protected修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问 default缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。 privateprivate成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。 注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。 包包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句package + 包名，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。 类的导入精确导入：导入某个包的特定类,如import java.util.Scanner通配导入：导入某个包的所有类,如import java.util.*编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类。静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如import static java.lang.System.*导入了System类的静态方法和静态域，就可以不加类名前缀:out.println(&quot;Hello world!&quot;)，out是System类里定义的静态成员，是PrintStream的实例。注意：1、在要使用某个类时可以不导入，但要采用包名.类名的方式使用这个类。2、不可以使用精确导入导入两个包中的同名类，此时应该一个类精确导入，另一个类通配导入。程序默认使用的类是精确导入的类，如果要使用通配导入的同名类，要使用包名.类名的方式。3、使用通配导入的时候不能跨级导入，比如在cn.habitdiary.core包中的类只能通过cn.habitdiary.core.*来导入，而不能通过cn.habitdiary.*来导入。 数据域封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。实现封装的步骤：1.用private可见性修饰符修饰类成员2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue)eclipse的source里有添加getter和setter方法的快捷选项。 向方法传递对象参数可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。 对象数组和普通数组所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。 不可变对象和类一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。一个类是不可变类要满足以下三个条件：1.所有的数据域都是私有的2.没有修改器方法3.没有一个返回指向可变数据域引用的访问器方法 变量作用域一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如1234public class F&#123; private int j = i + 1; private int i;&#125; 就是错误的，因为j的初始化基于i已经被初始化的前提。 局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。 建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。 this引用this关键字有两大作用：1.表示指向调用对象本身的引用名2.可以在构造方法内部调用同一个类的其他构造方法，此时this(参数列表)语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用this(参数列表)的形式来实现它们。这样做可以简化代码，使类易于维护。 对象构造默认域初始化即依赖编译器对数据域的默认初始化。 显式域初始化在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。 无参数的构造器即将对数据域的初始化置于一个无参的构造器中。 有参数的构造器即给构造器传入参数对数据域进行初始化 初始化块在方法内的代码块称为普通代码块，就是一组用花括号括起来的语句，没有特殊含义。而如果用花括号包含的一组数据域赋值代码块出现在类内，就称为初始化块或构造代码块。初始化块一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块，不允许在静态初始化块内初始化实例成员。 成员初始化顺序1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行(classLoader的类加载过程)。2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行(classLoader类加载过程)。3.父类的实例成员、实例初始化块、构造方法，按在代码中出现的顺序依次执行。4.子类实例成员、实例初始化块、构造方法，按在代码中出现的顺序依次执行。 注意：静态成员和静态初始化块只在该类被加载的时候初始化一次，可以看作初始化类。注意是被加载就初始化，不一定要构造对象。且静态成员和静态初始化块的初始化出现在main方法之前。 比如下面这个例子,有CodeBlock.java和Code.java两个文件。12345678910111213141516171819202122232425262728//CodeBlock.javapublic class CodeBlock&#123; // 创建CodeBlock的构造块 &#123; System.out.println("CodeBlock的构造块"); &#125; //创建CodeBlock的静态代码块 static&#123; System.out.println("CodeBlock的静态代码块"); &#125; //创建CodeBlock的构造方法 public CodeBlock()&#123; System.out.println("CodeBlock的构造方法"); &#125; public static void main(String[] args)&#123; System.out.println("CodeBlock的主方法"); System.out.println("产生Code类实例对象"); Code c = new Code(); System.out.println("产生CodeBlock类实例对象"); CodeBlock cb = new CodeBlock(); &#125;&#125; 123456789101112131415161718//Code.javaclass Code&#123; //创建外部类Code构造块（构造块） &#123; System.out.println("Code的构造块"); &#125; //创建外部类Code静态代码块（静态代码块） static&#123; System.out.println("Code的静态代码块"); &#125; //创建外部类Code构造方法（构造方法） public Code()&#123; System.out.println("Code的构造方法"); &#125;&#125; 运行结果如下： 文档注释JDK 包含一个很有用的工具 , 叫做 javadoc , 它可以由源文件生成一个 HTML 文档 。我们平时查阅的API就是这样形成的，而且添加文档注释后，eclipse也会对添加了文档注释的方法等给出智能提示。 注释的插入javadoc 实用程序 ( utility ) 从下面几个特性中抽取信息： 包 公有类与接口 公有的和受保护的构造器及方法 公有的和受保护的域 应该为上面几部分编写注释。注释应该放置在所描述特性的前面 。注释以 /** 开始, 并以 */ 结束 。插入文档注释的方法是输入/**后回车即可。每个 /** . . . */ 文档注释在标记之后紧跟着自由格式文本 (free-form text)。标记由@开始, 如 @ author 或 @ param 。自由格式文本的第一行或几行是关于类、变量和方法的主要描述。javadoc 实用程序自动地将这些句子抽取出来形成概要页 。在自由格式文本中, 可以使用 HTML 修饰符 , 例如 , 用于强调的 &lt;em&gt; ... &lt;/em&gt; 、用于着重强调的&lt;strong&gt; ... &lt;/strong&gt;以及包含图像的&lt; img…/&gt; 等 。 不过, 一定不要使用&lt;hl&gt;或&lt;hr&gt;,因为它们会与文档的格式产生冲突 。若要键入等宽代码, 需使用 {@code...} 而不是&lt;code&gt; ... &lt;/code&gt; ———— 这样一来 , 就不用操心对代码中的 &lt;字符转义了 。 类注释类注释必须放在 import 语句之后, 类定义之前 。下面是一个类注释的例子:没有必要在每一行的开始用星号*，例如,以下注释同样是合法的:然而,大部分IDE提供了自动添加星号*,并且当注释行改变时,自动重新排列这些星号的功能。 方法注释每一个方法注释必须放在所描述的方法之前。除了通用标记之外, 还可以使用下面的标记： @param 变量描述这个标记将对当前方法的 “param” ( 参数 ) 部分添加一个条目。这个描述可以占据多行,并可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。 @return 描述这个标记将对当前方法添加 “return” (返回 ) 部分。这个描述可以跨越多行,并可以使用 HTML 标记 。 @throws 类描述这个标记将添加一个注释,用于表示这个方法有可能抛出异常。 下面是一个方法注释的示例: 域注释只需要对公有域(通常指的是静态常量)建立文档。例如： 通用注释下面的标记可以用在类文档的注释中。 包与概述注释 注释的抽取javadoc 工具将你 Java 程序的源代码作为输入，输出一些包含你程序注释的HTML文件。每一个类的信息将在独自的HTML文件里。javadoc 也可以输出继承的树形结构和索引。 文档标签速查：菜鸟教程之Java文档注释 类设计技巧1.一定要保证数据域私有2.一定要对数据初始化最好不要依赖默认初始化，会影响程序可读性。 3.不要在类中使用过多的基本类型用其他集合了相关基本类型的类代替多个基本类型使用 4.不是所有的域都需要独立的域访问器和域修改器有的数据域定义后不必要修改 5.将职责过多的类进行分解所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变,那么这个类就具有多于一个的职责。而单一职责原则(SRP:Single responsibility principle)就是指一个类或者模块应该有且只有一个改变的原因。在软件系统中,一个类(大到模块,小到方法)承担的职责越多,它被复用的可能性就越小,而且一个类承担的职责过多,就相当于将这些职责耦合在一起,当其中一个职责变化时,可能会影响其他职责的运作,因此要将这些职责进行分离,将不同的职责封装在不同的类中,即将不同的变化原因封装在不同的类中,如果多个职责总是同时发生改变则可将它们封装在同一类中。 6.类名和方法名要能够体现它们的职责7.优先使用不可变的类更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习之区间dp]]></title>
    <url>%2F2017%2F10%2F11%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[简介区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。 算法结构设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段 For l:=2 to n do // 枚举区间长度for i:=1 to n do // 枚举区间的左端点beginj:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到if j&gt;n then break; // 保证了下标不越界for k:= i to j-1 do // 状态转移，去推出 f[i,j]f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }end; 这个结构必须记好，这是区间动态规划的代码结构。 例题石子合并题目链接:http://acm.nyist.net/JudgeOnline/problem.php?pid=737 题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。那么dp[i][j] = min(dp[i][k] + dp[k+1][j])那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2） 代码1(无优化) 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i)//枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = i; k &lt; j; ++k) &#123; dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; 代码2(平行四边形优化) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N],s[N][N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); s[i][i]=i; sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i) //枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = s[i][j-1]; k &lt;= s[i+1][j]; ++k)//四边形优化 &#123; if(dp[i][j]&gt;dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]) &#123; dp[i][j]=dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]; s[i][j]=k; &#125; &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; 括号匹配题目链接：http://poj.org/problem?id=2955 题意:给出一串的只有‘（’ ‘）’ ‘[‘ ‘]’四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。 分析：定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ;2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] ) 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;const int N = 120;int dp[N][N];int main()&#123; string s; while(cin&gt;&gt;s) &#123; if(s=="end") break; memset(dp,0,sizeof(dp)); int n = s.size(); for(int len = 2;len &lt;= n;len++)//枚举区间长度 &#123; for(int i = 0;i &lt;= n - len; i++)//枚举区间左端点 &#123; int j = i + len - 1;//确定区间右端点 if(j &gt; n) break; if(s[i]=='('&amp;&amp;s[j]==')' || s[i]=='['&amp;&amp;s[j]==']') dp[i][j]=dp[i+1][j-1]+2; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);//枚举中间位置,注意j不取等号 &#125; &#125; cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; &#125; return 0;&#125; 如果要求打印路径，即输出匹配后的括号 题目链接: http://poj.org/problem?id=1141 代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 120;int dp[N][N],pos[N][N]; /*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/string s;void show(int i,int j)&#123; if(i&gt;j) return; if(i==j) &#123; if(s[i]=='('||s[i]==')') cout&lt;&lt;"()"; else cout&lt;&lt;"[]"; &#125; else &#123; if(pos[i][j]==-1) &#123; cout&lt;&lt;s[i]; show(i+1,j-1); cout&lt;&lt;s[j]; &#125; else &#123; show(i,pos[i][j]); show(pos[i][j]+1,j); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;s) &#123; memset(dp,0,sizeof(dp)); int len=s.size(); for(int i=1; i&lt;len; i++) &#123; for(int j=0,k=i; k&lt;len; j++,k++) &#123; if(s[j]=='('&amp;&amp;s[k]==')' || s[j]=='['&amp;&amp;s[k]==']') &#123; dp[j][k]=dp[j+1][k-1]+2; pos[j][k]=-1; &#125; for(int f=j; f&lt;k; f++) &#123; if(dp[j][f]+dp[f+1][k]&gt;=dp[j][k]) &#123; dp[j][k]=dp[j][f]+dp[f+1][k]; pos[j][k]=f; &#125; &#125; &#125; &#125; show(0,len-1); cout&lt;&lt;endl; &#125; return 0;&#125; 整数划分题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=746 题意: 给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积 分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数设a[i][j]为区间[i,j]所形成的数所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i]) 代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long dp[25][25];long long a[25][25];char str[25];int main()&#123; int len, t, m; scanf("%d", &amp;t); while (t--) &#123; scanf("%s%d", str, &amp;m); len = strlen(str); m--; memset (a, 0, sizeof(a)); memset (dp, 0, sizeof(dp)); for (int i = 0; i &lt; len; i++) //先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值 &#123; a[i][i] = str[i] - '0'; for (int j = i + 1; j &lt; len; j++) &#123; a[i][j] = a[i][j - 1] * 10 + str[j] - '0'; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; dp[i][0] = a[0][i]; &#125; for (int j = 1; j &lt;= m; j++) &#123; for (int i = j; i &lt; len; i++) &#123; for (int k = 0; k &lt; i; k++) &#123; dp[i][j] = max(dp[i][j], dp[k][j - 1] * a[k + 1][i]); &#125; &#125; &#125; printf("%lld\n", dp[len - 1][m]); &#125; return 0;&#125; Halloween Costumes题目链接：http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422 题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会 分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有 ①：如果在之后的区间内都不再重复利用这件衣服，那么明显 dp[i][j] = dp[i+1][j] + 1; ②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，那么转移方程为 dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j]) 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[105];int dp[105][105];int main(void)&#123; int t; int cas = 0; scanf("%d",&amp;t); while(t--) &#123; cas ++; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) &#123; for(int j = i;j &lt;= n;j++) &#123; dp[i][j] = j-i+1; &#125; &#125; for(int i = n-1;i &gt;= 1;i--) &#123; for(int j = i+1;j &lt;= n;j++) &#123; dp[i][j] = dp[i+1][j] + 1; for(int k = i+1;k &lt;= j;k++) &#123; if(a[i] == a[k]) &#123; dp[i][j] = min(dp[i][j],dp[i][k-1] + dp[k+1][j]); &#125; &#125; &#125; &#125; printf("Case %d: %d\n",cas,dp[1][n]); &#125; return 0;&#125; Cheapest Palindrome题目链接:http://poj.org/problem?id=3280 题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。 分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况： 1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值； 2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值 3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小 然后dp[i][j]取上面这些情况的最小值 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int dp[2005][2005],add[27],del[27];char s[2005];int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)&gt;0) &#123; scanf("%s",s+1); for(int i=1;i&lt;=n;i++) &#123; char ch[10]; int tmp1,tmp2; scanf("%s%d%d",ch,&amp;tmp1,&amp;tmp2); add[ch[0]-'a'+1]=tmp1; del[ch[0]-'a'+1]=tmp2; &#125; memset(dp,0,sizeof(dp)); for(int i=m-1;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i+1][j]+add[s[i]-'a'+1],dp[i+1][j]+del[s[i]-'a'+1]); int tmp=min(dp[i][j-1]+add[s[j]-'a'+1],dp[i][j-1]+del[s[j]-'a'+1]); dp[i][j]=min(dp[i][j],tmp); if(s[i]==s[j]) dp[i][j]=min(dp[i][j],dp[i+1][j-1]); &#125; &#125; printf("%d\n",dp[1][m]); &#125; return 0;&#125; Treats for the Cows题目链接:http://poj.org/problem?id=3186 题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值 分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来转移方程：dp[i][j]=max(dp[i+1][j]+p[i](n+i-j),dp[i][j-1]+p[j](n+i-j)); 其中n-(j-i)是第几次取 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int p[2010];int dp[2010][2010];int n;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); dp[i][i]= n * p[i]; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=i;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i+1][j]+p[i]*(n+i-j),dp[i][j-1]+p[j]*(n+i-j)); &#125; printf("%d\n",dp[1][n]); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之Java基本程序设计结构]]></title>
    <url>%2F2017%2F10%2F10%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据类型Java是一种强类型语言，即意味着必须为每一个变量声明一种类型。在Java中一共有8种基本数据类型，其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真值的boolean类型。 1) 整型整型用于表示没有小数部分的值，它允许是负数，Java提供了4种整型： 在通常情况下,int类型最常用。如果要表示星球上居住的人数，就需要使用long类型了。byte和short类型用于特定的应用场合，比如底层的文件处理或者需要控制占用存储空间量的大数组。整型的直接量默认是int，即2表示int类型的2，为了表示一个long型的整型直接量，在其后追加字母L或l即可(建议使用L,以免和数字1混淆)。语句byte b = 128会造成编译错误，因为128是整型直接量且超过了byte的取值范围。默认情况下，整型直接量是一个十进制整数。要表示一个二进制整数直接量，使用0b或0B开头;表示一个八进制整数直接量，使用0开头;表示一个十六进制整数直接量，使用0x或0X开头。为了提高可读性,Java允许在数值直接量的两个数字之间使用下划线,例如long ssn = 232_45_4519Java没有任何无符号(unsigned)形式的int、long、short或byte类型十进制整数转其他进制整数：Integer.toString(int number, int radix)返回一个String其他进制整数转十进制：Integer.parseInt(String s, int radix)返回类型为int 2）浮点类型浮点类型用于表示有小数部分的数值，Java提供了2种浮点类型：double表示这种类型的数值精度是float的两倍,float称为单精度型,double称为双精度型。通常情况下,应该使用double型,因为它比float型更精确。可以以E或e为指数用科学计数法表示浮点数,例如1.2345E+2,在十六进制中,则使用p表示指数而不是e，且尾数采用十六进制时指数的基数是2而不是10浮点数直接量是double型,即5.0被认为是double型的,可以通过追加f或F表示float型直接量,当然也可以在浮点数值后面添加后缀D或d表示double型(虽然没有必要多此一举)。如果float接受的是一个整数，不需要加f或者F，但是如果是小数一定要加f或者F。常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN(以及相应的Float类型的常量)分别表示正无穷大、负无穷大和不是一个数。例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。不能用如下的方式检测一个特定的值是否等于Double.NaN:1if(x == Double.NaN) // is never true 应该改成1if(Double.isNaN(x)) // check whether x is "not a number" 浮点数在运算时会产生一定误差,如果对精度有极高要求，应该使用BigDecimal类 3）Unicode和char类型Java中字符采用Unicode编码(统一的字符编号，仅仅提供字符与编号间映射。符号数量在不断增加，已超百万)，Unicode又有不同的UTF(即Unicode转换格式，定义Unicode中编号的编码方式)，常用的有UTF-16和UTF-8，其中UTF-8为变长表示，长度可能为1～6个字节；UTF-16为变长表示，长度可能是2或4个字节。我们先来明确几个概念：内码：某种语言运行时，其char和string在内存中的编码方式。外码：除了内码，皆是外码。码点：Unicode编码中一个字符对应的二进制数。代码单元：在UTF-16编码中，用char表示的十六位二进制数，占两个字节。要注意的是，源代码编译产生的目标代码文件(可执行文件或class文件)中的编码方式属于外码。 JVM中内码采用UTF-16。早期，UTF-16采用固定长度2字节的方式编码，两个字节可以表示65536种符号（其实真正能表示要比这个少），足以表示当时Unicode中所有字符，也就是说当时一个码点就对应一个代码单元，即每个Unicode字符都用一个char表示，一个16位的Unicode码以\u开头的4位十六进制表示，范围从’\u0000’到’\uFFFF’,范围是0~65535。但是随着Unicode中字符的增加，2个字节无法表示所有的字符，UTF-16采用了2字节或4字节的方式来完成编码。Java为应对这种情况，考虑到向前兼容的要求，Java用一对char来表示那些需要4字节的字符。所以，Java中的char固定占用两个字节(即一个代码单元)，大多数常用Unicode字符使用一个代码单元表示，而辅助Unicode字符需要两个代码单元来表示，即一个码点由一个或两个代码单元组成。 String的length()方法返回的是采用UTF-16编码表示的给定字符串所需要的代码单元数量，它在一些情况下不等于字符串中实际的字符数，length()是一个较为底层的方法。如果要得到实际的字符数(即码点数量),可以调用:int cpCount = str.codePointCount(0,str.length());调用str.charAt(n)将返回位置n的代码单元，n介于0~str.length()-1之间。要想获得第i个码点,应该使用下列语句：12int index = str.offsetByCodePoints(0,i);int cp = str.codePointAt(index); 更多详见：Java中char占几个字节 char类型的字面量值要用单引号括起来。例如：’A’是编码值为65所对应的字符常量。它与”A”不同，”A”是包含一个字符A的字符串。char类型可以表示为十六进制值，范围从’\u0000’到’\uFFFF’有一些用于表示特殊字符的转义序列,如下：注意 \r 和 \n 的区别，前者叫回车(Carriage Return)，后者叫新行(New Line)，但是都会造成换行。不同操作系统的行分隔符不同，可用System.getProperty(“line.separator”)来获取当前OS的换行符不同系统的换行符为：\r Mac\n Unix/Linux\r\n Windows 注释中的\u也会起转义作用,如下： 12345// \u00A0 is a newline (\u00A0会被替换成换行符)// Look inside c:\users (会产生编译错误,因为\u后面未跟着4个十六进制数) 下面是判断一个字符是否是汉字的方法： 12345678public static boolean isChineseChar(char c)&#123; try &#123; return String.valueOf(c).getBytes("UTF-8").length &gt; 1; &#125; catch (UnsupportedEncodingException e) &#123; return false; &#125;&#125; 将字符c先用String.valueOf转换为字符串，然后使用getBytes(“UTF-8”)将字符串按照UTF-8编码格式转换为字节数组，汉字的字节数会大于1,即可判断(如果直接对String使用length得到的是字符数不是字节数)。但是可能会抛出UnsupportedEncodingException，要进行捕获处理。 4) boolean类型boolean类型有两个值：false和true，用来判定逻辑条件。不同于C/C++中0代表false，非0代表true，Java中整型值和布尔值之间不能进行相互转换。比如,下面的语句在C/C++中是允许的,表示一个无限循环：123while(1)&#123; do something&#125; 但是在Java中不允许这么做,可以改为：123while(true)&#123; do something&#125; 可以打印boolean类型的变量或者布尔表达式，会呈现true或者false 数据类型转换将一个小范围类型变量转化为大范围类型的变量称为拓宽类型，反之称为缩窄类型。把小范围类型变量赋值给大范围类型的变量或小范围类型变量和大范围类型变量共同参与运算,Java会自动拓宽类型。而如果要缩窄类型，必须显式完成。 注意：1.类型转换不改变被转换的变量，例如，下面的代码中的d在类型转换之后值不变：12double d = 4.5;int i = (int)d; // i becomes 4, but d is still 4.5 2.x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。因此，下面代码是正确的：12int sum = 0;sum += 4.5;// 等价于sum = (int)(sum + 4.5) 3.将一个int型变量赋值给short型或byte型的变量，必须显式地使用类型转换，如下面的语句会产生编译错误：12int i = 1;byte b = i; // Error because explicit casting is required 然而如果整型直接量在目标变量允许的范围内，那么将整型直接量赋给short型或byte型就不需要显式类型转换，如：1byte b = 1; 4.字符型数据和数值型数据之间的转换：char 型数据可以转换成任意一种数值类型，反之亦然。将整数转换成 char 型数据时，只用到该数据的低十六位，其余部分都被忽略。例如：123char ch = (char)0XAB0041; /* The lower 16 bits hex code 0041 is assigned to ch*/ System.out.println(ch); // ch is character A 注意：如果数值类型的值表示范围在0~65535之间，可以隐式转换为char，但如果超过65535就需要强制类型转换，char会截取数据的低十六位。当一个char 型数据转换成数值型时，这个字符的Unicode码就被转换成某个特定的数值类型。12int i = (int)'A'; // Decimal 65 is assigned to chSystem.out.println(ch) // i is 65 如果char的Unicode值未超过数值型范围，可以隐式转换，否则也要强制类型转换。如：12byte b = 'A'; //is OK,b = 65byte c = (byte)'\uFFF4'; //超过byte范围，必须强转 变量变量用于表示在程序中可能被改变的值。变量声明告知编译器根据数据类型为变量分配合适的内存空间。变量声明的语法如下：1datatype variableName; 如果几个变量为同一类型,允许一起声明它们：1datatype variable1, variable2, ..., variablen; 可以在声明变量的同时初始化，也可以先声明后初始化：1234int count = 1; // 声明同时初始化变量int count;count = 1; //先声明，后初始化 常量常量是一个赋值后保持不变的量,用final关键字修饰，在类中定义的常量一般用static final修饰。常量必须在同一条语句中声明和赋值，不可先声明再赋值。使用常量有三个好处：1)不必重复输入同一个值2)如果必须修改常量的值，只需在源代码的一处改动3)给常量赋一个描述性的名字会提高程序的易读性 数值操作符数值数据类型的操作符包括标准的算术操作符：加号(+)、减号(-)、乘号(*)、除号( / )、求余号(%)注意：1.如果被除数是负数，结果是负数;如果除数是负数被除数是正数结果是正数;如果都是负数其结果就是负数。如 -7 % 3 = -1, -26 % -8 = -2,20 % -13 = 7,即无论正负,商和除数乘积的绝对值不能超过被除数的绝对值。2.如果是两个byte short int long相除，得到结构如果是浮点数，小数位全部舍去保留整数部分3.如果是两个byte short int long除以0，等异常信息,那么久报异常java.lang.ArithmeticException: / by zero 看到异常就要立马明白，除数是0，要赶紧检查你的代码的逻辑出现0的地方在哪里。4.float.double除以0得到正无穷和负无穷。123System.out.println(1.0f/0); //正无穷System.out.println(-1/0.0); //负无穷System.out.println(0.0/0); //NaN 增强赋值操作符x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。其中op可以是加号(+)、减号(-)、乘号(*)、除号( / )、求余号(%) 自增和自减操作符分为++var、–var、var++、var–四种，加减号决定给var加1还是减1，前置还是后置符号决定先更新后使用值还是先使用值后更新 关系运算符Java中有一系列用于比较关系的运算符：==(等于)、!=(不等于)、&lt;(小于)、&gt;(大于)、&lt;=(小于等于)、&gt;=(大于等于) 逻辑操作符逻辑操作符!(非)、&amp;&amp;(与)、||(或)和^(异或)可以用于产生复合型布尔表达式，逻辑操作符被称为短路操作符或懒惰操作符，即按顺序执行表达式，如果某一步已经可以判断整个表达式的真假，不再继续执行，否则继续执行。 位运算符处理整型类型时，可以直接对组成整型数值的各个位完成操作。位运算符包括：&amp;(按位与)、|(按位或)、^(按位异或)、~(按位取反)、&lt;&lt;(左移，高位舍弃，低位补0)、&gt;&gt;(右移，低位舍弃，高位用符号位填充)、&gt;&gt;&gt;(右移，低位舍弃，高位0填充)注意：1) 移位运算符的右操作数要完成模32的运算(除非左操作数是long类型，在这种情况下右操作数要模64),例如1&lt;&lt;35等价于1&lt;&lt;32) &amp; 、| 和 ^ 也可以用在布尔表达式中，此时它们是逻辑操作符，但不会短路，不推荐使用3) 可以使用掩码技术得到一个数二进制的某一位：int fourthBitFromRight = (n &amp; 0b1000) / 0b1000上式将n的右数第4位保留，将其他位掩掉，再除以0b1000，就得到了该位上的数 选择Java中的选择语句类型有：单分支if语句、双分支if-else语句、嵌套if语句、多分支if-else语句、switch语句、条件表达式 1) 单分支if语句123if(布尔表达式)&#123; 语句(组); &#125; 分支中如果只有单条语句可以省略外围花括号，否则不能省略 2) 双分支if-else语句123456if(布尔表达式)&#123; 布尔表达式为真时执行的语句(组); &#125; else&#123; 布尔表达式为假时执行的语句(组); &#125; 嵌套层数没有限制，但为了程序可读性，尽量不要进行过多的嵌套，且嵌套语句应有适当的缩进保持层次关系。 3) 嵌套的if语句和多分支的if-else语句下面是一个嵌套的if语句，if(j &gt; k)嵌套在语句if(i &gt; k)内123456if(i &gt; k) &#123; if(j &gt; k) System.out.println("i and j greater than k");&#125;else System.out.println("i is less than or equal to k"); 下面是一个多分支的if-else语句12345678910111213141516if(score &gt;= 90.0) System.out.print("A");else&#123; if(score &gt;= 80.0) System.out.print("B"); else&#123; if(score &gt;= 70.0) System.out.print("C"); else&#123; if(score &gt;= 60.0) System.out.print("D"); else system.out.print("E"); &#125; &#125;&#125; 为了可读性，建议改写成如下形式：12345678910if(score &gt;= 90.0) System.out.print("A");else if(score &gt;= 80.0) System.out.print("B");else if(score &gt;= 70.0) System.out.print("C");else if(score &gt;= 60.0) System.out.print("D");else System.out.print("E"); 注意：只有在前面的所有条件都为false才测试下一个条件 4) switch语句switch语句常用于多分支的选择问题：12345678910switch(switch表达式)&#123; case value1: 语句(组)1; break; case value2: 语句(组)2; break; ... case valueN: 语句(组)N; break; default: 当没有一个给出的case与switch表达式匹配时执行的语句(组)&#125; 注意：1) switch表达式可以为char、byte、short、int或者String型值(整型中只有long不行),并且总要用括号括住2) value1,…,valueN必须与switch表达式具有相同的数据类型，且是常量表达式，不能出现变量，例如：x、y+1等3) 当switch表达式的值与case语句匹配时,执行从该case开始的语句，直到遇到一个break语句或到达switch语句的结束。break语句是可选的,会立即终止switch语句4) default语句是可选的，当没有一个给出的case与switch表达式匹配时执行default语句指定的操作，如果不加default语句，就什么也不做 5) 条件表达式条件表达式基于一个条件计算表达式的值，它是Java中唯一的三元操作符。12boolean-expression ? expression1 : expression2;//(布尔表达式? 表达式1:表达式2) 如果布尔表达式的值为true，则条件表达式的结果为表达式1;否则，结果为表达式2。例如：1System.out.println((num % 2 == 0) ? "num is even" : "num is odd"); 注意冒号两边是表达式，不能是其他操作。 循环1) 块作用域块(即复合语句)是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域，变量只在包含自己的块中可见。一个块可以嵌套在另一个块中。例如：123456789public static void main(String[] args)&#123; int n; . . . &#123; int k; . . . &#125; // k is only defined up to here&#125; 但是不能声明两个作用域(生命周期)重叠的同名变量，例如下面的语句会产生编译错误，这是因为前面定义的n的作用域是从定义处开始到方法末尾，后面定一个的n的作用于是从定义处到代码块末尾，两者作用于发生了重叠：12345678910public static void main(String[] args)&#123; int n; . . . &#123; int k; int n;//Erro -- can't redefine n in inner block . . . &#125; &#125; 这与C++不同，在C++中允许在重叠的作用域定义同名变量，后定义会覆盖先定义的变量。但在Java中并不允许这么做。 2) while循环while循环在条件为真的情况下，重复地执行语句：1234while(循环继续条件)&#123; //循环体 语句(组);&#125; 当程序不幸出现了死循环，如果是从命令窗口运行程序的，按CTRL+C键来结束 3) do-while循环do-while循环和while循环基本一样，不同的是while循环是前测循环，即先检测循环条件后执行循环体;do-while是后测循环，即先执行循环体后检测循环条件。只有在一开始就不满足循环继续条件时，两种循环的执行次数不同，即while循环不执行，do-while循环执行一次。否则两种循环的执行次数相同。1234do&#123; // 循环体; 语句(组);&#125;while(循环继续条件); 注意do-while循环后面的分号不要丢！ 4) for循环for循环的基本语法为：1234for(初始操作;循环继续条件;每次迭代后的操作) &#123; //循环体 语句(组);&#125; 初始动作可以是0个或是多个以逗号隔开的变量声明语句或赋值表达式：12345678int i = 0;for( ;i &lt; 100;i++)&#123; System.out.println("Welcome to Java!");&#125;// 将初始动作省略，放在循环语句之前执行for(int m = 0,n = 0; m + n &lt; 10; m++,n++)&#123; System.out.println("Welcome to Java!");&#125;// 多个初始化动作 每次迭代后的操作也可以是0个或多个逗号隔开的语句：1234567for(int i = 0;i &lt; 100; )&#123; System.out.println("Welcome to Java!"); i++;&#125;// 将每次迭代后的操作放入循环体内 for(int i = 1;i &lt; 100;System.out.println(i),i++);// 每次迭代后执行多个操作 下面的三种循环写法是等价的：1234567891011for( ; ; )&#123; //do something&#125;for( ;true; )&#123; //do something&#125;while(true)&#123; //do something&#125; 5) for-each循环Java有一种很强的循环结构，可以用来依次处理数组中的每个元素(其他类型的元素集合亦可)而不必为指定的下标值而分心。这种增强的for循环的语句格式为：1for(variable : collection) statement 定义一个变量用于暂存集合中的每一个元素，并执行相应的语句(组)，collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象(例如ArrayList)。for-each循环只能用于按顺序遍历数组或集合的情况，如果要使用其他顺序，应该使用其他循环语句 6) break和continuecontinue跳出本次迭代进入下一次迭代，break跳出整个循环。虽然不提倡使用goto语句，但偶尔使用goto语句跳出循环还是有益处的。Java中提供了类似于C++中goto语句的带标签的break语句和continue语句，用于跳出多重嵌套的循环语句。标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。另外要注意，只能跳出语句块，而不能跳入语句块。下面的代码使用了带标签的break语句：1234567int i; label1:for( i = 0;i &lt; 10;i ++) &#123;if(i == 5)break label1;&#125;System.out.println(i);// i = 5 上述代码中，i在等于5时跳出循环到循环首部的标签label1位置，由于是带标签的break语句，不再重新进入循环，而是跳过循环执行下面的打印语句。 如果把改成带标签的continue语句：1234567int i; label2:for( i = 0;i &lt; 10;i ++) &#123; if(i == 5) continue label2;&#125;System.out.println(i); // i = 10 上述代码中，i在等于5时也跳出循环到循环首部的标签label2位置，但由于是带标签的continue语句，会重新进入循环。 枚举类型有时，变量的取值只在一个有限集合内。例如：销售的服装或比萨饼只有小、中、大、超大这四种尺寸。此时可以给每种尺寸编号为1、2、3、4,但是为了程序的可读性，可以定义一个枚举类。可以把枚举类看作普通类，它们都可以定义一些属性和方法，也可以添加public等访问修饰符，不同之处是：枚举类不能使用 extends 关键字继承其他类，因为 枚举类已经继承了 java.lang.Enum&lt;T&gt;(java是单一继承),其中T是定义的枚举类类型，也就是说一个枚举类T的类型其实是&lt;T extends Enum&lt;T&gt;&gt;。Enum类是一个抽象类。下面定义一个简单的枚举类：1public enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;; 其中enum是定义枚举类的关键字，可类比普通类的class。Size是枚举类名，类比普通类名。SMALL、MEDIUM、LARGE、EXTRA_LARGE是枚举值，为枚举类的静态成员，static关键字被省略，类型为Size，可以用Size.枚举实例名来访问，命名习惯同常量。Size变量只能存储枚举类中定义的枚举值或null，尽量不要构造新的Size类型对象。可以在枚举类中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候使用，下面是一个示例：1234567891011public enum Size&#123; SMALL("S"),MEDIUM("M"),LARGE("L"),EXTRA_LARGE("XL"); private String abbreviation; private Size(String abbreaviation)&#123; this.abbreviation = abbreviation; &#125; public String getAbbreviation() &#123;return abbreviation&#125;;&#125; 注意：枚举值的声明必须是枚举类定义的第一条语句。枚举类的构造器必须为private，保证了构造器只能用于枚举类中定义的枚举值的构造，而不让客户代码构造新的枚举值。当访问枚举值时，构造方法被调用，枚举值构造方法中的参数被赋值给Abbreviation。如：12345public class TestSize&#123; public static void main(String[] args) &#123; Size size = Size.LARGE; System.out.println(size.getAbbreviation);&#125; 结果打印出”L” 枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal)构造函数中，在这里，每个枚举值的名称都被转换成一个字符串，且按照在枚举类中出现的先后次序，从0开始进行编号。下面是枚举类的常用API： int ordinal()返回enum声明中枚举常量的位置，位置从0开始计数 int compareTo(&lt;T extends Enum&lt;T&gt;&gt; o)按照序号(枚举类中的定义次序，即ordinal返回值)比较此枚举与指定对象的顺序，小于返回一个负值，绝对值是两者的序号差;等于返回0;大于返回一个正值，绝对值是两者的序号差 boolean equals(&lt;T extends Enum&lt;T&gt;&gt; o)比较两个枚举常量是否相等,可以用==代替 String toString()返回枚举常量的名称 static &lt;T extends Enum&lt;T&gt;&gt; valueOf(Class&lt;T&gt; enumType, String name)返回带指定名称的指定枚举类型的枚举常量(是toString的逆操作) static T[] values()返回一个包含全部枚举值的数组 例如： 12345678910111213 int index = Size.SMALL.ordinal(); //index是0 int cmp = Size.SMALL.compareTo(Size.MEDIUM); //cmp是-1 boolean isEqual = Size.SMALL.equals(Size.MEDIUM); //isEqual为false String enumName = Size.SMALL.toString();//enumName是"SMALL" Size s = Enum.valueof(Size.class,"SMALL"); //s是Size.SMALLSize[] values = Size.values(); /*返回一个包含Size.SMALL,Size.MEDIUM,Size.LARGE, Size.EXTRA_LARGE的数组 */ 要比较两个枚举值是否相同，既可以使用equals也可以使用== 枚举类型可以在一个类内定义，此时枚举类被作为内部类对待。程序编译后，将创建一个名为OuterClassName$EnumName的字节码文件。 可以在if或switch语句中使用枚举变量，例如：12345678if(size.equals(Size.SMALL)&#123; // process SMALL&#125;else if(size.equals(Size.MEDIUM)&#123; // process MEDIUM&#125;else... 等价于：123456789switch(size)&#123; case SMALL: // process SMALL break; case MEDIUM: // process MEDIUM break; ...&#125; 在switch语句中，case标签是一个无限定的枚举值(即SMALL，而不是Size.SMALL) 更多用法见：Java枚举(enum)详解7种常见的用法 输入输出1) 输入从控制台读取”标准输入流”System.in，需要构造一个Scanner对象，并与”标准输入流”System.in关联。1Scanner in = new Scanner(System.in); 下面给出Scanner类的常用API： Scanner(InputStream in)用给定的输入流创建一个Scanner对象(System.in就是一个InputStream,表示系统标准输入流，默认从键盘读取输入) Scanner(File source)用文件创建一个Scanner对象从文件读取输入，如果文件不存在会抛出FileNotFoundException Scanner(String str)用字符串创建一个Scanner对象从字符串读取输入 String nextLine()读取输入的下一行内容(以回车作为分隔符) String next()读取输入的下一个字符串(以空白字符如空格、回车作为分割符) String next(Pattern pattern)读取输入的下一个字符串，进行正则验证，如果输入不符合正则表达式会抛出InputMismatchException int nextInt()读取下一个int double nextDouble()读取下一个double() boolean hasNext()检测输入是否还有单词 boolean hasNext(Pattern pattern)检测输入的数据是否符合指定的正则标准 boolean hasNextInt()检测输入是否还有int boolean hasDouble()检测输入是否还有double useDelimiter(String pattern)修改输入分隔符(如果用\n作分隔符,next()就可以实现和nextLine()一样的功能) Scanner读入时会有回车残留的问题！在使用除了nextLine()的其他方法(称为标记读取方法)读入时，本次读入不会读取分隔符，即空格、Tab和回车等，但分隔符会进入缓冲区，如果在标记读取方法之后调用nextLine()就会先读取缓冲区的内容。使用nextLine()读入，本次读入则不会读入行分隔符(回车)，且回车不会进入缓冲区而是直接被舍弃，不影响下一次读入。行分隔符字符串是由系统定义的，在Windows平台上是\r\n，而在Linux|UNIX平台上是\n。为了得到特定平台上的行分隔符，使用：String lineSeparator = System.getProperty(&quot;line.separator&quot;); 因为输入是可见的，所以Scanner类不适用于从控制台读取密码。Java SE 6特别在io包中引入了Console类实现不回显的输入。要想读取一个密码，可以采用下列代码：12345678910111213Console cons = System.console(); if(cons != null) &#123; String username = cons.readLine("User name: "); char[] passwd = cons.readPassword("Password: "); cons.printf("Username is: " + username + "\n"); // 显示用户名 cons.printf("Password is: " + passwd + "\n"); // 显示密码 &#125; else &#123; System.out.println("Console is unavailable."); // 提示无控制台使用权限 &#125; 几点注意：1.Console类不能用new构造对象，属于单例模式，构造方法被private修饰2.为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理后，应该马上用一个填充值覆盖数组元素。3.采用Console对象处理输入不如Scanner方便，每次只能读取一行输入，而没有能够读取一个单词或一个数值的方法。4.Java要与Console进行交互，不总是能得到可用的Java Console类的。一个JVM是否有可用的Console，依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如linux的终端或windows的cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就我们可以得到一个可用的Console实例。当用Eclipse或NetBean中运行以上代码时Console中将会有以下文字输出：Console is unavailable.表示Java程序无法获得Console实例，是因为JVM不是在命令行中被调用的，或者输入输出被重定向了。 下面给出Console类的常用API： static Console console()返回一个Console对象 static char[] readPassword(String prompt, Object…args)显示提示字符串prompt并读取用户输入，直到输入行结束,结果存放在字符数组中。args参数用来提供输入格式。 static String readLine(String prompt,Object…args)显示提示字符串prompt并读取用户输入，直到输入行结束，结果存放在字符串中。args参数用来提供输入格式。 2) 输出可以使用 System.out.print(x) 将数值 x 输出到控制台上。这条命令将以 x 对应的数据类型所允许的最大非 0 数字位数打印输出 x 。例如：12double x = 10000.0 / 3.0;System.out.print(x); 打印3333.3333333333335如果希望显示美元、美分等符号， 则有可能会出现问题。在早期的 Java 版本中，格式化数值曾引起过一些争议。庆幸的是，Java SE 5.0 沿用了 C语言库函数中的 printf方法。例如，调用1System.out.printf("%8.2f",x); 可以用 8 个字符的宽度和小数点后两个字符的精度打印 x。也就是说，打印输出一个空格和7 个字符， 如下所示：3333.33在 printf中，可以使用多个参数， 例如：1System.out.printf("Hello, %s. Next year, you'll be %d", name, age); 每一个以 % 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数。 下表列出了所有转换符：另外，还可以给出控制格式化输出的各种标志。例如，逗号标志增加了分组的分隔符。即1System.out.printf("%,.2f", 10000.0 / 3.0); 打印3,333.33 下表列出了用于printf的所有标志 可以使用静态的 String.format 方法创建一个格式化的字符串，而不打印输出：1String message = String.format("Hello, %s. Next year, you'll be %d", name , age); 基于完整性的考虑， 下面简略地介绍 printf方法中日期与时间的格式化选项(已经过时)。在新代码中， 应当使用 java.time 包的方法。 不过你可能会在遗留代码中看到 Date 类和相关的格式化选项。格式包括两个字母， 以 t 开始， 以下表中的任意字母结束：例如1System.out.printf("%tc", new Date()); 这条语句将用下面的格式打印当前的日期和时间：Mon Feb 09 18:05:19 PST 2015 从上表可以看到，某些格式只给出了指定日期的部分信息。例如，只有日期或月份。如果需要多次对日期操作才能实现对每一部分进行格式化的目的就太笨拙了。为此，可以采用一个格式化的字符串指出要被格式化的参数索引，表示该处格式化的是待格式化参数列表的第几个参数。索引必须紧跟在%后面， 并以$终止。 例如：1System.out.printf("%1$s %2$tB %2$te,%2$tY","Due date:",new Date()); 打印Due date: February 9, 2015 还可以选择使用 &lt; 标志。它指示前面格式说明中的参数将被再次使用。也就是说，下列语句将产生与前面语句同样的输出结果：1System.out .printf("%s %tB %&lt;te, %&lt;tY", "Due date:", new Date()); 注意：参数索引值从1开始，而不是从0开始，%1$…对第一个参数格式化。这就避免了与0标志混淆。 现在，已经了解了 printf 方法的所有特性。下表给出了格式说明符的语法图： 3) 重定向语法Java使用System.out(系统类的输出流对象)来表示标准输出设备，默认情况下是显示器，而用System.in(系统类的输入流对象)来表示标准输入设备，默认情况下是键盘。有时，我们需要从文件而不是键盘读入数据，并希望将程序输出结果保存到文件中而不是打印在控制台上。此时，可以在命令行利用Shell的重定向语法将任意文件关联到System.in和System.out，例如下面的语句实现了从input.txt文件输入并将程序输出结果输入output.txt：1java MyProg &lt; input.txt &gt; output.txt 本节只是介绍了最常用的输入输出方式，更多输入输出知识详见：Java学习总结之Java IO系统 方法1) 定义方法下面先来看一个方法的定义，其作用是返回两个整数中的较大者：12345678public static int max(int num1,int num2)&#123; int result; if(num1 &gt; num2) result = num1; else result = num2; return result;&#125; 其中花括号前的部分是方法头，花括号包括的部分是方法体。方法头包括修饰符(public static)、返回值类型(int)、方法名(max)、形式参数(int num1、int num2)。形式参数构成参数列表，方法名和参数列表构成方法签名。对带返回值的方法而言，return语句是必需的，且如果存在多个选择分支，要确保任何分支都有返回值。对于void方法，也可以在方法中使用return结束方法调用。 2) 调用方法如调用上述max方法：1int z = max(x,y); 其中x,y是实际参数。 每当调用一个方法时，系统会创建一个活动记录(也称为活动框架)，用于保存方法中的参数和变量。活动记录置于一个内存区域中，称为调用堆栈(call stack)。调用堆栈也称为执行堆栈、运行时堆栈，或者一个机器堆栈，常简称为”堆栈”。当一个方法调用另一个方法时，调用者的活动记录保持不动，一个新的活动记录被创建用于被调用的新方法,一个新的记录”入栈”。一个方法结束返回到调用者时，相应的活动记录被释放，其中的参数和变量被销毁，栈顶的记录”出栈”。堆栈的最底层活动记录是main方法的记录，当整个程序结束，main方法记录”出栈”,栈为空，程序结束。 当调用带参数的方法时，如果参数是基本数据类型，实参的值传递给形参(即拷贝)，这个过程称为按值传递，无论形参在方法中是否改变，实参都不受影响;如果参数是引用类型，则传递的是引用值，可以理解为传共享，形参和实参指向同一对象，此时实际对象可能会被改变。 main方法也有参数，是一个String数组，可以在命令行里给main方法传递字符串参数(也可以通过eclipse传递参数，在运行——运行配置——自变量里传递)。例如，下面的命令行用三个字符串arg0、arg1、arg2启动程序TestMain：1java TestMain arg0 arg1 arg2 其中arg0、arg1、arg2都是字符串，但是在命令行中出现时不需要双引号，但如果字符串包含空格，就必须用双引号括住。当调用main方法时，Java解释器会创建一个数组存储命令行参数，然后将该数组的引用传递给args。例如，如果调用有n个命令行参数的程序，Java解释器创建一个如下所示的数组：1args = new String[n]; 然后Java解释器传递参数args去调用main方法注意：如果命令行没有传递参数，那么使用new String[0]创建数组。在这种情况下args引用了一个长度为0的空数组，它的值不是null，但是args.length是0 数组Java和许多高级语言都提供了一种称作数组的数据结构，可以用它来存储一个元素个数固定且元素类型相同的有序集。数组一旦被创建，它的大小不能改变。使用一个数组引用变量，通过下标来访问数组中的元素。 1) 声明和创建数组(以一维数组为例)来看下面的语句：12elementType[] arrayRefVar = new elementType[arraySize];//(元素类型[] 数组引用变量 = new 元素类型[数组大小]) 该语句完成了三个操作：1.elementType[] arrayRefVar声明了一个elementType类型的数组引用变量arrayRefVar2.new elementType[arraySize]创建了一个大小为arraySize的elementType的数组3.= 把数组引用赋给数组引用变量 注意：1.elementType[] arrayRefVar只是声明数组变量，并不在内存中给数组分配任何空间，它只是创建一个对数组应用的存储位置，如果变量不包含对数组的引用，这个变量的值为null2.new elementType[arraySize]在内存中给数组元素分配了存储空间3.一个数组变量看起来似乎是存储了一个数组，但实际上它存储的是只是数组的引用。4.当创建数组后，它的元素被赋予默认值，数值型基本数据类型的默认值为0,char型的默认值为’\u0000’(空字符，但长度为1),boolean型的默认值为false，非基本数据类型的默认值均为null5.与C++不同，Java允许动态开数组，即无需在编译期就确定数组大小，可以在程序运行时决定数组大小并创建相应大小的数组。 2) 初始化数组1.逐一赋值123456int[] myList = new int[5];myList[0] = 1;myList[1] = 2;myList[2] = 3;myList[3] = 4;myList[4] = 5; 2.数组初始化语法 下面的语法可以给数组的前k个元素赋值：1elementType[] arrayRefVar = &#123;value0, value1, .., valuek&#125;; 注意：在使用数组初始化语法时，必须将声明、创建和初始化放在一条语句中，将它们分开会产生语法错误：12int[] myList;myList = &#123;1,2,3,4,5&#125;; //Error 3) 访问数组元素可以用arrayRefVar.length得到数组长度，数组元素的下标为0 ～ arrayRefVar.length - 1。可以直接使用下标随机访问数组元素：1arrayRefVar[index] (数组引用变量[下标]) 如果要打印数组，可以使用一个循环打印逐一数组元素。如果是字符数组，可以使用一条打印语句打印:12char[] city = &#123;'B','e','i','j','i','n','g'&#125;;System.out.println(city); 4) 复制数组要将一个数组中的内容复制到另一个中，如果使用=直接赋值，如：1list2 = list1; 上述语句只是将list1的引用值复制给了list2，这条语句执行后，list1和list2都指向了同一个数组，如果改变其中一者，另一者也会受到同样的影响。list2原先所引用的数组不能再引用，它就变成了垃圾，会被JVM自动回收。在Java中，可以使用赋值语句复制基本类型的值，但不能复制数组等引用类型的值。 复制数组的四种方法1.申请一个新数组，遍历原数组逐一复制元素2.使用System类的静态方法arraycopy()3.使用数组对象.clone()返回一个数组克隆的引用4.使用Arrays类的copyOf()方法 下面是四种复制数组的方法的效率比较，非常有趣，看来要多读读JDK源码^-^参考博客：https://www.cnblogs.com/zhengbin/p/5671403.html 5) 匿名数组来看下面的语法：1new elementType[] &#123;value0,value1, ... ,valuek&#125;; 该语句创建了一个没有显式引用变量的数组并进行了初始化，这样的数组称为匿名数组。注意匿名数组的方括号里不指定数组长度! 6) 可变长参数列表可以把类型相同但个数可变的参数传递给方法，语法如下：1typeName...parameterName (类型名...参数名) 注意：1.在方法声明中，指定类型后紧跟着省略号(…)2.只能给方法中指定一个可变长参数，且该参数必须是最后一个参数，任何常规参数必须在它之前3.Java将可变长参数当成数组对待，当用数目可变的参数调用方法时，Java会创建一个数组并把参数传给它。所以可以传入一个数组，但反之如果参数是数组类型，不能传递可变长参数。且参数为数组和可变长参数的两个方法(其他参数均相同)不能重载，因为它们被认为是同一方法。4.如果有多个重载的方法都满足被调用的条件，带可变常参数的方法最后考虑被调用。 7) Arrays类Arrays类中包含了许多对处理数组的方法 下面是Arrays类的常用API： 如果计算机有多个处理器，可以使用parallelSort，比sort更高效。 8) 多维数组以二维数组为例，二维数组引用变量有三种表示方法：123elementType arrayRefVar[][]elementType[] arrayRefVar[]elementType[][] arrayRefVar 推荐使用elementType[][] arrayRefVar声明二维数组引用变量。初始化语法也适用于多维数组：1234int[][] array = &#123; &#123;1, 2&#125;, &#123;3, 4&#125;&#125;; 等价于：12345int[][] array = new int[2][2];array[0][0] = 1;array[0][1] = 2;array[1][0] = 3;array[1][1] = 4; 二维数组其实是一个数组，它的每个元素都是一个一维数组，即它是数组的数组。x.length可以获取二维数组的第一维长度，x[index].length可以获取index行对应的第二维长度。如果没有初始化二维数组二维数组的所有元素默认为null，因为二维数组的元素是数组类型，默认值为null二维数组中的每一行本身就是一个数组，因此，各行的长度可以不同。这样的数组称为锯齿数组，例如：1234567int[][] triangleArray = &#123; &#123;1, 2, 3, 4, 5&#125;, &#123;2, 3, 4, 5&#125;, &#123;3, 4, 5&#125;, &#123;4, 5&#125;, &#123;5&#125;&#125;; 其余没有赋值的部分并不会被赋为默认值，就是未分配空间,如果进行访问会抛出ArrayIndexOutOfBoundsException 二维数组在创建时可以省略第二维长度(留到后续指定)，但必须指定第一维长度：123456int[][] triangleArray = new int[5][];triangleArray[0] = new int[5];triangleArray[1] = new int[4];triangleArray[2] = new int[3];triangleArray[3] = new int[4];triangleArray[4] = new int[5]; 如果想打印多维数组，可以使用嵌套循环打印，也可以使用Arrays类的deepToString()方法。 零敲碎打 一个Java源文件内只能有一个public类,且该类名称必须与文件名相同 main方法是程序的入口，JVM将从指定类中的main方法开始执行。根据Java语言规范，main方法必须声明为public static void main(String[] args) 在源代码中，字符串常量不能跨行，因此，下面的语句会造成编译错误： 12System.out.println("Welcome to theworld of Java!"); 为了改正错误，可以将该字符串分成几个单独的子串，然后再用连接符(+)将它们组合起来：12System.out.println("Welcome to the“ +”world of Java!"); 在eclipse中创建一个工程，目录包含关系如下：在work-space文件夹下会生成一个以工程名命名的文件夹，下面有bin和src文件，bin文件夹用于存放字节码文件，src用于存放源文件。如果工程创建了包，比如cn.habitdiary.core，会在bin和src文件夹下都创建三级文件夹cn/habitdiary/core。特别注意，在eclipse中哪怕没有编译，bin中也会出现字节码文件。事实上每次保存源文件都会自动编译。 eclipse调试和设置断点：按F11进入程序调试，程序运行到设置的断点处会暂停执行，注意调试到某条语句时该语句是还未执行的状态，按F6单步执行，按F8向下执行直到遇到断点或程序结束，按F5从进入方法进行调试(step in)，按F7从方法内部返回调用处(step out)。 eclipse中按Alt+/调出代码提示。 eclipse中输入Sysout，按Alt+/即可补全为System.out.println();]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之Java程序设计概述]]></title>
    <url>%2F2017%2F10%2F07%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、走进JavaJava是一个完整的平台,有一个庞大的库,其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。它是功能完善的通用程序设计语言，可以用来开发健壮的任务关键的应用程序。现在，它不仅用于Web程序设计，而且用于在服务器、台式计算机和移动设备上开发跨平台的独立应用程序。 二、Java”白皮书”的关键术语1) 简单性Java语法是C++语法的一个“纯净”版本。这里没有头文件、指针运算(甚至指针语法)、结构、联合、操作符重载、虚基类等。其剔除了C++中许多很少使用、难以理解、易混淆的特性。目前看来，这些特性带来的麻烦远远多于其带来的好处。 2) 面向对象简单地讲，面向对象设计是一种程序设计技术。传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。 3) 分布式Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。 4) 健壮性Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java投入了大量的精力进行早期的问题检测(编译时检测)，后期动态的检测(运行时检测)，并消除了容易出错的情况。 5) 安全性Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。 6) 体系结构中立Java源文件经过编译生成中间字节码文件(.class)，这是一种体系结构中立的文件格式，精心设计的字节码不仅可以很容易地在任何带Java虚拟机(JVM)的平台上运行，而且还可以动态地翻译成本地机器代码，即Java程序可以”一次编译，处处运行”。当然，解释虚拟机指令肯定会比全速运行机器指令慢很多。虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程称为即时编译。 7) 可移植性与C和C++不同，Java规范中没有”依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。例如，Java中的int永远是32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是int类型的大小不能低于short int，并且不能高于long int。在Java中，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。 8) 解释型Java源程序(.java)在编写完成后，经过编译生成中间字节码文件(.class)，字节码文件被JVM解释执行，不同于C/C++等编译型语言，字节码被解释为机器代码后立即执行，不产生中间机器代码文件。 9) 高性能尽管对解释后的字节码性能已经比较满意，但有些场合下还需要更加高效的性能。字节码可以(在运行时刻)动态地翻译成对应运行这个应用的特定CPU的机器码。 10) 多线程多线程可以带来更好的交互响应和实时行为。我们非常关注并发性，因为我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。Java是第一个支持并发程序设计的主流语言。 11) 动态性Java能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时的类型信息十分简单。 三、名词释疑JDK即Java开发工具包(Java Development Kit)，是编写Java程序的程序员使用的软件，包括开发和运行Java程序的软件。 OpenJDKJava SE的一个免费开源实现，不包含浏览器集成或JavaFX SDK即Software Development Kit,是一个过时的术语，用于描述1998 ～ 2006年之间的JDK J2一个过时的术语，用于描述1998 ～ 2006年之间的Java版本 JRE即Java运行时环境(Java Runtime Environment)，是运行Java程序的用户使用的软件，它包含Java虚拟机但不包含编译器，为不需要开发只需要运行Java程序的用户提供。 Sever JRE在服务器上运行Java程序的软件。 JVM即Java虚拟机(Java Virtual Machine)，用于解释执行中间字节码文件。 API即应用程序接口(Application Program Interface),也称为库，包括为开发Java程序而预定义的类和接口。 IDE即集成开发环境(Integrated Development Environment),是为了快速开发程序而提供的开发工具，编辑、编译、链接、调试和在线帮助都集成在一个图形用户界面中。 applet能在Web浏览器中运行的Java程序称为Java小程序(applet) Java SE即Java标准版(Java Standard Edition),可以用来开发客户端的应用程序。应用程序可以独立运行或作为applet在Web浏览器中运行。 Java EE即Java企业版(Java Enterprise Edition),可以用来开发服务器端的应用程序，例如，Java servlet和JavaServer Pages(JSP)，以及JavaServer Faces(JSF)。 Java ME即Java微型版(Java Micro Edition)，可以用来开发移动设备的应用程序，例如手机。 JavaFX开发Java GUI程序的框架，在Oracle的Java SE发布版本中提供。 四、JDK、JRE和JVM三者的关系见大牛博客：JDK、JRE、JVM三者间的关系 五、创建、编译和执行Java程序的过程Java源程序编写后被保存为.java文件，通过Java编译器编译生成字节码.class文件，字节码文件和所需的库代码被送去JVM解释执行。在执行一个Java程序时，JVM首先会用一个称为类加载器(class loader)的程序将类的字节码加载到内存中。如果你的程序中使用其他类，类加载程序会在需要它们之前动态地加载它们。当加载该类后，JVM使用一个字节码验证器(bytecode verifier)的程序来检验字节码的合法性，确保字节码不会违反Java的安全规范，以确保来自网络的Java程序不会篡改和危害你的计算机。 六、通过命令行编译、运行Java程序在命令行里输入以下命令编译Java程序：java classname.java编译成功后，使用以下语句运行程序：java classname //注意此处不要加.class后缀注意：如果提示命令不存在，应该先配置环境变量，在path中用分号和前面的内容分隔，然后加入jdk/bin的路径，因为java.exe,javac.exe文件都在该目录下。 七、注释1) 行注释行注释以//开始，不能跨行 2) 块注释块注释以/*开始，以*/结尾，可以跨行 3) 文档注释文档注释以/**开始，以*/结尾，添加方法是输入/**后回车即可，可以添加@author、@version等参数，它能使用JDK的javadoc命令提取一个HTML文件(在控制台输入javadoc 文件名，然后会在执行目录下生成若干文件，打开index.html即可)。使用javadoc注释来注释整个类或整个方法，为了将这些注释提取出来放在一个javadoc HTML文件中，这些注释必须放在类或者方法头前面。要注释方法中的某一步骤，使用行注释//更多文档注释内容详见：Java学习总结之对象与类 eclipse快捷键：选中要注释的区域 ctrl+/ 或者ctrl+shift+c 为该区域加上行注释选中要注释的区域 ctrl+shift+/ 为该区域加上块注释 八、程序设计错误1) 语法错误在编译过程中出现的错误称为语法错误或编译错误。 2) 运行时错误运行时错误是引起程序非正常中断的错误，即程序能通过编译，但在运行时环境检测到一个不可能执行的操作，就会出现运行错误。 3) 逻辑错误当程序没有按预期的方式执行就会发生逻辑错误。 九、Java标识符Java标识符用于命名类、接口、变量、常量、方法等，有如下规则： 标识符是由字母、数字、下划线(_)和美元符号($)组成的字符序列 必须以字母、下划线(_)或美元符号($)开头，不能以数字开头 标识符不能是关键字(如public)或保留字(如goto) 标识符不能是true、false或null等字面常量 标识符可以为任意长度 不要用字符$命名标识符，习惯上$只用于机器自动产生的源代码中 十、命名规范注意：在命名时尽量避免采用缩写作为标识符，用完整的词汇会更具有描述性，比如numberOfStudents比numStds、numOfStuds或者numOfStudents要好。另外，Java是区分大小写的。 1) 类名和接口使用Pascal命名法，每个单词的首字母大写,例如类名ComputeArea和System 2) 变量和方法使用驼峰命名法，一个单词都小写，如有多个单词则第一个单词字母小写，后面每个单词的首字母大写，例如变量radius以及方法setRadius 3) 常量大写常量的所有字母，如果有多个单词，单词之间用下划线连接，例如，常量PI和常量MAX_VALUE]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH远程登录实现本地机和服务器的文件传输]]></title>
    <url>%2F2017%2F10%2F07%2FSSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见: 在Ubuntu下通过SSH连接远程服务器 (1)用SSH登录远程ubuntu主机假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu我们在命令行输入以下命令来连接：ssh -l ubuntu 118.89.223.117之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端 (2)从远程Ubuntu主机下载文件/文件夹到本地(scp)语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径 我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件要下载文件到本地,我们要结束SSH连接,切换到本地机,输入eixt或quit即可 我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功 我们进入本地目录验证一下 hello文件的确下载到了本地 (3)从本地向远程ubuntu主机上传文件/文件夹(scp)语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径 假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下 要上传本地文件,我们要结束SSH连接,切换到本地机,输入eixt或quit即可然后输入命令$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/，输入密码后提示文件上传成功 我们通过SSH登录到远程主机验证一下,pwd打印当前所在位置，发现我们处于/home/ubuntu目录下,ls显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下通过SSH连接远程服务器]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。 环境准备装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台 步骤一:打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端$ sudo apt-get install aptitude$ sudo aptitude install openssh-server 步骤二:启动ssh-server$ /etc/init.d/ssh restart 步骤三：确认ssh-server已经正常工作$ netstat -tlptcp6 0 0 *:ssh *:* LISTEN -看到上面一行说明ssh-server已经在运行了 步骤四：在本地机终端通过ssh登录服务器$ ssh -l 远程服务器用户名 服务器ip地址接下来会提示输入密码，然后就能成功登录到服务器上了 参考http://blog.csdn.net/wh_19910525/article/details/7585257]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制修改ubuntu密码]]></title>
    <url>%2F2017%2F10%2F06%2F%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。 查了资料,总结出两种解决方法: 方法一:加上sudo权限 方法二:切换到root用户 mark一下]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习笔记]]></title>
    <url>%2F2017%2F10%2F05%2FMarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。1. 标题标题根据字体大小分级产生层次，有两种写法：写法一：1234一级标题==================二级标题--------------------- 效果如下： 一级标题二级标题写法二：123456# 一级标题## 二级标题 ### 三级标题 #### 四级标题##### 五级标题 ###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题可见#的数量越多标题字号越小，要特别注意#和标题之间要留一个空格! 2. 内联样式内联样式能描述文字的粗细、倾斜程度等2.1 语义标记：代码:123456*这是斜体*_这是斜体_**这是粗体** ***这是加粗斜体*** **_这是加粗斜体_**~~这是删除线~~ 效果如下: 这是斜体这是斜体这是粗体这是加粗斜体这是加粗斜体这是删除线 可见语义标记允许叠加 2.2 语义标签代码:123456&lt;i&gt;这是斜体&lt;/i&gt; &lt;b&gt;这是粗体&lt;/b&gt; &lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt; &lt;em&gt;这是强调&lt;/em&gt; 这是上标 Z&lt;sup&gt;a&lt;/sup&gt; 这是下标 Z&lt;sub&gt;a&lt;/sub&gt; 效果如下： 这是斜体这是粗体这是粗斜体这是强调这是上标 Za这是下标 Za 可见语义标签可以嵌套，特别要注意&lt;em&gt;&lt;/em&gt;标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用&lt;i&gt;&lt;/i&gt;标签替代 3. 引用3.1 单行式 代码: 1&gt; hello world 效果如下: hello world 3.2 多行式 代码: 123&gt; hello world &gt; hello world &gt; hello world 效果如下: hello worldhello worldhello world 3.3 嵌套式 代码: 123&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc 效果如下: aaaaaaaaa bbbbbbbbb cccccccccc 4. 换行与段落缩进换行: 在行末敲两个空格和一个回车段落缩进: 将输入法切换为全角后敲击两次空格即可完成两个字符的缩进5. 行内标记与代码块5.1 行内标记(用前后各一个`标记代码块将变成一行) 代码: 1标记之外`hello world`标记之外 效果如下: 标记之外hello world标记之外 5.2 代码块(用于插入各类型的代码) 方法一 (使用前后各一个```包裹代码生成块,注意```之后换行不需要敲两个空格!!!): 效果如下: 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 方法二 (使用Tab缩进): 代码及效果如下: 我是文字… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 注意要在前文后空一行再进行Tab缩进 方法三 (自定义语法)： 即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮 效果如下： html代码块 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; javascript代码块 12345var num = 0;for(var i = 0; i &lt; 5; i++)&#123; num += i; &#125;console.log(num); 6. 超链接 Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。 6.1 行内式语法说明: []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。 代码: 12这是[XJY&apos;s Blog](http://habitdiary.cn) 这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;) 效果如下:这是XJY’s Blog这是XJY’s Blog 6.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明:参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 代码: 12345我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。[1]:http://www.baidu.com &quot;Baidu&quot;[2]:http://note.youdao.com/ &quot;youdaonote&quot;[3]:http://www.imooc.com/ &quot;IMOOC&quot;[网站]:http://note.youdao.com/ &quot;youdaonote&quot; 效果如下: 我经常去的网站有Baidu、有道云笔记以及IMOOC,有道云笔记是不错的网站。 6.3 自动链接语法说明:Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：代码: 12&lt;http://example.com/&gt;&lt;address@example.com&gt; 效果如下:http://example.com/&#x61;&#x64;&#100;&#x72;&#101;&#115;&#115;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#x6d; 7. 列表7.1 无序列表代码: 123* 吃饭* 睡觉* 打代码 效果如下: 吃饭 睡觉 打代码 7.2 有序列表代码: 1231. 把冰箱门打开2. 把大象关进去3. 把冰箱门带上 效果如下: 把冰箱门打开 把大象关进去 把冰箱门带上 7.3 序表嵌套代码: 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 效果如下: one one-1 two-2 two two-1 two-2 7.4 任务列表代码(方括号里是x表示打勾,空格表示为空): 123- [x] 选项一- [ ] 选项二 - [ ] 选项三 效果如下: 选项一 选项二 选项三 8. 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 8.1 内联式语法说明:![图片Alt](图片地址 “图片Title”)代码: 12爱琴海![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;) 效果如下:爱琴海 8.2 参照式语法说明:在文档要插入图片的地方写![图片Alt][标记]，在文档的最后写上[标记]:图片地址 “Title”代码: 123爱琴海![爱琴海][1][1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot; 效果如下:爱琴海 说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/574157059. 插入视频如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：1&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt; 效果如下: mark一下第一次写博客遇到的神坑: 在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 最后要感谢提供参考的大牛博客: http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13 http://www.jianshu.com/p/b03a8d7b1719]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
