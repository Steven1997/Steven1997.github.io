<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java学习总结之反射]]></title>
    <url>%2F2017%2F10%2F14%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。 1.什么是反射？反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。 2.反射的作用1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制2.在运行时分析对象的数据域3.实现通用的数组操作代码4.利用Method对象，这个对象很像C++中的函数指针 3.Class类我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是java.lang.Class&lt;T&gt;泛型类的一个实例，比如Class&lt;MyClass&gt;对象即为一个封装了MyClass类的定义信息的Class&lt;T&gt;实例，从中我们可以得出结论：万物皆对象，任何类型(包括基本类型和引用类型).class都是java.lang.Class&lt;T&gt;的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于java.lang.Class&lt;T&gt;类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。在下面的讲解中，我们将以People类和Student类为例：1234567891011121314151617181920212223242526272829public class People &#123; private String name; private int age; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println(getName() + " " + getAge()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student extends People &#123; private int grade; public Student(String name, int age) &#123; super(name, age); &#125; public Student(String name, int age, int grade) &#123; super(name, age); this.grade = grade; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; private void learn(String course) &#123; System.out.println(name + " learn " + course); &#125; &#125;``` #### 获取class对象有以下三种： 1) 可以通过`类名.class`得到相应类的Class对象，如: ```javaClass&lt;People&gt; peopleClass = People.class;``` 2) 如果已知类的**全限定名称(包含包名)**，可以通过Class的forName静态方法得到类的Class对象，如： ```javaClass&lt;People&gt; peopleClass = Class.forName("cn.habitdiary.People");//假设People类在cn.habitdiary包中``` 在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如: ```javatry&#123; String name = "xxx"; Class c1 = Class.forName(name); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; 3) 可以通过类的实例对象.getClass()得到相应类的Class对象，如：12345678910111213141516People people = new People("Steven"， 20);Class&lt;People&gt; peopleClass = people.getClass();``` `实例对象.getClass().getName()` 可以获取当前对象的类的全限定名称(包含包名) `实例对象.getClass().getSimpleName()`可以获取当前对象的类的底层类简称(不含包名) `实例对象.getClass().getCanonicalName()`大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。 但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName() **注意： 1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象 2.Class类是一个泛型类，但有时候我们不能提前确定class对象的类型,就可以用`Class&lt;?&gt;`来代替，即上面代码中的`Class&lt;People&gt; peopleClass`可以写成`Class&lt;?&gt; peopleClass` 3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作 4.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，比如:** ```javaString s = "java.util.Random";Object m = Class.forName(s).newInstance(); 如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。 4.在运行时分析类的能力下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。Java中为了支持反射机制主要提供了以下的类：java.lang.Classjava.lang.reflect.Fieldjava.lang.reflect.Constructorjava.lang.reflect.Methodjava.lang.reflect.Modifier java.lang.Class类的常用API如下： Field[] getFields() Field[] getDeclaredFields() Method[] getMethods() Method[] getDeclaredMethods() Constructor&lt; ? &gt;[] getConstructors() Constructor&lt; ? &gt;[] getDeclaredConstructors() Class&lt; ? &gt; getSupperClass() Class&lt; ? &gt;[] getInterfaces() 提示：getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有、受保护和默认成员，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象 其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。这三个类的常用API如下： String getName() 返回一个用于描述域名、构造器或方法的字符串 Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象 Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)返回一个用于描述方法抛出异常类型的Class对象数组 int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值 Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组 Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象 java.lang.reflect.Modifier类的常用API如下 static String toString(int modifiers)返回修饰符对应的字符串描述 static boolean isAbstract(int modifiers) static boolean isFinal(int modifiers) static boolean isInterface(int modifiers) static boolean isNative(int modifiers) static boolean isPrivate(int modifiers) static boolean isProtected(int modifiers) static boolean isPublic(int modifiers) static boolean isStatic(int modifiers) static boolean isStrict(int modifiers) static boolean isSynchronized(int modifiers) static boolean isVolatile(int modifiers)上述方法检测修饰符是否是某一特定修饰符java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义 下面是一个检测类内部结构的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import java.lang.reflect.*;import java.lang.Class;import java.util.Scanner;public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if(args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date)"); name = in.next(); &#125; try &#123; Class&lt;?&gt; c1 = Class.forName(name); Class&lt;?&gt; superc1 = c1.getSuperclass(); String modifiers = Modifier.toString(c1.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " " ); System.out.print("class " + name); if(superc1 != null &amp;&amp; superc1 != Object.class) System.out.print(" extends " + superc1.getSimpleName()); System.out.print("\n&#123;\n"); printFields(c1); System.out.println(); printConstructors(c1); System.out.println(); printMethods(c1); System.out.println("&#125;"); &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class&lt;?&gt; c1) &#123; Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors(); for(Constructor&lt;?&gt; c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class&lt;?&gt;[] paramTypes = c.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class&lt;?&gt; c1) &#123; Method[] methods = c1.getDeclaredMethods(); for(Method m :methods) &#123; Class&lt;?&gt; retType = m.getReturnType(); String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getSimpleName() + " " + name + "("); Class&lt;?&gt;[] paramTypes = m.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class&lt;?&gt; c1) &#123; Field[] Fields = c1.getDeclaredFields(); for(Field f : Fields) &#123; Class&lt;?&gt; type = f.getType(); String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getSimpleName() + " " + name + ";"); &#125; &#125;&#125;``` ### 5.在运行时使用反射分析对象 反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。 查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如： ```javaEmployee harry = new Empolyee("Harry Hacker",35000,10,1,1989);Class&lt;Employee&gt; c1 = harry.getClass();Field f = c1.getDeclaredField("name"); //返回某一个特定域f.setAccessible(true); //由于name是私有域，必须先设置为可访问Object v = f.get(harry);``` 上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value **下面是一些相关API** 在java.lang.reflect.Field中： * Object get(Object obj) 返回obj对象中用Field对象表示的域值* xxx getXxx(Object obj) 返回obj对象的基本类型的域的值* void set(Object obj,Object newValue) 用一个新值设置obj对象中Field对象表示的域 在java.lang.Class中： * Field getField(String name) 返回指定名称的公有域 * Field getDeclaredField(String name) * 返回指定名称的声明的域 在java.lang.reflect.AccessibleObject中： * void setAccessible(boolean flag) 为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置 * boolean isAccessible() 返回反射对象的可访问标志的值 * static void setAccessible(AccessibleObject[] array,boolean flag) 批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 ### 6.使用反射编写泛型数组代码 java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。 ```javaEmployee[] a = new Employee[100];a = Arrays.copyOf(a,2 * a.length);``` 我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试: ```javapublic static Object[] badCopyOf(Object[] a,int newLength)&#123; Object[] newArray = new Object[newLength]; System.arraycopy(a,0,newArray,0,Math.min(a.length,newLength); return newArray;&#125;``` 上述代码存在一个错误，即使用了`new Object[newLength]`创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。 **为了解决这个问题，下面提供java.lang.reflect.Array中的API** * static Object get(Object array,int index) 返回对象数组某个位置上的元素* static xxx getXxx(Object array,int index) (xxx是基本数据类型)返回基本类型数组某个位置上的值 * static void set(Object array,int index,Object newValue) 设置对象数组某个位置上的元素* static void setXxx(Object array,int index,xxx newValue) (xxx是基本数据类型)设置基本类型数组某个位置上的值 * static int getLength(Object array) 返回数组的长度 * static Object newInstance(Class componentType,int length) * static Object newInstance(Class componentType,int[] length) 返回一个具有给定类型、给定维数的新数组 下面给出正确的代码实现： ```java public static Object goodCopyOf(Object a,int newLength)&#123; &#123; Class c1 = a.getClass();//获取a数组的类对象 if(!c1.isArray()) return null;//确认是一个数组 Class componentType = c1.getComponentType(); //获取数组类型 int length = Array.getLength(a); Object newArray = Array.newInstance(componentType,newLength); System.arraycopy(a,0,newArray,0,Math.min(length,newLength)); return newArray; &#125; 这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例： int[] a = {1,2,3,4,5}; a = (int[]) goodCopyOf(a,10); 为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之继承和多态]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[父类与子类在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。 继承面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。 继承有如下几个关键点1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们3.不是所有的“是一种”(is-a)关系都该用继承来建模4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承5.Java中类与类的继承是单一继承 super关键字super关键字有两种作用：1.调用父类的构造方法因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。形式是super()或super(arguments)，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条super()有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。 2.调用父类的方法在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用super.方法名来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，super.super.方法名是不合法的。 构造方法链在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码： public class Faculty extends Employee{ public static void main(String[] args){ new Faculty(); } public Faculty(){ System.out.println("(4) Performs Faculty's tasks"); } } class Employee extends Person{ public Employee(){ this("(2) Invoke Employee's overloaded constructor"); System.out.println("(3) Perfoms Employee's tasks"); } public Employee(String s){ System.out.println(s); } } class Person{ public Person() { System.out.println("(1) Performs Person's tasks"); } } 打印结果为:(1) Performs Person’s tasks(2) Invoke Employee’s overloaded constructor(3) Performs Employee’s tasks(4) Performs Faculty’s tasks 我们可以知道：子类的构造方法的第一条语句要么是super语句(包括编译器隐式插入的),要么是this语句，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类 注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。 方法重载与重写重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同) 重写方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。为了避免错误，可以使用重写标注，在要重写的方法前加上@Override，该标注会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。 关于重写的几点注意1.仅当实例方法时刻访问的，它才能被覆盖2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法 方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。 多态Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。 动态绑定多态机制的底层实现技术是动态绑定，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。 对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。 静态绑定(前期绑定)：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。 动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。 简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。 理解方法调用假设下面要调用x.f(args)，方法调用的过程为：1） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(int)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。2） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。3） 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为private方法、构造器不能被继承，更谈不上重写，而static方法和final方法虽然能被继承，但不能被重写。4) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。 每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。方法表示例(Manager继承自Employee)： Employee:getName() -&gt; Employee.getName()getSalary() -&gt; Employee.getSalary()getHireDay() -&gt; Employee.getHireDay()raiseSalary(double) -&gt; Employee.raiseSalary(double) Manager:getName() -&gt; Employee.getName()//继承的方法getSalary() -&gt; Manager.getSalary()//重写的方法getHireDay() -&gt; Employee.getHireDay()//继承的方法raiseSalary(double) -&gt; Employee.raiseSalary(double)//继承的方法setBonus(double) -&gt; Manager.setBonus(double)//新增的方法 内联优化带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联优化所有的final方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高50%。如果确定一个类不会被派生或一个方法不会被重写，建议使用final关键字修饰。 对象类型转换和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。我们可以通过instanceof运算符来检测一个对象是否是某个类或接口的实例，其返回值是boolean类型的。注意:1.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();2.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。 Object类Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出public class xxx extends Object,在Java中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。下面介绍Object类中的几个重要方法及重写规范： 1) equals方法Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。 equals方法的原型是public boolean equals(Object obj),默认实现是: public boolean equals(Object obj){ return (this == obj); } 调用它的语法是object1.equals(object2)，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。比如类Employee定义了数据域：private String name,private double salary,private LocalDate hireDayequals方法重写如下： public boolean equals(Object obj){ if(this == obj) return true; //快速检测引用是否相等，相等返回ture if(obj == null) return false; //检测引用是否为空，为空返回false if(getClass() != obj.getClass()) return false; //检测是否属于同一个类，不是返回false Empolyee other = (Employee) obj;//向下转型 return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); //逐一比较数据域,有一个不等返回就false，否则返回true 进一步改进：改进一上述的第4步检测，可以改为 return Objects.equals(name,other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay,other.hireDay); 其中Objects.equals方法可以防备name 或 hireDay 可能为null的情况，如果两个参数都为null，Objects(a,b)返回true;如果其中一个为null，返回false;如果两个参数都不为null,调用a.equals(b)。Objects类在java.util包中。 在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。比如Manager类继承自Employee，在父类的基础上增加了private double bonus： public boolean equals(Object obj){ if(!super.equals(obj)) return false; Manager other = (Manager) obj; return bonus == other.bonus; } 改进二上述代码的第3步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用instanceof进行检测，比如雇员的ID作为相等的概念，就可以用xxx instanceof Employee进行检测，并将Empolyee.equals声明为final。 equals方法要满足下面的特性 自反性: 对于任何非空引用，x.equals(x)应该返回true 对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同 传递性：对于任何引用x、y和z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true 一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果 对于任何非空引用x,x.equals(null)应该返回false 下面我们给出编写一个完美的equals方法的建议：1) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测2) 检测引用是否为空，如果为空，不必再检测，直接返回不等3) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:if(getClass() != obj.getClass()) return false;如果所有子类都拥有统一的语义(父类决定相等)，就使用instanceof检测：if(!(obj instanceof ClassName) return false)4) 将obj向下转型为相应类的类型变量5) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测数组对象用静态的Arrays.equals方法判等 2) hashCode方法散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。String类使用下列算法计算散列码： int hash = 0; for(int i = 0;i &lt; length();i++){ hash = 31 * hash + charAt(i); } 由于hashCode方法定义在Object类中，方法原型是public int hashCode(),因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。hashCode方法应该返回一个整型数值(可以是负数),并合理地组合实例域的散列码，以便能让各个不同的对象产生的散列码更均匀。例如，下面是Employee类的hashCode方法 public int hashCode(){ return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode(); 进一步改进 public int hashCode(){ return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); 从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象 还有更简单的做法 public int hashCode(){ return Objects.hash(name,salary,hireDay); } Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID 3) toString方法方法原型是public String toString(),用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：类名@对象十六进制内存地址的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似[I@1a46e30的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。 泛型数组列表在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如： int actualSize = . . .; Employee[] staff = new Employee[actualSize]; 但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。ArrayList是一个采用类型参数的泛型类,声明方式为ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;(),从Java SE 7开始，可以省去右边的类型参数，即ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于ArrayList&lt;Object&gt;,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。 ArrayList类的常用API ArrayList&lt;E&gt;() 构造一个初始容量为10的空列表 ArrayList&lt;E&gt;(int initialCapacity)构造一个具有指定初始容量的空列表 boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true void add(int index, E element) 将指定的元素插入此列表中的指定位置。 int size() 返回此列表中的元素数。 void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。 E get(int index) 返回此列表中指定位置上的元素。 E remove(int index) 移除此列表中指定位置上的元素并返回该元素。 boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。 void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。 boolean isEmpty() 如果此列表中没有元素，则返回 true boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。 void clear() 移除此列表中的所有元素。 Object clone() 返回此 ArrayList 实例的浅表副本。 trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。 对于数组列表有用的方法1.数组和ArrayList互相转换 数组转ArrayList: String[] array = {"red","green","blue"}; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array)); ArrayList转数组: String[] array = new String[list.size()]; list.toArray(array); 2.Collections类Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。 ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。 final关键字总结final关键字在不同语句中有不同的作用：1) 修饰类变量或成员变量 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。final还可以修饰方法的局部变量，即常量2) 修饰方法 表示该方法不能被重写3) 修饰类 表示该类不能被扩展 继承的设计技巧1.将公共操作和域放在超类2.不要使用受保护的域protected机制并不能够带来更好的保护，其原因主要有两点:第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的 3.使用继承实现 “is-a” 关系4.除非所有继承的方法都有意义，否则不要使用继承比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。 5.在覆盖方法时，不要改变预期的行为6.使用多态，而非类型信息即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为 7.不要过多地使用反射反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之对象与类]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[面向对象程序设计概述 面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。 传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。 对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。 类和对象 类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。 对象：由类构造的实例，一个类可以构造多个实例。 设计类的简单规则 先从设计类的数据域开始，再向类里添加方法。 类之间的关系1.依赖(use-a) 如果A类的方法操纵B类的对象，我们说A类依赖于B类。应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。2.聚合(has-a) 如果A类对象包含B类对象，我们说A类和B类聚合。3.继承(is-a) 如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 对象与对象变量 对象是调用构造方法在堆上分配内存产生的(用new + 构造方法来调用)，而对象变量是在栈上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上产生了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。 存储区域1.创建的实例及成员变量（静、非静态）在堆中2.局部变量在栈中3.类的基本信息和方法定义在方法区 UML类图相关知识见http://www.uml.org.cn/oobject/201211231.asp 构造器 构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。 构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，不能被static修饰。 构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。 访问对象的数据和方法 在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。 引用数据域和null值 如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。 默认赋值规则 类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。 基本变量和引用变量的区别 基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。 没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。 静态/非静态变量、常量和静态/非静态方法静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。非静态方法：又称实例方法，是依赖于具体对象的方法。关系：静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。 工厂方法静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：12345NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.gerPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x));// prints $0.10System.out.println(percentFormatter.format(x));//prints 10% 使用静态工厂方法的原因主要有两个：1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类 可见性修饰符public修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public protected修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问 default缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。 privateprivate成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。 注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。 包包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句package + 包名，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。 类的导入精确导入：导入某个包的特定类,如import java.util.Scanner通配导入：导入某个包的所有类,如import java.util.*当使用多个包中的同名类时，要用包名.类名的格式编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如import static java.lang.System.*导入了System类的静态方法和静态域，就可以不加类名前缀:out.println(&quot;Hello world!&quot;)，out是System类里定义的静态成员，是PrintStream的实例。 数据域封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。实现封装的步骤：1.用private可见性修饰符修饰类成员2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue) 向方法传递对象参数可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。 对象数组和普通数组所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。 不可变对象和类一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。一个类是不可变类要满足以下三个条件：1.所有的数据域都是私有的2.没有修改器方法3.没有一个返回指向可变数据域引用的访问器方法 变量作用域一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如1234public class F&#123; private int j = i + 1; private int i;&#125; 就是错误的，因为j的初始化基于i已经被初始化的前提。 局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。 建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。 this引用this关键字有两大作用：1.表示指向调用对象本身的引用名2.可以在构造方法内部调用同一个类的其他构造方法，此时this(参数列表)语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用this(参数列表)的形式来实现它们。这样做可以简化代码，使类易于维护。 对象构造默认域初始化即依赖编译器对数据域的默认初始化。 显式域初始化在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。 无参数的构造器即将对数据域的初始化置于一个无参的构造器中。 有参数的构造器即给构造器传入参数对数据域进行初始化 初始化块即用花括号包含的一组数据域赋值代码块，一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块。 成员初始化顺序1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行。2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。3.父类的实例成员和实例初始化块，按在代码中出现的顺序依次执行。4.执行父类的构造方法。5.子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。6.执行子类的构造方法。 注意：静态成员只在构造该类的第一个对象时初始化一次，可以看作初始化类。 类设计技巧1.一定要保证数据域私有2.一定要对数据初始化最好不要依赖默认初始化，会影响程序可读性。 3.不要在类中使用过多的基本类型用其他集合了相关基本类型的类代替多个基本类型使用 4.不是所有的域都需要独立的域访问器和域修改器有的数据域定义后不必要修改 5.将职责过多的类进行分解6.类名和方法名要能够体现它们的职责7.优先使用不可变的类更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划之区间dp]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[简介区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。 算法结构设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段 For l:=2 to n do // 枚举区间长度for i:=1 to n do // 枚举区间的左端点beginj:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到if j&gt;n then break; // 保证了下标不越界for k:= i to j-1 do // 状态转移，去推出 f[i,j]f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }end; 这个结构必须记好，这是区间动态规划的代码结构。 例题石子合并题目链接:http://acm.nyist.net/JudgeOnline/problem.php?pid=737 题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。那么dp[i][j] = min(dp[i][k] + dp[k+1][j])那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2） 代码1(无优化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #define N 210 int dp[N][N],sum[N]; int main() &#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i)//枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = i; k &lt; j; ++k) &#123; dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0; &#125; ``` 代码2(平行四边形优化) ```cpp #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #define N 210 int dp[N][N],sum[N],s[N][N]; int main() &#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); s[i][i]=i; sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i) //枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = s[i][j-1]; k &lt;= s[i+1][j]; ++k)//四边形优化 &#123; if(dp[i][j]&gt;dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]) &#123; dp[i][j]=dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]; s[i][j]=k; &#125; &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0; &#125; ``` ### 括号匹配 题目链接：&lt;http://poj.org/problem?id=2955&gt; 题意:给出一串的只有‘（’ ‘）’ '[‘ ']'四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。 分析： 定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目 1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ; 2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] ) 代码 ```cpp #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;string&gt; using namespace std; const int N = 120; int dp[N][N]; int main() &#123; string s; while(cin&gt;&gt;s) &#123; if(s=="end") break; memset(dp,0,sizeof(dp)); int n = s.size(); for(int len = 2;len &lt;= n;len++)//枚举区间长度 &#123; for(int i = 0;i &lt;= n - len; i++)//枚举区间左端点 &#123; int j = i + len - 1;//确定区间右端点 if(j &gt; n) break; if(s[i]=='('&amp;&amp;s[j]==')' || s[i]=='['&amp;&amp;s[j]==']') dp[i][j]=dp[i+1][j-1]+2; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);//枚举中间位置,注意j不取等号 &#125; &#125; cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; &#125; return 0; &#125;``` 如果要求打印路径，即输出匹配后的括号 题目链接: &lt;http://poj.org/problem?id=1141&gt; 代码: ```cpp #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 120; int dp[N][N],pos[N][N]; /*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/ string s; void show(int i,int j) &#123; if(i&gt;j) return; if(i==j) &#123; if(s[i]=='('||s[i]==')') cout&lt;&lt;"()"; else cout&lt;&lt;"[]"; &#125; else &#123; if(pos[i][j]==-1) &#123; cout&lt;&lt;s[i]; show(i+1,j-1); cout&lt;&lt;s[j]; &#125; else &#123; show(i,pos[i][j]); show(pos[i][j]+1,j); &#125; &#125; &#125; int main() &#123; while(cin&gt;&gt;s) &#123; memset(dp,0,sizeof(dp)); int len=s.size(); for(int i=1; i&lt;len; i++) &#123; for(int j=0,k=i; k&lt;len; j++,k++) &#123; if(s[j]=='('&amp;&amp;s[k]==')' || s[j]=='['&amp;&amp;s[k]==']') &#123; dp[j][k]=dp[j+1][k-1]+2; pos[j][k]=-1; &#125; for(int f=j; f&lt;k; f++) &#123; if(dp[j][f]+dp[f+1][k]&gt;=dp[j][k]) &#123; dp[j][k]=dp[j][f]+dp[f+1][k]; pos[j][k]=f; &#125; &#125; &#125; &#125; show(0,len-1); cout&lt;&lt;endl; &#125; return 0; &#125; 整数划分题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=746 题意: 给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积 分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数设a[i][j]为区间[i,j]所形成的数所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i]) 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168 #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; long long dp[25][25]; long long a[25][25]; char str[25]; int main() &#123; int len, t, m; scanf("%d", &amp;t); while (t--) &#123; scanf("%s%d", str, &amp;m); len = strlen(str); m--; memset (a, 0, sizeof(a)); memset (dp, 0, sizeof(dp)); for (int i = 0; i &lt; len; i++) //先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值 &#123; a[i][i] = str[i] - '0'; for (int j = i + 1; j &lt; len; j++) &#123; a[i][j] = a[i][j - 1] * 10 + str[j] - '0'; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; dp[i][0] = a[0][i]; &#125; for (int j = 1; j &lt;= m; j++) &#123; for (int i = j; i &lt; len; i++) &#123; for (int k = 0; k &lt; i; k++) &#123; dp[i][j] = max(dp[i][j], dp[k][j - 1] * a[k + 1][i]); &#125; &#125; &#125; printf("%lld\n", dp[len - 1][m]); &#125; return 0; &#125;``` ### Halloween Costumes 题目链接：&lt;http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422&gt; 题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会 分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有①：如果在之后的区间内都不再重复利用这件衣服，那么明显 dp[i][j] = dp[i+1][j] + 1;②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，那么转移方程为 dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j]) 代码:```cpp #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n; int a[105]; int dp[105][105]; int main(void) &#123; int t; int cas = 0; scanf("%d",&amp;t); while(t--) &#123; cas ++; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) &#123; for(int j = i;j &lt;= n;j++) &#123; dp[i][j] = j-i+1; &#125; &#125; for(int i = n-1;i &gt;= 1;i--) &#123; for(int j = i+1;j &lt;= n;j++) &#123; dp[i][j] = dp[i+1][j] + 1; for(int k = i+1;k &lt;= j;k++) &#123; if(a[i] == a[k]) &#123; dp[i][j] = min(dp[i][j],dp[i][k-1] + dp[k+1][j]); &#125; &#125; &#125; &#125; printf("Case %d: %d\n",cas,dp[1][n]); &#125; return 0; &#125;``` ### Cheapest Palindrome题目链接:&lt;http://poj.org/problem?id=3280&gt; 题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。 分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况：1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值；2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小然后dp[i][j]取上面这些情况的最小值 代码 ```cpp #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int dp[2005][2005],add[27],del[27]; char s[2005]; int main() &#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)&gt;0) &#123; scanf("%s",s+1); for(int i=1;i&lt;=n;i++) &#123; char ch[10]; int tmp1,tmp2; scanf("%s%d%d",ch,&amp;tmp1,&amp;tmp2); add[ch[0]-'a'+1]=tmp1; del[ch[0]-'a'+1]=tmp2; &#125; memset(dp,0,sizeof(dp)); for(int i=m-1;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i+1][j]+add[s[i]-'a'+1],dp[i+1][j]+del[s[i]-'a'+1]); int tmp=min(dp[i][j-1]+add[s[j]-'a'+1],dp[i][j-1]+del[s[j]-'a'+1]); dp[i][j]=min(dp[i][j],tmp); if(s[i]==s[j]) dp[i][j]=min(dp[i][j],dp[i+1][j-1]); &#125; &#125; printf("%d\n",dp[1][m]); &#125; return 0; &#125; Treats for the Cows题目链接:http://poj.org/problem?id=3186 题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值 分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来转移方程：dp[i][j]=max(dp[i+1][j]+p[i](n+i-j),dp[i][j-1]+p[j](n+i-j)); 其中n-(j-i)是第几次取 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int p[2010];int dp[2010][2010];int n;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); dp[i][i]= n * p[i]; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=i;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i+1][j]+p[i]*(n+i-j),dp[i][j-1]+p[j]*(n+i-j)); &#125; printf("%d\n",dp[1][n]); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH远程登录实现本地机和服务器的文件传输]]></title>
    <url>%2F2017%2F10%2F07%2FSSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见: 在Ubuntu下通过SSH连接远程服务器 (1)用SSH登录远程ubuntu主机假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu我们在命令行输入以下命令来连接：ssh -l ubuntu 118.89.223.117之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端 (2)从远程Ubuntu主机下载文件/文件夹到本地(scp)语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径 我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件要下载文件到本地,我们要结束SSH连接,切换到本地机,输入eixt或quit即可 我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功 我们进入本地目录验证一下 hello文件的确下载到了本地 (3)从本地向远程ubuntu主机上传文件/文件夹(scp)语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径 假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下 要上传本地文件,我们要结束SSH连接,切换到本地机,输入eixt或quit即可然后输入命令$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/，输入密码后提示文件上传成功 我们通过SSH登录到远程主机验证一下,pwd打印当前所在位置，发现我们处于/home/ubuntu目录下,ls显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下通过SSH连接远程服务器]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。 环境准备装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台 步骤一:打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端$ sudo apt-get install aptitude$ sudo aptitude install openssh-server 步骤二:启动ssh-server$ /etc/init.d/ssh restart 步骤三：确认ssh-server已经正常工作$ netstat -tlptcp6 0 0 *:ssh *:* LISTEN -看到上面一行说明ssh-server已经在运行了 步骤四：在本地机终端通过ssh登录服务器$ ssh -l 远程服务器用户名 服务器ip地址接下来会提示输入密码，然后就能成功登录到服务器上了 参考http://blog.csdn.net/wh_19910525/article/details/7585257]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制修改ubuntu密码]]></title>
    <url>%2F2017%2F10%2F06%2F%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。 查了资料,总结出两种解决方法: 方法一:加上sudo权限 方法二:切换到root用户 mark一下]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习笔记]]></title>
    <url>%2F2017%2F10%2F05%2FMarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。1. 标题标题根据字体大小分级产生层次，有两种写法：写法一：1234一级标题==================二级标题--------------------- 效果如下： 一级标题二级标题写法二：123456# 一级标题## 二级标题 ### 三级标题 #### 四级标题##### 五级标题 ###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题可见#的数量越多标题字号越小，要特别注意#和标题之间要留一个空格! 2. 内联样式内联样式能描述文字的粗细、倾斜程度等2.1 语义标记：代码:123456*这是斜体*_这是斜体_**这是粗体** ***这是加粗斜体*** **_这是加粗斜体_**~~这是删除线~~ 效果如下: 这是斜体这是斜体这是粗体这是加粗斜体这是加粗斜体这是删除线 可见语义标记允许叠加 2.2 语义标签代码:123456&lt;i&gt;这是斜体&lt;/i&gt; &lt;b&gt;这是粗体&lt;/b&gt; &lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt; &lt;em&gt;这是强调&lt;/em&gt; 这是上标 Z&lt;sup&gt;a&lt;/sup&gt; 这是下标 Z&lt;sub&gt;a&lt;/sub&gt; 效果如下： 这是斜体这是粗体这是粗斜体这是强调这是上标 Za这是下标 Za 可见语义标签可以嵌套，特别要注意&lt;em&gt;&lt;/em&gt;标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用&lt;i&gt;&lt;/i&gt;标签替代 3. 引用3.1 单行式 代码: 1&gt; hello world 效果如下: hello world 3.2 多行式 代码: 123&gt; hello world &gt; hello world &gt; hello world 效果如下: hello worldhello worldhello world 3.3 嵌套式 代码: 123&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc 效果如下: aaaaaaaaa bbbbbbbbb cccccccccc 4. 换行与段落缩进换行: 在行末敲两个空格和一个回车段落缩进: 将输入法切换为全角后敲击两次空格即可完成两个字符的缩进5. 行内标记与代码块5.1 行内标记(用前后各一个`标记代码块将变成一行) 代码: 1标记之外`hello world`标记之外 效果如下: 标记之外hello world标记之外 5.2 代码块(用于插入各类型的代码) 方法一 (使用前后各一个```包裹代码生成块): 效果如下: 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 方法二 (使用Tab缩进): 代码及效果如下: 我是文字… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 注意要在前文后空一行再进行Tab缩进 方法三 (自定义语法)： 即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮 效果如下： html代码块 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; javascript代码块 12345var num = 0;for(var i = 0; i &lt; 5; i++)&#123; num += i; &#125;console.log(num); 6. 超链接 Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。 6.1 行内式语法说明: []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。 代码: 12这是[XJY&apos;s Blog](http://habitdiary.cn) 这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;) 效果如下:这是XJY’s Blog这是XJY’s Blog 6.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明:参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 代码: 12345我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。[1]:http://www.baidu.com &quot;Baidu&quot;[2]:http://note.youdao.com/ &quot;youdaonote&quot;[3]:http://www.imooc.com/ &quot;IMOOC&quot;[网站]:http://note.youdao.com/ &quot;youdaonote&quot; 效果如下: 我经常去的网站有Baidu、有道云笔记以及IMOOC,有道云笔记是不错的网站。 6.3 自动链接语法说明:Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：代码: 12&lt;http://example.com/&gt;&lt;address@example.com&gt; 效果如下:http://example.com/&#x61;&#x64;&#100;&#114;&#101;&#x73;&#115;&#64;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#x6f;&#109; 7. 列表7.1 无序列表代码: 123* 吃饭* 睡觉* 打代码 效果如下: 吃饭 睡觉 打代码 7.2 有序列表代码: 1231. 把冰箱门打开2. 把大象关进去3. 把冰箱门带上 效果如下: 把冰箱门打开 把大象关进去 把冰箱门带上 7.3 序表嵌套代码: 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 效果如下: one one-1 two-2 two two-1 two-2 7.4 任务列表代码(方括号里是x表示打勾,空格表示为空): 123- [x] 选项一- [ ] 选项二 - [ ] 选项三 效果如下: 选项一 选项二 选项三 8. 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 8.1 内联式语法说明:![图片Alt](图片地址 “图片Title”)代码: 12爱琴海![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;) 效果如下:爱琴海 8.2 参照式语法说明:在文档要插入图片的地方写![图片Alt][标记]，在文档的最后写上[标记]:图片地址 “Title”代码: 123爱琴海![爱琴海][1][1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot; 效果如下:爱琴海 说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/574157059. 插入视频如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：1&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt; 效果如下: mark一下第一次写博客遇到的神坑: 在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 最后要感谢提供参考的大牛博客: http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13 http://www.jianshu.com/p/b03a8d7b1719]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
