<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux下shell脚本对拍]]></title>
    <url>%2F2017%2F12%2F02%2FLinux%E4%B8%8Bshell%E8%84%9A%E6%9C%AC%E5%AF%B9%E6%8B%8D%2F</url>
    <content type="text"><![CDATA[在算法竞赛中，我们常常会遇到一道题一直WA的情况，这时我们不得不自己造样例，这会耗费大量时间，而且还不一定能快速确定样例的答案。所以，如果时间充足，可以写一个对拍程序。对拍程序需要四个文件：1.我们已经写好但WA的待测试文件，记为code.cpp2.一个纯暴力程序(复杂度高但能保证答案一定正确)，记为std.cpp3.一个数据生成器(用srand函数和rand函数产生随机数即可)，记为data.cpp4.一个用于比较输出的shell脚本,记为duipai.sh对拍程序，顾名思义，就是随机生成数据给两个程序分别跑一遍，看看对不对的上。 我们以一个计算1到n的和的程序为例，我们都知道计算1到n的暴力方法是用循环加和，简便方法则是使用等差数列求和公式。 下面是待测试程序code.cpp(等比数列求和,当然这里没有WA)12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;n * (n + 1) / 2&lt;&lt;endl; return 0;&#125; 下面是暴力求和程序std.cpp123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int ans = 0; for(int i = 1;i &lt;= n;i++)&#123; ans += i; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 然后是随机数据生成器data.cpp1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; srand(time(0)); int n = 100; while(n--)&#123; int k = rand() % 10 + 1; //生成100个[1,10]的随机数 cout&lt;&lt;k&lt;&lt;endl; &#125; return 0;&#125; rand函数和srand函数的用法有点忘了，参见：有关rand()，srand()产生随机数学习总结 最后是duipai.sh123456789101112#!/bin/bashwhile true; do ./data &gt; data.in ./std &lt;data.in &gt;std.out ./code &lt;data.in &gt;code.out if diff std.out code.out; then printf "AC\n" else printf "Wa\n" exit 0 fidone 这个程序的意思是运行三个可执行文件，比较std.out code.out是否相同，相同输出”AC”，不相同输出错误信息，并输出”WA”且退出。 下面开始跑对拍，先用g++编译三个cpp文件，g++ code.cpp -o code,g++ std.cpp -o std,g++ data.cpp -o data。g++ code.cpp -o code表示将code.cpp编译并连接生成一个名为code的可执行文件，如果不加 -o 选项，所有cpp文件都默认生成一个名为a.out的可执行文件。通过./a.out可以运行这个可执行文件,./表示当前目录。如果加上 -c 选项，如g++ -c code.cpp -o code则只编译不连接，会产生一个obj文件而不是exe文件。 编译完成后，输入sh duipai.sh即得结果。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jsoup简易爬取POJ题面]]></title>
    <url>%2F2017%2F12%2F01%2F%E4%BD%BF%E7%94%A8jsoup%E7%AE%80%E6%98%93%E7%88%AC%E5%8F%96POJ%E9%A2%98%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[最近校创的项目终于立项啦！一直在等答辩通知，结果无需答辩直接立项2333。马上和队友开始着手项目，目标是做一个基于习题推荐的算法分类学习平台，简单来说就是一个根据用户历史做题情况自动推荐相应难度或类型题目的Online Judge。作为ACM校队的弱菜，正好造福一下学弟学妹ORZ当然，作为一个新兴的OJ，肯定是没有题目来源的，所以我们把罪恶的双手(嘘~)伸向了一些目前主流的OJ。我们需要用爬虫技术爬取这些OJ的题面，并提取总提交数和通过数来计算AC率，从而把AC率作为题目难度的一个指标，以便后续实现题目推荐。之前没有写过爬虫，队友告诉我Java可以用jsoup库很方便地解析html网页的元素。于是粗略学习了jsoup,再配合一点CSS选择器的知识，这对于一般的html网页的爬取就够用了，下面是几个学习的网站：jsoup Cookbook(中文版)CSS 选择器 我分到的是POJ，打开Problems，选择第一道题，即A+B Problem。查看网页的源代码发现TABLE标签之后的table标签恰好包括了所有我需要的信息(POJ真友好啊)，将爬到的内容重定向到一个html文件，我们就得到了题面。核心代码只有几行，不多说上代码：123456789101112131415161718192021222324252627282930import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;import java.util.Iterator;import java.util.List;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.nodes.Node;import org.jsoup.select.Elements;public class Crawler &#123; public static void main(String[] args) throws IOException &#123; for(int pid = 1000;pid &lt;= 1100;pid++) &#123; Document doc = Jsoup.connect("http://poj.org/" +"problem?id=" + pid).get(); Elements text = doc.select("TABLE+table"); //选择TABLE标签之后的table标签 text.select(".ptt").attr("align", "center"); //题目没有居中，添加居中属性 System.setOut(new PrintStream(new FileOutputStream("problem"+pid+".html"))); System.out.println(text); //重定向输出到html文件 &#125; &#125; &#125; 耐心等待爬取题目编号为1000到1100的题目,显示如下：用浏览器打开problem1000.html，效果如下：大功告成！！！]]></content>
      <tags>
        <tag>Java</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之Java IO系统]]></title>
    <url>%2F2017%2F11%2F28%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava-IO%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。先上一个Java IO流类层次图，如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据：是不是被吓到了？没关系，我们将通过一个个例子来学习这些功能。 读取控制台输入在Java中，从控制台输入有三种方法： 1.使用标准输入流对象System.inSystem.in是System中内置的InputStream类对象，它的read方法一次只读入一个字节数据，返回0 ~ 255的一个int字节值,一般用来读取一个字符，需要强制类型转换为char类型，而我们通常要取得一个字符串或一组数字，故这种方法不常用。下面给出这种方法的一个例子：1234567891011public class CharTest&#123;public static void main(String[] args) &#123; try&#123; System.out.print("Enter a Char:"); char i = (char)System.in.read(); System.out.println("Yout Enter Char is:" + i); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 使用这种方法必须提供try-catch块或者在main方法首部声明IOException异常 2.使用Scanner类Scanner类功能十分强大，可以读入字符串、整数、浮点数、布尔类型值等等。下面是例子：1234567891011121314public class ScannerTest&#123;public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); System.out.println("ScannerTest, Please Enter Name:"); String name = sc.nextLine(); //读取字符串型输入 System.out.println("ScannerTest, Please Enter Age:"); int age = sc.nextInt(); //读取整型输入 System.out.println("ScannerTest, Please Enter Salary:"); float salary = sc.nextFloat(); //读取float型输入 System.out.println("Your Information is as below:"); System.out.println("Name:" + name +"\n" + "Age:"+age + "\n"+"Salary:"+salary); &#125; &#125; 注意：1.用nextXXX()读入XXX类型的数据，XXX可以是除了char外的所有基本数据类型，还可以是BigInteger或BigDecimal，其中凡是整型类型的数据还可以指定radix(进制)，可以用next()和nextLine()读取一个字符串或一行字符2.next()和nextLine()的区别：next() 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine() 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 3.可以用循环配合hasNextXXX方法判断输入是否继续4.Scanner类没有直接提供读取一个字符的方法，如果要读取一个字符，有三种方法，一是读入一个字符串后取字符串的第一个字符，二是使用System.in的read方法，三是使用字符流读入 3.使用BufferedReader对象可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。下面是创建 BufferedReader 的基本语法：12BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符(读入一个用0~65535之间的整数表示的字符，需要强制类型转换为char类型，如果已到达流末尾，则返回 -1)，或者用 readLine() 方法读取一个字符串。下面是例子：1234567891011121314public static void main(String[] args)&#123;//必须要处理java.io.IOException异常 BufferedReader br = new BufferedReader(new InputStreamReader (System.in )); //java.io.InputStreamReader继承了Reader类 String read = null; System.out.print("输入数据："); try &#123; read = br.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("输入数据："+read); &#125; 下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。12345678910111213141516171819// 使用 BufferedReader 在控制台读取字符 import java.io.*; public class BRRead &#123; public static void main(String args[]) throws IOException &#123; char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println("输入字符, 按下 'q' 键退出。"); // 读取字符 do &#123; c = (char) br.read(); System.out.println(c); &#125; while(c != 'q'); &#125;&#125; 下面的程序读取和显示字符行直到你输入了单词”end”。1234567891011121314151617// 使用 BufferedReader 在控制台读取字符import java.io.*;public class BRReadLines &#123; public static void main(String args[]) throws IOException &#123; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str; System.out.println("Enter lines of text."); System.out.println("Enter 'end' to quit."); do &#123; str = br.readLine(); System.out.println(str); &#125; while(!str.equals("end")); &#125;&#125; 在ACM等算法竞赛中，我们常常也会使用Java，在输入数据时有以下几点注意：1.hasXXX等价于C++中读到文件末尾(EOF)2.使用BufferedReader输入会比Scanner输入快十倍左右! 控制台输出控制台的输出由 print() 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类的一个对象。PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。PrintStream 定义 write() 的最简单格式如下所示：void write(int byteval)该方法将 byteval 的低八位字节写到流中,即System.out的write方法一次只能写一个字节(类比System.in的read方法一次只能读取一个字节)。下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：1234567891011import java.io.*; // 演示 System.out.write().public class WriteDemo &#123; public static void main(String args[]) &#123; int b; b = 'A';//向上类型转换 System.out.write(b); System.out.write('\n'); &#125;&#125; 注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。 读写文件下面将要讨论的两个重要的流是 FileInputStream 和 FileOutputStream：FileInputStream该流用于从文件读取数据，它的对象可以用关键字 new 来创建。有多种构造方法可用来创建对象。可以使用字符串类型的文件名来创建一个输入流对象来读取文件：1InputStream f = new FileInputStream("C:/java/hello"); 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：12File f = new File("C:/java/hello");InputStream out = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。下面是一个例子：1234567public static void main(String[] args) throws IOException&#123; InputStream f = new FileInputStream ("/home/xiejunyu/桌面/test.txt"); int c; while((c = f.read()) != -1) System.out.println((char)c);&#125; 注意: 每调用一次read方法,当前读取在文件中的位置就会向后移动一个字节，已经到文件末尾会返回-1，可以通过read方法返回-1判断是否读到文件末尾，也可以使用available方法返回下一次可以不受阻塞读取的字节数来读取。FileInputStream不支持mark和reset方法进行重复读取。 FileOutputStream该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。有两个构造方法可以用来创建 FileOutputStream 对象。使用字符串类型的文件名来创建一个输出流对象：1OutputStream f = new FileOutputStream("C:/java/hello") 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：12File f = new File("C:/java/hello");OutputStream f = new FileOutputStream(f); 创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。下面是一个演示 InputStream 和 OutputStream 用法的例子：123456789101112131415161718192021222324import java.io.*; public class FileStreamTest&#123; public static void main(String args[])&#123; try&#123; byte bWrite [] = &#123;'A','B','C'&#125;; OutputStream os = new FileOutputStream("/home/xiejunyu/桌面/test.txt"); for(int x=0; x &lt; bWrite.length ; x++)&#123; os.write(bWrite[x] ); // writes the bytes &#125; os.close(); InputStream is = new FileInputStream("/home/xiejunyu/桌面/test.txt"); int size = is.available(); for(int i=0; i&lt; size; i++)&#123; System.out.print((char)is.read() + " "); &#125; is.close(); &#125;catch(IOException e)&#123; System.out.print("Exception"); &#125; &#125;&#125; 上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*; public class fileStreamTest2&#123; public static void main(String[] args) throws IOException &#123; File f = new File("a.txt"); FileOutputStream fop = new FileOutputStream(f); // 构建FileOutputStream对象,文件不存在会自动新建 OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8"); // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk writer.append("中文输入"); // 写入到缓冲区 writer.append("\r\n"); //换行 writer.append("English"); // 刷新缓冲区,写入到文件,如果下面已经没有写入的内容了,直接close也会写入 writer.close(); //关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉 fop.close(); // 关闭输出流,释放系统资源 FileInputStream fip = new FileInputStream(f); // 构建FileInputStream对象 InputStreamReader reader = new InputStreamReader(fip, "UTF-8"); // 构建InputStreamReader对象,编码与写入相同 StringBuffer sb = new StringBuffer(); while (reader.ready()) &#123; sb.append((char) reader.read()); // 转成char加到StringBuffer对象中 &#125; System.out.println(sb.toString()); reader.close(); // 关闭读取流 fip.close(); // 关闭输入流,释放系统资源 &#125;&#125; 除了FileInputStream和FileOutputStream外，还有一些其他的输入输出流：ByteArrayInputStream字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中。创建字节数组输入流对象有以下几种方式。接收字节数组作为参数创建：12ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] a); 另一种创建方式是接收一个字节数组，和两个整型变量 off、len，off表示第一个读取的字节，len表示读取字节的长度,即将字节数组中从off开始的len个字节读入该输入流。12ByteArrayInputStream bArray = newByteArrayInputStream(byte []a,int off,int len) 成功创建字节数组输入流对象后，可以参见以下列表中的方法，对流进行读操作或其他操作。ByteArrayOutputStream字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中。创建字节数组输出流对象有以下几种方式。下面的构造方法创建一个32字节（默认大小）的缓冲区。1OutputStream bOut = new ByteArrayOutputStream(); 另一个构造方法创建一个大小为n字节的缓冲区。1OutputStream bOut = new ByteArrayOutputStream(int a) 成功创建字节数组输出流对象后，可以参见以下列表中的方法，对流进行写操作或其他操作。下面的例子演示了ByteArrayInputStream 和 ByteArrayOutputStream的使用：1234567891011121314151617181920212223242526import java.io.*;public class ByteStreamTest &#123; public static void main(String args[])throws IOException &#123; ByteArrayOutputStream bOutput = new ByteArrayOutputStream(12); while( bOutput.size()!= 10 ) &#123; // 获取用户输入 bOutput.write(System.in.read()); &#125; byte b [] = bOutput.toByteArray(); System.out.println("Print the content"); for(int x= 0 ; x &lt; b.length; x++) &#123; // 打印字符 System.out.print((char)b[x] + " "); &#125; System.out.println(" "); int c; ByteArrayInputStream bInput = new ByteArrayInputStream(b); System.out.println("Converting characters to Upper case " ); for(int y = 0 ; y &lt; 1; y++ ) &#123; while(( c= bInput.read())!= -1) &#123; System.out.println(Character.toUpperCase((char)c)); &#125; bInput.reset(); &#125; &#125;&#125; DataInputStream数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。下面的构造方法用来创建数据输入流对象。1DataInputStream dis = new DataInputStream(InputStream in); 另一种创建方式是接收一个字节数组，和两个整形变量 off、len，off表示第一个读取的字节，len表示读取字节的长度。1DataInputStream dis = new DataInputStream(byte[] a,int off,int len); DataOutputStream数据输出流允许应用程序以与机器无关方式将Java基本数据类型写到底层输出流。下面的构造方法用来创建数据输出流对象。1DataOutputStream out = new DataOutputStream(OutputStream out); 创建对象成功后，可以参照以下列表给出的方法，对流进行写操作或者其他操作。下面的例子演示了DataInputStream和DataOutputStream的使用，该例从文本文件test.txt中读取5行，并转换成大写字母，最后保存在另一个文件test1.txt中。123456789101112131415161718192021import java.io.*;public class Test&#123; public static void main(String args[])throws IOException&#123; DataInputStream d = new DataInputStream(new FileInputStream("test.txt")); DataOutputStream out = new DataOutputStream(new FileOutputStream("test1.txt")); String count; while((count = d.readLine()) != null)&#123; String u = count.toUpperCase(); System.out.println(u); out.writeBytes(u + " ,"); &#125; d.close(); out.close(); &#125;&#125; 还有一些关于文件和I/O的类，我们也需要知道：FileJava文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等(注意File类不涉及文件内容的变化)。File对象代表磁盘中实际存在的文件和目录。创建一个File对象不等于创建了文件本身，如果文件不存在，也可以创建一个File对象，使用对象的createNewFile可以真正创建不存在的文件。通过以下构造方法创建一个File对象。通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。1File(File parent, String child); 通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。1File(String pathname); 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。1File(String parent, String child) 通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。1File(URI uri) 创建File对象成功后，可以使用以下列表中的方法操作文件。序号 方法描述1 public String getName()返回由此抽象路径名表示的文件或目录的名称。2 public String getParent()、 返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 null。3 public File getParentFile()返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回 null。4 public String getPath()将此抽象路径名转换为一个路径名字符串。5 public boolean isAbsolute()测试此抽象路径名是否为绝对路径名。6 public String getAbsolutePath()返回抽象路径名的绝对路径名字符串。7 public boolean canRead()测试应用程序是否可以读取此抽象路径名表示的文件。8 public boolean canWrite()测试应用程序是否可以修改此抽象路径名表示的文件。9 public boolean exists()测试此抽象路径名表示的文件或目录是否存在。10 public boolean isDirectory()测试此抽象路径名表示的文件是否是一个目录。11 public boolean isFile()测试此抽象路径名表示的文件是否是一个标准文件。12 public long lastModified()返回此抽象路径名表示的文件最后一次被修改的时间。13 public long length()返回由此抽象路径名表示的文件的长度。14 public boolean createNewFile() throws IOException当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。15 public boolean delete() 删除此抽象路径名表示的文件或目录。 16 public void deleteOnExit()在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。17 public String[] list()返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。18 public String[] list(FilenameFilter filter)返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。19 public File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件。20 public File[] listFiles(FileFilter filter)返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。21 public boolean mkdir()创建此抽象路径名指定的目录。22 public boolean mkdirs()创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。23 public boolean renameTo(File dest) 重新命名此抽象路径名表示的文件。 24 public boolean setLastModified(long time)设置由此抽象路径名所指定的文件或目录的最后一次修改时间。25 public boolean setReadOnly()标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。26 public static File createTempFile(String prefix, String suffix, File directory) throws IOException在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。27 public static File createTempFile(String prefix, String suffix) throws IOException在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。28 public int compareTo(File pathname)按字母顺序比较两个抽象路径名。29 public int compareTo(Object o)按字母顺序比较抽象路径名与给定对象。30 public boolean equals(Object obj)测试此抽象路径名与给定对象是否相等。31 public String toString() 返回此抽象路径名的路径名字符串。 下面的实例演示了File对象的使用：123456789101112131415161718192021import java.io.File;public class DirList &#123; public static void main(String args[]) &#123; String dirname = "/java"; File f1 = new File(dirname); if (f1.isDirectory()) &#123; System.out.println( "Directory of " + dirname); String s[] = f1.list(); for (int i=0; i &lt; s.length; i++) &#123; File f = new File(dirname + "/" + s[i]); if (f.isDirectory()) &#123; System.out.println(s[i] + " is a directory"); &#125; else &#123; System.out.println(s[i] + " is a file"); &#125; &#125; &#125; else &#123; System.out.println(dirname + " is not a directory"); &#125; &#125;&#125; FileReaderFileReader类从InputStreamReader类继承而来。该类按字符读取流中数据。可以通过以下几种构造方法创建需要的对象。在给定从中读取数据的 File 的情况下创建一个新 FileReader。1FileReader(File file) 在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。1FileReader(FileDescriptor fd) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。1FileReader(String fileName) 创建FIleReader对象成功后，可以参照以下列表里的方法操作文件。FileWriterFileWriter 类从 OutputStreamWriter 类继承而来。该类按字符向流中写入数据。可以通过以下几种构造方法创建需要的对象。在给出 File 对象的情况下构造一个 FileWriter 对象。1FileWriter(File file) 在给出 File 对象的情况下构造一个 FileWriter 对象。1FileWriter(File file, boolean append) 构造与某个文件描述符相关联的 FileWriter 对象。1FileWriter(FileDescriptor fd) 在给出文件名的情况下构造 FileWriter 对象，它具有指示是否挂起写入数据的 boolean 值。1FileWriter(String fileName, boolean append) 创建FileWriter对象成功后，可以参照以下列表里的方法操作文件。下面的例子演示了FileReader和FileWriter的使用123456789101112131415161718192021import java.io.*;public class FileRead&#123; public static void main(String args[])throws IOException&#123; File file = new File("Hello1.txt"); // 创建文件 file.createNewFile(); // creates a FileWriter Object FileWriter writer = new FileWriter(file); // 向文件写入内容 writer.write("This\n is\n an\n example\n"); writer.flush(); writer.close(); //创建 FileReader 对象 FileReader fr = new FileReader(file); char [] a = new char[50]; fr.read(a); // 从数组中读取内容 for(char c : a) System.out.print(c); // 一个个打印字符 fr.close(); &#125;&#125; Java中的目录创建目录：File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 mkdirs()方法创建一个文件夹和它的所有父文件夹。下面的例子创建 “/tmp/user/java/bin”文件夹： 12345678910import java.io.File; public class CreateDir &#123; public static void main(String args[]) &#123; String dirname = "/tmp/user/java/bin"; File d = new File(dirname); // 现在创建目录 d.mkdirs(); &#125;&#125; mkdirs是递归创建文件夹，允许在创建某文件夹时其父文件夹不存在,从而一同创建;mkdir必须满足路径上的父文件夹全都存在注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。读取目录：一个目录其实就是一个 File 对象，它包含其他文件和文件夹。如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容： 12345678910111213141516171819202122import java.io.File; public class DirList &#123; public static void main(String args[]) &#123; String dirname = "/tmp"; File f1 = new File(dirname); if (f1.isDirectory()) &#123; System.out.println( "目录 " + dirname); String s[] = f1.list(); for (int i=0; i &lt; s.length; i++) &#123; File f = new File(dirname + "/" + s[i]); if (f.isDirectory()) &#123; System.out.println(s[i] + " 是一个目录"); &#125; else &#123; System.out.println(s[i] + " 是一个文件"); &#125; &#125; &#125; else &#123; System.out.println(dirname + " 不是一个目录"); &#125; &#125;&#125; 删除目录或文件：删除文件可以使用 java.io.File.delete() 方法。以下代码会删除目录/tmp/java/，即便目录不为空。测试目录结构：123/tmp/java/|-- 1.log|-- test deleteFolder是一个递归函数，类似于DFS思想123456789101112131415161718192021222324import java.io.File; public class DeleteFileDemo &#123; public static void main(String args[]) &#123; // 这里修改为自己的测试目录 File folder = new File("/tmp/java/"); deleteFolder(folder); &#125; //删除文件及目录 public static void deleteFolder(File folder) &#123; File[] files = folder.listFiles(); if(files!=null) &#123; for(File f: files) &#123; if(f.isDirectory()) &#123; deleteFolder(f); &#125; else &#123; f.delete(); &#125; &#125; &#125; folder.delete(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用telnet发送HTTP请求报文]]></title>
    <url>%2F2017%2F11%2F19%2F%E4%BD%BF%E7%94%A8telnet%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[我们可以使用telnet给特定的Web服务器发送HTTP请求报文，得到服务器的HTTP相应报文。 比如，打开终端输入下面命令： telnet www.baidu.com 80 //Web服务器ip或域名、端口GET https://www.baidu.com/ HTTP/1.1//请求行：方法字段、URL字段、HTTP版本字段Host: www.baidu.com //首部行 在输入最后一个首部行之后连续按两次回车，这就打开一个到主机 www.baidu.com 的80端口的TCP连接，并发送一个HTTP请求报文。你将会看到一个携带包括百度主页的HTML基本文件的相应报文(HTML文件，即对象被封装在相应报文的实体体中)。如果只是想看一下HTTP协议的报文行，而不是获取对象本身的话，可以用HEAD代替GET。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用telnet登录SMTP服务发送邮件]]></title>
    <url>%2F2017%2F11%2F19%2F%E4%BD%BF%E7%94%A8telnet%E7%99%BB%E5%BD%95SMTP%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在看《计算机网络自顶向下方法》，初步了解了SMTP协议。尝试用telnet登录SMTP服务给自己的qq邮箱发送了一封邮件，中间踩了很多坑，现在把具体步骤总结如下： 1.打开终端，输入telnet,回车 2.输入o smtp.139.com 25,此处o是open的缩写,以139邮箱为例,25表示SMTP服务器时刻监听的端口号,登录SMTP服务器。服务器返回220 localhost richmail system v10(2eff5a1190ba8e2-ea850)表示成功 3.输入HELO xxx,和服务器打招呼,xxx可以是任意内容,确认服务器应答,服务器返回250 localhost richmail system v10(2eff5a1190ba8e2-ea850)表示成功 4.输入auth login,请求登录,服务器返回334 dXNlcm5hbWU6,334是成功的状态码,后面是 username: 的base64码,可以在网上找到编码和解码工具 5.输入转换为base64码后的发送邮箱的用户名,不用带邮件域名，服务器返回334 UGFzc3dvcmQ6，334是成功的状态码，后面是 password: 的base64码 6.输入转换为base64码后的发送邮箱的密码,服务器返回235 Authentication successful表示登录成功 7.输入MAIL FROM:&lt;发件人邮箱地址&gt;，告诉服务器发信人的地址,服务器返回250 Mail OK表示成功 8.输入RCPT TO:&lt;收件人邮箱地址&gt;，告诉服务器收信人的地址,服务器返回250 Mail OK表示成功 9.输入DATA,开始写邮件,服务器返回354 End data with .提示邮件以一个单独占有一行的.结束 10.邮件格式如下:123456To:收件人邮箱地址From:发件人邮箱地址Subject:邮件主题 //前三行是首部行 //首部行和报文体之间要有一个空行 邮件正文 //报文体． //结束邮件的标志 服务器返回250 ok表示发送成功，如果要继续发送，则返回步骤7重复即可。 11.发送完所有邮件之后输入QUIT,关闭TCP连接 下面是成功接收的邮件 注意几个坑：1.发件方使用的是139邮箱，尝试qq邮箱和163邮箱开启了SMTP服务也不成功，可能是基于安全性考虑进行了限制2.收件方邮箱如果有反垃圾机制，应该事先关闭，否则会拒绝接收邮件]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之异常处理]]></title>
    <url>%2F2017%2F11%2F08%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[引言在程序运行过程中(注意是运行阶段，程序可以通过编译)，如果JVM检测出一个不可能执行的操作，就会出现运行时错误。例如，使用一个越界的下标访问数组，程序就会产生一个ArrayIndexOutOfBoundsException的运行时错误。如果程序需要输入一个整数的时候用户输入了一个double值，会得到一个InputMismatchException的运行时错误。在Java中，运行时错误会作为异常抛出。异常就是一种对象，表示阻止正常进行程序执行的错误或者情况。如果异常没有被处理，那么程序就会非正常终止。人们在遇到错误时会感觉不爽。如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序了，为了避免这类事情的发生，至少应该做到以下几点： 向用户通告错误 保存所有的工作结果 允许用户以妥善的形式退出程序 Java使用一种称为异常处理的错误捕获机制处理，从而使程序继续运行或优雅终止。 异常处理概述异常处理使得程序可以处理非预期的情景，并且继续正常的处理。我们来看一个读取两个整数并显示它们商的例子：12345678910public class Quotient&#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); System.out.println(number1 + " / " + number2 + " is " + (number1 / number2)); &#125;&#125; 如果number2为0,就会产生一个运行时错误，因为不能用一个整数除以0(注意，一个浮点数除以0不会产生异常)。我们可以添加一个if语句来测试第二个数据：12345678910111213public class Quotient&#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); if(number2 != 0) System.out.println(number1 + " / " + number2 + " is " + (number1 / number2)); else System.out.println("Divisor cannot be zero"); &#125;&#125; 为了介绍异常处理，我们使用一个方法来实现两个整数求商的操作：12345678910111213141516public class QuotientWithMethod &#123; public static int quotient(int number1,int number2) &#123; if(number2 == 0) &#123; System.out.println("Divisor cannot be zero"); System.exit(0); &#125; return number1 / number2; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); int result = quotient(number1,number2); System.out.println(number1 + " / " + number2 + " is " + result); 但上述代码有一个问题：当number2为0时，程序在quotient方法内终止。但不应该让一个方法来终止程序 —— 应该由方法的调用者决定是否终止程序，即方法只需要通知其调用者有运行时错误产生，而不应该自己做决定。下面使用异常处理的方法，让quotient方法抛出一个异常，使其被调用这捕获和处理：12345678910111213141516171819202122232425public class QuotientWithException &#123; public static int quotient(int number1,int number2) &#123; if (number2 == 0) throw new ArithmeticException("Divisor cannot be zero"); return number1 / number2; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("Enter two integers: "); int number1 = input.nextInt(); int number2 = input.nextInt(); try&#123; int result = quotient(number1,number2); System.out.println(number1 + " / " + number2 + " is " + result); &#125; catch(ArithmeticException ex) &#123; System.out.println("Exception: an integer " + "cannot be divided by zero"); &#125; System.out.println("Execution continues ..."); &#125;&#125; 我们可以看到，上面的代码能使方法抛出一个异常给调用者，并由调用者处理该异常。如果不这么做，被调用的方法本身必须处理异常或者终止程序。但是库方法在设计时通常无法确定在出错时要进行什么操作，最好的做法就是将检测出的错误作为异常抛出给调用者处理，查阅API我们也会发现库方法会对其可能抛出的异常进行说明。异常处理的最根本优势就是将检测错误(由被调用的方法完成)从处理错误(由调用方法完成)中分离出来。当然，如果运行时错误发生在main方法中，就不必抛出异常了，可以考虑提供一个异常处理器对异常进行捕获和处理。 异常类型异常是对象，而对象都采用类来定义。在 Java 程序设计语言中， 异常对象都是派生于 Throwable 类的一个实例。稍后还可以看到，如果 Java 中内置的异常类不能够满足需求，用户可以创建自己的异常类。 下面是Java中的异常层次结构： 可以看到，Throwable是所有异常类的根类，所有异常类都直接或间接继承自 Throwable。但在下一层立即分解为两个分支：Error 和 Exception。Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。这种情况很少出现。在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于RuntimeException;而程序本身没有问题，但由于像 I/O 错误这类问题导致的异常属于其他异常。有一条相当有道理的规则：如果出现 RuntimeException，那么就一定是你的问题。也就是说，RuntimeException是可以在编程时避免的。比如，可以通过检测数组下标是否越界来避免IndexOutOfBoundsException，可以通过在使用变量前检测是否为null杜绝NullPointerException。 免检异常：又称非受查异常，RuntimeException、Error以及它们的子类都称为免检异常。意思是编译器不会强制检查程序是否处理或声明了异常。必检异常：又称受查异常，除了免检异常的其他异常都是必检异常，意思是编译器会强制程序员检查并通过try-catch语句处理它们，或者在方法头进行声明，否则无法通过编译。 关于异常处理的更多知识异常处理器是通过从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到的。即如果某方法的异常没有在该方法内被捕获和处理，就会被抛出给它的调用者，并在调用者中搜寻相应的异常处理器，如果还没有找到就继续上抛，如果在整个方法调用链中异常都没有被捕获处理，该异常会被抛给JVM，JVM会终止程序并打印错误信息。Java的异常处理模型基于三种操作： 声明异常 抛出异常 捕获异常 声明异常一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误。例如，一段读取文件的代码知道有可能读取的文件不存在， 或者内容为空，因此， 试图处理文件信息的代码就需要通知编译器可能会抛出 IOException 类的异常。方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映出这个方法可能抛出异常。每个方法只需声明所有它可能抛出的必检异常类型，这称为声明异常。无需声明免检异常，因为免检异常要么不可控制(Error)，要么就应该避免发生(RuntimeException)。可以声明多个异常，用逗号隔开即可：1public void myMethod() throws Exception1, Exception2,... 当然，从前面的示例中可以知道：除了声明异常之外， 还可以捕获异常。这样会使异常不被抛到方法之外，也不需要 throws 规范。稍后，将会讨论如何决定一个异常是被捕获，还是被抛出让其他的处理器进行处理。下面有一些规则： 如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用(也就是说，子类方法中可以抛出更特定的异常，或者根本不抛出任何异常) 如果在超类方法中没有声明/抛出异常，子类也不能声明/抛出异常 抛出异常检测到错误的程序可以创建一个合适的异常类型的实例并抛出它，这就称为抛出异常。下面有一个例子，方法的参数必须是非负的，如果传入一个负参数，程序就创建一个IllegalArgumentException实例并抛出它：123IllegalArgumentException ex = new IllegalArgumentException("Wrong Argument");throw ex; 或者1throw new IllegalArgumentException("Wrong Argument"); 第一种写法创建了一个异常对象并赋给一个异常类引用变量，并抛出它;第二种写法则直接抛出一个匿名异常对象。Java库中每个异常类一般至少有两个构造方法：一个无参构造方法和一个带可描述这个异常的String参数的构造方法。如上述就使用了带参数的构造方法并传入了”Wrong Argument”的异常描述。可以通过在异常对象上调用getMessage()获取异常描述字符串。抛出异常的三个步骤： 找到一个合适的异常类 创建这个类的一个对象 将对象抛出 注意：这里所说抛出异常是指我们在编写程序时用throw关键字显式抛出异常，但是在很多情况下，异常是由库方法抛出的，throw关键字被封装在库方法中，对用户是不可见的，此时用户程序中是没有显式的throw关键字的。 捕获异常当抛出一个异常时，可以提供try-catch语句来捕获和处理它，如下所示：12345678910111213try &#123; statements; // Statements that may throw exceptions &#125; catch(Exception exVar1) &#123; handler for exception1; &#125; catch(Exception exVar2) &#123; handler for exception2; &#125; ... catch(Exception exVarN) &#123; handler for exceptionN; &#125; 可以为一个try块提供多个catch语句，因为一个try块可能抛出多种不同类型的异常。如果在执行try块的过程中没有出现异常，则跳过catch子句。如果try块中的某条语句抛出一个异常，Java就会跳过try块中剩余的语句，然后开始查找合适的处理异常的代码，即异常处理器。可以从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到这个处理器。从第一个到最后一个逐个检查catch块，判断在catch块中的异常类变量是否是该异常对象的类型。如果是，就将该异常对象赋值给所声明的变量，然后执行catch块中的代码。如果没有发现异常处理器，Java会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来查找处理器。如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息。寻找处理器的过程称为捕获异常。注意：如果一个catch块可以捕获一个父类的异常对象，它就能捕获那个父类的所有子类的异常对象。在catch块中异常被指定的顺序是非常重要的，如果父类异常的catch块在子类异常的catch块之前，就会导致编译错误。道理很简单，如果将父类异常的catch块放在子类异常的catch块之前，则子类异常对象一定会被父类异常的catch块捕获，子类异常的catch块就失去了意义。对于使用同样的处理代码处理多个异常的情况，可以使用多捕获特征简化异常的代码编写，如：123catch(Exception1 | Exception2 | ... | ExceptionN ex) &#123; // Same code for handling these exceptions&#125; 创建自定义异常类在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。在这种情况下，我们可以通过派生Exception类或其子类来创建自定义的异常类。下面给出一个例子，当半径为负时，setRadius方法会抛出一个异常：1234567891011public class InvalidRadiusException extends Exception &#123; private double radius; public InvalidRadiusException(double radius) &#123; super("Invalid radius " + radius); this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125; 可见异常类里可定义数据域和访问器，使外界能访问到导致异常的非法参数。注意：建议不要让自定义的异常类继承RuntimeException及其子类，这样会使自定义的异常类称为免检异常，最好使自定义的异常类必检，这样编译器就可以在程序中强制捕获或声明这些异常。 从异常中获取信息异常对象中包含了关于异常的有价值的信息，可以利用Throwable类中的实例方法获取有关的信息，如下所示： Throwable() 无参构造器 Throwable(String message) 带描述异常信息字符串的构造器 String getMessage() 返回一个描述该异常对象信息的字符串 String toString() 返回三个字符串的连接：1) 异常类的全名; 2) “: “ 一个冒号和一个空格 3) getMessage(方法) void printStackTrace() 在控制台上打印 Throwable对象和它的调用堆栈信息 同样Exception和RuntimeException也有类似的方法堆栈轨迹(stack trace)是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。类似于数据结构中的栈，一个方法被调用就会入栈，即最先被调用的方法(main方法)在栈底，后被调用的方法在栈顶。当一个方法调用结束，就会出栈，也是栈顶方法先出栈，最后main方法也调用完毕，整个方法栈被销毁，程序结束。Throwable的printStackTrace方法就是这样从上到下打印了方法栈，栈顶是产生异常的方法，栈底是main方法。比如下面的代码访问了数组的-1下标，抛出一个ArrayIndexOutOfBoundsException：123456789public class TestException &#123; public static void main(String[] args) &#123; int[] array = &#123;1,2,3,4,5&#125;; printArrayElement(array,-1); &#125; public static void printArrayElement(int[] a,int index) &#123; System.out.println(a[index]); &#125;&#125; 打印的堆栈轨迹是：一种更灵活的方法是getStackTrace()，它会得到一个StackTraceElement对象的一个数组，每个元素都是方法堆栈中的一个方法，其API如下： 再次抛出异常与异常链当异常被捕获之后，可以在catch子句中重新抛出异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用的子系统，那么，用于表示子系统的异常类型可能会产生多种解释。ServletException就是这样一个异常类型的例子。执行servlet的代码可能不想知道发生错误的细节原因，但希望明确地知道servlet是否有问题。同原始异常一起抛出一个新异常(带有附加信息)，这称为异常链。下面给出了抛出异常链的基本方法：123456789try &#123; access the database&#125;catch(SQLException e)&#123; Throwable se = new ServletException("database error: " + e.getMessage());&#125; 不过，我们发现原始异常被改变了。有一种更好的处理方法，可以将原始异常设置为新异常的”原因”：12345678910try &#123; access the database&#125;catch(SQLException e)&#123; Throwable se = new ServletException("database error"); se.initCause(e); throw se;&#125; 当捕获到异常时，就可以使用下面的这条语句重新得到原始异常：1Throwable e = se.getCause(); 强烈建议使用这种包装技术，这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。 finally子句当代码抛出一个异常时，就会终止方法中剩余代码的处理，并退出这个方法的执行。如果方法获得了一些本地资源，并且只有这个方法自己知道，又如果这些资源在退出方法之前必须被回收，那么就会产生资源回收问题。一种解决方案是捕获并重新抛出所有的异常。但是，这种解决方案比较乏味，这是因为需要在两个地方清除所分配的资源。一个在正常的代码中；另一个在异常代码中。Java 有一种更好的解决方案，这就是 finally 子句。无论异常是否产生，finally子句总是会被执行,即使在到达finally子句之前有一个return语句，finally块还是会执行。在try块(或try-catch块)和finally块之间不能有其他任何代码。finally子句常用于在抛出异常时关闭资源，比如关闭文件和关闭与数据库的连接。比如下面的代码：12345678910111213141516171819InputStream in = new FileInputStream(. . .);try&#123;//1code that might throw exceptions//2&#125;catch (IOException e)&#123;// 3show error message// 4&#125;finally&#123;// 5in.close();&#125;//6 在上面的代码中，有下列3种情况会执行finally子句：1) 代码没有抛出异常。在这种情况下，程序首先执行 try 语句块中的全部代码，然后执行 finally 子句中的代码。随后，继续执行 try 语句块之后的下一条语句。也就是说，执行标注的1、2、5、6处2) 抛出一个在 catch 子句中捕获的异常。在上面的示例中就是 IOException 异常。在这种情况下，程序将执行 try语句块中的所有代码，直到发生异常为止。此时，将跳过 try语句块中的剩余代码，转去执行与该异常匹配的 catch 子句中的代码， 最后执行 finally 子句中的代码。 如果 catch 子句没有抛出异常，程序将执行 try 语句块之后的第一条语句。在这里，执行标注 1、 3、 4、5、 6 处的语句。 如果 catch 子句抛出了一个异常， 异常将被抛回这个方法的调用者。在这里， 执行标注1、 3、 5 处的语句。3) 代码抛出了一个异常，但这个异常不是由 catch 子句捕 获的。在这种情况下，程序将执行 try 语句块中的所有语句，直到有异常被抛出为止。此时，将跳过 try 语句块中的剩余代码，然后执行 finally 子句中的语句，并将异常抛给这个方法的调用者。在这里， 执行标注 1、5 处的语句。try 语句可以只有 finally 子句，而没有 catch 子句。例如，下面这条 try 语句：123456789 InputStream in = . .try&#123;code that might throw exceptions&#125;finally&#123;in.close();&#125; 无论在 try 语句块中是否遇到异常，finally 子句中的 in.close()语句都会被执行。当然,如果真的遇到一个异常，这个异常将会被重新抛出，并且必须由另一个 catch 子句捕获。强烈建议解耦合 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。例如：12345678910111213141516InputStream in = . . .;try&#123; try &#123; code that might throw exceptions &#125; finally &#123; in.close(); &#125;&#125;catch (IOException e)&#123;show error message&#125; 内层的 try 语句块只有一个职责，就是确保关闭输入流。外层的 try 语句块也只有一个职责，就是确保报告出现的错误。这种设计方式不仅清楚， 而且还具有一个功能，就是将会报告 finally 子句中出现的错误。注意：当 finally 子句包含 return 语句时，将会出现一种意想不到的结果„ 假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会覆盖原始的返回值。请看一个复杂的例子：123456789101112public static int f(int n)&#123; try &#123; int r = n * n; return r; &#125; finally &#123; if (n == 2) return 0; &#125;&#125; 如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句然而，在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值4。有时候， finally 子句也会带来麻烦。例如， 清理资源的方法也有可能抛出异常。假设希望能够确保在流处理代码中遇到异常时将流关闭。123456789InputStream in = . . .;try&#123;code that might throw exceptions&#125;finally&#123;in.close();&#125; 现在，假设在 try 语句块中的代码抛出了一些非 IOException 的异常，这些异常只有这个方法的调用者才能够给予处理。执行 finally 语句块，并调用 close 方法。而 close 方法本身也有可能抛出 IOException 异常。当出现这种情况时， 原始的异常将会丢失，转而抛出 close 方法的异常。这会有问题， 因为第一个异常很可能更有意思。如果你想做适当的处理，重新抛出原来的异常， 代码会变得极其繁琐。 如下所示：12345678910111213141516171819202122232425InputStream in = . . .;Exception ex = null;try&#123; try &#123; code that might throw exceptions &#125; catch (Exception e) &#123; ex = e; throw ex; &#125;&#125;finally&#123; try &#123; in.close()； &#125; catch (Exception e) &#123; if (ex = null) throw e; &#125;&#125; 上面的代码太繁琐，在 Java SE 7中提供了一种更便捷的方法。 带资源的try语句对于以下代码模式:123456789open a resourcetry&#123; work with the resource&#125;finally&#123; close the resource&#125; 假设资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。AutoCloseable 接口有一个方法：1void close() throws Exception 另外，还有一个 Closeable 接口。这是 AutoCloseable 的子接口， 也包含一个 close方法。不过，这个方法声明为抛出一个 IOException。带资源的 try 语句（try-with-resources) 的最简形式为：1234try (Resource res = . . .)&#123; work with res&#125; try块退出时，会自动调用 res.close()。下面给出一个典型的例子， 这里要读取一个文件中的所有单词：12345try (Scanner in = new Scanner(new FileInputStream(7usr/share/dict/words")), "UTF-8")&#123; while (in.hasNext()) System.out.println(in.next());&#125; 这个块正常退出时， 或者存在一个异常时， 都会调用 in.close() 方法， 就好像使用了finally块一样。还可以指定多个资源,例如：123456try (Scanner in = new Scanne(new FileInputStream("7usr/share/dict/words"), "UTF-8");PrintWriter out = new PrintWriter("out.txt"))&#123; while (in.hasNext()) out.println(in.next().toUpperCase());&#125; 不论这个块如何退出， in 和 out 都会关闭。如果你用常规方式手动编程，就需要两个嵌套的 try/finally语句。前面已经看到，如果 try 块抛出一个异常， 而且 close 方法也抛出一个异常，这就会带来一个难题。带资源的 try 语句可以很好地处理这种情况。原来的异常会重新抛出，而 close方法抛出的异常会”被抑制”。这些异常将自动捕获，并由 addSuppressed 方法增加到原来的异常。 如果对这些异常感兴趣， 可以调用 getSuppressed 方法，它会得到从 close 方法抛出并被抑制的异常列表。你肯定不想采用这种常规方式编程。只要需要关闭资源， 就要尽可能使用带资源的 try语句。 使用异常机制的技巧1.异常处理不能代替简单的测试异常处理需要初始化新的异常对象，需要调用栈返回，而且还需要沿着方法调用链来传播异常以找到它的异常处理器，所以，异常处理通常需要更多的时间和资源。如果能在发生异常的方法中处理异常，就不需要抛出异常。在个别方法中的简单错误最好进行局部处理，无须抛出异常。例如：123456try &#123; System.out.println(refVar.toString());&#125;catch(NullPointerException ex) &#123; System.out.println("refVar is null");&#125; 最好用下面的代码代替：1234if (refVar != null) System.out.println(refVar.toString());else System.out.println("refVar is null"); 只有在异常不可预料的情况下才抛出异常，简单的情况不应该使用异常机制。 1.不要过分细化异常很多程序员习惯将每一条语句都分装在一个独立的 try 语句块中。123456789101112131415161718192021PrintStream out;Stack s;for (i = 0;i &lt; 100; i++)&#123; try &#123; n = s.pop(); &#125; catch (EmptyStackException e) &#123; // stack was empty &#125; try &#123; out.writelnt(n); &#125; catch (IOException e) &#123; // problem writing to file &#125;&#125; 这种编程方式将导致代码量的急剧膨胀。首先看一下这段代码所完成的任务。在这里，希望从栈中弹出 100 个数值， 然后将它们存入一个文件中。如果栈是空的， 则不会变成非空状态；如果文件出现错误， 则也很难给予排除。出现上述问题后，这种编程方式无能为力。因此，有必要将整个任务包装在一个 try语句块中，这样，当任何一个操作出现问题时，整个任务都可以取消。12345678910111213141516try&#123; for (i = 0; i &lt; 100; i++) &#123; n = s.pop(); out.writelnt(n); &#125;&#125;catch (IOException e)&#123; // problem writing to file&#125;catch (EmptyStackException e)&#123; // stack was empty&#125; 这段代码看起来清晰多了。这样也满足了异常处理机制的其中一个目标，将正常处理与错误处理分开。 3.利用异常层次结构不要只抛出 RuntimeException 异常。应该寻找更加适当的子类或创建自己的异常类。不要只捕获 Thowable 异常， 否则，会使程序代码更难读、 更难维护。考虑受查异常与非受查异常的区别。 已检查异常本来就很庞大，不要为逻辑错误抛出这些异常。（例如， 反射库的做法就不正确。 调用者却经常需要捕获那些早已知道不可能发生的异常。）将一种异常转换成另一种更加适合的异常时不要犹豫。例如， 在解析某个文件中的一个整数时，捕获NumberFormatException 异 常，然后将它转换成 IOException 或 MySubsystemException 的子类。 4.不要压制异常在 Java 中，往往强烈地倾向关闭异常。如果编写了一个调用另一个方法的方法，而这个方法有可能 100 年才抛出一个异常， 那么， 编译器会因为没有将这个异常列在 throws 表中产生抱怨。而没有将这个异常列在 throws 表中主要出于编译器将会对所有调用这个方法的方法进行异常处理的考虑。因此，应该将这个异常关闭：123456789public Image loadImage(String s)&#123; try &#123; // code that threatens to throw checked exceptions &#125; catch (Exception e) &#123;&#125; // so there&#125; 现在，这段代码就可以通过编译了。除非发生异常，否则它将可以正常地运行。即使发生了异常也会被忽略。如果认为异常非常重要，就应该对它们进行处理。 5.在检测错误时，”苛刻”要比放任更好当检测到错误的时候，有些程序员担心抛出异常。在用无效的参数调用一个方法时，返回一个虚拟的数值， 还是抛出一个异常， 哪种处理方式更好？ 例如， 当栈空时，Stack.pop 是返回一个 null, 还是抛出一个异常？ 我们认为：在出错的地方抛出一个 EmptyStackException异常要比在后面抛出一个 NullPointerException 异常更好。 6.不要羞于传递异常很多程序员都感觉应该捕获抛出的全部异常。如果调用了一个抛出异常的方法，例如，FilelnputStream 构造器或 readLine 方法，这些方法就会本能地捕获这些可能产生的异常。其实， 传递异常要比捕获这些异常更好：123456public void readStuff(String filename) throws IOException// not a sign of shame!&#123;InputStream in = new FilelnputStream(filename);. . .&#125; 让高层次的方法通知用户发生了错误， 或者放弃不成功的命令更加适宜。规则 5、6 可以归纳为”早抛出，晚捕获” 使用断言在测试期间，需要进行大量的检测以验证程序操作的正确性。然而，这些检测可能非常耗时，在测试完成后也不必保留它们，因此，可以将这些检测删掉，并在其他测试需要时将它们粘贴回来，这是一件很乏味的事。 1.断言的概念假设确信某个属性符合要求，并且代码的执行依赖于这个属性。例如，需要计算：1double y = Math.sqrt(x); 我们确信，这里的 X 是一个非负数值。原因是：X 是另外一个计算的结果，而这个结果不可能是负值；或者 X 是一个方法的参数，而这个方法要求它的调用者只能提供一个正整数。然而，还是希望进行检查，以避免让“不是一个数”的数值参与计算操作。当然，也可以抛出一个异常：1if (x &lt; 0) throw new IllegalArgumentException("x &lt; 0"); 但是这段代码会一直保留在程序中，即使测试完毕也不会自动地删除。如果在程序中含有大量的这种检查，程序运行起来会相当慢。断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插入的检测语句将会被自动地移走。Java 语言引人了关键字 assert。这个关键字有两种形式：assert 条件;和assert 条件：表达式;这两种形式都会对条件进行检测，如果结果为 false, 则在第一种形式中会抛出一个 AssertionError 异常。在第二种形式中，表达式将被传人 AssertionError 的构造器，并转换成一个消息字符串,在打印异常信息时会随之显示出来。注意：“表达式”部分的唯一目的是产生一个消息字符串。AssertionError 对象并不存储表达式的值，因此，不可能在以后得到它。正如 JDK 文档所描述的那样：如果使用表达式的值，就会鼓励程序员试图从断言中恢复程序的运行，这不符合断言机制的初衷。要想断言 x 是一个非负数值，只需要简单地使用下面这条语句：assert x &gt;= 0;或者将 x 的实际值传递给 AssertionError 对象， 从而可以在后面显示出来：assert x &gt;= 0 : x; 2.启用和禁用断言在默认情况下，断言被禁用。可以在运行程序时用-enableassertions 或 -ea 选项启用：1java -enableassertions MyApp 需要注意的是，在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器(class loader) 的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。也可以在某个类或整个包中使用断言，例如：java -ea:MyClass -ea:com.mycompany.mylib... MyApp 这条命令将开启 MyClass 类以及在 com.mycompany.mylib 包和它的子包中的所有类的断言。选项 -ea 将开启默认包中的所有类的断言。 也可以用选项 -disableassertions 或 -da 禁用某个特定类和包的断言：java -ea:... -da:MyClass MyApp有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。然而，启用和禁用所有断言的 -ea 和 -da 开关不能应用到那些没有类加载器的”系统类”上。对于这些系统类来说，需要使用 -enablesystemassertions/-esa 开关启用断言。在程序中也可以控制类加载器的断言状态。有关这方面的内容请参看本文末尾的 API 注释。还可以在eclipse里开启断言，只要Run -&gt; Run Configurations -&gt; Arguments页签 -&gt; VM arguments文本框中加上断言开启的标志:-enableassertions 或者-ea 就可以了。 3.使用断言完成参数检查在 Java 语言中，给出了3种处理系统错误的机制： 抛出一个异常 日志 使用断言 什么时候应该选择使用断言呢？ 请记住下面几点： 断言失败是致命的、 不可恢复的错误。 断言检查只用于开发和测阶段(这种做法有时候被戏称为“ 在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”)。 因此，不应该使用断言向程序的其他部分通告发生了可恢复性的错误，或者，不应该作为程序向用户通告问题的手段。断言只应该用于在测试阶段确定程序内部的错误位置。下面看一个十分常见的例子：检查方法的参数。是否应该使用断言来检查非法的下标值或null 引用呢？ 要想回答这个问题， 首先阅读一下这个方法的文档。假设实现一个排序方法。123456789101112131415/**Sorts the specified range of the specified array in ascending numerical order.The range to be sorted extends from fromlndex, inclusive, to tolndex, exclusive.@param a the array to be sorted.@param fromlndex the index of the first element (inclusive) to be sorted.@param tolndex the index of the last element (exclusive) to be sorted.©throws IllegalArgumentException if fromlndex &gt; tolndex©throws ArraylndexOutOfBoundsException if fromlndex &lt; 0 or tolndex &gt; a.length*/static void sort(int[] a, int fromlndex, int tolndex) 文档指出，如果方法中使用了错误的下标值，那么就会抛出一个异常。这是方法与调用者之间约定的处理行为。如果实现这个方法，那就必须要遵守这个约定，并抛出表示下标值有误的异常。因此，这里使用断言不太适宜。是否应该断言 a 不是 null 呢？ 这也不太适宜。当 a 是 null 时，这个方法的文档没有指出应该采取什么行动。在这种情况下，调用者可以认为这个方法将会成功地返回，而不会抛出一个断言错误。然而，假设对这个方法的约定做一点微小的改动：1@param a the array to be sorted (must not be null) 现在，这个方法的调用者就必须注意：不允许用 null 数组调用这个方法，并在这个方法的开头使用断言：assert a != null;计算机科学家将这种约定称为前置条件(Precondition)。最初的方法对参数没有前置条件， 即承诺在任何条件下都能够给予正确的执行。修订后的方法有一个前置条件，即 a 非空。如果调用者在调用这个方法时没有提供满足这个前置条件的参数， 所有的断言都会失败，并且这个方法可以执行它想做的任何操作。事实上，由于可以使用断言，当方法被非法调用时， 将会出现难以预料的结果。有时候会拋出一个断言错误， 有时候会产生一个 null 指针异常， 这完全取决于类加载器的配置。 4.为文档假设使用断言很多程序员使用注释说明假设条件。看一下下面的示例：123456if (i % 3 == 0) . . .else if (i % 3 = 1) . . .else // (i % 3 == 2) . . . 在这个示例中，使用断言会更好一些。123456789if (i % 3 == 0) . . .else if (i % 3 == 1) . . .else&#123; assert i % 3 == 2; . . .&#125; 当然，如果再仔细地考虑一下这个问题会发现一个更有意思的内容。i%3 会产生什么结果？如果 i 是正值，那余数肯定是 0、 1 或 2。如果 i 是负值，则余数则可以是 -1 和-2。然而，实际上都认为 i 是非负值， 因此， 最好在 if 语句之前使用下列断言：assert i &gt;= 0;无论如何，这个示例说明了程序员如何使用断言来进行自我检查。前面已经知道，断言是一种测试和调试阶段所使用的战术性工具; 而日志记录是一种在程序的整个生命周期都可以使用的策略性工具。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之集合]]></title>
    <url>%2F2017%2F10%2F23%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java集合框架Java中封装了许多常用的数据结构，称为集合框架，可以有效组织数据，提高程序性能。最初Java只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、Bitset和Enumeration接口，其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，但要想建立一个全面的集合类库还需要大量的时间和高超的技能。后来，经过艰难的抉择，设计人员设计出了一组功能完善的数据结构，下面我们来进入集合框架的学习。 集合接口与具体实现分离Java集合类库将接口与实现分离。比如队列接口，其指出可以在队列的尾部添加元素，在队头删除元素，并可以查找队列中元素的个数等。队列接口的最简形式可能类似下面这样：123456public interface Queue&lt;E&gt;&#123; void add(E element); E remove(); int size();&#125; 但这个接口并没有说明队列的具体实现，实际上，队列的实现主要有两种方式：一是使用循环数组，二是使用链表。如果需要一个循环数组队列，可以使用ArrayDeque类;如果需要一个链表队列，就直接使用LinkedList类。这两个类都实现了Queue接口。当我们使用队列时，一旦创建了集合就不用关心究竟使用了哪种实现，因此，只有在构建集合时，使用具体的类才有意义。用两种具体类实现Queue接口：12Queue&lt;E&gt; q = new ArrayDeque&lt;&gt;();Queue&lt;E&gt; q = new LinkedList&lt;&gt;(); 注意：一般情况下循环数组比链表更高效，但它是一个有界集合，即容量有限，超过一定范围会进行扩容，降低效率。所以如果处理的数据量较小，优先使用循环数组，但如果程序要收集的对象数量没有上限，最好使用链表实现。在研究API时会发现一组名字以Abstract开头的类，例如，AbstractQueue。这些类是为类库设计者设计的，如果想要实现自己的队列类，会发现扩展AbstractQueue类比实现Queue接口中的所有方法轻松得多。 Collection接口在Java类库中，集合类的基本接口是Collection接口，其常用API如下： boolean add(E e)将一个元素添加到集合中。如果由于这个调用改变了集合，返回true。 boolean addAll(Collection&lt;? extends E&gt; other)将other集合中的所有元素都添加到这个集合。如果由于这个调用改变了集合，返回true。 void clear() 移除这个集合中的所有元素。 boolean contains(Object obj)如果这个集合包含了一个与obj相等的对象，返回true。 boolean containsAll(Collection&lt;?&gt; other)如果这个集合包含other集合中的所有元素，返回 true。 boolean isEmpty() 如果这个集合没有元素，返回 true。 Iterator&lt;E&gt; iterator()返回一个用于访问集合中每个元素的迭代器。 boolean remove(Object obj)从这个集合中删除等于obj的对象。如果有匹配的对象被删除，返回true。 boolean removeAll(Collection&lt;?&gt; other)从这个集合中删除other集合中存在的所有元素。如果由于这个调用改变了集合，返回true。 boolean retainAll(Collection&lt;?&gt; other)仅保留这个集合中那些也包含在other集合里的元素 int size() 返回这个集合的元素数。 Object[] toArray() 返回这个集合的对象数组。 &lt;T&gt; T[] toArray(T[] arrayToFill)返回这个集合的对象数组。如果arrayToFill足够大，就将集合的元素填入这个数组中，剩余空间补null;否则，分配一个新数组，其成员类型和arrayToFill一样，其长度等于集合的大小，并填充集合元素。 default boolean removeIf(Predicate&lt;? super E&gt; filter)从这个集合中删除filter返回true的所有元素。如果这个调用改变了集合，返回true 注意：在使用Object[] toArray()时不能把返回的Object[]数组成强制类型转换其他类型的数组，因为所有数组类型的父类都是Object，甚至Object[]的父类也是Object，所以这种向下类型转换是错误的,会抛出一个ClassCastException 12Integer[] array = (Integer[])a.toArray();// ErrorObject[] array = a.toArray();// Right 或者使用 1Integer[] array = a.toArray(new Integer[10]); removeIf函数的参数是一个函数式接口Predicate，表示布尔值函数，可以传递一个lambda表达式描述要删除的元素的特征。例如下面的代码可以删除列表中的所有偶数： 1a.removeIf(e -&gt; e %2 == 0); 同队列，Java也给类库设计者提供了一个AbstractCollection类，其提供了一些例行方法，可以让实现者更容易实现自己的集合类。 迭代器Collection接口的Iterator&lt;E&gt; iterator()方法可以返回一个迭代器，它是一个实现了Iterator接口的对象，可以使用这个迭代器对象依次访问集合中的元素。Iterator接口包含4个方法： 123456public interface Iterator&lt;E&gt;&#123; E next(); boolean hasNext(); void remove(); default void forEachRemaining(Consumer&lt;? super E&gt; action); C++的STL中的迭代器是根据数组索引建模的，即迭代器指向指定位置的元素。但Java中的迭代器应该理解为位于两个元素之间，其起始位置在所有元素之前。调用next方法，迭代器会越过一个元素并且返回被越过的元素。通过next方法可以逐个访问集合中的每个元素，但是如果到达了集合的末尾，next方法将抛出一个NoSuchElementException。因此,需要在每次调用next方法之前调用hasNext方法。如果迭代器还有剩余供访问的元素，这个方法就返回true。如果要想查看一个集合中的所有元素，就请求一个迭代器，并在hasNext返回true时反复调用next方法，例如： 1234567Collection&lt;String&gt; c = . . .;Iterator&lt;String&gt; iter = c.iterator();while(iter.hasNext())&#123;String element = iter.next(); do something with element&#125; “for-each”循环可以更简练地表示同样的操作： 1234for(String element: c)&#123; do something with element&#125; 编译器简单地将”for-each”循环翻译为带有迭代器的循环，”for-each”循环可以和任何实现了Iterable接口的对象一起工作，这个接口只包含一个抽象方法： 1234public interface Iterable&lt;E&gt;&#123; Interator&lt;E&gt; iterator();&#125; Iterable接口表示实现它的类是可以迭代的(即可以返回一个迭代器对象)，Collection接口扩展了Iterable接口，所以对于标准类库中的任何集合都可以使用”for-each”循环Java SE 8提供了一种更简便的方式，甚至不用写循环。可以调用forEachRemaining方法并提供一个lambda表达式(它会处理一个元素)。将对迭代器的每一个元素调用这个lambda表达式，直到再没有元素为止,例如： 1iter.forEachRemaining(element -&gt; do something with element); 元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次索引加1.如果访问HashSet中的元素，每个元素将会以某种随机的次序出现。但这对于计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说没有影响。Iterator接口的remove方法将会删除上一次调用next方法时返回的元素，也就是说，如果要删除某个元素，必须先用next方法越过它： 123Iterator&lt;String&gt; it = c.iterator();it.next();// skip over the first elementit.remove(); // now remove it 如果在调用remove方法之前没有调用next方法会抛出一个IllegalStateException。如果想删除两个相邻的元素，不能直接连续调用两次remove：12it.remove();it.remove();//Error 必须先越过要删除的元素：123it.remove();it.next();it.remove();//OK 所以删除元素必须在刚越过该元素时就进行，否则”过了这个村就没这个店了” 集合框架中的接口Java集合框架为不同类型的集合定义了大量接口，如下图所示： 集合有两个基本接口：Collection和Map。Collection用于保存一个元素序列，Map用于表示键值对之间的映射关系。在Collection中插入元素使用boolean add(E element),获取元素使用迭代器访问;在Map中插入元素使用V put(K key,V value),通过key获取value使用V get(K key)List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：使用迭代器访问，使用一个整数索引访问。前者称为顺序访问，后者称为随机访问。List的重要API如下：1234567891011121314* ListIterator&lt;E&gt; listIterator() 返回一个列表迭代器，以便用来访问列表中的元素 * ListIterator&lt;E&gt; listIterator(int index) 返回一个列表迭代器，以便用来访问列表中的元素， 初始位置在索引为index元素的前面，索引从0开始 * void add(int i,E element) 在给定位置添加一个元素 * E remove(int i) 删除给定位置的元素并返回这个元素 * E get(int i) 获取给定位置的元素 * E set(int i, E element) 用新元素取代给定位置的元素，并返回原来那个元素 * int indexOf(Object element) 返回与指定元素相等的元素 在列表中第一次出现的位置，如果没有这样的元素返回-1 * int lastIndexOf(Object element) 返回与指定元素相等的元素 在列表中最后一次出现的位置，如果没有这样的元素返回-1 我们发现List接口提供了多个用于随机访问的方法：1234void add(int i,E element)void remove(int index)E get(int index)E set(int index,E element) 当我们给List接口选择具体实现类时，需要考虑顺序访问和随机访问哪种情况更多，如果随机访问占操作的大多数，应该使用数组或动态列表ArrayList实现List接口，否则应该使用链表LinkedList实现List接口。为了避免对链表进行随机访问，Java定义了一个标记接口RandomAccess，这个接口不包含任何方法，但可以用来测试一个特定的集合是否支持高效的随机访问：12345678if(c instanceof RandomAccess)&#123; use random access algorithm&#125;else&#123; use sequential access algorithm&#125; 不建议在LinkedList实现的List列表中使用get、set等随机访问方法，此时应该通过一个ListIterator顺序访问列表。ListIterator接口是Iterator的一个子接口，它是一种更灵活的迭代器，只用于List。下面是ListIterator的重要API： void add(E newElement) 在当前位置前添加一个元素 void set(E newElement) 用新元素取代next或previous上次访问的元素。 boolean hasPrevious() 当反向迭代列表时，还有可供访问的元素，返回true E previous() 返回前一个对象，如果已经到达了列表的头部，就抛出一个NoSuchElementException int nextIndex() 返回下次调用next方法时将返回元素的索引 int previous() 返回下次调用previous方法时将返回元素的索引 并发修改：如果在一个迭代器修改集合时，另一个迭代器对它进行遍历，一定会出现混乱。例如：123456List&lt;String&gt; list = . . .;ListIterator&lt;String&gt; iter1 = list.ListIterator();ListIterator&lt;String&gt; iter2 = list.ListIterator();iter1.next();iter1.remove();iter2.next();//throws ConcurrentModificationException 上述代码中iter2迭代器在遍历链表时，iter1修改了链表结构，iter2会检测到这种变化，抛出一个ConcurrentModificationException。为了避免出现并发修改异常，请遵循下述简单规则：可以根据需要给容器附加许多迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读也写的迭代器。通过调用AbstractCollection类的toString方法可以打印出集合中的所有元素。Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。集(Set)的add方法不允许增加重复的元素。要适当定义equals方法：只要两个集包含同样的元素就认为是相等的，而不要求有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码。SortedSet和SortedMap接口会提供用于排序的比较器对象，这两个接口定义了可以得到集合子集试图的方法。最后，Java SE 6引入了接口NavigableSet和NavigableMap，其中包含一些用于搜索和遍历有序集和映射的方法，TreeSet和TreeMap实现了这些接口。 具体的集合下面是Java库中的具体集合和集合框架中的类 LinkedListLinkedList是链表类，相较于数组以及动态的ArrayList类，能够更高效地从集合的中间位置插入、删除元素，Java中的LinkedList类是双向链接的。除了实现了Collection接口和List接口之外，LinkedList还提供了以下API： LinkedList() 构造一个空链表 LinkedList(Collection&lt;? extends E&gt; elements)构造一个链表，并将集合中的所有元素添加到这个链表中 void addFirst(E element) 将某个元素添加到列表的头部 void addLast(E element) 将某个元素添加到列表的尾部 E getFirst 返回列表头部的元素 E getLast 返回列表尾部的元素 E removeFirst() 删除并返回列表头部的元素 E removeLast() 删除并返回列表尾部的元素 ArrayListArrayList是动态数组列表，适用于常常要随机访问元素的情况。下面给出ArrayList的常用API： ArrayList&lt;E&gt;() 构造一个初始容量为10的空列表 ArrayList&lt;E&gt;(int initialCapacity)构造一个具有指定初始容量的空列表 boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true void add(int index, E element) 将指定的元素插入此列表中的指定位置。 int size() 返回此列表中的元素数。 void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。 E get(int index) 返回此列表中指定位置上的元素。 E remove(int index) 移除此列表中指定位置上的元素并返回该元素。 boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。 void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。 boolean isEmpty() 如果此列表中没有元素，则返回 true boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。 void clear() 移除此列表中的所有元素。 Object clone() 返回此 ArrayList 实例的浅表副本。 trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。 ArrayList和Vector的区别：Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vector对象，然而如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间。所以建议在不需要同步的时候使用ArrayList，而不要使用Vector HashSet链表和数组可以按照人们的意愿排列元素的次序，但如果要查看某个元素，却忘记了它的位置，需要访问所有元素直到找到为止，将会消耗很多时间。HashSet是一种基于散列表的集，实现了Set接口，它无法控制元素的次序，但可以快速查找元素。散列表基于散列码，散列码由类的hashCode方法提供，用于将元素插入散列表的特定位置，hashCode和equals方法应该兼容，即使用equals方法返回true的两个对象应该有相同的散列码，一个自定义类如果重写了equals方法就必须要重写hashCode方法，以便于将该类的对象插入散列表中。在Java中，散列表用链表数组实现，每个散列单元被称为桶。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的总数取余，如果桶中没有元素，可以直接插入，如果已经有元素，即发生散列冲突，则需要将新元素和桶中已有的所有元素进行比较，如果桶中有元素和新元素相等，就不插入，反之插入。注意：在HashSet的一个桶中可以有多个不同元素，即使用链地址法解决冲突。如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突，或者有恶意代码试图在散列表中填充多个有相同散列码的值，这样就能提高性能。如果想更多地控制散列表的运行性能，就要指定一个初始桶数。通常将桶数设置为预计元素个数的75% ~ 150%,最好将桶数设置为一个素数,以防键的集聚。标准类库使用的桶数是2的幂，默认值为16,为散列表的大小提供的任何值都被自动转换为2的下一个幂。如果最初的估计过低，散列表太满，散列表会进行再散列，创建一个桶数更多的表。装填因子决定何时再散列，比如装填因子为0.75，当散列表中超过75%的位置已经填入了元素，这个表就会用双倍的桶数自动进行再散列，大多数情况装填因子为0.75是比较合理的。下面是HashSet的常用API： HashSet() 构造一个空散列集 HashSet(Collection&lt;? extends E&gt; elements)构造一个散列集，并将集合中的所有元素添加到这个散列集中 HashSet(int initialCapacity) 构造一个具有指定容量(桶数)的散列集 HashSet(int initialCapacity,float loadFactor) 构造一个具有指定容量和装填因子(一个0.0 ~ 1.0之间的数值，确定散列表填充的百分比，当大于这个百分比时，散列表进行再散列)的空散列集 特别要注意,在HashSet中没有get和set方法，因为HashSet是无序集，不存在索引概念，如果要访问HashSet中的元素应该使用迭代器，另外contains方法也被重新定义，可以快速查看某个元素是否出现在集中，此时不用查看集中的所有元素，只用通过散列码定位到一个桶，查看这个桶中的所有元素即可 TreeSetTreeSet和HashSet十分类似，不过当元素以任意顺序插入TreeSet时，TreeSet会保证元素是有序排列的。其底层是由红黑树实现的,每次将一个元素添加到树中，都被放置在正确的排序位置上。一个元素添加到树中比添加到散列表中慢，但是与检查数组或链表中的重复元素相比还是快很多。如果树中包含n个元素，查找新元素的正确位置平均需要log2n次比较。如果对集合中的元素次序没有要求，应该使用HashSet而不是TreeSet，即使排序的花销不大，但也会影响效率。注意：要使用TreeSet，插入的元素必须可排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator从Java SE 6起,TreeSet类实现了Navigable接口，这个接口增加了几个便于定位元素以及反向遍历的方法。 下面是TreeSet的常用API： TreeSet() 构造一个空树集 TreeSet(Collection&lt;? extends E&gt; elements)构造一个空树集，并将集合中的所有元素添加到这个树集中 TreeSet(Comparator&lt;? super E&gt; comparator) 构造一个空树集 TreeSet(SortedSet&lt;E&gt; s)构造一个空树集，并将有序集中的所有元素添加到这个树集中，并使用与给定的有序集相同的比较器 下面是SortedSet的常用API： Comparator&lt;? super E&gt; comparator()返回用于对元素进行排序的比较器。如果元素用Comparable接口的compareTo方法进行比较则返回null E first() 返回有序集中的最小元素 E last() 返回有序集中的最大元素 下面是NavigableSet的常用API： E higher(E value) E lower(E value)返回大于value的最小元素或小于value的最大元素，如果没有这样的元素则返回null E ceiling(E value) E floor(E value)返回大于等于value的最小元素或小于等于value的最大元素，如果没有这样的元素则返回null E poolFirst() E pollLast()删除并返回这个集合中的最大元素或最小元素，这个集合为空时返回null Iterator&lt;E&gt; descendingIterator()返回一个按照递减顺序遍历集中元素的反向迭代器 队列与双端队列Deque(双端队列)接口继承自Queue(队列)接口，与之有所不同的是，双端队列可以在队列的头部和尾部添加或删除元素，但也不支持在队列中间添加或删除元素。和普通队列一样，双端队列也可以用ArrayDeque和LinkedList实现。 下面是Queue的常用API： boolean add(E element) boolean offer(E element)都是将一个元素入队并返回true，如果队列已满，前者会抛出一个IllegalStateException，后者则返回false E remove() E poll()都是将队头元素出队并返回，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null E element() E peek()都是取队头元素但不删除，如果队列为空，前者会抛出一个NoSuchElementException，后者则返回null 下面是Deque的常用API： void addFirst(E element) void addLast(E element) boolean offerFirst(E element) boolean offerLast(E element)都是将给定元素添加到双端队列的头部或尾部，如果队列满了，前两个方法会抛出一个IllegalStateException，后两个方法则返回false E removeFirst() E removeLast() E pollFirst() E pollLast()都是删除双端队列的头部或尾部并返回元素，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null E getFirst() E getLast() E peekFirst() E peekLast()都是返回双端队列的头部或尾部元素但不删除，如果队列为空，前两个方法会抛出一个NoSuchElementException，后两个方法则返回null 下面是ArrayDeque的常用API： ArrayDeque() 用默认初始容量16构造一个空队列 ArrayDeque(int initialCapacity) 用指定容量构造一个空队列 PriorityQueue在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先出队。优先队列具有最高级先出(first in, largest out)的行为特征。PriorityQueue的底层是通过堆(小根堆，将较小的元素设为最高优先级)实现的，堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。PriorityQueue是一个实现了Queue接口的具体类。和TreeSet一样，要实现排序，即这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator。 注意：方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。原因是PriorityQueue内部是一个堆，堆只能保证根具有最高的优先级，但整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历，也就是只能保证数组的第一个元素具有最高优先级。但如果将元素依次出队，出队顺序可以保证是有序的，这是因为在每一次出队后堆会进行调整，将下一个优先级最高的元素移动到根。 下面是PriorityQueue的常用API： PriorityQueue() 构造一个空优先队列 PriorityQueue(int initialCapacity)用指定容量构造一个空优先队列 PriorityQueue(int initialCapacity,Comaparator&lt;? super E&gt; c)用指定容量构造一个空优先队列,并指定比较器对元素进行排序 映射集是一个集合，它可以快速查找现有元素。但是，有时我们知道某些键的信息，并想要查找与之对应的元素。映射(map)数据结构就是为此设计的，map用来存放键值对，提供键(Key)就能快速查找到值(Value)Java类库为映射提供了两个实现：HashMap和TreeMap，这两个类都实现了Map接口。HashMap(散列映射)对键进行散列，键值对是无序的。TreeMap(树映射)用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。与集一样，HashMap比TreeMap快一些，如果不需要按照排列顺序访问键，就最好选择散列。 下面是Map接口的常用API： V get(Object key)获取并返回与键对应的值，如果没有在映射中找到这个键，返回null default V getOrDefault(Object key,V defaultValue)获取并返回与键对应的值，如果没有在映射中找到这个键，返回defaultValue V put(K key,V value)将键与对应的值关系插入到映射中。如果这个键已经存在，新的对象将取代与这个键对应的旧对象，并返回键对应的旧值，如果这个键以前没有出现过则返回null。键可以为null，但值不能为null V putAll(Map&lt;? extends K,? extends V&gt; entries)将给定映射中的所有条目添加到这个映射中 boolean containsKey(Object key)如果在映射中已经有这个键，返回true boolean containsValue(Object value)如果在映射中已经有这个值，返回true default void forEach(BiConsumer&lt;? super K,? super V&gt; action)对这个映射中的所有键值对应用这个动作，参数是一个函数式接口类型，可以传入一个lambda表达式,例如： 12scores.forEach((k,v) -&gt; System.out.println("key=" + k + ", value=" + v)); 下面是HashMap的常用API： HashMap() 构造一个空散列映射 HashMap(int initialCapacity) 用指定容量构造一个空散列映射 HashMap(int initialCapacity,float LoadFactor)用指定容量和装填因子构造一个空散列映射，默认的装填因子是0.75 下面是TreeMap的常用API： TreeMap() 构造一个空树映射 TreeMap(Comparator&lt;? super K&gt; c)构造一个空树映射，并使用一个指定的比较器对键进行排序 TreeMap(Map&lt;? extends K,? extends V&gt; entries) 构造一个空树映射，并将某个映射的所有条目添加到树映射中 TreeMap(SortedMap&lt;? extends K,? extends V&gt; entries)构造一个空树映射，将某个有序映射中的所有条目添加到树映射中，并使用与给定的有序映射相同的比较器 下面是SortedMap的常用API： Comparator&lt;? super K&gt; comparator()返回对键进行排序的比较器。如果键是用Comparable接口的compareTo方法进行比较的，返回null K firstKey() K lastKey()返回映射中最小元素和最大元素 更新映射项假设我们要统计一个单词在文件中出现的次数，当得到一个单词时，我们将其计数器加1：1counts.put(word,counts.get(word) + 1); 但这可能会出错，如果word第一次出现，counts.get(word)会返回null，从而抛出一个NullPointerException。 为了避免这种情况，我们可以用getOrDefault方法来取代get方法，即：1counts.put(word,counts.getOrDefault(word,0) + 1); 另一种方法是首先调用putIfAbsent方法，这个方法会在映射中不存在word时插入键值对初始化word的值为0：12counts.putIfAbsent(word,0);counts.put(word,counts.get(word) + 1); 还可以做得更好,merge方法可以简化这个常见操作。如果键原先不存在，则下面的调用：1counts.merge(word,1,Integer::sum); 将把word和1关联，如果word存在，则会使用Integer::sum函数组合原值和1(也就是将原值和1求和) 映射视图集合框架不认为映射本身是一种集合，不过可以得到映射视图 —— 这是实现了Collection接口或某个子接口的对象。有三种视图：键集、值集合(不是一个集)、键值对集。键集和键值对集是集，因为一个映射中的键是唯一的，但值不能构成集，只能是值集合，因为一个映射中可以有多个相同的值。下面的方法可以从映射中返回这三种视图：123Set&lt;K&gt; keySet()Collection&lt;V&gt; values()Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 需要说明的是，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口，所以可以向使用集合一样使用keySet 键值对是Map.Entry&lt;K,V&gt;类型的，可以使用entrySet()方法返回映射的键值对集，再通过循环对于每个键值对对象使用，例如：123456for(Map.Entry&lt;String,Employee&gt; entry: staff.entrySet())&#123; String k = entry.getKey(); Employee v = entry.getValue(); // do something with k,v&#125; getKey方法获取该键值对的键，getValue方法获取该键值对的值，setValue方法将键值对的值设置为新值并返回原值。当然查看键值对最高效的方法是使用forEach方法：123counts.forEach((k,v) -&gt; &#123; do something with k,v&#125;) 注意:可以在键集视图上调用迭代器的remove方法，结果会在映射中删除这个键和与它关联的值，但不能调用add方法，否则会抛出一个UnsupportedOperationException;可以在值集合视图删除元素，所删除的值和相应的键将从映射中删除，也不能增加元素;可以在键值对集合中删除元素，将从映射中删除相应的键值对，但也不能增加元素。总之，可删不可增。 WeakHashMap当一个映射中引用某个值的所有键都消亡，即没有任何途径引用这个值时，这个值成为了无用对象。但是垃圾回收器跟踪活动的对象，只要映射对象是活动的，其中的所有桶也是活动的，它们不能被回收。于是，长期存活的映射中可能会存在一些无用的值，此时需要由程序负责从长期存活的映射表中删除那些无用的值，或者使用WeakHashMap。当对键的唯一应用来自散列条目时，这种数据结构会协助垃圾回收期协同工作一起删除键值对。下面是这种机制的内部运行情况。WeakHashMap使用弱引用保存键。WeakReference对象将引用保存到另外一个对象中，在这里，就是散列键。对于这种特定类型的对象，垃圾回收器用一种特有的方式进行处理。通常，如果垃圾回收器发现某个特定的对象已经没有他人引用了，就将其回收。然而，如果某个对象只能由WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。 更多细节见：深入理解WeakHashMap LinkedHashSet &amp; LinkedHashMapLinkedHashSet和LinkedHashMap会按照元素插入顺序存放元素或键值对。当条目插入到表中时，就会并入到双向链表中。也可以使用LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true)来构造一个按照元素访问顺序迭代键值对的LinkedHashMap。每次调用get或put，受到影响的条目将从当前位置删除，并放到条目链表的尾部(只有条目在链表中位置会受影响，而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中)。访问顺序对于实现高速缓存的“最近最少使用”原则十分重要。例如，可能希望将访问频率高的元素放在内存中，而访问频率低的元素则从数据库中读取。当在表中找不到元素项且表又已满时，可以将迭代器加入到表中，并将前几个元素删除掉。这些是近期最少使用的几个元素。甚至可以让这一过程自动化。即构造一个LinkedHashMap的子类，然后覆盖下面的方法：1protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) 每当方法返回true时，就添加一个新条目，从而导致删除eldest条目。例如，下面的高速缓存可以存放100个元素：1234567891011Map&lt;K, V&gt; cache = new LinkedHashMap&lt;&gt;(128, 0.75F, true)&#123; protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; 100; /*当元素个数 &lt;= 100，直接插入元素， 否则进行替换，删除“最近最少使用”的元素， 插入新元素*/ &#125;&#125;(); 另外，还可以对eldest条目进行评估，以此决定是否应该将它删除。例如，可以检查与这个条目一起存在的时间戳。 EnumSet &amp; EnumMapEnumSet是一个枚举类型元素集的高效实现。由于枚举类型只有有限个实例，所以EnumSet内部用位序列实现。如果对应的值在集中，则相应的位被置为1.EnumSet没有公共的构造器，可以使用静态工厂方法构造这个集，下面给出得到EnumSet的几个常用方法：例如：12345enum Weekday &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY,Weekday.FRIDAY);EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY,Weekday.WEDNESDAY,Weekday.FRIDAY); 可以使用Set接口的常用方法来修改EnumSetEnumMap是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时，需要在构造器中指定键类型：1EnumMap&lt;Weekday, Employee&gt; personInChange = new EnumMap&lt;&gt;(Weekday.class); 这样就构造了一个键为Weekday类型的空映射。 IdentityHashMap类IdentityHashMap有特殊的作用。在这个类中，键的散列值不是用hashCode函数计算的，而是用System.identityHashCode方法计算的。这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式。而且，在对两个对象进行比较时，IdentityHashMap类使用 == ，而不使用equals也就是说，不同的键对象，即使内容相同，也被视为不同的对象。在实现对象遍历算法(如对象串行化)时，这个类非常有用，可以用来跟踪每个对象的遍历状况。 视图与包装器通过使用视图可以获取其他的实现了Collection接口或Map接口的对象，映射类的keySet方法就是这样一个示例。这个方法看似创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。然而事实并非如此，keySet方法返回一个实现了Set接口的类对象，这个类的方法对原映射进行操作。这样的集合称为视图。 轻量级集合包装器Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法。例如：123Card[] cardDeck = new Card[52]; ... List&lt;Card&gt; cardList = Arrays.asList(cardDeck); 返回的对象不是ArrayList，而是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法(例如，与迭代器相关的add和remove方法)都会抛出一个UnsupportedOperationException。asList方法可以接收可变数目的参数，如：1List&lt;String&gt; names = Arrays.asList("Amy","Bob","Carl"); 这个方法调用Collections.nCopies(n,anObject)将返回一个实现了List接口的不可修改的对象，并给人一种包含n个元素，每个元素都像是一个anObject的错觉。例如，下面的调用将创建一个包含100个字符串的List，每个串都被设置为”DEFAULT”：1List&lt;String&gt; settings = Collections.nCopies(100,"DEFAULT"); 存储代价很小，可用于不需要修改元素的情况。这是视图技术的一种巧妙的应用。注意：Collections类包含很多使用的方法，这些方法的参数和返回值都是集合，不要将它和Collection接口混起来。 如果调用以下方法：1Collections.singleton(anObject); 将返回一个实现了Set接口的视图对象(与产生List视图的ncopies方法不同)，即一个不可修改的单元素集，而不需要付出建立数据结构的开销。singletonList方法与singletonMap方法类似。类似地，对于集合框架中的每一个接口，还有一些方法可以生成空集、列表、映射等等。特别是，集的类型可以推导得出：1Set&lt;String&gt; deepThoughts = Collections.emptySet(); 子范围可以为很多集合建立子范围视图。例如，假设有一个列表staff，想从中取出第10个-第19个元素。可以使用subList方法来获得一个列表的子范围视图：1List group2 = staff.subList(10,20); 第一个索引包含在内，第二个索引则不包含在内。可以将任何操作应用于子范围，该操作会影响整个列表。例如，可以删除整个子范围：1group2.clear(); 现在，staff列表中该范围的元素也被删除，并且group2为空。对于SortedSet和SortedMap，可以使用排序顺序而不是元素位置建立子范围。SortedSet接口声明了3个方法：123SortedSet&lt;E&gt; subSet(E from,E to)SortedSet&lt;E&gt; headSet(E to)SortedSet&lt;E&gt; tailSet(E from) 这些方法返回大于等于from且小于to的所有元素构成的子集。 SortedMap也有类似的方法：123SortedMap&lt;K, V&gt; subMap(K from,K to)SortedMap&lt;K, V&gt; headMap(K to)SortedMap&lt;K, V&gt; tailMap(K from) 返回映射视图，该映射包含键落在指定范围内的所有元素。Java SE 6引入的NavigableSet接口赋予子范围操作更多控制能力。可以指定是否包括边界：123NavigableSet&lt;E&gt; subSet(E from, boolean fromInclusive,E to,boolean toInclusive)NavigableSet&lt;E&gt; headSet(E to,boolean toInclusive)NavigableSet&lt;E&gt; tailSet(E from,boolean fromInclusive) 不可修改的视图 同步视图 受查视图 关于可选操作的说明 Collections内容较多，见Java核心技术卷一 P388 ~ P396，并查阅相关API 遗留的集合见Java核心技术 P396 ~ P402]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之泛型程序设计]]></title>
    <url>%2F2017%2F10%2F22%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[泛型程序设计泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如ArrayList类可以聚集任何类型的对象，这是一个泛型程序设计的实例。实际上，在Java增加泛型类之前已经有一个ArrayList类，下面来研究泛型程序设计机制是如何演变的。 类型参数的好处在Java增加泛型类之前，泛型程序设计是用继承实现的。ArrayLists类只维护一个Object引用的数组：1234567public class ArrayList&#123; private Object[] elementData; . . . public Object get(int i) &#123; . . . &#125; public void add(Object o) &#123; . . . &#125;&#125; 这种方法有两个问题，我们以一个保存文件名的files数组列表为例：1) 当获取一个值时必须进行强制类型转换：123ArrayList files = new ArrayList();. . .String filename = (String)files.get(0); 2) 当添加一个值时不进行类型检查，可以添加任何类的对象：1files.add(new File(". . .")); 此调用在编译和运行时都不会出错，但如果将get的结果强制转换为String会产生一个错误 为了解决上述问题，引入了类型参数。ArrayList有一个类型参数用来指示元素类型：ArrayList&lt;T&gt; files = new ArrayList&lt;T&gt;();在Java SE 7及以后的版本，构造函数可以省略类型参数，即ArrayList&lt;T&gt; files = new ArrayList&lt;&gt;();这种方法有三个好处：1)get得到的值不必进行强制类型转换2)向数组列表中添加对象时会进行类型检查，如果不符合类型，无法通过编译，出现编译错误比类在运行时出现类的强制转换异常要好得多3)程序具有更好的可读性，比如ArrayList&lt;String&gt; files一看就是聚集了String对象的数组列表 定义简单的泛型类一个泛型类就是具有一个或多个类型变量的类，下面使用一个简单的Pair类作为例子：1234567891011public class Pair&lt;T&gt;&#123; private T first; private T second; public Pair() &#123;first = null; second = null&#125; public Pair(T first,T second) &#123;this.first = first; this.second = second&#125; public void setFirst(T newValue) &#123;first = newValue;&#125; public void setSecond(T newValue) &#123;second = newValue;&#125; &#125; Pair类引入了一个类型变量T，用尖括号括起来，并放在类名的后面。注意这里的T只是指定了一种类型，不代表类只有一个属性成员，而表示接下来类中出现的T都和尖括号里的类型保持一致,即类定义的类型变量指定方法返回类型以及域和局部变量的类型。泛型类可以有多个类型变量，如可以定义两个域类型不同的Pair类public class Pair&lt;T,U&gt; {. . .}类型变量命名规则：E表示集合的元素类型，K和V分别表示表的关键字和值的类型，T(需要时还可以用临近的字母U和S)表示“任意类型”。实际使用中将类定义尖括号里的T替换为具体类型，类中的T也会进行相应的替换，所以，泛型类可以看作普通类的工厂 泛型方法前面介绍了如何定义一个泛型类，下面我们来定义一个带有类型参数的简单泛型方法：1234567class ArrayAlg&#123; public static &lt;T&gt; T getMiddle(T...a) &#123; return a[a.length / 2]; &#125;&#125; 注意：1)类型变量放在修饰符(这里是public static)的后面，返回类型的前面2)泛型方法可以定义在普通类中，也可以定义在泛型类中3)当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：1String middle = ArrayAlg.&lt;String&gt;getMiddle("John","Q.","Public"); 类型变量的限定有时，类或方法需要对类型变量加以约束。下面是一个典型的例子，我们要计算数组中的最小元素：123456789101112class ArrayAlg&#123; public static &lt;T&gt; T min(T[] a) &#123; if(a == null || a.length == 0) return null; T smallest = a[0]; for(int i = 1; i &lt; a.length;i++) if(smallest.compareTo(a[i]) &gt; 0) smallest = a[i]; return smallset; &#125;&#125; 我们会发现一个问题，smallest的类型为T，既可以是任何一个类的对象，如何保证T类型有compareTo方法呢？解决方法是限制T为实现了Comparable接口的类，即将泛型方法定义改为public static &lt;T extends Comparable&gt; T min(T[] a)注意：1)限定类时如果实现的是接口也用extends关键字，如上面的T extends Comparable2)只需要在尖括号里限定，之后的T不用再加限定 一个类型变量或通配符可以有多个限定，用’&amp;’分隔限定类型，用逗号分隔类型变量，例如：T extends Comparable &amp; Serializable 可以有多个接口限定和至多一个类限定，将标记接口(空接口)放在限定列表的末尾，如果用一个类作为限定，它必须是限定列表中的第一个 类型擦除对于虚拟机来说没有泛型类型，只有普通类和方法。无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。在编译时泛型类型会被转化为原始类型。原始类型就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(无限定类型的变量替换为Object)。例如，Pair&lt;T&gt;的原始类型如下：1234567891011public class Pair&#123; private Object first; private Object second; public Pair() &#123;first = null; second = null&#125; public Pair(Object first,Object second) &#123;this.first = first; this.second = second&#125; public void setFirst(Object newValue) &#123;first = newValue;&#125; public void setSecond(Object newValue) &#123;second = newValue;&#125; &#125; 因为T是一个无限定的参数变量，所以直接用Object替换如果是T是一个限定类型的参数变量，用限定列表中的第一个类型替换，比如T extends Comparable &amp; Serializable被替换为Comparable 翻译泛型表达式当泛型表达式编译时，编译器会将其编译为原始类型并加入强制类型转换。比如：12Pair&lt;Employee&gt; buddies = . . . ;Employee buddy = buddies.getFirst(); 编译器会把这个方法调用翻译为两条虚拟机指令： 对原始方法Pair.getFirst的调用 将返回的Object类型强制转换为Employee类型 当存入一个泛型域时编译器也会自动在字节码中插入强制类型转换。 翻译泛型方法类型擦除会发生一些问题，比如一个类subPair继承自类Pair&lt;String&gt;：1234class SubPair extends Pair&lt;String&gt; //继承一个泛型类 &#123; public void setFirst(String newValue)&#123;....&#125;//重写了父类的方法 &#125; Pair在编译的时候被类型擦除，Pair的setFirst方法变为了setFirst(Object newValue)，这样SubPair的setFirst(Stirng newValue)方法就无法覆盖父类中的setFirst(Object newValue)方法，因为参数不同，不是同一个方法。SubPair中会出现两个方法：12public void setFirst(String newValue)&#123;....&#125;public void setFirst(Object newValue)&#123;....&#125; 此时如果有如下测试代码：123SubPair p = new SubPair(. . .);Pair&lt;String&gt; pair = p;p.setFirst("Hello world"); 按理来说，这段测试代码应该不能通过编译，因为要实现多态的话，所调用的方法必须在子类中重写，但是在这里SubPair类并没有重写Pair类中的setFirst方法，只是单纯的继承而已，并且新加了一个参数不同的同名方法。但结果可以运行，因为为了解决这种类型擦除和多态的冲突，编译器会在SubPair类中生成一个桥方法，上述两个方法被编译器变成了这样：12345678public void setFirst(String newValue)&#123;....&#125; //子类定义的方法不变//编译器生成的桥方法 public void setFirst(Object newValue)&#123; setFirst((String) newValue); //桥内部调用的是子类中定义的setFirst(String newValue)方法&#125; 可以看出，这个桥方法实际上就是对超类中setFirst(Object newValue)的重写。这样做的原因是，当程序员在子类中写下setFirst(String newValue)方法时，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免类型擦除与多态发生冲突。详见博客：Java中的类型擦除与桥方法 约束与局限性在使用Java泛型时需要考虑一些限制。大多数限制都是由类型擦除引起的。 1.不能用基本类型实例化类型参数类型参数不能为基本类型。比如，没有Pair&lt;double&gt;只有Pair&lt;Double&gt;,其原因是类型擦除，因为擦除之后，Pair类含有Object类型的域，Object不能存储double值。 2.运行时类型查询只适用于原始类型使用instanceof查询一个对象是否属于某个泛型类会产生编译错误，比如：1if(a instanceof Pair&lt;String&gt;)//Error 同样的道理，getClass方法总是返回原始类型。例如：123Pair&lt;String&gt; stringPair = . . .;Pair&lt;Employee&gt; employeePair = . . .;if(stringPair.getClass() == employeePair.getClass()) //equal 其比较结果是true，因为两次调用getClass结果都返回Pair.class 3.不能创建参数化类型的数组不能实例化参数化类型的数组，例如：1Pair&lt;String&gt;[] table = new Pair&lt;String&gt; [10];//Error 最安全而有效的方法是使用ArrayList，即ArrayList&lt;Pair&lt;String&gt;&gt; 4.Varargs警告考虑下面的方法，它有可变长的泛型类型参数ts：123public static&lt;T&gt; void addAll(Collection&lt;T&gt; coll,T...ts)&#123; for(t : ts) coll.add(t); &#125; 现在如果调用：1234Collection&lt;Pair&lt;String&gt;&gt; table = . . .;Pair&lt;String&gt; pair1 = . . .;Pair&lt;String&gt; pair2 = . . .;addAll(table,pair1,pair2); JVM会为了可变长参数建立一个Pair数组，这违反了前面的规则。这里特别注意：Java不支持泛型类型的数组，但如果向参数个数可变的方法传递一个泛型类型的实例(即传递一个泛型类型对象的数组)这种规则有所放松，你只会得到一个警告，而不是错误。可以用@SuppressWarnings(&quot;unchecked&quot;)或用@SafeVarags标注addAll方法来抑制警告。即如下：12@SafeVarargspublic static&lt;T&gt; void addAll(Collection&lt;T&gt; coll,T...ts) 现在就可以提供泛型类型来调用这个方法了。 5.不能实例化类型变量不能使用像new T(…),new T[…]或T.class这样的表达式中的类型变量。例如，下面的Pair&lt;T&gt;构造器是非法的：1public Pair() &#123;first = new T();second = new T();&#125;//Error 类型擦除将T改变成Object，而且本意肯定不希望调用new Object()。在Java SE 8之后，最好的解决方法是让调用者提供一个构造器表达式。例如：1Pair&lt;String&gt; p = Pair.makePair(String::new); makePair方法接受一个Supplier&lt;T&gt;，这是一个函数式接口，表示一个无参数而且返回类型为T的函数：1234public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplier&lt;T&gt; constr)&#123; return new Pair&lt;&gt; (constr.get(),constr.get());&#125; 比较传统的解决方法是通过反射调用Class.newInstance方法来构造泛型对象。遗憾的是，细节有点复杂。不能调用：1first = T.class.newInstance();//Error 表达式T.class是不合法的，因为它会被类型擦除为Object.class。必须像下面这样设计API以便得到一个Class对象：12345public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; c1)&#123; try &#123;return new Pair&lt;&gt; (c1.newInstance(),c1.newInstance())&#125;; catch(Exception ex) &#123;return null;&#125;&#125; 这个方法可以按照下列方式调用：1Pair&lt;String&gt; p = Pair.makePair(String.class); 注意，Class类本身是泛型。例如,String.class是一个Class&lt;String&gt;的实例(事实上，它是唯一的实例)。因此,makePair方法能够推断除pair的类型。 6.不能构造泛型数组就像不能实例化一个泛型实例一样，也不能实例化数组。不过原因有所不同，毕竟数组会填充null值，构造时看上去是安全的。不过，数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被擦除。例如，考虑下面的例子：1public static &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;T[] mm = new T[2];&#125;//Error 类型擦除会让这个方法永远构造Comparable[2]数组。如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object[],并且在屈原素时进行类型转换。例如，ArrayList可以这样实现:12345678public class ArrayList&lt;E&gt;&#123; private Object[] elements; . . . @SuppressWarnings("unchecked") public E get(int i) &#123; return (E) elements[i];&#125;//取元素时强制类型转换 public void set(int i,E e) &#123; elements[i] = e;&#125;//改变元素时不必强转&#125; 实际的实现没有那么清晰：123456public class ArrayList&lt;E&gt;&#123; private E[] elements; . . . public ArrayList() &#123;elements = (E[]) new Object[10];&#125;&#125; 这里的强制类型转换E[]是一个假象，而类型擦除使其无法察觉。由于 minmax 方法返回 T[] 数组，使得这一技术无法施展， 如果掩盖这个类型会有运行时错误结果。假设实现代码：123456public static &lt;T extends Comparable&gt; T[] minmax(T... a)&#123;Object[] mm = new Object[2];. . .return (T[]) mm; // compiles with warning&#125; 调用 String[] ss = ArrayAlg.minmax(“Tom”, “Dick”, “Harry”);编译时不会有任何警告。当 Object[] 引用赋给 Comparable[] 变量时，将会发生 ClassCastException异常。在这种情况下， 最好让用户提供一个数组构造器表达式：1String[] ss = ArrayAlg.minmax (String[]::new，"Tom", "Dick", "Harry"); 构造器表达式 String::new 指示一个函数，给定所需的长度，会构造一个指定长度的String数组。minmax方法使用这个参数生成一个有正确类型的数组：1234public static &lt;T extends Comparable〉T[] minmax(IntFunction&lt;T[]&gt; constr, T... a)&#123; T[] mm = constr.apply(2);&#125; 比较老式的方法是利用反射， 调用 Array.newInstance:12345public static &lt;T extends Comparable〉T[] minmaxfT... a)&#123;T[] mm = (T[]) Array.newlnstance (a.getClass().getComponentType() , 2); . . .&#125; ArrayList 类的 toArray 方法就没有这么幸运。它需要生成一个 T[] 数组， 但没有成分类型。因此， 有下面两种不同的形式：12Object[] toArray()T[] toArray(T[] result) 第二个方法接收一个数组参数。如果数组足够大,就使用这个数组。否则,用 result 的成分类型构造一个足够大的新数组。 7.泛型类的静态上下文中类型变量无效不能在静态域或方法中引用类型变量。例如， 下列高招将无法施展：123456789public class Singleton&lt;T&gt;&#123; private static T singlelnstance; // Error public static T getSinglelnstanceO // Error &#123; if (singleinstance == null) //construct new instance of T return singlelnstance; &#125;&#125; 8.不能抛出或捕获泛型类的实例既不能抛出也不能捕获泛型类对象。实际上， 甚至泛型类扩展 Throwable 都是不合法的。例如， 以下定义就不能正常编译：12public class Problem&lt;T&gt; extends Exception &#123; /* . . . */ &#125; // Error can't extend Throwable catch 子句中不能使用类型变量。例如， 以下方法将不能编译：1234567891011public static &lt;T extends Throwable〉void doWork(Class&lt;T&gt; t)&#123; try &#123; do work &#125; catch (T e) // Error can 't catch type variable &#123; Logger.global.info(...) &#125;&#125; 不过，在异常规范中使用类型变量是允许的。以下方法是合法的：12345678910111213public static &lt;T extends Throwable&gt; void doWork(T t) throws T // OK&#123; try &#123; do work &#125; catch (Throwable real Cause) &#123; t.initCause(real Cause); throw t; &#125; &#125; 9.可以消除对受查异常的检查Java 异常处理的一个基本原则是， 必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。关键在于以下方法：12345@SuppressWamings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable e) throws T&#123;throw (T) e;&#125; 假设这个方法包含在类 Block 中，如果调用Block.&lt;RuntimeException&gt;throwAs(t);编译器就会认为 t 是一个非受查异常。 以下代码会把所有异常都转换为编译器所认为的非受查异常：12345678try&#123; do work&#125;catch (Throwable t)&#123; Block.&lt;RuntimeException&gt;throwAs(t) ;&#125; 下面把这个代码包装在一个抽象类中。用户可以覆盖 body 方法来提供一个具体的动作。调用 toThread 时， 会得到 Thread 类的一个对象， 它的 run 方法不会介意受查异常。12345678910111213141516171819202122232425public abstract class Block&#123; public abstract void body() throws Exception; public Thread toThrea() &#123; return new Thread() &#123; public void run() &#123; try &#123; body(); &#125; catch (Throwable t) &#123; Block.&lt;RuntimeException&gt; throwAs(t); &#125; &#125; &#125;;&#125;@SuppressWamings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable e) throws T&#123;throw (T) e;&#125; 例如， 以下程序运行了一个线程， 它会拋出一个受查异常。12345678910111213141516public class Test&#123; public static void main(String[] args) &#123; new Block() &#123; public void body() throws Exception &#123; Scanner in = new Scanner(new File("ququx") ,"UTF-8"); while (in.hasNext()) System.out.println(in.next()); &#125; &#125; .toThread() .start(); &#125;&#125; 运行这个程序时， 会得到一个栈轨迹， 其中包含一个FileNotFoundException ( 当然,假设你没有提供一个名为 ququx 的文件)。这有什么意义呢？ 正常情况下， 你必须捕获线程 run 方法中的所有受查异常， 把它们”包装”到非受查异常中， 因为 run 方法声明为不抛出任何受查异常。不过在这里并没有做这种”包装”。我们只是抛出异常， 并”哄骗”编译器， 让它认为这不是一个受查异常。通过使用泛型类、 擦除和 @SuppressWarnings 注解， 就能消除 Java 类型系统的部分基本限制。 注意擦除后的冲突当泛型类型被擦除时，无法创建引发冲突的条件。下面是一个示例。假定像下面这样将equals 方法添加到 Pair 类中：1234public class Pair&lt;T&gt;&#123;public boolean equals(T value) &#123; return first.equals(value) &amp;&amp; second.equals(value); &#125;&#125; 考虑一个Pair&lt;String&gt;。从概念上讲，它有两个equals方法：12boolean equals(String) // defined in Pair&lt;T&gt;boolean equals(Object) // inherited from Object 但是，直觉把我们引入歧途。方法擦除boolean equals(T)，就是boolean equals(Object)与 Object.equals 方法发生冲突。当然，补救的办法是重新命名引发错误的方法。泛型规范说明还提到另外一个原则:”要想支持擦除的转换， 就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，而这两个接口是同一接口的不同参数化。”例如，下述代码是非法的：123class Employee implements Coinparab1e&lt;Emp1oyee&gt; &#123; . . . &#125;class Manager extends Employee implements Comparable&lt;Hanager&gt; &#123; . . . &#125; // Error Manager 会实现 Comparable&lt;Employee&gt; 和 Comparable&lt;Manager&gt;, 这是同一接口的不同参数化。这一限制与类型擦除的关系并不十分明确。毕竟，下列非泛型版本是合法的。12class Employee implements Comparable &#123; . . . &#125;class Manager extends Employee implements Comparable &#123; . . . &#125; 其原因非常微妙， 有可能与合成的桥方法产生冲突。实现了 Comparable&lt;X&gt; 的类可以获得一个桥方法：1public int compareTo(Object other) &#123; return compareTo((X) other); &#125; 对于不同类型的 X 不能有两个这样的方法。 泛型类型的继承规则]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习之线段树]]></title>
    <url>%2F2017%2F10%2F18%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。 线段树是什么？有什么用？线段树类似区间树，它在各个节点保存一条线段(数组中的一段子数组)，主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。你可能会问：查询区间和可以用O(n)的复杂度预处理一个前缀和数组，然后就可以O(1)地查询某段区间和;查询区间最值，也就是RMQ问题，也可以用O(nlogn)的复杂度预处理ST表，然后O(1)地查询区间最值。那么为什么要使用线段树呢？线段树的精髓就在于它能在支持区间动态修改的前提下保持每个操作O(logn)的复杂度，这是其他两者做不到的。线段树能进行的操作主要有：1)单点更新，区间查询 2)区间更新，区间查询 3)区间更新，单点查询除了上述操作，线段树还可以解决区间染色和矩形面积交、面积并等问题。 线段树基本知识线段树的结构： 建立一个线段树的示意图(可以维护区间和或最值)： 单点修改后重新调整线段树： 区间查询区间最值： 线段树的结点关系: 线段树的代码实现下面给出建立线段树和进行各种操作的模板，关键点在代码的注释中有解释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*node：区间结点号 begin：该node的区间左边界 end：该node的区间右边界 left：查询区间的左边界 right：查询区间的右边界 pos：查询区间的点*/ /*线段树:求和或最值 单点更新,区间查询区间更新,单点查询(lazy标记表示本节点的信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。lazy初始为0,区间加上k给该区间管理的结点的lazy加k,push_down给子节点加(end-begin+1)*k)区间更新,区间查询 lson 2*noderson 2*node+1[begin,end][begin,mid] [mid+1,end] 其中mid为(begin+end)/2 */ #define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1) int segTree[maxn*4];int lazy[maxn*4];void pushUp(int node)&#123;//pushUp自底向上更新区间和与最值 segTree[node]=segTree[lson]+segTree[rson];//segTree[node]=max(segTree[lson],segTree[rson]) &#125;void pushDown(int node,int begin,int end)&#123;//pushDown自顶向下更新lazy数组和给结点加上lazy数组的值 if(!lazy[node]) return;//lazy[node]为0直接return segTree[lson]+=(mid-begin+1)*lazy[node]; segTree[rson]+=(end-mid)*lazy[node]; lazy[lson]+=lazy[node]; lazy[rson]+=lazy[node];//给左右孩子传递lazy,是+=不是=，因为孩子节点可能被多次延迟标记又没有向下传递 lazy[node]=0;//把父节点的lazy置为0 &#125;void build(int node,int begin,int end)&#123;//建树 lazy[node]=0; if(begin==end)&#123;//begin==end表示管理的是结点 scanf("%d",&amp;segTree[node]);//按照顺序输入结点，由于建树类似于树的先根遍历，所以建立的线段树的叶子结点从左到右的值就是输入的顺序 //segTree[node]=a[begin] 用于任意顺序输入,先将输入存入a数组,下标从1开始，begin = end = index return;//输入完成后要return，否则会继续访问左右孩子，可能越界 &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123;//单点更新 if(pos&lt;begin||pos&gt;end) return;//管理的区间不包含pos,直接return if(begin==end)&#123; segTree[node]+=k; return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125; int query(int node,int begin,int end,int left,int right)&#123;//区间查询 if(left&gt;end||right&lt;begin) return 0;//查询结点和区间没有公共点 if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node];//查询区间包含查询结点 pushDown(node,begin,end); int sum=0;//int maxx=-1 sum+=query(lson,begin,mid,left,right);//maxx=max(maxx,query(lson,begin,mid,left,right)) sum+=query(rson,mid+1,end,left,right);//maxx=max(maxx,query(rson,mid+1,end,left,right)) return sum;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123;//区间更新 if(left&gt;end||right&lt;begin) return;//结点和更新区间没有公共点 if(left&lt;=begin&amp;&amp;right&gt;=end)&#123;//更新区间包含结点 segTree[node]+=(end-begin+1)*k; lazy[node]+=k; return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125; 例题一、单点更新，区间查询HDU1166 敌兵布阵题目链接:http://acm.split.hdu.edu.cn/showproblem.php?pid=1166代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define maxn 50005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[maxn*4];int T,N,a,b;char command[10];void pushUp(int node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void build(int node,int begin,int end)&#123; if(begin==end)&#123; scanf("%d",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segTree[node]+=k; return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; int sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;int main()&#123; scanf("%d",&amp;T); int cas=1; while(T--)&#123; scanf("%d",&amp;N); build(1,1,N); printf("Case %d:\n",cas++); while(scanf("%s",command)!=EOF)&#123; if(command[0]=='E') break; scanf("%d%d",&amp;a,&amp;b); if(command[0]=='Q') cout&lt;&lt;query(1,1,N,a,b)&lt;&lt;endl; else if(command[0]=='A') update(1,1,N,a,b); else if(command[0]=='S') update(1,1,N,a,-b); &#125; &#125;&#125; HDU 1754 I Hate It题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1754代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define maxn 200005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[4*maxn];int N,M,A,B;char C[3];void pushUp(int node)&#123; segTree[node]=max(segTree[lson],segTree[rson]);&#125;void build(int node,int begin,int end)&#123; if(begin==end)&#123; scanf("%d",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segTree[node]=k;//直接修改 return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; int maxx=0; maxx=max(maxx,query(lson,begin,mid,left,right)); maxx=max(maxx,query(rson,mid+1,end,left,right)); return maxx;&#125;int main()&#123; while(scanf("%d%d",&amp;N,&amp;M)!=EOF)&#123; build(1,1,N); while(M--)&#123; scanf("%s%d%d",C,&amp;A,&amp;B); if(C[0]=='Q')&#123; printf("%d\n",query(1,1,N,A,B)); &#125; else&#123; update(1,1,N,A,B); &#125; &#125; &#125;&#125; 二、区间更新，区间查询POJ 3468 A Simple Problem with Integers题目链接:http://poj.org/problem?id=3468代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#define maxn 100005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;typedef long long ll;ll segTree[4*maxn];ll lazy[4*maxn];ll N,Q,A,B,C;char command[3];void pushUp(ll node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void pushDown(ll node,ll begin,ll end)&#123; if(!lazy[node]) return; segTree[lson]+=(mid-begin+1)*lazy[node]; segTree[rson]+=(end-mid)*lazy[node]; lazy[lson]+=lazy[node]; lazy[rson]+=lazy[node]; lazy[node]=0;&#125;void build(ll node,ll begin,ll end)&#123; lazy[node]=0; if(begin==end)&#123; scanf("%lld",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node); &#125;ll query(ll node,ll begin,ll end,ll left,ll right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; pushDown(node,begin,end); ll sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;void update(ll node,ll begin,ll end,ll left,ll right,ll k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segTree[node]+=(end-begin+1)*k; lazy[node]+=k; return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125;int main()&#123; scanf("%lld%lld",&amp;N,&amp;Q); build(1,1,N); while(Q--)&#123; scanf("%s",command); if(command[0]=='Q')&#123; scanf("%lld%lld",&amp;A,&amp;B); printf("%lld\n",query(1,1,N,A,B)); &#125; else&#123; scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;C); update(1,1,N,A,B,C); &#125; &#125;&#125; HDU 1698 Just A Hook题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1698代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define maxn 100005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[4*maxn];int lazy[4*maxn];int T,N,Q,X,Y,Z;void pushUp(int node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void build(int node,int begin,int end)&#123; lazy[node]=0; if(begin==end)&#123; segTree[node]=1; return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void pushDown(int node,int begin,int end)&#123; if(!lazy[node]) return; segTree[lson]=(mid-begin+1)*lazy[node];//+=改成=,直接更新到底部 segTree[rson]=(end-mid)*lazy[node]; lazy[lson]=lazy[node]; lazy[rson]=lazy[node]; lazy[node]=0;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segTree[node]=(end-begin+1)*k;//+=改成=,直接更新到底部 lazy[node]=k;//+=改成=,因为此时lazy即使没有下传也不叠加 return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; pushDown(node,begin,end); int sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;int main()&#123; scanf("%d",&amp;T); int cas=1; while(T--)&#123; scanf("%d%d",&amp;N,&amp;Q); build(1,1,N); while(Q--)&#123; scanf("%d%d%d",&amp;X,&amp;Y,&amp;Z); update(1,1,N,X,Y,Z); &#125; printf("Case %d: The total value of the hook is %d.\n",cas++,query(1,1,N,1,N)); &#125;&#125; 三、区间染色问题ZOJ 1610 Count the Colors题目链接:https://vjudge.net/problem/11553/origin代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)#define maxn 8005using namespace std;int col[maxn*4];//col[node]表示node管辖的区间的颜色 int sum[maxn];//表示某点的颜色 int res[maxn];void pushDown(int node)&#123; col[lson]=col[rson]=col[node]; col[node]=-1;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; col[node]=k; return; &#125; if(col[node]!=-1) pushDown(node); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k);&#125;//不用建树,直接在query里存储颜色即可，因为染色不用求区间和或者最值 void query(int node,int begin,int end,int left,int right)&#123; if(begin==end)&#123; sum[begin]=col[node];//存储每个点的颜色 return; &#125; if (col[node] != -1) pushDown(node); query(lson,begin,mid,left,right); query(rson,mid+1,end,left,right);&#125;int main()&#123; int n,x1,x2,c; while(scanf("%d",&amp;n)!=EOF)&#123; memset(col,-1,sizeof(col)); memset(sum,-1,sizeof(sum)); memset(res,0,sizeof(res)); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;x1,&amp;x2,&amp;c); if(x1==x2) continue;//为了保证R-1&gt;=L update(1,0,maxn-1,x1,x2-1,c);//为防止重叠,更新区间[L,R-1] /*注意begin=0 end=maxn-1 而不是begin=1 end=n 因为只是涂n次,不一定在1-n范围内涂 */ &#125; query(1,0,maxn-1,0,maxn-1); for(int i=0; i&lt;maxn; i++) &#123; while(i!=0&amp;&amp;sum[i]!=-1&amp;&amp;sum[i]==sum[i-1])//涂过同一颜色也加1 i++; res[sum[i]]++; &#125; for(int i=0; i&lt;maxn; i++) if(res[i]) printf("%d %d\n",i,res[i]); printf("\n"); &#125; return 0;&#125; POJ 2528 Mayor’s posters题目链接:http://poj.org/problem?id=2528代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/*解法：离散化，如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的 1 2 3 4 6 7 8 10 — — — — — — — — 1 2 3 4 5 6 7 8离散化 X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。但是只是这样简单的离散化是错误的，如三张海报为：1~10 1~4 6~10离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10第一张海报时：墙的1~4被染为1；第二张海报时：墙的1~2被染为2，3~4仍为1；第三张海报时：墙的3~4被染为3，1~2仍为2。最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3最终，1~2为2，3为1，4~5为3，于是输出正确结果3。*/ #include&lt;cstdio&gt; #include&lt;cstring&gt;#include&lt;algorithm&gt;#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;#define maxn 10005//不用建树,直接在query里记录hash即可，因为染色不用求区间和或者最值，也不用pushUp int m, li[maxn], ri[maxn];int poster[maxn&lt;&lt;3], col[maxn&lt;&lt;4], ans; //col记录当前该位置最上面一层的海报种类,即染色问题的颜色 //poster记录海报位置 bool hash[maxn];//hash用于标记某种种类的海报是否计算过,若已计算过标记为true,不再重复计算 void pushDown(int node) &#123; col[lson] = col[rson] = col[node];//类似lazy标记，向下传递后清空 col[node] = -1;&#125;void update(int node,int begin, int end,int left, int right, int k) &#123; if(left&gt;end||right&lt;begin) return; if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; col[node] = k; return; &#125; if(col[node] != -1) pushDown(node); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k);&#125;void query(int node,int begin,int end) &#123; if (begin == end) &#123; if (!hash[col[node]]) &#123; ans++; hash[col[node]] = true; &#125; return; &#125; if (col[node] != -1) pushDown(node); query(lson,begin,mid); query(rson,mid+1,end);&#125;int binarySearch(int ll, int hh, int xx) &#123; int mm; while (ll &lt;= hh) &#123; mm = (ll + hh) &gt;&gt; 1; if (poster[mm] == xx) return mm; else if (poster[mm] &gt; xx) hh = mm - 1; else ll = mm + 1; &#125; return -1;&#125;int main()&#123; int t, n, i; scanf ("%d", &amp;t); while (t--) &#123; memset(col, -1, sizeof (col));//-1表示没有染色 memset (hash, false, sizeof (hash));/*因为本题墙的长度为10000000,直接做会超时,而实际海报数量只有10000,考虑把每张海报左右两端的两段映射到小范围计算，所以考虑离散化,但传统离散化会出错,要如果有两个位置相邻的数字数值不相邻,考虑在中间插入一个比大的数小1的数*/ int cnt = 0; scanf ("%d", &amp;n); for (i = 1; i &lt;= n; i++) &#123; scanf ("%d %d", &amp;li[i], &amp;ri[i]); poster[++cnt] = li[i]; poster[++cnt] = ri[i]; &#125; sort(poster+1, poster+cnt+1); m = 1; for (i = 2; i &lt;= cnt; i++) &#123; if (poster[i] != poster[i-1]) poster[++m] = poster[i];//去重 &#125; for (i = m; i &gt; 1; i--) &#123; if (poster[i] - poster[i-1] &gt; 1) poster[++m] = poster[i] - 1;//在末尾加入要增加的点 &#125; sort(poster+1, poster+m+1);//重新排序 for (i = 1; i &lt;= n; i++) &#123; int l = binarySearch(1, m, li[i]);//在离散化后的poster数组里二分查找每一组的左右端点 int r = binarySearch(1, m, ri[i]); update(1,1,m,l,r,i); &#125; ans = 0; query(1, 1, m); printf("%d\n", ans); &#125; return 0;&#125; 四、矩形面积交/面积并HDU 1542 Atlantis(矩形面积并)题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1542代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt; #define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)#define maxn 2005using namespace std;int n;double y[maxn];//沿x轴扫描,沿y轴建树,线段树的结点是纵向的线段,最下面一层结点以排序后相邻的y1,y2为边界 struct LINE // 存储线段信息；&#123; double x; // 该线段的x坐标； double y_up,y_down; // 竖向线段的上下端点； int flag;//矩形的左边界为1,右边界为-1 &#125;line[maxn];struct node//线段树的结点,不再是单个点,是一个区间 &#123; double l,r; // 区间的左右边界,即某段扫描线的上下端点 double x; // 记录上一个横坐标位置，用于求面积； int cover; // 记录覆盖的线段数;即同一方向的线段数;由flag累加 bool flag; // 标记只有一个区间的节点,即在线段树最底层的结点,我们将一个个连续的区间离散化成一个结点；&#125;node[maxn&lt;&lt;2];bool cmp(LINE a,LINE b)&#123; return a.x&lt;b.x;&#125;void build(int rt,int l,int r) // 建树；&#123; node[rt].l=y[l]; // 维护区间； node[rt].r=y[r]; node[rt].x=-1; node[rt].flag=false; node[rt].cover=0; if(l+1==r)&#123; // 区间是连续的; node[rt].flag=true; // 标记为结点; return; &#125; build(lson,l,mid); build(rson,mid,r); // 因为将一个个连续区间离散成点，所以此处mid不需要+1；&#125;double Insert_query(int rt,double x,double l,double r,int flag) /*查询+更新x处（l,r）区间面积，l和r代表的是区间查询区间的边界，node[rt].l和node[rt].r代表的是结点边界*/&#123; if(l&gt;=node[rt].r||r&lt;=node[rt].l) return 0; // 该方向结点不包含所要查询的区间； if(node[rt].flag)&#123; // 找到只有一个区间的叶子结点； if(node[rt].cover&gt;0)&#123; double pre=node[rt].x; double ans=(x-pre)*(node[rt].r-node[rt].l); // 计算面积； node[rt].x=x; // 更新定位x位置，便于下次计算面积； node[rt].cover+=flag; // 更新覆盖的线段数； return ans; &#125; else&#123; node[rt].x=x; node[rt].cover+=flag; return 0;//没有产生面积并也要return 0 &#125; &#125; double ans1,ans2; ans1=Insert_query(lson,x,l,r,flag); ans2=Insert_query(rson,x,l,r,flag); return ans1+ans2;&#125;int main()&#123; int Case=0; double x1,x2,y1,y2; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int cnt=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); y[cnt]=y1; line[cnt].x=x1; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=1; // 表示左边线段； y[cnt]=y2; line[cnt].x=x2; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=-1; // 表示右边线段； &#125; sort(y,y+cnt); // 将所有高度由小到大排序，将区间建树表示 sort(line,line+cnt,cmp); // 因为扫描线从左到右扫描，所以按照横坐标从小到大排序后逐一插入线段树 build(1,0,cnt-1); double area=0; for(int i=0;i&lt;cnt;i++)&#123; area+=Insert_query(1,line[i].x,line[i].y_down,line[i].y_up,line[i].flag); &#125; printf("Test case #%d\nTotal explored area: %.2lf\n\n",++Case,area); &#125; return 0;&#125; HDU 1255 覆盖的面积(矩形面积交)题目链接:http://acm.split.hdu.edu.cn/showproblem.php?pid=1255代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)#define maxn 2005using namespace std;int T,N;double y[maxn];struct LINE&#123; double x; double y_up,y_down; int flag;&#125;line[maxn];struct node&#123; double l,r; double x; int cover; bool flag;&#125;node[maxn&lt;&lt;2];bool cmp(LINE a,LINE b)&#123; return a.x&lt;b.x;&#125;void build(int rt,int l,int r)&#123; node[rt].l=y[l]; node[rt].r=y[r]; node[rt].x=-1; node[rt].flag=false; node[rt].cover=0; if(l+1==r)&#123; node[rt].flag=true; return; &#125; build(lson,l,mid); build(rson,mid,r);&#125;double Insert_query(int rt,double x,double l,double r,int flag)&#123; if(l&gt;=node[rt].r||r&lt;=node[rt].l) return 0; if(node[rt].flag)&#123; if(node[rt].cover&gt;1)&#123; double pre=node[rt].x; double ans=(x-pre)*(node[rt].r-node[rt].l); node[rt].x=x; node[rt].cover+=flag; return ans; &#125; else&#123; node[rt].x=x; node[rt].cover+=flag; return 0; &#125; &#125; double ans1,ans2; ans1=Insert_query(lson,x,l,r,flag); ans2=Insert_query(rson,x,l,r,flag); return ans1+ans2;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; int cnt=0; scanf("%d",&amp;N); while(N--)&#123; double x1,y1,x2,y2; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); y[cnt]=y1; line[cnt].x=x1; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=1; y[cnt]=y2; line[cnt].x=x2; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=-1; &#125; sort(y,y+cnt); sort(line,line+cnt,cmp); build(1,0,cnt-1); double area=0; for(int i=0;i&lt;cnt;i++)&#123; area+=Insert_query(1,line[i].x,line[i].y_down,line[i].y_up,line[i].flag); &#125; printf("%.2lf\n",area); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之抽象类、接口、lambda表达式与内部类]]></title>
    <url>%2F2017%2F10%2F16%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它子类的共同特征。如果一个父类设计得非常抽象，以至于它没有任何具体的实例，这样的类称为抽象类，使用abstract关键字修饰。抽象类定义了相关子类的共同行为。 抽象方法如果一个方法非常抽象，只定义了方法，没有提供方法的具体实现，那么我们把它定义为一个抽象方法，它的具体实现由子类提供，即子类覆盖抽象方法提供方法体。抽象方法由abstract关键字修饰，只有方法头，没有花括号和方法体，以分号结尾。比如一个GeometricObject类定义了一个名为getArea的抽象方法，即public abstract double getArea(); 几点说明1.抽象方法应该定义为public，以便子类进行重写。2.抽象类的构造器应该定义为protected，因为抽象类不能通过new直接创建实例，其构造器只被子类调用。创建一个具体子类的实例时，它的父类的构造器被调用以初始化父类中定义的数据域。3.一个包含抽象方法的类必须定义为抽象类，一个不包含抽象方法的类也可以定义为抽象类(如果不想让某类创建实例，可以把它定义为抽象类)4.如果子类继承抽象类时没有覆盖其所有的抽象方法，即子类中仍有抽象方法，子类也应该定义为抽象的5.抽象方法是非静态的6.子类可以覆盖父类的方法并将它定义为abstract,这种情况很少见，但它在当父类方法实现在子类中变得无效时是很有用的，在这种情况下，子类必须定义为abstract7.即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object是具体的，但它的子类GeometricObject是抽象的。8.不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。下面的语句创建一个GeometricObject类型的数组是正确的：GeometricObject[] objects = new GeometricObject[10];然后可以创建一个具体子类的实例并把它的引用赋给数组，如：Objects[0] = new Circle(); 接口接口在很多方面都与抽象类很相似，但它的目的是指明相关或者不相关类的多个对象的共同行为，属性成员都是公共静态常量，成员方法都是公共抽象方法。例如，使用正确的接口，可以指明这些对象是可比较的、可克隆的。为了区分接口和类，Java采用Interface关键字定义接口。在一个java文件内，只能有一个public类或一个public接口，即public类和public接口不能同文件共存。接口没有构造器，没有实例域，也不能使用new操作符创建实例。接口没有构造器的原因有三点：1.构造器用于初始化成员变量，接口没有成员变量，不需要构造器2.类可以实现多个接口，如果多个接口都有构造方法，不好确定构造方法链的调用次序3.作为高度抽象的概念，接口不能实例化对象，也就不需要构造器 像常规类一样，每个接口都被编译为独立的字节码文件，可以作为引用变量的数据类型和类型转换的结果，可以使用instanceof关键字等。类实现接口用implements关键字，一个类可以实现多个接口，用逗号隔开即可。一个接口可以继承多个接口，用extends关键字。在定义接口中的数据域和方法时可以简写，例如：1234public interface T&#123; public static final int K = 1; public abstract void p(); &#125; 可简写成1234public interface T&#123; int K = 1; void p();&#125; 要注意接口中所有的数据域都是public static final，所有的方法都是public abstract，在定义接口中允许省略修饰符，但在子类重写方法时不可缺省public修饰符，否则方法的可见性会缩小为包内可见。 静态方法从Java SE 8开始，允许在接口中增加静态方法，理论上讲是可以的，但这有违于接口作为抽象规范的初衷。 默认方法可以为接口方法提供一个默认实现，用default修饰符标记，这样子类无需重写这个方法也能得到一个接口的默认实现。例如：12345678public interface Collection&#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 这样实现Collection的程序员就不用操心实现isEmpty方法了。默认方法的一个重要用法是“接口演化”。以Collection接口为例，这个接口作为Java的一部分已经很多年了，假设很久以前定义了一个实现Collection接口的类Bag。后来在Collection接口中增加了一个stream方法，假设stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。如果不重新编译这个类，而是使用原先包含这个类的JAR文件，这个类仍能正常加载，正常构造实例，但如果在一个Bag实例上调用stream方法，会出现一个AbstractMethodError。但如果把stream方法定义为默认方法就可以解决这个问题，既可以重新编译也可以使用JAR文件加载类并调用stream方法。 解决默认方法的冲突如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生冲突。解决冲突规则如下：1) 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。2) 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突，即从中选择一个方法重写。 Comparable接口Comparable接口定义了compareTo方法，用于比较对象。当想使用Arrays类的sort方法对对象数组进行排序时，对象所属的类必须实现了Comparable接口。Comparable接口是一个带泛型的接口，定义为：123public interface Comparable&lt;E&gt;&#123; public int compareTo(E o); &#125; compareTo应该与equals保持一致，即当且仅当o1.equals(o2)为true时，o1.compareTo(o2) == 0成立。以下是compareTo方法的实现： 12345class Employee implements Comparable&lt;Employee&gt;&#123;public int compareTo(Employee other)&#123; return Double.compare(salary,other.salary); &#125;&#125; 在比较浮点数时可以使用Double的静态方法compare,这样就不必担心溢出或精度损失，类似的还有Integer.compare方法等 继承过程中的compareTo，如果由子类决定相等的概念，每个compare方法都应该在开始时检测：if(getClass() != other.getClass()) throw new ClassCastException()：如果父类决定相等的概念，应该在超类中提供一个compareTo方法，并将这个方法声明为final。 Comparator接口 Comparator接口意为”比较器”接口，是一个泛型接口，可用于自定义排序规则和大小比较等。要进行自定义排序，Arrays.sort方法有一个重载版本，需要提供一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。接口定义为： 1234public interface Comparator&lt;T&gt;&#123; int compare(T first,T second);&#125; 如果要按长度比较字符串，由于String是按字典序比较字符串，肯定不能让String类用两种方法实现compareTo方法 —— 况且String类也不由我们修改。此时可以定义如下实现Comparator的类： 123456class lengthComparator implements Comparator&lt;String&gt;&#123; public int compare(String first,String second)&#123; return first.length() - second.length(); &#125;&#125; 因为要调用compare方法，所以具体比较大小和排序时都要创建一个lengthComparator的实例： 大小比较 12Comparator&lt;String&gt; comp = new LengthComparator();if(comp.compare(words[i],words[j]) &gt; 0) ... 自定义排序 12String[] friends = &#123;"Peter","Paul","Mary"&#125;;Arrays.sort(friends,new LengthComparator()); Cloneable接口 首先，我们考虑为一个包含对象引用的变量建立副本会发生什么，例如： 123Employee original = new Employee("John Public",50000);Employee copy = original;copy.ratseSalary(10); //original的salary也被改变 原变量和副本都会指向同一个对象，这说明，任何一个变量的改变都会影响到另一个变量。如果有一个对象original，希望创建一个对象copy使得其初始状态与original相同，但是之后它们各自回有自己不同的状态，这种情况下就可以使用克隆，例如：12Employee copy = original.clone();copy.raiseSalary(10); //original的salary不会被改变 Object类中的clone方法将原始对象的每个数据域复制给目标对象，如果一个数据域是基本数据类型，复制的就是它的值，如果是引用类型，复制的就是它的引用，这种克隆称为浅复制,即original != copy,但original.hireDay == copy.hireDay。这有时是不符合我们要求的，我们不希望在改变某个对象的引用类型的数据域时影响到另一个对象，这时我们需要深复制,即如果数据域是引用类型，复制的是对象的内容而不是引用。无论是浅复制还是深复制，我们都需要先实现Cloneable接口，否则会产生一个必检异常。Cloneable接口的定义是：123public interface Cloneable&#123;&#125; 我们发现这个接口是空的，一个带空体的接口称为标记接口。一个标记接口既不包括常量也不包括方法，它用来表示一个类拥有的某些特定的属性，其惟一的作用是允许在类型查询中使用instanceof关键字。但如果一个请求克隆的对象不实现这个接口，会产生CloneNotSupportedException，即使clone的默认(浅拷贝)实现能够满足要求，还是要实现这一接口。在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone方法，这个方法是从Object类继承的，这个接口只是作为一个标记。 Object类中提供的原始clone方法的方法头是protected native Object clone() throws CloneNotSupportedException,关键字native表明这个方法不是用Java写的，但它是JVM针对自身平台实现的。关键字protected限定方法只能在同一个包内或在其子类中访问。由于这个原因：必须在要实现克隆的子类中覆盖这个方法并把可见性修饰父改为public。下面给出一个浅复制的例子：12345678class Employee implements Cloneable&#123; public Employee clone() throws CloneNotSupportedException &#123; return (Employee) super.clone(); &#125; . . .&#125; 下面给出一个深复制的例子： 12345678910class Employee implements Cloneable&#123; public Employee clone() throws CloneNotSupportedException &#123; . . . Employee cloned = (Employee) super.clone; cloned.hireDay = (Date)hireDay.clone(); return cloned; &#125;&#125; 我们注意到Object类的clone方法的返回值类型是Object，而Employee类的clone方法返回值类型是Employee，这叫做协变返回类型，即子类在重写父类方法时可以返回父类返回值类型的子类型。clone方法声明异常也可以改成捕获异常，如：123456789public Employee clone()&#123; try &#123; Employee cloned = (Employee) super.clone(); . . . &#125; catch(CloneNotSupportedException e)&#123; return null;&#125; &#125; 复制数组的四种方法1.申请一个新数组，遍历原数组逐一复制元素2.使用System类的静态方法arraycopy3.使用数组对象.clone返回一个数组克隆的引用4.使用Arrays类的copyOf方法 接口和抽象类区别：1.接口所有的变量必须是public static final;抽象类的变量无限制2.接口没有构造方法，不能用new操作符实例化;抽象类有构造方法，由子类通过构造方法链调用，不能用new操作符实例化3.接口所有方法必须是公共抽象实例方法(Java SE 8开始允许定义静态方法)，抽象类无限制4.一个类只可以继承一个父类，但可以实现多个接口5.所有的类有一个共同的根Object类，接口没有共同的根6.抽象类和子类的关系应该是强的“是一种”关系(strong is-a relationship),而接口和子类的关系是弱的”是一种”关系(weak is-a relationship)。接口比抽象类更灵活，因为实现接口的子类只需要具有统一的行为即可，不需要都属于同一个类型的类。 接口与回调 回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下按钮或选择某个菜单项时应该采取什么行动。 内部类 内部类，或者称为嵌套类，是一个定义在另一个类范围中的类。一个内部类可以如常规类一样使用。通常，在一个类只被它的外部类所使用的时候，才将它定义为内部类，内部类机制主要用于设计具有互相协作关系的类集合。比如： 12345678910111213141516//OuterClass.java: inner class demopublic class OuterClass &#123; private int data; /** A method in the outer class */ public void m()&#123; //Do something &#125; // An inner class class InnerClass &#123; /** A method in the inner class */ public void mi()&#123; data++; m(); &#125; &#125; &#125; 为什么要使用内部类，主要原因有三： 1.内部类可以访问包含它的外部类的所有数据域(包括私有数据域)和方法，没有必要将外部类对象的引用传递给内部类的构造方法,内部类有一个指向外部类对象的隐式引用，如果显式写出，外部类的引用是OuterClass.this 2.内部类可以对同一个包中的其他类隐藏起来 3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷 内部类具有一下特征： 1) 一个内部类被编译成一个名为OuterClassName$InnerClassName的类。例如，一个定义在Test类中的内部类A被编译成Test$A.class 2) 一个内部类可以使用可见性修饰符(public、private、protected、default)所定义，和应用于一个类中成员的可见性规则一样 3) 一个内部类可以被定义为static，一个static的内部类可以使用外部类的名字访问,一个static内部类不能访问外部类中的非静态成员 4) 内部类对象通常在外部类中创建，但是你也可以从另外一个类中来创建一个内部类的对象。如果内部类是非静态的，你必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类对象：OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 如果内部类是静态的，使用下面语法来创建一个内部类对象:OuterClass.InnerClass innerObject = new OuterClass.InnerClass(); 5) 内部类所有的静态域必须是final修饰的静态常量,不能有静态变量，也不能有静态方法 一个简单的内部类的用途是将相互依赖的类结合到一个主类中，这样做减少了源文件的数量(因为非内部类如果用public修饰必须放在不同的源文件中，而内部类可放在同一源文件中)，这样也使得类文件容易组织，因为它们都将主类名作为前缀。另外一个内部类的实际用途是避免类名冲突。 内部类对于定义处理器类非常有用，一个处理器类被设计为针对一个GUI组件创建一个处理器对象(比如，一个按钮)。处理器类不会被其他应用所共享，所以将它定义在主类里面作为一个内部类使用是恰如其分的。 广泛意义上的内部类一般来说包括四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。 成员内部类 成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式： 1234567891011121314 class Circle &#123; private double radius = 0; public static int count =1; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; //内部类 public void drawSahpe() &#123; System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125;&#125; 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：外部类.this.成员变量 外部类.this.成员方法 局部内部类 可以把内部类定义在一个方法中，称为局部内部类。局部内部类就像是方法里面的一个局部变量一样，不能有public、protected、private以及static修饰符。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，即对外部世界完全隐藏起来。即使外部类中的其他代码也不能访问它。除了其所在的方法之外，没有任何方法知道该局部类的存在。局部内部类只能访问被final修饰的局部变量。 123456789101112131415161718 class People&#123; public People() &#123; &#125;&#125; class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 匿名内部类 一个匿名内部类是一个没有名字的内部类，其语法如下： 12345new SuperClassName/InterfaceName()&#123; //implement or override methods in superclass or interface //Other methods if necessary &#125; 其含义是创建一个继承自SuperClass或实现Interface的类的实例，并在类块内重写父类或接口的抽象方法，应该将匿名内部类理解成一个匿名子类的匿名对象,而不是理解成一个类。 匿名内部类有如下特征： 1.没有可见性修饰符 2.没有构造方法(因为没有名字,无法命名构造方法),但可以调用父类的构造方法，即new SuperClassName()调用父类无参构造方法，new SuperClassName(args1,...)调用父类有参构造方法。如果实现的是接口，则不能有任何参数，但是小括号仍然不可缺省 3.必须总是从一个父类继承或者实现一个接口，但是它不能有显式的extends或者implements子句 4.必须实现父类或接口中的所有抽象方法 5.一个匿名内部类被编译成一个名为OuterClassName$n.class的类，例如：如果外部类Test有两个匿名内部类，分别被编译成Test$1.class和Test$2.class 应用一 下面的技巧称为“双括号初始化”，这里利用了内部类语法。假设你想构造一个数组列表，并将它传递到一个方法。 1234ArrayList&lt;String&gt; friends = new ArrayList&lt;String&gt;();friends.add("Harry");friends.add("Tony");invite(friends); 如果不再需要这个数组列表，最好让它作为一个匿名列表。语法如下： 1234567 invite(new ArrayList&lt;String&gt; &#123; &#123; add("Harry"); add("Tony"); &#125;&#125;); 注意这里的双括号，外括号建立了一个ArrayList的匿名子表，内括号则是一个对象构造块。 应用二 生成日志或调试消息时，通常希望包含当前类的类名，如： System.err.println(&quot;Something awful happened in &quot; + getClass()); 不过这对于静态方法并不凑效，因为调用getClass()调用的是this.getClass(),但静态方法里没有this，所以应该使用下面的表达式：new Object(){}.getClass().getEnclosingClass(),在这里，new Object(){} 会建立Object的一个匿名子类的匿名对象，getEnclosingClass则得到其外围类，也就是包含这个静态方法的类 静态内部类 有时候，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类的对象。为此，可以为内部类加上static关键字声明为静态内部类，以便取消产生的引用。与常规内部类不同，静态内部类可以有静态变量和静态方法。 下面是一个使用静态内部类的典型例子。考虑一下计算一个数组中最大值和最小值的问题，当然，可以编写两个方法，一个计算最大值，一个计算最小值，在调用这两个方法的时候，数组被遍历两次，而如果数组只被遍历一次就可以计算出最大值和最小值，那么效率就大大提高了。通过一个方法就计算出最大值和最小值：这个方法需要返回两个数（max 和 min），为此可以定义一个Pair类来封装这种数据结构，但是Pair是个非常大众的名字，可能在其他地方定义过，会发生名字冲突，此时可以将Pair定义为ArrayAlg类的内部类ArrayAlg.Pair。又因为Pair没有必要访问外围类ArrayAlg的数据域或方法，应该定义为静态内部类。 下面给出代码： 12345678910111213141516171819202122232425262728293031323334353637383940 public class ArrayAlg&#123; //Pair类，起数据封装的作用 public static class Pair&#123; private double first; private double second; public Pair(double f, double s)&#123; first = f; second = s; &#125; public double getFirst()&#123; return first; &#125; public double getSecond()&#123; return second; &#125; &#125; public static Pair maxmin(double[] values)&#123; double min = Double.POSITIVE_INFNITY; double max = Double.NEGATIVE_INFNITY; for(double x : values)&#123; if(x&lt;min) min = x; if(x&gt;max) max = x; &#125; return new Pair(max,min); &#125; public static void main(String[] args)&#123; Test te = new Test(); double[] teArgs = new double[]&#123;2.13,100.0,11.2,34.5,67.1,88.9&#125;; Pair res = te.maxmin(teArgs); System.out.println("max = "+res.getFirst()); System.out.println("min = "+res.getSecond()); &#125;&#125; 特别注意：代码中的Pair类如果没有声明为static，就不能在静态方法minmax中构造Pair的实例，编译器会给出错误报告：没有可用的隐式ArrayAlg类型对象初始化内部类对象 lambda表达式 lambda表达式可以被看作使用精简语法的匿名内部类，编译器对待一个lambda表达式如同它是从一个匿名内部类创建的对象。它是一种表示可以在将来某个时间点执行的代码块的简洁方法。使用lambda表达式，可以用一种精简的方式表示使用回调或变量行为的代码。如果要编译器理解lambda表达式，其代替的匿名内部类实现的接口必须只包含一个抽象方法，这样的接口被称为函数式接口(功能接口、单抽象方法接口）。在底层，接受lambda表达式的方法会接受实现某函数式接口的类的对象，并在这个对象上调用接口的方法，所以可以把lambda表达式赋给函数式接口(lambda表达式实际是一个实现了该函数式接口的类的类型，这里用到了多态)，不能把lambda表达式赋给Object变量，因为Object不是一个函数式接口。 一个lambda表达式就是一个代码块，以及必须传入代码的变量规范。其基础语法是(expression只有一条语句，不用花括号，也不用分号结尾) 1(type1 param1, type2 param2, ...) -&gt; expression 或者(statements是多条语句，要花括号，每条语句之后要分号结尾) 1(type1 param1, type2 param2, ...) -&gt; &#123;statements;&#125; 一个参数的数据类型既可以显式声明，也可以由编译器隐式推断。如果只有一个参数，并且没有显式的数据类型，圆括号可以被省略。如： 123e -&gt; &#123;// Code for processing event e&#125; 即使lambda表达式没有参数，也要提供空括号，就像无参数方法一样： 1() -&gt; &#123;for(int i = 100;i &gt;=0 ;i--) System.out.println(i);&#125; 无需指定lambda表达式的返回类型，编译器会由上下文推断，例如： 1(String first,String second) -&gt; first.length() - second.length() 可以在需要int类型结果的上下文中使用 如果一个lambda表达式只在某些分支上返回一个值，而在另外一些分支不返回值，是不合法的。例如： 1(int x) -&gt; &#123;if(x &gt;= 0) return 1;&#125; Comparator接口是一个函数式接口，可以用lambda表达式实现自定义排序的简化： 12Arrays.sort(words,(first,second) -&gt; first.length() - second.length()); 函数式接口 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口。 如果自己设计了一个函数式接口，可以用@FunctionalInterface注解来标记这个接口，这样做有两个好处： 1.可以在你无意中增加一个非抽象方法时产生编译错误 2.javadoc页里会指出你的接口是一个函数式接口 方法引用 有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如，假设你希望只要出现一个定时器事件就打印这个事件对象，可以调用： 1Timer t = new Timer(1000,event -&gt; System.out.println(event)); 可以直接把println方法传递到Timer的构造器： 1Timer t = new Timer(1000,System.out::println); 表达式System.out::println是一个方法引用，它等价于lambda表达式x -&gt; System.out.println(x) 我们再看一个例子，假设要对字符串排序，而不考虑字母的大小写，可以调用Arrays.sort(strings,String::compareToIgnoreCase); 方法引用主要有三种情况： object::instanceMethod Class::staticMethod Class::instanceMethod 对于前两种情况，方法引用等价于提供方法参数的lambda表达式。比如：System.out::println等价于x -&gt; System.out.println(x)，Math::pow等价于(x,y) -&gt; Math.pow(x,y)。第三种情况的第一个参数会称成为调用方法的目标对象，其余参数成为方法参数，比如：String::compareToIgnoreCase等价于(x,y) -&gt; x.compareToIgnoreCase(y)可以在方法里使用this和super,this::equals等同于x -&gt; this.equals(x),super::greet等同于() -&gt; super.greet() 类似于lambda表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。 构造器引用构造器引用与方法引用类似，只不过方法名为new。例如Employee::new是Employee构造器的一个引用。至于是哪一个构造器取决于上下文，比如Function&lt;Integer,Employee&gt; func1 = Employee :: new;就相当于Function&lt;Integer,Employee&gt; func = x -&gt; new Employee(x);数组类型也有构造器引用，如int[]::new等价于lambda表达式x -&gt; new int[x] 处理lambda表达式我们之前提到，lambda表达式的重点是延迟执行，之所以希望以后再执行代码，有很多原因，如： 在一个单独的线程中运行代码 多次运行代码 在算法的恰当位置运行代码(例如，排序中的比较操作) 发生某种情况时执行代码(如，点击了一个按钮、数据到达等) 只在必要时才运行代码 下面是常用的函数式接口和基本类型的函数式接口： 下面来看一个简单的例子。假设你想要重复一个动作n次。将这个动作和重复次数传递给一个repeat方法：1repeat(10,() -&gt; System.out.println("Hello world")); 要接受这个lambda表达式，需要选择一个函数式接口。在这里，我们可以使用Runnable接口：12345public static void repeat(int n,Runnable action)&#123; for(int i = 0;i &lt; n;i++) action.run();&#125; 现在让这个例子更复杂一点，我们希望告诉这个动作它出现在那一次迭代中。为此需要选择一个合适的函数式接口，其中要包含一个方法。这个方法有一个int参数而且返回类型为void。处理int值的标准接口如下：1234public interface IntConsumer&#123; void accept(int value);&#125; 下面给出repeat方法的改进版本:1234public static void repeat(int n,IntConsumer action)&#123; for(int i = 0;i &lt; n;i++) action.accept(i);&#125; 可以如下调用它：1repeat(10,i -&gt; System.out.println("Countdown: " + (9 - i))); 大多数函数标准函数式接口都提供了非抽象方法来生成或合并函数。例如,Predicate.isEqual(a)等同于a::equals,不过如果a为null也能正常工作。已经提供了默认方法and、or和negate来合并谓词。例如,Predicate.isEqual(a).or(Predicate.isEqual(b))就等同于x -&gt; a.equals(x) || b.equals(x) 通过三种方式实现事件处理器1.内部类 12345678910111213141516171819202122232425262728293031323334353637383940 public class HandleEvent extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; HBox pane = new HBox(10); pane.setAlignment(Pos.CENTER); Button btOK = new Button("OK"); OKHandlerClass handler1 = new OKHandlerClass(); btOK.setOnAction(handler1); Button btCancel = new Button("Cancel"); CancelHandlerClass handler2 = new CancelHandlerClass(); btCancel.setOnAction(handler2); pane.getChildren().addAll(btOK,btCancel); Scene scene = new Scene(pane,100,50); primaryStage.setTitle("HandleEvent"); primaryStage.setScene(scene); primaryStage.show(); &#125; class OKHandlerClass implements EventHandler&lt;ActionEvent&gt;&#123; @Override public void handle(ActionEvent e) &#123; System.out.println("OK button clicked"); &#125; &#125; class CancelHandlerClass implements EventHandler&lt;ActionEvent&gt;&#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Cancel button clicked"); &#125; &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; 2.匿名内部类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class AnonymousHandlerDemo extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; HBox hBox = new HBox(); hBox.setSpacing(10); hBox.setAlignment(Pos.CENTER); Button btNew = new Button("New"); Button btOpen = new Button("Open"); Button btSave= new Button("Save"); Button btPrint = new Button("Print"); hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint); btNew.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process New"); &#125; &#125;); btOpen.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process Open"); &#125; &#125;); btSave.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process Save"); &#125; &#125;); btPrint.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Process Print"); &#125; &#125;); Scene scene = new Scene(hBox,300,50); primaryStage.setTitle("AnonymousHandlerDemo"); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; 3.lambda表达式 123456789101112131415161718192021222324252627282930313233343536373839404142 import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class LambdaHandlerDemo extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; HBox hBox = new HBox(); hBox.setSpacing(10); hBox.setAlignment(Pos.CENTER); Button btNew = new Button("New"); Button btOpen = new Button("Open"); Button btSave= new Button("Save"); Button btPrint = new Button("Print"); hBox.getChildren().addAll(btNew,btOpen,btSave,btPrint); btNew.setOnAction((ActionEvent e)-&gt;&#123;System.out.println("Process New");&#125;); btOpen.setOnAction((e)-&gt;&#123;System.out.println("Process Open");&#125;); btSave.setOnAction(e-&gt;&#123;System.out.println("Process Save");&#125;); btPrint.setOnAction(e-&gt;System.out.println("Process Print")); Scene scene = new Scene(hBox,300,50); primaryStage.setTitle("LambdaHandlerDemo"); primaryStage.setScene(scene); primaryStage.show(); &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; 代理 见大牛博客 Java的三种代理模式 java中Proxy(代理与动态代理) java静态代理和动态代理 深入理解Java反射]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之反射]]></title>
    <url>%2F2017%2F10%2F14%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。 1.什么是反射？ 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。 要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。 2.反射的作用 1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制 2.在运行时分析对象的数据域 3.实现通用的数组操作代码 4.利用Method对象，这个对象很像C++中的函数指针 3.Class类 我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是java.lang.Class&lt;T&gt;泛型类的一个实例，比如Class&lt;MyClass&gt;对象即为一个封装了MyClass类的定义信息的Class&lt;T&gt;实例，从中我们可以得出结论：万物皆对象，任何类型(包括基本类型和引用类型).class都是java.lang.Class&lt;T&gt;的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于java.lang.Class&lt;T&gt;类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。 在下面的讲解中，我们将以People类和Student类为例：1234567891011121314151617181920212223242526272829public class People &#123; private String name; private int age; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println(getName() + " " + getAge()); &#125;&#125; 123456789101112131415161718192021222324public class Student extends People &#123; private int grade; public Student(String name, int age) &#123; super(name, age); &#125; public Student(String name, int age, int grade) &#123; super(name, age); this.grade = grade; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; private void learn(String course) &#123; System.out.println(name + " learn " + course); &#125; &#125; 获取class对象有以下三种: 1) 可以通过类名.class得到相应类的Class对象，如: 1Class&lt;People&gt; peopleClass = People.class; 2) 如果已知类的全限定名称(包含包名)，可以通过Class的forName静态方法得到类的Class对象，如： 12Class&lt;People&gt; peopleClass = Class.forName("cn.habitdiary.People");//假设People类在cn.habitdiary包中 在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如: 1234567try&#123; String name = "xxx"; Class c1 = Class.forName(name); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; 3) 可以通过类的实例对象.getClass()得到相应类的Class对象，如: 12People people = new People("Steven"， 20);Class&lt;People&gt; peopleClass = people.getClass(); 实例对象.getClass().getName() 可以获取当前对象的类的全限定名称(包含包名) 实例对象.getClass().getSimpleName()可以获取当前对象的类的底层类简称(不含包名) 实例对象.getClass().getCanonicalName()大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。 但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName() 注意： 1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象 2.Class类是一个泛型类，但有时候我们不能提前确定class对象的类型,就可以用Class&lt;?&gt;来代替，即上面代码中的Class&lt;People&gt; peopleClass可以写成Class&lt;?&gt; peopleClass 3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作 4.getClass()方法返回的是对象实际类型的class对象，而不是声明类型的class对象 5.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，比如: 12String s = "java.util.Random";Object m = Class.forName(s).newInstance(); 如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。 4.在运行时分析类的能力 下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。Java中为了支持反射机制主要提供了以下的类：java.lang.Classjava.lang.reflect.Fieldjava.lang.reflect.Constructorjava.lang.reflect.Methodjava.lang.reflect.Modifier java.lang.Class类的常用API如下： Field[] getFields() Field[] getDeclaredFields() Method[] getMethods() Method[] getDeclaredMethods() Constructor&lt; ? &gt;[] getConstructors() Constructor&lt; ? &gt;[] getDeclaredConstructors() Class&lt; ? &gt; getSupperClass() Class&lt; ? &gt;[] getInterfaces() 提示：getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有、受保护和默认成员，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象 其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。这三个类的常用API如下： String getName() 返回一个用于描述域名、构造器或方法的字符串 Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象 Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)返回一个用于描述方法抛出异常类型的Class对象数组 int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值 Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组 Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象 java.lang.reflect.Modifier类的常用API如下 static String toString(int modifiers)返回修饰符对应的字符串描述 static boolean isAbstract(int modifiers) static boolean isFinal(int modifiers) static boolean isInterface(int modifiers) static boolean isNative(int modifiers) static boolean isPrivate(int modifiers) static boolean isProtected(int modifiers) static boolean isPublic(int modifiers) static boolean isStatic(int modifiers) static boolean isStrict(int modifiers) static boolean isSynchronized(int modifiers) static boolean isVolatile(int modifiers)上述方法检测修饰符是否是某一特定修饰符java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义 下面是一个检测类内部结构的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.lang.reflect.*;import java.lang.Class;import java.util.Scanner;public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if(args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date)"); name = in.next(); &#125; try &#123; Class&lt;?&gt; c1 = Class.forName(name); Class&lt;?&gt; superc1 = c1.getSuperclass(); String modifiers = Modifier.toString(c1.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " " ); System.out.print("class " + name); if(superc1 != null &amp;&amp; superc1 != Object.class) System.out.print(" extends " + superc1.getSimpleName()); System.out.print("\n&#123;\n"); printFields(c1); System.out.println(); printConstructors(c1); System.out.println(); printMethods(c1); System.out.println("&#125;"); &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class&lt;?&gt; c1) &#123; Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors(); for(Constructor&lt;?&gt; c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class&lt;?&gt;[] paramTypes = c.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class&lt;?&gt; c1) &#123; Method[] methods = c1.getDeclaredMethods(); for(Method m :methods) &#123; Class&lt;?&gt; retType = m.getReturnType(); String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getSimpleName() + " " + name + "("); Class&lt;?&gt;[] paramTypes = m.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class&lt;?&gt; c1) &#123; Field[] Fields = c1.getDeclaredFields(); for(Field f : Fields) &#123; Class&lt;?&gt; type = f.getType(); String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getSimpleName() + " " + name + ";"); &#125; &#125;&#125; 5.在运行时使用反射分析对象 反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。 查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如： 12345Employee harry = new Empolyee("Harry Hacker",35000,10,1,1989);Class&lt;Employee&gt; c1 = harry.getClass();Field f = c1.getDeclaredField("name"); //返回某一个特定域f.setAccessible(true); //由于name是私有域，必须先设置为可访问Object v = f.get(harry); 上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value 下面是一些相关API在java.lang.reflect.Field中： Object get(Object obj)返回obj对象中用Field对象表示的域值 xxx getXxx(Object obj)返回obj对象的基本类型的域的值 void set(Object obj,Object newValue)用一个新值设置obj对象中Field对象表示的域 在java.lang.Class中： Field getField(String name)返回指定名称的公有域 Field getDeclaredField(String name) 返回指定名称的声明的域 在java.lang.reflect.AccessibleObject中： void setAccessible(boolean flag)为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置 boolean isAccessible()返回反射对象的可访问标志的值 static void setAccessible(AccessibleObject[] array,boolean flag)批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 6.使用反射编写泛型数组代码 java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。12Employee[] a = new Employee[100];a = Arrays.copyOf(a,2 * a.length); 我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试:12345public static Object[] badCopyOf(Object[] a,int newLength)&#123; Object[] newArray = new Object[newLength]; System.arraycopy(a,0,newArray,0,Math.min(a.length,newLength); return newArray;&#125; 上述代码存在一个错误，即使用了new Object[newLength]创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。为了解决这个问题，下面提供java.lang.reflect.Array中的API static Object get(Object array,int index)返回对象数组某个位置上的元素 static xxx getXxx(Object array,int index)(xxx是基本数据类型)返回基本类型数组某个位置上的值 static void set(Object array,int index,Object newValue)设置对象数组某个位置上的元素 static void setXxx(Object array,int index,xxx newValue)(xxx是基本数据类型)设置基本类型数组某个位置上的值 static int getLength(Object array)返回数组的长度 static Object newInstance(Class componentType,int length) static Object newInstance(Class componentType,int[] length)返回一个具有给定类型、给定维数的新数组 下面给出正确的代码实现： 1234567891011public static Object goodCopyOf(Object a,int newLength)&#123;&#123; Class c1 = a.getClass();//获取a数组的类对象 if(!c1.isArray()) return null;//确认是一个数组 Class componentType = c1.getComponentType(); //获取数组类型 int length = Array.getLength(a); Object newArray = Array.newInstance(componentType,newLength); System.arraycopy(a,0,newArray,0,Math.min(length,newLength)); return newArray; &#125; 这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例: 12int[] a = &#123;1,2,3,4,5&#125;;a = (int[]) goodCopyOf(a,10); 为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型 7.调用任意方法 通过反射还可以调用任意方法，这是通过Method类的invoke方法实现的，方法签名是:Object invoke(Object obj,Object... args),Object obj表示调用方法的对象，Object…args表示方法的参数列表。如果方法是静态方法，将第一个参数设置为null;如果方法是非静态无参方法，第二个参数列表可以忽略。 例如：String n = (String)m1.invoke(harry);(m1表示Employee类的getName方法)。如果返回值是基本类型，invoke方法会返回其包装器类型,可以利用自动开箱将其还原为基本数据类型。例如:double s = (Double)m2.invoke(harry);(m2表示Employee类的getSalary方法)getMethods方法和getDeclaredMethods会返回一个Method对象列表，如果要得到特定的Method对象，可以调用Class类的getMethod方法，其签名是Method getMethod(String Methodname,Class…parameterTypes)。例如： 12Method m1 = Employee.class.getMethod("getName"); Method m2 = Employee.class.getMethod("raiseSalary",double.class); 下面给出一个调用任意方法打印函数表的程序(以自定义的square和Math.sqrt方法为例)： 12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.*;public class MethodTableTest&#123; public static void main(String[] args) &#123;Method square = MethodTableTest.class.getMethod("square",double.class); Method sqrt = Math.class.getMethod("sqrt",double.class); printTable(1,10,10,square); printTable(1,10,10,sqrt); &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from,double to,int n,Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for(double x = from;x &lt;= to;x += dx) &#123; try &#123; double y = (Double)f.invoke(null,x); System.out.printf("%10.4f | %10/4f\n",x,y); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; invoke方法如果提供了错误的参数，会抛出一个异常，所以要提供一个异常处理器 建议在有必要的时候才使用invoke方法，有如下原因: 1.invoke方法的参数和返回值必须是Object类型，意味着必须进行多次类型转换，这样会使编译器错过检查代码的机会，等到测试阶段才发现错误，找到并改正会更加困难 2.通过反射调用方法比直接调用方法要明显慢一些 特别重申：建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的执行速度更快，更易于维护。 推荐博客： Java核心技术点之反射 深入理解Java反射 Java中的反射机制 Java反射教程 Java反射详解]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之继承和多态]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[父类与子类在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。 继承面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。 继承有如下几个关键点1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们3.不是所有的“是一种”(is-a)关系都该用继承来建模4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承5.Java中类与类的继承是单一继承 super关键字super关键字有两种作用：1.调用父类的构造方法因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。形式是super()或super(arguments)，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条super()有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。 2.调用父类的方法在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用super.方法名来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，super.super.方法名是不合法的。 构造方法链在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码： public class Faculty extends Employee{ public static void main(String[] args){ new Faculty(); } public Faculty(){ System.out.println("(4) Performs Faculty's tasks"); } } class Employee extends Person{ public Employee(){ this("(2) Invoke Employee's overloaded constructor"); System.out.println("(3) Perfoms Employee's tasks"); } public Employee(String s){ System.out.println(s); } } class Person{ public Person() { System.out.println("(1) Performs Person's tasks"); } } 打印结果为:(1) Performs Person’s tasks(2) Invoke Employee’s overloaded constructor(3) Performs Employee’s tasks(4) Performs Faculty’s tasks 我们可以知道：子类的构造方法的第一条语句要么是super语句(包括编译器隐式插入的),要么是this语句，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类 注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。 方法重载与重写重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同) 重写方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。为了避免错误，可以使用重写标注，在要重写的方法前加上@Override，该标注会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。 关于重写的几点注意1.仅当实例方法时刻访问的，它才能被覆盖2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法 方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。 多态Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。 动态绑定多态机制的底层实现技术是动态绑定，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。 对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。 静态绑定(前期绑定)：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。 动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。 简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。 理解方法调用假设下面要调用x.f(args)，方法调用的过程为：1） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(int)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。2） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。3） 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为private方法、构造器不能被继承，更谈不上重写，而static方法和final方法虽然能被继承，但不能被重写。4) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。 每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。方法表示例(Manager继承自Employee)： Employee:getName() -&gt; Employee.getName()getSalary() -&gt; Employee.getSalary()getHireDay() -&gt; Employee.getHireDay()raiseSalary(double) -&gt; Employee.raiseSalary(double) Manager:getName() -&gt; Employee.getName()//继承的方法getSalary() -&gt; Manager.getSalary()//重写的方法getHireDay() -&gt; Employee.getHireDay()//继承的方法raiseSalary(double) -&gt; Employee.raiseSalary(double)//继承的方法setBonus(double) -&gt; Manager.setBonus(double)//新增的方法 内联优化带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联优化所有的final方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高50%。如果确定一个类不会被派生或一个方法不会被重写，建议使用final关键字修饰。 对象类型转换和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。我们可以通过instanceof运算符来检测一个对象是否是某个类或接口的实例，其返回值是boolean类型的。注意:1.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();2.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。 Object类Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出public class xxx extends Object,在Java中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。下面介绍Object类中的几个重要方法及重写规范： 1) equals方法Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。 equals方法的原型是public boolean equals(Object obj),默认实现是: public boolean equals(Object obj){ return (this == obj); } 调用它的语法是object1.equals(object2)，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。比如类Employee定义了数据域：private String name,private double salary,private LocalDate hireDayequals方法重写如下： public boolean equals(Object obj){ if(this == obj) return true; //快速检测引用是否相等，相等返回ture if(obj == null) return false; //检测引用是否为空，为空返回false if(getClass() != obj.getClass()) return false; //检测是否属于同一个类，不是返回false Empolyee other = (Employee) obj;//向下转型 return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); //逐一比较数据域,有一个不等返回就false，否则返回true 进一步改进：改进一上述的第4步检测，可以改为 return Objects.equals(name,other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay,other.hireDay); 其中Objects.equals方法可以防备name 或 hireDay 可能为null的情况，如果两个参数都为null，Objects(a,b)返回true;如果其中一个为null，返回false;如果两个参数都不为null,调用a.equals(b)。Objects类在java.util包中。 在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。比如Manager类继承自Employee，在父类的基础上增加了private double bonus： public boolean equals(Object obj){ if(!super.equals(obj)) return false; Manager other = (Manager) obj; return bonus == other.bonus; } 改进二上述代码的第3步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用instanceof进行检测，比如雇员的ID作为相等的概念，就可以用xxx instanceof Employee进行检测，并将Empolyee.equals声明为final。 equals方法要满足下面的特性 自反性: 对于任何非空引用，x.equals(x)应该返回true 对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同 传递性：对于任何引用x、y和z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true 一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果 对于任何非空引用x,x.equals(null)应该返回false 下面我们给出编写一个完美的equals方法的建议：1) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测2) 检测引用是否为空，如果为空，不必再检测，直接返回不等3) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:if(getClass() != obj.getClass()) return false;如果所有子类都拥有统一的语义(父类决定相等)，就使用instanceof检测：if(!(obj instanceof ClassName) return false)4) 将obj向下转型为相应类的类型变量5) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测数组对象用静态的Arrays.equals方法判等 拓展：Integer判断相等，到底该用==还是equals 2) hashCode方法散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。String类使用下列算法计算散列码： int hash = 0; for(int i = 0;i &lt; length();i++){ hash = 31 * hash + charAt(i); } 由于hashCode方法定义在Object类中，方法原型是public int hashCode(),因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。hashCode方法应该返回一个整型数值(可以是负数),并合理地组合实例域的散列码，以便能让各个不同的对象产生的散列码更均匀。例如，下面是Employee类的hashCode方法 public int hashCode(){ return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode(); 进一步改进 public int hashCode(){ return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); 从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象 还有更简单的做法 public int hashCode(){ return Objects.hash(name,salary,hireDay); } Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID 3) toString方法方法原型是public String toString(),用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：类名@对象十六进制内存地址的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似[I@1a46e30的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。 泛型数组列表在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如： int actualSize = . . .; Employee[] staff = new Employee[actualSize]; 但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。ArrayList是一个采用类型参数的泛型类,声明方式为ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;(),从Java SE 7开始，可以省去右边的类型参数，即ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于ArrayList&lt;Object&gt;,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。 ArrayList类的常用API ArrayList&lt;E&gt;() 构造一个初始容量为10的空列表 ArrayList&lt;E&gt;(int initialCapacity)构造一个具有指定初始容量的空列表 boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true void add(int index, E element) 将指定的元素插入此列表中的指定位置。 int size() 返回此列表中的元素数。 void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。 E get(int index) 返回此列表中指定位置上的元素。 E remove(int index) 移除此列表中指定位置上的元素并返回该元素。 boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。 void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。 boolean isEmpty() 如果此列表中没有元素，则返回 true boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。 void clear() 移除此列表中的所有元素。 Object clone() 返回此 ArrayList 实例的浅表副本。 trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。 对于数组列表有用的方法1.数组和ArrayList互相转换 数组转ArrayList: String[] array = {"red","green","blue"}; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array)); ArrayList转数组: String[] array = new String[list.size()]; list.toArray(array); 2.Collections类Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。 ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。 final关键字总结final关键字在不同语句中有不同的作用：1) 修饰类变量或成员变量 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。final还可以修饰方法的局部变量，即常量2) 修饰方法 表示该方法不能被重写3) 修饰类 表示该类不能被扩展 继承的设计技巧1.将公共操作和域放在超类2.不要使用受保护的域protected机制并不能够带来更好的保护，其原因主要有两点:第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的 3.使用继承实现 “is-a” 关系4.除非所有继承的方法都有意义，否则不要使用继承比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。 5.在覆盖方法时，不要改变预期的行为6.使用多态，而非类型信息即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为 7.不要过多地使用反射反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之对象与类]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[面向对象程序设计概述 面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。 传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。 对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。 类和对象 类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。 对象：由类构造的实例，一个类可以构造多个实例。 设计类的简单规则 先从设计类的数据域开始，再向类里添加方法。 类之间的关系1.依赖(use-a) 如果A类的方法操纵B类的对象，我们说A类依赖于B类。应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。2.聚合(has-a) 如果A类对象包含B类对象，我们说A类和B类聚合。3.继承(is-a) 如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 对象与对象变量 对象是调用构造方法在堆上分配内存产生的(用new + 构造方法来调用)，而对象变量是在栈上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上产生了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。 存储区域1.创建的实例及成员变量（静、非静态）在堆中2.局部变量在栈中3.类的基本信息和方法定义在方法区 UML类图相关知识见http://www.uml.org.cn/oobject/201211231.asp 构造器 构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。 构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，因为它是用来创建实例的，所以它永远是实例方法，不能被static修饰。 构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。 访问对象的数据和方法 在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。 引用数据域和null值 如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。 默认赋值规则 类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。 基本变量和引用变量的区别 基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。 没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。 静态/非静态变量、常量和静态/非静态方法静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。不要从构造器中传入参数来初始化静态域，最好使用set方法改变静态数据域。非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。非静态方法：又称实例方法，是依赖于具体对象的方法。关系：静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。 工厂方法静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：12345NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.gerPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x));// prints $0.10System.out.println(percentFormatter.format(x));//prints 10% 使用静态工厂方法的原因主要有两个：1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类 可见性修饰符public修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public protected修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问 default缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。 privateprivate成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。 注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。 包包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句package + 包名，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。 类的导入精确导入：导入某个包的特定类,如import java.util.Scanner通配导入：导入某个包的所有类,如import java.util.*当使用多个包中的同名类时，要用包名.类名的格式编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如import static java.lang.System.*导入了System类的静态方法和静态域，就可以不加类名前缀:out.println(&quot;Hello world!&quot;)，out是System类里定义的静态成员，是PrintStream的实例。 数据域封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。实现封装的步骤：1.用private可见性修饰符修饰类成员2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue) 向方法传递对象参数可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。 对象数组和普通数组所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。 不可变对象和类一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。一个类是不可变类要满足以下三个条件：1.所有的数据域都是私有的2.没有修改器方法3.没有一个返回指向可变数据域引用的访问器方法 变量作用域一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如1234public class F&#123; private int j = i + 1; private int i;&#125; 就是错误的，因为j的初始化基于i已经被初始化的前提。 局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。 建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。 this引用this关键字有两大作用：1.表示指向调用对象本身的引用名2.可以在构造方法内部调用同一个类的其他构造方法，此时this(参数列表)语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用this(参数列表)的形式来实现它们。这样做可以简化代码，使类易于维护。 对象构造默认域初始化即依赖编译器对数据域的默认初始化。 显式域初始化在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。 无参数的构造器即将对数据域的初始化置于一个无参的构造器中。 有参数的构造器即给构造器传入参数对数据域进行初始化 初始化块即用花括号包含的一组数据域赋值代码块，一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块。 成员初始化顺序1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行。2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。3.父类的实例成员和实例初始化块，按在代码中出现的顺序依次执行。4.执行父类的构造方法。5.子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。6.执行子类的构造方法。 注意：静态成员只在构造该类的第一个对象时初始化一次，可以看作初始化类。 类设计技巧1.一定要保证数据域私有2.一定要对数据初始化最好不要依赖默认初始化，会影响程序可读性。 3.不要在类中使用过多的基本类型用其他集合了相关基本类型的类代替多个基本类型使用 4.不是所有的域都需要独立的域访问器和域修改器有的数据域定义后不必要修改 5.将职责过多的类进行分解6.类名和方法名要能够体现它们的职责7.优先使用不可变的类更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习之区间dp]]></title>
    <url>%2F2017%2F10%2F11%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[简介区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。 算法结构设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段 For l:=2 to n do // 枚举区间长度for i:=1 to n do // 枚举区间的左端点beginj:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到if j&gt;n then break; // 保证了下标不越界for k:= i to j-1 do // 状态转移，去推出 f[i,j]f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }end; 这个结构必须记好，这是区间动态规划的代码结构。 例题石子合并题目链接:http://acm.nyist.net/JudgeOnline/problem.php?pid=737 题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。那么dp[i][j] = min(dp[i][k] + dp[k+1][j])那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2） 代码1(无优化) 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i)//枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = i; k &lt; j; ++k) &#123; dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; 代码2(平行四边形优化) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N],s[N][N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); s[i][i]=i; sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i) //枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = s[i][j-1]; k &lt;= s[i+1][j]; ++k)//四边形优化 &#123; if(dp[i][j]&gt;dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]) &#123; dp[i][j]=dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]; s[i][j]=k; &#125; &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; 括号匹配题目链接：http://poj.org/problem?id=2955 题意:给出一串的只有‘（’ ‘）’ ‘[‘ ‘]’四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。 分析：定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ;2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] ) 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;const int N = 120;int dp[N][N];int main()&#123; string s; while(cin&gt;&gt;s) &#123; if(s=="end") break; memset(dp,0,sizeof(dp)); int n = s.size(); for(int len = 2;len &lt;= n;len++)//枚举区间长度 &#123; for(int i = 0;i &lt;= n - len; i++)//枚举区间左端点 &#123; int j = i + len - 1;//确定区间右端点 if(j &gt; n) break; if(s[i]=='('&amp;&amp;s[j]==')' || s[i]=='['&amp;&amp;s[j]==']') dp[i][j]=dp[i+1][j-1]+2; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);//枚举中间位置,注意j不取等号 &#125; &#125; cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; &#125; return 0;&#125; 如果要求打印路径，即输出匹配后的括号 题目链接: http://poj.org/problem?id=1141 代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 120;int dp[N][N],pos[N][N]; /*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/string s;void show(int i,int j)&#123; if(i&gt;j) return; if(i==j) &#123; if(s[i]=='('||s[i]==')') cout&lt;&lt;"()"; else cout&lt;&lt;"[]"; &#125; else &#123; if(pos[i][j]==-1) &#123; cout&lt;&lt;s[i]; show(i+1,j-1); cout&lt;&lt;s[j]; &#125; else &#123; show(i,pos[i][j]); show(pos[i][j]+1,j); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;s) &#123; memset(dp,0,sizeof(dp)); int len=s.size(); for(int i=1; i&lt;len; i++) &#123; for(int j=0,k=i; k&lt;len; j++,k++) &#123; if(s[j]=='('&amp;&amp;s[k]==')' || s[j]=='['&amp;&amp;s[k]==']') &#123; dp[j][k]=dp[j+1][k-1]+2; pos[j][k]=-1; &#125; for(int f=j; f&lt;k; f++) &#123; if(dp[j][f]+dp[f+1][k]&gt;=dp[j][k]) &#123; dp[j][k]=dp[j][f]+dp[f+1][k]; pos[j][k]=f; &#125; &#125; &#125; &#125; show(0,len-1); cout&lt;&lt;endl; &#125; return 0;&#125; 整数划分题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=746 题意: 给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积 分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数设a[i][j]为区间[i,j]所形成的数所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i]) 代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long dp[25][25];long long a[25][25];char str[25];int main()&#123; int len, t, m; scanf("%d", &amp;t); while (t--) &#123; scanf("%s%d", str, &amp;m); len = strlen(str); m--; memset (a, 0, sizeof(a)); memset (dp, 0, sizeof(dp)); for (int i = 0; i &lt; len; i++) //先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值 &#123; a[i][i] = str[i] - '0'; for (int j = i + 1; j &lt; len; j++) &#123; a[i][j] = a[i][j - 1] * 10 + str[j] - '0'; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; dp[i][0] = a[0][i]; &#125; for (int j = 1; j &lt;= m; j++) &#123; for (int i = j; i &lt; len; i++) &#123; for (int k = 0; k &lt; i; k++) &#123; dp[i][j] = max(dp[i][j], dp[k][j - 1] * a[k + 1][i]); &#125; &#125; &#125; printf("%lld\n", dp[len - 1][m]); &#125; return 0;&#125; Halloween Costumes题目链接：http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422 题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会 分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有 ①：如果在之后的区间内都不再重复利用这件衣服，那么明显 dp[i][j] = dp[i+1][j] + 1; ②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，那么转移方程为 dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j]) 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[105];int dp[105][105];int main(void)&#123; int t; int cas = 0; scanf("%d",&amp;t); while(t--) &#123; cas ++; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) &#123; for(int j = i;j &lt;= n;j++) &#123; dp[i][j] = j-i+1; &#125; &#125; for(int i = n-1;i &gt;= 1;i--) &#123; for(int j = i+1;j &lt;= n;j++) &#123; dp[i][j] = dp[i+1][j] + 1; for(int k = i+1;k &lt;= j;k++) &#123; if(a[i] == a[k]) &#123; dp[i][j] = min(dp[i][j],dp[i][k-1] + dp[k+1][j]); &#125; &#125; &#125; &#125; printf("Case %d: %d\n",cas,dp[1][n]); &#125; return 0;&#125; Cheapest Palindrome题目链接:http://poj.org/problem?id=3280 题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。 分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况： 1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值； 2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值 3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小 然后dp[i][j]取上面这些情况的最小值 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int dp[2005][2005],add[27],del[27];char s[2005];int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)&gt;0) &#123; scanf("%s",s+1); for(int i=1;i&lt;=n;i++) &#123; char ch[10]; int tmp1,tmp2; scanf("%s%d%d",ch,&amp;tmp1,&amp;tmp2); add[ch[0]-'a'+1]=tmp1; del[ch[0]-'a'+1]=tmp2; &#125; memset(dp,0,sizeof(dp)); for(int i=m-1;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i+1][j]+add[s[i]-'a'+1],dp[i+1][j]+del[s[i]-'a'+1]); int tmp=min(dp[i][j-1]+add[s[j]-'a'+1],dp[i][j-1]+del[s[j]-'a'+1]); dp[i][j]=min(dp[i][j],tmp); if(s[i]==s[j]) dp[i][j]=min(dp[i][j],dp[i+1][j-1]); &#125; &#125; printf("%d\n",dp[1][m]); &#125; return 0;&#125; Treats for the Cows题目链接:http://poj.org/problem?id=3186 题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值 分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来转移方程：dp[i][j]=max(dp[i+1][j]+p[i](n+i-j),dp[i][j-1]+p[j](n+i-j)); 其中n-(j-i)是第几次取 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int p[2010];int dp[2010][2010];int n;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); dp[i][i]= n * p[i]; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=i;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i+1][j]+p[i]*(n+i-j),dp[i][j-1]+p[j]*(n+i-j)); &#125; printf("%d\n",dp[1][n]); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之Java基本程序设计结构]]></title>
    <url>%2F2017%2F10%2F10%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据类型Java是一种强类型语言，即意味着必须为每一个变量声明一种类型。在Java中一共有8种基本数据类型，其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真值的boolean类型。 1) 整型整型用于表示没有小数部分的值，它允许是负数，Java提供了4种整型：类型 存储需求 取值范围byte 1字节 -27 ~ 27-1short 2字节 -215 ~ 215-1int 4字节 -231 ~ 231-1long 8字节 -263 ~ 263-1 在通常情况下,int类型最常用。如果要表示星球上居住的人数，就需要使用long类型了。byte和short类型用于特定的应用场合，比如底层的文件处理或者需要控制占用存储空间量的大数组。整型的直接量默认是int，即2表示int类型的2，为了表示一个long型的整型直接量，在其后追加字母L或l即可(建议使用L,以免和数字1混淆)。语句byte b = 128会造成编译错误，因为128是整型直接量且超过了byte的取值范围。默认情况下，整型直接量是一个十进制整数。要表示一个二进制整数直接量，使用0b或0B开头;表示一个八进制整数直接量，使用0开头;表示一个十六进制整数直接量，使用0x或0X开头。为了提高可读性,Java允许在数值直接量的两个数字之间使用下划线,例如long ssn = 232_45_4519Java没有任何无符号(unsigned)形式的int、long、short或byte类型十进制整数转其他进制整数：Integer.toString(int number, int radix)返回一个String其他进制整数转十进制：Integer.parseInt(String s, int radix)返回类型为int 2）浮点类型浮点类型用于表示有小数部分的数值，Java提供了2种浮点类型：类型 存储需求 取值范围float 4字节 负数范围：-3.4028235E+38 ~ -1.4E-45 正数范围： 1.4E-45 ~ 3.4028235E+38 (有效位数为6~7位)double 8字节 负数范围：-1.7976931348623157E+308 ~ -4.9E-324 正数范围： 4.9E-324 ~ 1.7976931348623157E+308 (有效位数为15位)double表示这种类型的数值精度是float的两倍,float称为单精度型,double称为双精度型。通常情况下,应该使用double型,因为它比float型更精确。可以以E或e为指数用科学计数法表示浮点数,例如1.2345E+2,在十六进制中,则使用p表示指数而不是e，且尾数采用十六进制时指数的基数是2而不是10浮点数直接量是double型,即5.0被认为是double型的,可以通过追加f或F表示float型直接量,当然也可以在浮点数值后面添加后缀D或d表示double型(虽然没有必要多此一举)。如果float接受的是一个整数，不需要加f或者F，但是如果是小数一定要加f或者F。常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN(以及相应的Float类型的常量)分别表示正无穷大、负无穷大和不是一个数。例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。不能用如下的方式检测一个特定的值是否等于Double.NaN:1if(x == Double.NaN) // is never true 应该改成1if(Double.isNaN(x)) // check whether x is "not a number" 浮点数在运算时会产生一定误差,如果对精度有极高要求，应该使用BigDecimal类 3）Unicode和char类型char类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些则需要两个char值。 详见：Java中char占几个字节 char类型的字面量值要用单引号括起来。例如：’A’是编码值为65所对应的字符常量。它与”A”不同，”A”是包含一个字符A的字符串。char类型可以表示为十六进制值，范围从’\u0000’到’\uFFFF’有一些用于表示特殊字符的转义序列,如下：注意 \r 和 \n 的区别，前者叫回车(Carriage Return)，后者叫新行(New Line)，但是都会造成换行。不同操作系统的行分隔符不同，可用System.getProperty(“line.separator”)来获取当前OS的换行符不同系统的换行符为：\r Mac\n Unix/Linux\r\n Windows 注释中的\u也会起转义作用,如下： 12345// \u00A0 is a newline (\u00A0会被替换成换行符)// Look inside c:\users (会产生编译错误,因为\u后面未跟着4个十六进制数) 下面是判断一个字符是否是汉字的方法： 12345678public static boolean isChineseChar(char c)&#123; try &#123; return String.valueOf(c).getBytes("UTF-8").length &gt; 1; &#125; catch (UnsupportedEncodingException e) &#123; return false; &#125;&#125; 将字符c先用String.valueOf转换为字符串，然后使用getBytes(“UTF-8”)将字符串按照UTF-8编码格式转换为字节数组，汉字的字节数会大于1,即可判断(如果直接对String使用length得到的是字符数不是字节数)。但是可能会抛出UnsupportedEncodingException，要进行捕获处理。 4) boolean类型boolean类型有两个值：false和true，用来判定逻辑条件。不同于C/C++中0代表false，非0代表true，Java中整型值和布尔值之间不能进行相互转换。比如,下面的语句在C/C++中是允许的,表示一个无限循环：123while(1)&#123; do something&#125; 但是在Java中不允许这么做,可以改为：123while(true)&#123; do something&#125; 可以打印boolean类型的变量或者布尔表达式，会呈现true或者false 数据类型转换将一个小范围类型变量转化为大范围类型的变量称为拓宽类型，反之称为缩窄类型。把小范围类型变量赋值给大范围类型的变量或小范围类型变量和大范围类型变量共同参与运算,Java会自动拓宽类型。而如果要缩窄类型，必须显式完成。注意：1.类型转换不改变被转换的变量，例如，下面的代码中的d在类型转换之后值不变：12double d = 4.5;int i = (int)d; // i becomes 4, but d is still 4.5 2.x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。因此，下面代码是正确的：12int sum = 0;sum += 4.5;// 等价于sum = (int)(sum + 4.5) 3.将一个int型变量赋值给short型或byte型的变量，必须显式地使用类型转换，如下面的语句会产生编译错误：12int i = 1;byte b = i; // Error because explicit casting is required 然而如果整型直接量在目标变量允许的范围内，那么将整型直接量赋给short型或byte型就不需要显式类型转换，如：1byte b = 1; 变量变量用于表示在程序中可能被改变的值。变量声明告知编译器根据数据类型为变量分配合适的内存空间。变量声明的语法如下：1datatype variableName; 如果几个变量为同一类型,允许一起声明它们：1datatype variable1, variable2, ..., variablen; 可以在声明变量的同时初始化，也可以先声明后初始化：1234int count = 1; // 声明同时初始化变量int count;count = 1; //先声明，后初始化 常量常量是一个赋值后保持不变的量,用final关键字修饰，在类中定义的常量一般用static final修饰。常量必须在同一条语句中声明和赋值，不可先声明再赋值。使用常量有三个好处：1)不必重复输入同一个值2)如果必须修改常量的值，只需在源代码的一处改动3)给常量赋一个描述性的名字会提高程序的易读性 数值操作符数值数据类型的操作符包括标准的算术操作符：加号(+)、减号(-)、乘号(*)、除号( / )、求余号(%)注意：1.如果被除数是负数，结果是负数;如果除数是负数被除数是正数结果是正数;如果都是负数其结果就是负数。如 -7 % 3 = -1, -26 % -8 = -2,20 % -13 = 7,即无论正负,商和除数乘积的绝对值不能超过被除数的绝对值。2.如果是两个byte short int long相除，得到结构如果是浮点数，小数位全部舍去保留整数部分3.如果是两个byte short int long除以0，等异常信息,那么久报异常java.lang.ArithmeticException: / by zero 看到异常就要立马明白，除数是0，要赶紧检查你的代码的逻辑出现0的地方在哪里。4.float.double除以0得到正无穷和负无穷。123System.out.println(1.0f/0); //正无穷System.out.println(-1/0.0); //负无穷System.out.println(0.0/0); //NaN 增强赋值操作符x1 op= x2形式的增强赋值表达式的执行为x1 = (T)(x1 op x2),T是x1的类型。其中op可以是加号(+)、减号(-)、乘号(*)、除号( / )、求余号(%) 自增和自减操作符分为++var、–var、var++、var–四种，加减号决定给var加1还是减1，前置还是后置符号决定先更新后使用值还是先使用值后更新 关系运算符Java中有一系列用于比较关系的运算符：==(等于)、!=(不等于)、&lt;(小于)、&gt;(大于)、&lt;=(小于等于)、&gt;=(大于等于) 逻辑操作符逻辑操作符!(非)、&amp;&amp;(与)、||(或)和^(异或)可以用于产生复合型布尔表达式，逻辑操作符被称为短路操作符或懒惰操作符，即按顺序执行表达式，如果某一步已经可以判断整个表达式的真假，不再继续执行，否则继续执行。 位运算符处理整型类型时，可以直接对组成整型数值的各个位完成操作。位运算符包括：&amp;(按位与)、|(按位或)、^(按位异或)、~(按位取反)、&lt;&lt;(左移，高位舍弃，低位补0)、&gt;&gt;(右移，低位舍弃，高位用符号位填充)、&gt;&gt;&gt;(右移，低位舍弃，高位0填充)注意：1) 移位运算符的右操作数要完成模32的运算(除非左操作数是long类型，在这种情况下右操作数要模64),例如1&lt;&lt;35等价于1&lt;&lt;32) &amp; 、| 和 ^ 也可以用在布尔表达式中，此时它们是逻辑操作符，但不会短路，不推荐使用3) 可以使用掩码技术得到一个数二进制的某一位：int fourthBitFromRight = (n &amp; 0b1000) / 0b1000上式将n的右数第4位保留，将其他位掩掉，再除以0b1000，就得到了该位上的数 选择Java中的选择语句类型有：单分支if语句、双分支if-else语句、嵌套if语句、多分支if-else语句、switch语句、条件表达式 1) 单分支if语句123if(布尔表达式)&#123; 语句(组); &#125; 分支中如果只有单条语句可以省略外围花括号，否则不能省略 2) 双分支if-else语句123456if(布尔表达式)&#123; 布尔表达式为真时执行的语句(组); &#125; else&#123; 布尔表达式为假时执行的语句(组); &#125; 嵌套层数没有限制，但为了程序可读性，尽量不要进行过多的嵌套，且嵌套语句应有适当的缩进保持层次关系。 3) 嵌套的if语句和多分支的if-else语句下面是一个嵌套的if语句，if(j &gt; k)嵌套在语句if(i &gt; k)内123456if(i &gt; k) &#123; if(j &gt; k) System.out.println("i and j greater than k");&#125;else System.out.println("i is less than or equal to k"); 下面是一个多分支的if-else语句12345678910111213141516if(score &gt;= 90.0) System.out.print("A");else&#123; if(score &gt;= 80.0) System.out.print("B"); else&#123; if(score &gt;= 70.0) System.out.print("C"); else&#123; if(score &gt;= 60.0) System.out.print("D"); else system.out.print("E"); &#125; &#125;&#125; 为了可读性，建议改写成如下形式：12345678910if(score &gt;= 90.0) System.out.print("A");else if(score &gt;= 80.0) System.out.print("B");else if(score &gt;= 70.0) System.out.print("C");else if(score &gt;= 60.0) System.out.print("D");else System.out.print("E"); 注意：只有在前面的所有条件都为false才测试下一个条件 4) switch语句switch语句常用于多分支的选择问题：12345678910switch(switch表达式)&#123; case value1: 语句(组)1; break; case value2: 语句(组)2; break; ... case valueN: 语句(组)N; break; default: 当没有一个给出的case与switch表达式匹配时执行的语句(组)&#125; 注意：1) switch表达式可以为char、byte、short、int或者String型值(整型中只有long不行),并且总要用括号括住2) value1,…,valueN必须与switch表达式具有相同的数据类型，且是常量表达式，不能出现变量，例如：x、y+1等3) 当switch表达式的值与case语句匹配时,执行从该case开始的语句，直到遇到一个break语句或到达switch语句的结束。break语句是可选的,会立即终止switch语句4) default语句是可选的，当没有一个给出的case与switch表达式匹配时执行default语句指定的操作，如果加default语句，就什么也不做 5) 条件表达式条件表达式基于一个条件计算表达式的值，它是Java中唯一的三元操作符。12boolean-expression ? expression1 : expression2;//(布尔表达式? 表达式1:表达式2) 如果布尔表达式的值为true，则条件表达式的结果为表达式1;否则，结果为表达式2。例如：1System.out.println((num % 2 == 0) ? "num is even" : "num is odd"); 注意冒号两边是表达式，不能是其他操作。 循环1) 块作用域块(即复合语句)是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域，变量只在包含自己的块中可见。一个块可以嵌套在另一个块中。例如：123456789public static void main(String[] args)&#123; int n; . . . &#123; int k; . . . &#125; // k is only defined up to here&#125; 但是不能在嵌套的两个块中声明同名变量，例如下面的语句会产生编译错误：12345678910public static void main(String[] args)&#123; int n; . . . &#123; int k; int n;//Erro -- can't redefine n in inner block . . . &#125; &#125; 这与C++不同，在C++中允许在嵌套的块中定义同名变量，内层变量会覆盖外层定义的变量。 2) while循环while循环在条件为真的情况下，重复地执行语句：1234while(循环继续条件)&#123; //循环体 语句(组);&#125; 当程序不幸出现了死循环，如果是从命令窗口运行程序的，按CTRL+C键来结束 3) do-while循环do-while循环和while循环基本一样，不同的是while循环是前测循环，即先检测循环条件后执行循环体;do-while是后测循环，即先执行循环体后检测循环条件。只有在一开始就不满足循环继续条件时，两种循环的执行次数不同，即while循环不执行，do-while循环执行一次。否则两种循环的执行次数相同。1234do&#123; // 循环体; 语句(组);&#125;while(循环继续条件); 注意do-while循环后面的分号不要丢！ 4) for循环for循环的基本语法为：1234for(初始操作;循环继续条件;每次迭代后的操作) &#123; //循环体 语句(组);&#125; 初始动作可以是0个或是多个以逗号隔开的变量声明语句或赋值表达式：12345678int i = 0;for( ;i &lt; 100;i++)&#123; System.out.println("Welcome to Java!");&#125;// 将初始动作省略，放在循环语句之前执行for(int m = 0,n = 0; m + n &lt; 10; m++,n++)&#123; System.out.println("Welcome to Java!");&#125;// 多个初始化动作 每次迭代后的操作也可以是0个或多个逗号隔开的语句：1234567for(int i = 0;i &lt; 100; )&#123; System.out.println("Welcome to Java!"); i++;&#125;// 将每次迭代后的操作放入循环体内 for(int i = 1;i &lt; 100;System.out.println(i),i++);// 每次迭代后执行多个操作 下面的三种循环写法是等价的：1234567891011for( ; ; )&#123; //do something&#125;for( ;true; )&#123; //do something&#125;while(true)&#123; //do something&#125; 5) for-each循环Java有一种很强的循环结构，可以用来依次处理数组中的每个元素(其他类型的元素集合亦可)而不必为指定的下表值而分心。这种增强的for循环的语句格式为：1for(variable : collection) statement 定义一个变量用于暂存集合中的每一个元素，并执行相应的语句(组)，collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象(例如ArrayList)。for-each循环只能用于按顺序遍历数组或集合的情况，如果要使用其他顺序，应该使用其他循环语句 6) break和continuecontinue跳出本次迭代进入下一次迭代，break跳出整个循环。虽然不提倡使用goto语句，但偶尔使用goto语句跳出循环还是有益处的。Java中提供了类似于C++中goto语句的带标签的break语句和continue语句，用于跳出多重嵌套的循环语句。标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。另外要注意，只能跳出语句块，而不能跳入语句块。下面的代码使用了带标签的break语句：1234567int i; label1:for( i = 0;i &lt; 10;i ++) &#123;if(i == 5)break label1;&#125;System.out.println(i);// i = 5 上述代码中，i在等于5时跳出循环到循环首部的标签label1位置，由于是带标签的break语句，不再重新进入循环，而是跳过循环执行下面的打印语句。 如果把改成带标签的continue语句：1234567int i; label2:for( i = 0;i &lt; 10;i ++) &#123; if(i == 5) continue label2;&#125;System.out.println(i); // i = 10 上述代码中，i在等于5时也跳出循环到循环首部的标签label2位置，但由于是带标签的continue语句，会重新进入循环。 枚举类型有时，变量的取值只在一个有限集合内。例如：销售的服装或比萨饼只有小、中、大、超大这四种尺寸。此时可以给每种尺寸编号为1、2、3、4,但是为了程序的可读性，可以定义一个枚举类。可以把枚举类看作普通类，它们都可以定义一些属性和方法，不同之处是：枚举类不能使用 extends 关键字继承其他类，因为 枚举类已经继承了 java.lang.Enum&lt;T&gt;(java是单一继承),其中T是定义的枚举类类型，可类比每个普通类的Class对象都是Class&lt;T&gt;类的实例。Enum类是一个抽象类。下面定义一个简单的枚举类：1public enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;; 其中enum是定义枚举类的关键字，可类比普通类的class。Size是枚举类名，类比普通类名。SMALL、MEDIUM、LARGE、EXTRA_LARGE是枚举值，为枚举类的静态成员，static关键字被省略，类型为Size，可以用Size.枚举实例名来访问，命名习惯同常量。Size变量只能存储枚举类中定义的枚举值或null，尽量不要构造新的Size类型对象。可以在枚举类中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候使用，下面是一个示例：1234567891011public enum Size&#123; SMALL("S"),MEDIUM("M"),LARGE("L"),EXTRA_LARGE("XL"); private String abbreviation; private Size(String abbreaviation)&#123; this.abbreviation = abbreviation; &#125; public String getAbbreviation() &#123;return abbreviation&#125;;&#125; 注意：枚举值的声明必须是枚举类定义的第一条语句。枚举类的构造器必须为private，保证了构造器只能用于枚举类中定义的枚举值的构造，而不让客户代码构造新的枚举值。当访问枚举值时，构造方法被调用，枚举值构造方法中的参数被赋值给Abbreviation。如：12345public class TestSize&#123; public static void main(String[] args) &#123; Size size = Size.LARGE; System.out.println(size.getAbbreviation);&#125; 结果打印出”L” 枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal)构造函数中，在这里，每个枚举值的名称都被转换成一个字符串，且按照在枚举类中出现的先后次序，从0开始进行编号。下面是枚举类的常用API： int compareTo(E o)按照序号(枚举类中的定义次序)比较此枚举与指定对象的顺序 String toString()返回枚举常量的名称 static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name)返回带指定名称的指定枚举类型的枚举常量(是toString的逆操作)，例如： 12345678 Size s = Enum.valueof(Size.class,"SMALL"); ``` s的值为Size.SMALL * static T[] values() 返回一个包含全部枚举值的数组，例如： ```javaSize[] values = Size.values(); 返回一个包含Size.SMALL,Size.MEDIUM,Size.LARGE, Size.EXTRA_LARGE的数组 要比较两个枚举值是否相同，既可以使用equals也可以使用== 枚举类型可以在一个类内定义，此时枚举类被作为内部类对待。程序编译后，将创建一个名为OuterClassName$EnumName的字节码文件。 可以在if或switch语句中使用枚举变量，例如：12345678if(size.equals(Size.SMALL)&#123; // process SMALL&#125;else if(size.equals(Size.MEDIUM)&#123; // process MEDIUM&#125;else... 等价于：123456789switch(size)&#123; case SMALL: // process SMALL break; case MEDIUM: // process MEDIUM break; ...&#125; 在switch语句中，case标签是一个无限定的枚举值(即SMALL，而不是Size.SMALL) 更多用法见：Java枚举(enum)详解7种常见的用法 输入输出1) 输入从控制台读取”标准输入流”System.in，需要构造一个Scanner对象，并与”标准输入流”System.in关联。1Scanner in = new Scanner(System.in); 下面给出Scanner类的常用API： Scanner(InputStream in)用给定的输入流创建一个Scanner对象 String nextLine()读取输入的下一行内容(以回车作为分隔符) String next()读取输入的下一个单词(以空白字符如空格、回车作为分割符) int nextInt()读取下一个int double nextDouble()读取下一个double() boolean hasNext()检测输入是否还有单词 boolean hasNextInt()检测输入是否还有int boolean hasDouble()检测输入是否还有double 因为输入是可见的，所以Scanner类不使用于从控制台读取密码。Java SE 6特别引入了Console类实现不回显的输入。要想读取一个密码，可以采用下列代码：123Console cons = System.console();String username = cons.readLine("User name: ");char[] passwd = cons.readPassword("Password: "); 几点注意：1.Console类不能用new构造对象，属于单例模式，构造方法被private修饰2.为了安全起见，返回的密码存放在一维字符数组中，而不是字符串中。在对密码进行处理后，应该马上用一个填充值覆盖数组元素。3.采用Console对象处理输入不如Scanner方便，每次只能读取一行输入，而没有能够读取一个单词或一个数值的方法 下面给出Console类的常用API： static Console console()返回一个Console对象 static char[] readPassword(String prompt, Object…args)显示提示字符串prompt并读取用户输入，直到输入行结束,结果存放在字符数组中。args参数用来提供输入格式。 static String readLine(String prompt,Object…args)显示提示字符串prompt并读取用户输入，直到输入行结束，结果存放在字符串中。args参数用来提供输入格式。 2) 输出可以使用 System.out.print(x) 将数值 x 输出到控制台上。这条命令将以 x 对应的数据类型所允许的最大非 0 数字位数打印输出 x 。例如：12double x = 10000.0 / 3.0;System.out.print(x); 打印3333.3333333333335如果希望显示美元、美分等符号， 则有可能会出现问题。在早期的 Java 版本中，格式化数值曾引起过一些争议。庆幸的是，Java SE 5.0 沿用了 C语言库函数中的 printf方法。例如，调用1System.out.printf("%8.2f",x); 可以用 8 个字符的宽度和小数点后两个字符的精度打印 x。也就是说，打印输出一个空格和7 个字符， 如下所示：3333.33在 printf中，可以使用多个参数， 例如：1System.out.printf("Hello, %s. Next year, you'll be %d", name, age); 每一个以 % 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数。 下表列出了所有转换符：另外，还可以给出控制格式化输出的各种标志。例如，逗号标志增加了分组的分隔符。即1System.out.printf("%,.2f", 10000.0 / 3.0); 打印3,333.33 下表列出了用于printf的所有标志 可以使用静态的 String.format 方法创建一个格式化的字符串，而不打印输出：1String message = String.format("Hello, %s. Next year, you'll be %d", name , age); 基于完整性的考虑， 下面简略地介绍 printf方法中日期与时间的格式化选项(已经过时)。在新代码中， 应当使用 java.time 包的方法。 不过你可能会在遗留代码中看到 Date 类和相关的格式化选项。格式包括两个字母， 以 t 开始， 以下表中的任意字母结束。例如1System.out.printf("%tc", new Date()); 这条语句将用下面的格式打印当前的日期和时间：Mon Feb 09 18:05:19 PST 2015 从上表可以看到，某些格式只给出了指定日期的部分信息。例如，只有日期或月份。如果需要多次对日期操作才能实现对每一部分进行格式化的目的就太笨拙了。为此，可以采用一个格式化的字符串指出要被格式化的参数索引。索引必须紧跟在%后面， 并以$终止。 例如：1System.out.printf("%1$s %2$tB %2$te,%2$tY","Due date:",new Date()); 打印Due date: February 9, 2015 还可以选择使用 &lt; 标志。它指示前面格式说明中的参数将被再次使用。也就是说，下列语句将产生与前面语句同样的输出结果：1System.out .printf("%s %tB %&lt;te, %&lt;tY", "Due date:", new Date()); 注意：参数索引值从1开始，而不是从0开始，%1$…对第一个参数格式化。这就避免了与0标志混淆。 现在，已经了解了 printf 方法的所有特性。下表给出了格式说明符的语法图： 3) 重定向语法Java使用System.out(系统类的输出流对象)来表示标准输出设备，默认情况下是显示器，而用System.in(系统类的输入流对象)来表示标准输入设备，默认情况下是键盘。有时，我们需要从文件而不是键盘读入数据，并希望将程序输出结果保存到文件中而不是打印在控制台上。此时，可以在命令行利用Shell的重定向语法将任意文件关联到System.in和System.out，例如下面的语句实现了从input.txt文件输入并将程序输出结果输入output.txt：1java MyProg &lt; input.txt &gt; output.txt 方法1) 定义方法下面先来看一个方法的定义，其作用是返回两个整数中的较大者：12345678public static int max(int num1,int num2)&#123; int result; if(num1 &gt; num2) result = num1; else result = num2; return result;&#125; 其中花括号前的部分是方法头，花括号包括的部分是方法体。方法头包括修饰符(public static)、返回值类型(int)、方法名(max)、形式参数(int num1、int num2)。形式参数构成参数列表，方法名和参数列表构成方法签名。对带返回值的方法而言，return语句是必需的，且如果存在多个选择分支，要确保任何分支都有返回值。对于void方法，也可以在方法中使用return结束方法调用。 2) 调用方法如调用上述max方法：1int z = max(x,y); 其中x,y是实际参数。 每当调用一个方法时，系统会创建一个活动记录(也称为活动框架)，用于保存方法中的参数和变量。活动记录置于一个内存区域中，称为调用堆栈(call stack)。调用堆栈也称为执行堆栈、运行时堆栈，或者一个机器堆栈，常简称为”堆栈”。当一个方法调用另一个方法时，调用者的活动记录保持不动，一个新的活动记录被创建用于被调用的新方法,一个新的记录”入栈”。一个方法结束返回到调用者时，相应的活动记录被释放，其中的参数和变量被销毁，栈顶的记录”出栈”。堆栈的最底层活动记录是main方法的记录，当整个程序结束，main方法记录”出栈”,栈为空，程序结束。 当调用带参数的方法时，如果参数是基本数据类型，实参的值传递给形参(即拷贝)，这个过程称为按值传递，无论形参在方法中是否改变，实参都不受影响;如果参数是引用类型，则传递的是引用值，可以理解为传共享，形参和实参指向同一对象，此时实际对象可能会被改变。 main方法也有参数，是一个String数组，可以在命令行里给main方法传递字符串参数(也可以通过eclipse传递参数，在运行——运行配置——自变量里传递)。例如，下面的命令行用三个字符串arg0、arg1、arg2启动程序TestMain：1java TestMain arg0 arg1 arg2 其中arg0、arg1、arg2都是字符串，但是在命令行中出现时不需要双引号，但如果字符串包含空格，就必须用双引号括住。当调用main方法时，Java解释器会创建一个数组存储命令行参数，然后将该数组的引用传递给args。例如，如果调用有n个命令行参数的程序，Java解释器创建一个如下所示的数组：1args = new String[n]; 然后Java解释器传递参数args去调用main方法注意：如果命令行没有传递参数，那么使用new String[0]创建数组。在这种情况下args引用了一个长度为0的空数组，它的值不是null，但是args.length是0 数组Java和许多高级语言都提供了一种称作数组的数据结构，可以用它来存储一个元素个数固定且元素类型相同的有序集。数组一旦被创建，它的大小不能改变。使用一个数组引用变量，通过下标来访问数组中的元素。 1) 声明和创建数组(以一维数组为例)来看下面的语句：12elementType[] arrayRefVar = new elementType[arraySize];//(元素类型[] 数组引用变量 = new 元素类型[数组大小]) 该语句完成了三个操作：1.elementType[] arrayRefVar声明了一个elementType类型的数组引用变量arrayRefVar2.new elementType[arraySize]创建了一个大小为arraySize的elementType的数组3.= 把数组引用赋给数组引用变量 注意：1.elementType[] arrayRefVar只是声明数组变量，并不在内存中给数组分配任何空间，它只是创建一个对数组应用的存储位置，如果变量不包含对数组的引用，这个变量的值为null2.new elementType[arraySize]在内存中给数组元素分配了存储空间3.一个数组变量看起来似乎是存储了一个数组，但实际上它存储的是只是数组的引用。4.当创建数组后，它的元素被赋予默认值，数值型基本数据类型的默认值为0,char型的默认值为’\u0000’(空字符，但长度为1),boolean型的默认值为false，非基本数据类型的默认值均为null5.与C++不同，Java允许动态开数组，即无需在编译期就确定数组大小，可以在程序运行时决定数组大小并创建相应大小的数组。 2) 初始化数组1.逐一赋值123456int[] myList = new int[5];myList[0] = 1;myList[1] = 2;myList[2] = 3;myList[3] = 4;myList[4] = 5; 2.数组初始化语法 下面的语法可以给数组的前k个元素赋值：1elementType[] arrayRefVar = &#123;value0, value1, .., valuek&#125;; 注意：在使用数组初始化语法时，必须将声明、创建和初始化放在一条语句中，将它们分开会产生语法错误：12int[] myList;myList = &#123;1,2,3,4,5&#125;; //Error 3) 访问数组元素可以用arrayRefVar.length得到数组长度，数组元素的下标为0 ～ arrayRefVar.length - 1。可以直接使用下标随机访问数组元素：1arrayRefVar[index] (数组引用变量[下标]) 如果要打印数组，可以使用一个循环打印逐一数组元素。如果是字符数组，可以使用一条打印语句打印:12char[] city = &#123;'B','e','i','j','i','n','g'&#125;;System.out.println(city); 4) 复制数组要将一个数组中的内容复制到另一个中，如果使用=直接赋值，如：1list2 = list1; 上述语句只是将list1的引用值复制给了list2，这条语句执行后，list1和list2都指向了同一个数组，如果改变其中一者，另一者也会受到同样的影响。list2原先所引用的数组不能再引用，它就变成了垃圾，会被JVM自动回收。在Java中，可以使用赋值语句复制基本类型的值，但不能复制数组等引用类型的值。 复制数组的四种方法1.申请一个新数组，遍历原数组逐一复制元素2.使用System类的静态方法arraycopy3.使用数组对象.clone返回一个数组克隆的引用4.使用Arrays类的copyOf方法 5) 匿名数组来看下面的语法：1new elementType[] &#123;value0,value1, ... ,valuek&#125;; 该语句创建了一个没有显式引用变量的数组并进行了初始化，这样的数组称为匿名数组。注意匿名数组的方括号里不指定数组长度! 6) 可变长参数列表可以把类型相同但个数可变的参数传递给方法，语法如下：1typeName...parameterName (类型名...参数名) 注意：1.在方法声明中，指定类型后紧跟着省略号(…)2.只能给方法中指定一个可变长参数，且该参数必须是最后一个参数，任何常规参数必须在它之前3.Java将可变长参数当成数组对待，当用数目可变的参数调用方法时，Java会创建一个数组并把参数传给它 7) Arrays类Arrays类中包含了许多对处理数组的方法 下面是Arrays类的常用API： 如果计算机有多个处理器，可以使用parallelSort，比sort更高效。 8) 多维数组以二维数组为例，二维数组引用变量有三种表示方法：123elementType arrayRefVar[][]elementType[] arrayRefVar[]elementType[][] arrayRefVar 推荐使用elementType[][] arrayRefVar声明二维数组引用变量。初始化语法也适用于多维数组：1234int[][] array = &#123; &#123;1, 2&#125;, &#123;3, 4&#125;&#125;; 等价于：12345int[][] array = new int[2][2];array[0][0] = 1;array[0][1] = 2;array[1][0] = 3;array[1][1] = 4; 二维数组其实是一个数组，它的每个元素都是一个一维数组，即它是数组的数组。x.length可以获取二维数组的第一维长度，x[index].length可以获取index行对应的第二维长度。如果没有初始化二维数组二维数组的所有元素默认为null，因为二维数组的元素是数组类型，默认值为null二维数组中的每一行本身就是一个数组，因此，各行的长度可以不同。这样的数组称为锯齿数组，例如：1234567int[][] triangleArray = &#123; &#123;1, 2, 3, 4, 5&#125;, &#123;2, 3, 4, 5&#125;, &#123;3, 4, 5&#125;, &#123;4, 5&#125;, &#123;5&#125;&#125;; 其余没有赋值的部分并不会被赋为默认值，就是未分配空间,如果进行访问会抛出ArrayIndexOutOfBoundsException 二维数组在创建时可以省略第二维长度(留到后续指定)，但必须指定第一维长度：123456int[][] triangleArray = new int[5][];triangleArray[0] = new int[5];triangleArray[1] = new int[4];triangleArray[2] = new int[3];triangleArray[3] = new int[4];triangleArray[4] = new int[5]; 如果想打印多维数组，可以使用嵌套循环打印，也可以使用Arrays类的deepToString方法。 零敲碎打 一个Java源文件内只能有一个public类,且该类名称必须与文件名相同 main方法是程序的入口，JVM将从指定类中的main方法开始执行。根据Java语言规范，main方法必须声明为public static void main(String[] args) 在源代码中，字符串常量不能跨行，因此，下面的语句会造成编译错误： 12System.out.println("Welcome to theworld of Java!"); 为了改正错误，可以将该字符串分成几个单独的子串，然后再用连接符(+)将它们组合起来：12System.out.println("Welcome to the“ +”world of Java!");]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之Java程序设计概述]]></title>
    <url>%2F2017%2F10%2F07%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、走进JavaJava是一个完整的平台,有一个庞大的库,其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。它是功能完善的通用程序设计语言，可以用来开发健壮的任务关键的应用程序。现在，它不仅用于Web程序设计，而且用于在服务器、台式计算机和移动设备上开发跨平台的独立应用程序。 二、Java”白皮书”的关键术语1) 简单性Java语法是C++语法的一个“纯净”版本。这里没有头文件、指针运算(甚至指针语法)、结构、联合、操作符重载、虚基类等。其剔除了C++中许多很少使用、难以理解、易混淆的特性。目前看来，这些特性带来的麻烦远远多于其带来的好处。 2) 面向对象简单地讲，面向对象设计是一种程序设计技术。传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。 3) 分布式Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。 4) 健壮性Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java投入了大量的精力进行早期的问题检测(编译时检测)，后期动态的检测(运行时检测)，并消除了容易出错的情况。 5) 安全性Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。 6) 体系结构中立Java源文件经过编译生成中间字节码文件(.class)，这是一种体系结构中立的文件格式，精心设计的字节码不仅可以很容易地在任何带Java虚拟机(JVM)的平台上运行，而且还可以动态地翻译成本地机器代码，即Java程序可以”一次编译，处处运行”。当然，解释虚拟机指令肯定会比全速运行机器指令慢很多。虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程称为即时编译。 7) 可移植性与C和C++不同，Java规范中没有”依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。例如，Java中的int永远是32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是int类型的大小不能低于short int，并且不能高于long int。在Java中，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。 8) 解释型Java源程序(.java)在编写完成后，经过编译生成中间字节码文件(.class)，字节码文件被JVM解释执行，不同于C/C++等编译型语言，字节码被解释称机器代码后立即执行，不产生中间机器代码文件。 9) 高性能尽管对解释后的字节码性能已经比较满意，但有些场合下还需要更加高效的性能。字节码可以(在运行时刻)动态地翻译成对应运行这个应用的特定CPU的机器码。 10) 多线程多线程可以带来更好的交互响应和实时行为。我们非常关注并发性，因为我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。Java是第一个支持并发程序设计的主流语言。 11) 动态性Java能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时的类型信息十分简单。 三、名词释疑JDK即Java开发工具包(Java Development Kit)，是编写Java程序的程序员使用的软件，包括开发和运行Java程序的软件。 OpenJDKJava SE的一个免费开源实现，不包含浏览器集成或JavaFX SDK即Software Development Kit,是一个过时的术语，用于描述1998 ～ 2006年之间的JDK J2一个过时的术语，用于描述1998 ～ 2006年之间的Java版本 JRE即Java运行时环境(Java Runtime Environment)，是运行Java程序的用户使用的软件，它包含Java虚拟机但不包含编译器，为不需要开发只需要运行Java程序的用户提供。 Sever JRE在服务器上运行Java程序的软件。 JVM即Java虚拟机(Java Virtual Machine)，用于解释执行中间字节码文件。 API即应用程序接口(Application Program Interface),也称为库，包括为开发Java程序而预定义的类和接口。 IDE即集成开发环境(Integrated Development Environment),是为了快速开发程序而提供的开发工具，编辑、编译、链接、调试和在线帮助都集成在一个图形用户界面中。 applet能在Web浏览器中运行的Java程序称为Java小程序(applet) Java SE即Java标准版(Java Standard Edition),可以用来开发客户端的应用程序。应用程序可以独立运行或作为applet在Web浏览器中运行。 Java EE即Java企业版(Java Enterprise Edition),可以用来开发服务器端的应用程序，例如，Java servlet和JavaServer Pages(JSP)，以及JavaServer Faces(JSF)。 Java ME即Java微型版(Java Micro Edition)，可以用来开发移动设备的应用程序，例如手机。 JavaFX开发Java GUI程序的框架，在Oracle的Java SE发布版本中提供。 四、JDK、JRE和JVM三者的关系见大牛博客：JDK、JRE、JVM三者间的关系 五、创建、编译和执行Java程序的过程Java源程序编写后被保存为.java文件，通过Java编译器编译生成字节码.class文件，字节码文件和所需的库代码被送去JVM解释执行。在执行一个Java程序时，JVM首先会用一个称为类加载器(class loader)的程序将类的字节码加载到内存中。如果你的程序中使用其他类，类加载程序会在需要它们之前动态地加载它们。当加载该类后，JVM使用一个字节码验证器(bytecode verifier)的程序来检验字节码的合法性，确保字节码不会违反Java的安全规范，以确保来自网络的Java程序不会篡改和危害你的计算机。 六、通过命令行编译、运行Java程序在命令行里输入以下命令编译Java程序：java classname.java编译成功后，使用以下语句运行程序：java classname //注意此处不要加.class后缀 七、注释1) 行注释行注释以//开始，不能跨行 2) 块注释块注释以/*开始，以*/结尾，可以跨行 3) 文档注释文档注释以/**开始，以*/结尾，它能使用JDK的javadoc命令提取一个HTML文件。使用javadoc注释来注释整个类或整个方法，为了将这些注释提取出来放在一个javadoc HTML文件中，这些注释必须放在类或者方法头前面。要注释方法中的某一步骤，使用行注释// eclipse快捷键：ctrl+/ 或者ctrl+shift+c –单行注释ctrl+shift+/ —多行注释 八、程序设计错误1) 语法错误在编译过程中出现的错误称为语法错误或编译错误。 2) 运行时错误运行时错误是引起程序非正常中断的错误，即程序能通过编译，但在运行时环境检测到一个不可能执行的操作，就会出现运行错误。 3) 逻辑错误当程序没有按预期的方式执行就会发生逻辑错误。 九、Java标识符Java标识符用于命名类、接口、变量、常量、方法等，有如下规则： 标识符是由字母、数字、下划线(_)和美元符号($)组成的字符序列 必须以字母、下划线(_)或美元符号($)开头，不能以数字开头 标识符不能是保留字 标识符不能是true、false或null等字面常量 标识符可以为任意长度 不要用字符$命名标识符，习惯上$只用于机器自动产生的源代码中 十、命名规范注意：在命名时尽量避免采用缩写作为标识符，用完整的词汇会更具有描述性，比如numberOfStudents比numStds、numOfStuds或者numOfStudents要好。另外，Java是区分大小写的。 1) 类名和接口每个单词的首字母大写,例如类名ComputeArea和System 2) 变量和方法使用小写字母命名变量和方法，如有多个单词则第一个单词字母小写，后面每个单词的首字母大写，例如变量radius以及方法setRadius 3) 常量大写常量的所有字母，如果有多个单词，单词之间用下划线连接，例如，常量PI和常量MAX_VALUE]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH远程登录实现本地机和服务器的文件传输]]></title>
    <url>%2F2017%2F10%2F07%2FSSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见: 在Ubuntu下通过SSH连接远程服务器 (1)用SSH登录远程ubuntu主机假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu我们在命令行输入以下命令来连接：ssh -l ubuntu 118.89.223.117之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端 (2)从远程Ubuntu主机下载文件/文件夹到本地(scp)语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径 我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件要下载文件到本地,我们要结束SSH连接,切换到本地机,输入eixt或quit即可 我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功 我们进入本地目录验证一下 hello文件的确下载到了本地 (3)从本地向远程ubuntu主机上传文件/文件夹(scp)语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径 假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下 要上传本地文件,我们要结束SSH连接,切换到本地机,输入eixt或quit即可然后输入命令$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/，输入密码后提示文件上传成功 我们通过SSH登录到远程主机验证一下,pwd打印当前所在位置，发现我们处于/home/ubuntu目录下,ls显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下通过SSH连接远程服务器]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。 环境准备装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台 步骤一:打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端$ sudo apt-get install aptitude$ sudo aptitude install openssh-server 步骤二:启动ssh-server$ /etc/init.d/ssh restart 步骤三：确认ssh-server已经正常工作$ netstat -tlptcp6 0 0 *:ssh *:* LISTEN -看到上面一行说明ssh-server已经在运行了 步骤四：在本地机终端通过ssh登录服务器$ ssh -l 远程服务器用户名 服务器ip地址接下来会提示输入密码，然后就能成功登录到服务器上了 参考http://blog.csdn.net/wh_19910525/article/details/7585257]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制修改ubuntu密码]]></title>
    <url>%2F2017%2F10%2F06%2F%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。 查了资料,总结出两种解决方法: 方法一:加上sudo权限 方法二:切换到root用户 mark一下]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习笔记]]></title>
    <url>%2F2017%2F10%2F05%2FMarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。1. 标题标题根据字体大小分级产生层次，有两种写法：写法一：1234一级标题==================二级标题--------------------- 效果如下： 一级标题二级标题写法二：123456# 一级标题## 二级标题 ### 三级标题 #### 四级标题##### 五级标题 ###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题可见#的数量越多标题字号越小，要特别注意#和标题之间要留一个空格! 2. 内联样式内联样式能描述文字的粗细、倾斜程度等2.1 语义标记：代码:123456*这是斜体*_这是斜体_**这是粗体** ***这是加粗斜体*** **_这是加粗斜体_**~~这是删除线~~ 效果如下: 这是斜体这是斜体这是粗体这是加粗斜体这是加粗斜体这是删除线 可见语义标记允许叠加 2.2 语义标签代码:123456&lt;i&gt;这是斜体&lt;/i&gt; &lt;b&gt;这是粗体&lt;/b&gt; &lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt; &lt;em&gt;这是强调&lt;/em&gt; 这是上标 Z&lt;sup&gt;a&lt;/sup&gt; 这是下标 Z&lt;sub&gt;a&lt;/sub&gt; 效果如下： 这是斜体这是粗体这是粗斜体这是强调这是上标 Za这是下标 Za 可见语义标签可以嵌套，特别要注意&lt;em&gt;&lt;/em&gt;标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用&lt;i&gt;&lt;/i&gt;标签替代 3. 引用3.1 单行式 代码: 1&gt; hello world 效果如下: hello world 3.2 多行式 代码: 123&gt; hello world &gt; hello world &gt; hello world 效果如下: hello worldhello worldhello world 3.3 嵌套式 代码: 123&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc 效果如下: aaaaaaaaa bbbbbbbbb cccccccccc 4. 换行与段落缩进换行: 在行末敲两个空格和一个回车段落缩进: 将输入法切换为全角后敲击两次空格即可完成两个字符的缩进5. 行内标记与代码块5.1 行内标记(用前后各一个`标记代码块将变成一行) 代码: 1标记之外`hello world`标记之外 效果如下: 标记之外hello world标记之外 5.2 代码块(用于插入各类型的代码) 方法一 (使用前后各一个```包裹代码生成块,注意```之后换行不需要敲两个空格!!!): 效果如下: 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 方法二 (使用Tab缩进): 代码及效果如下: 我是文字… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 注意要在前文后空一行再进行Tab缩进 方法三 (自定义语法)： 即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮 效果如下： html代码块 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; javascript代码块 12345var num = 0;for(var i = 0; i &lt; 5; i++)&#123; num += i; &#125;console.log(num); 6. 超链接 Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。 6.1 行内式语法说明: []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。 代码: 12这是[XJY&apos;s Blog](http://habitdiary.cn) 这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;) 效果如下:这是XJY’s Blog这是XJY’s Blog 6.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明:参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 代码: 12345我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。[1]:http://www.baidu.com &quot;Baidu&quot;[2]:http://note.youdao.com/ &quot;youdaonote&quot;[3]:http://www.imooc.com/ &quot;IMOOC&quot;[网站]:http://note.youdao.com/ &quot;youdaonote&quot; 效果如下: 我经常去的网站有Baidu、有道云笔记以及IMOOC,有道云笔记是不错的网站。 6.3 自动链接语法说明:Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：代码: 12&lt;http://example.com/&gt;&lt;address@example.com&gt; 效果如下:http://example.com/&#x61;&#100;&#100;&#114;&#x65;&#x73;&#x73;&#64;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#111;&#x6d; 7. 列表7.1 无序列表代码: 123* 吃饭* 睡觉* 打代码 效果如下: 吃饭 睡觉 打代码 7.2 有序列表代码: 1231. 把冰箱门打开2. 把大象关进去3. 把冰箱门带上 效果如下: 把冰箱门打开 把大象关进去 把冰箱门带上 7.3 序表嵌套代码: 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 效果如下: one one-1 two-2 two two-1 two-2 7.4 任务列表代码(方括号里是x表示打勾,空格表示为空): 123- [x] 选项一- [ ] 选项二 - [ ] 选项三 效果如下: 选项一 选项二 选项三 8. 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 8.1 内联式语法说明:![图片Alt](图片地址 “图片Title”)代码: 12爱琴海![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;) 效果如下:爱琴海 8.2 参照式语法说明:在文档要插入图片的地方写![图片Alt][标记]，在文档的最后写上[标记]:图片地址 “Title”代码: 123爱琴海![爱琴海][1][1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot; 效果如下:爱琴海 说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/574157059. 插入视频如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：1&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt; 效果如下: mark一下第一次写博客遇到的神坑: 在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 最后要感谢提供参考的大牛博客: http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13 http://www.jianshu.com/p/b03a8d7b1719]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
