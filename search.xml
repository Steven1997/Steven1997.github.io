<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态规划之区间dp]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[简介区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。 算法结构设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段 For l:=2 to n do // 枚举区间长度for i:=1 to n do // 枚举区间的左端点beginj:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到if j&gt;n then break; // 保证了下标不越界for k:= i to j-1 do // 状态转移，去推出 f[i,j]f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }end; 这个结构必须记好，这是区间动态规划的代码结构。 例题石子合并题目链接:http://acm.nyist.net/JudgeOnline/problem.php?pid=737 题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。那么dp[i][j] = min(dp[i][k] + dp[k+1][j])那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2） 代码1(无优化)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i)//枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = i; k &lt; j; ++k) &#123; dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125;``` 代码2(平行四边形优化) ```cpp#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N],s[N][N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); s[i][i]=i; sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i) //枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = s[i][j-1]; k &lt;= s[i+1][j]; ++k)//四边形优化 &#123; if(dp[i][j]&gt;dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]) &#123; dp[i][j]=dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]; s[i][j]=k; &#125; &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125;``` ### 括号匹配 题目链接：&lt;http://poj.org/problem?id=2955&gt; 题意:给出一串的只有‘（’ ‘）’ '[‘ ']'四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。 分析： 定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目 1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ; 2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] ) 代码 ```cpp #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;const int N = 120;int dp[N][N];int main()&#123; string s; while(cin&gt;&gt;s) &#123; if(s=="end") break; memset(dp,0,sizeof(dp)); int n = s.size(); for(int len = 2;len &lt;= n;len++)//枚举区间长度 &#123; for(int i = 0;i &lt;= n - len; i++)//枚举区间左端点 &#123; int j = i + len - 1;//确定区间右端点 if(j &gt; n) break; if(s[i]=='('&amp;&amp;s[j]==')' || s[i]=='['&amp;&amp;s[j]==']') dp[i][j]=dp[i+1][j-1]+2; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);//枚举中间位置,注意j不取等号 &#125; &#125; cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; &#125; return 0;&#125;``` 如果要求打印路径，即输出匹配后的括号 题目链接: &lt;http://poj.org/problem?id=1141&gt; 代码: ```cpp#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 120;int dp[N][N],pos[N][N]; /*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/string s;void show(int i,int j)&#123; if(i&gt;j) return; if(i==j) &#123; if(s[i]=='('||s[i]==')') cout&lt;&lt;"()"; else cout&lt;&lt;"[]"; &#125; else &#123; if(pos[i][j]==-1) &#123; cout&lt;&lt;s[i]; show(i+1,j-1); cout&lt;&lt;s[j]; &#125; else &#123; show(i,pos[i][j]); show(pos[i][j]+1,j); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;s) &#123; memset(dp,0,sizeof(dp)); int len=s.size(); for(int i=1; i&lt;len; i++) &#123; for(int j=0,k=i; k&lt;len; j++,k++) &#123; if(s[j]=='('&amp;&amp;s[k]==')' || s[j]=='['&amp;&amp;s[k]==']') &#123; dp[j][k]=dp[j+1][k-1]+2; pos[j][k]=-1; &#125; for(int f=j; f&lt;k; f++) &#123; if(dp[j][f]+dp[f+1][k]&gt;=dp[j][k]) &#123; dp[j][k]=dp[j][f]+dp[f+1][k]; pos[j][k]=f; &#125; &#125; &#125; &#125; show(0,len-1); cout&lt;&lt;endl; &#125; return 0;&#125; 整数划分题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=746 题意: 给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积 分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数设a[i][j]为区间[i,j]所形成的数所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i]) 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long dp[25][25];long long a[25][25];char str[25];int main()&#123; int len, t, m; scanf("%d", &amp;t); while (t--) &#123; scanf("%s%d", str, &amp;m); len = strlen(str); m--; memset (a, 0, sizeof(a)); memset (dp, 0, sizeof(dp)); for (int i = 0; i &lt; len; i++) //先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值 &#123; a[i][i] = str[i] - '0'; for (int j = i + 1; j &lt; len; j++) &#123; a[i][j] = a[i][j - 1] * 10 + str[j] - '0'; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; dp[i][0] = a[0][i]; &#125; for (int j = 1; j &lt;= m; j++) &#123; for (int i = j; i &lt; len; i++) &#123; for (int k = 0; k &lt; i; k++) &#123; dp[i][j] = max(dp[i][j], dp[k][j - 1] * a[k + 1][i]); &#125; &#125; &#125; printf("%lld\n", dp[len - 1][m]); &#125; return 0;&#125;``` ### Halloween Costumes 题目链接：&lt;http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422&gt; 题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会 分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有①：如果在之后的区间内都不再重复利用这件衣服，那么明显 dp[i][j] = dp[i+1][j] + 1;②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，那么转移方程为 dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j]) 代码:```cpp#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[105];int dp[105][105];int main(void)&#123; int t; int cas = 0; scanf("%d",&amp;t); while(t--) &#123; cas ++; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) &#123; for(int j = i;j &lt;= n;j++) &#123; dp[i][j] = j-i+1; &#125; &#125; for(int i = n-1;i &gt;= 1;i--) &#123; for(int j = i+1;j &lt;= n;j++) &#123; dp[i][j] = dp[i+1][j] + 1; for(int k = i+1;k &lt;= j;k++) &#123; if(a[i] == a[k]) &#123; dp[i][j] = min(dp[i][j],dp[i][k-1] + dp[k+1][j]); &#125; &#125; &#125; &#125; printf("Case %d: %d\n",cas,dp[1][n]); &#125; return 0;&#125; Cheapest Palindrome题目链接:http://poj.org/problem?id=3280 题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。 分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况： 1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值； 2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值 3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小 然后dp[i][j]取上面这些情况的最小值 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int dp[2005][2005],add[27],del[27];char s[2005];int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)&gt;0) &#123; scanf("%s",s+1); for(int i=1;i&lt;=n;i++) &#123; char ch[10]; int tmp1,tmp2; scanf("%s%d%d",ch,&amp;tmp1,&amp;tmp2); add[ch[0]-'a'+1]=tmp1; del[ch[0]-'a'+1]=tmp2; &#125; memset(dp,0,sizeof(dp)); for(int i=m-1;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i+1][j]+add[s[i]-'a'+1],dp[i+1][j]+del[s[i]-'a'+1]); int tmp=min(dp[i][j-1]+add[s[j]-'a'+1],dp[i][j-1]+del[s[j]-'a'+1]); dp[i][j]=min(dp[i][j],tmp); if(s[i]==s[j]) dp[i][j]=min(dp[i][j],dp[i+1][j-1]); &#125; &#125; printf("%d\n",dp[1][m]); &#125; return 0;&#125; Treats for the Cows题目链接:http://poj.org/problem?id=3186 题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值 分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来转移方程：dp[i][j]=max(dp[i+1][j]+p[i](n+i-j),dp[i][j-1]+p[j](n+i-j)); 其中n-(j-i)是第几次取 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int p[2010];int dp[2010][2010];int n;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); dp[i][i]= n * p[i]; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=i;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i+1][j]+p[i]*(n+i-j),dp[i][j-1]+p[j]*(n+i-j)); &#125; printf("%d\n",dp[1][n]); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH远程登录实现本地机和服务器的文件传输]]></title>
    <url>%2F2017%2F10%2F07%2FSSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见: 在Ubuntu下通过SSH连接远程服务器 (1)用SSH登录远程ubuntu主机假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu我们在命令行输入以下命令来连接：ssh -l ubuntu 118.89.223.117之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端 (2)从远程Ubuntu主机下载文件/文件夹到本地(scp)语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径 我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件要下载文件到本地,我们要结束SSH连接,切换到本地机,输入eixt或quit即可 我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功 我们进入本地目录验证一下 hello文件的确下载到了本地 (3)从本地向远程ubuntu主机上传文件/文件夹(scp)语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径 假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下 要上传本地文件,我们要结束SSH连接,切换到本地机,输入eixt或quit即可然后输入命令$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/，输入密码后提示文件上传成功 我们通过SSH登录到远程主机验证一下,pwd打印当前所在位置，发现我们处于/home/ubuntu目录下,ls显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下通过SSH连接远程服务器]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。 环境准备装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台 步骤一:打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端$ sudo apt-get install aptitude$ sudo aptitude install openssh-server 步骤二:启动ssh-server$ /etc/init.d/ssh restart 步骤三：确认ssh-server已经正常工作$ netstat -tlptcp6 0 0 *:ssh *:* LISTEN -看到上面一行说明ssh-server已经在运行了 步骤四：在本地机终端通过ssh登录服务器$ ssh -l 远程服务器用户名 服务器ip地址接下来会提示输入密码，然后就能成功登录到服务器上了 参考http://blog.csdn.net/wh_19910525/article/details/7585257]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制修改ubuntu密码]]></title>
    <url>%2F2017%2F10%2F06%2F%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。 查了资料,总结出两种解决方法: 方法一:加上sudo权限 方法二:切换到root用户 mark一下]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习笔记]]></title>
    <url>%2F2017%2F10%2F05%2FMarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。1. 标题标题根据字体大小分级产生层次，有两种写法：写法一：1234一级标题==================二级标题--------------------- 效果如下： 一级标题二级标题写法二：123456# 一级标题## 二级标题 ### 三级标题 #### 四级标题##### 五级标题 ###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题可见#的数量越多标题字号越小，要特别注意#和标题之间要留一个空格! 2. 内联样式内联样式能描述文字的粗细、倾斜程度等2.1 语义标记：代码:123456*这是斜体*_这是斜体_**这是粗体** ***这是加粗斜体*** **_这是加粗斜体_**~~这是删除线~~ 效果如下: 这是斜体这是斜体这是粗体这是加粗斜体这是加粗斜体这是删除线 可见语义标记允许叠加 2.2 语义标签代码:123456&lt;i&gt;这是斜体&lt;/i&gt; &lt;b&gt;这是粗体&lt;/b&gt; &lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt; &lt;em&gt;这是强调&lt;/em&gt; 这是上标 Z&lt;sup&gt;a&lt;/sup&gt; 这是下标 Z&lt;sub&gt;a&lt;/sub&gt; 效果如下： 这是斜体这是粗体这是粗斜体这是强调这是上标 Za这是下标 Za 可见语义标签可以嵌套，特别要注意&lt;em&gt;&lt;/em&gt;标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用&lt;i&gt;&lt;/i&gt;标签替代 3. 引用3.1 单行式 代码: 1&gt; hello world 效果如下: hello world 3.2 多行式 代码: 123&gt; hello world &gt; hello world &gt; hello world 效果如下: hello worldhello worldhello world 3.3 嵌套式 代码: 123&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc 效果如下: aaaaaaaaa bbbbbbbbb cccccccccc 4. 换行与段落缩进换行: 在行末敲两个空格和一个回车段落缩进: 将输入法切换为全角后敲击两次空格即可完成两个字符的缩进5. 行内标记与代码块5.1 行内标记(用前后各一个`标记代码块将变成一行) 代码: 1标记之外`hello world`标记之外 效果如下: 标记之外hello world标记之外 5.2 代码块(用于插入各类型的代码) 方法一 (使用前后各一个```包裹代码生成块): 效果如下: 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 方法二 (使用Tab缩进): 代码及效果如下: 我是文字… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 注意要在前文后空一行再进行Tab缩进 方法三 (自定义语法)： 即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮 效果如下： html代码块 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; javascript代码块 12345var num = 0;for(var i = 0; i &lt; 5; i++)&#123; num += i; &#125;console.log(num); 6. 超链接 Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。 6.1 行内式语法说明: []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。 代码: 12这是[XJY&apos;s Blog](http://habitdiary.cn) 这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;) 效果如下:这是XJY’s Blog这是XJY’s Blog 6.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明:参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 代码: 12345我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。[1]:http://www.baidu.com &quot;Baidu&quot;[2]:http://note.youdao.com/ &quot;youdaonote&quot;[3]:http://www.imooc.com/ &quot;IMOOC&quot;[网站]:http://note.youdao.com/ &quot;youdaonote&quot; 效果如下: 我经常去的网站有Baidu、有道云笔记以及IMOOC,有道云笔记是不错的网站。 6.3 自动链接语法说明:Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：代码: 12&lt;http://example.com/&gt;&lt;address@example.com&gt; 效果如下:http://example.com/&#x61;&#100;&#x64;&#114;&#101;&#115;&#x73;&#x40;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#101;&#46;&#x63;&#111;&#109; 7. 列表7.1 无序列表代码: 123* 吃饭* 睡觉* 打代码 效果如下: 吃饭 睡觉 打代码 7.2 有序列表代码: 1231. 把冰箱门打开2. 把大象关进去3. 把冰箱门带上 效果如下: 把冰箱门打开 把大象关进去 把冰箱门带上 7.3 序表嵌套代码: 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 效果如下: one one-1 two-2 two two-1 two-2 7.4 任务列表代码(方括号里是x表示打勾,空格表示为空): 123- [x] 选项一- [ ] 选项二 - [ ] 选项三 效果如下: 选项一 选项二 选项三 8. 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 8.1 内联式语法说明:![图片Alt](图片地址 “图片Title”)代码: 12爱琴海![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;) 效果如下:爱琴海 8.2 参照式语法说明:在文档要插入图片的地方写![图片Alt][标记]，在文档的最后写上[标记]:图片地址 “Title”代码: 123爱琴海![爱琴海][1][1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot; 效果如下:爱琴海 说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/574157059. 插入视频如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：1&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt; 效果如下: mark一下第一次写博客遇到的神坑: 在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 最后要感谢提供参考的大牛博客: http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13 http://www.jianshu.com/p/b03a8d7b1719]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
