<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法学习之线段树]]></title>
    <url>%2F2017%2F10%2F18%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近重温了一下线段树，发现暑假学得太囫囵吞枣，某些细节没有真正理解，学算法还是要脚踏实地啊(日常鸡汤)！下面来总结一下线段树。 线段树是什么？有什么用？线段树类似区间树，它在各个节点保存一条线段(数组中的一段子数组)，主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)。你可能会问：查询区间和可以用O(n)的复杂度预处理一个前缀和数组，然后就可以O(1)地查询某段区间和;查询区间最值，也就是RMQ问题，也可以用O(nlogn)的复杂度预处理ST表，然后O(1)地查询区间最值。那么为什么要使用线段树呢？线段树的精髓就在于它能在支持区间动态修改的前提下保持每个操作O(logn)的复杂度，这是其他两者做不到的。线段树能进行的操作主要有：1)单点更新，区间查询 2)区间更新，区间查询 3)区间更新，单点查询除了上述操作，线段树还可以解决区间染色和矩形面积交、面积并等问题。 线段树基本知识线段树的结构： 建立一个线段树的示意图(可以维护区间和或最值)： 单点修改后重新调整线段树： 区间查询区间最值： 线段树的结点关系: 线段树的代码实现下面给出建立线段树和进行各种操作的模板，关键点在代码的注释中有解释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208/*node：区间结点号 begin：该node的区间左边界 end：该node的区间右边界 left：查询区间的左边界 right：查询区间的右边界 pos：查询区间的点*/ /*线段树:求和或最值 单点更新,区间查询区间更新,单点查询(lazy标记表示本节点的信息已经根据标记更新过了，但是本节点的子节点仍需要进行更新。lazy初始为0,区间加上k给该区间管理的结点的lazy加k,push_down给子节点加(end-begin+1)*k)区间更新,区间查询 lson 2*noderson 2*node+1[begin,end][begin,mid] [mid+1,end] 其中mid为(begin+end)/2 */ #define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1) int segTree[maxn*4];int lazy[maxn*4];void pushUp(int node)&#123;//pushUp自底向上更新区间和与最值 segTree[node]=segTree[lson]+segTree[rson];//segTree[node]=max(segTree[lson],segTree[rson]) &#125;void pushDown(int node,int begin,int end)&#123;//pushDown自顶向下更新lazy数组和给结点加上lazy数组的值 if(!lazy[node]) return;//lazy[node]为0直接return segTree[lson]+=(mid-begin+1)*lazy[node]; segTree[rson]+=(end-mid)*lazy[node]; lazy[lson]+=lazy[node]; lazy[rson]+=lazy[node];//给左右孩子传递lazy,是+=不是=，因为孩子节点可能被多次延迟标记又没有向下传递 lazy[node]=0;//把父节点的lazy置为0 &#125;void build(int node,int begin,int end)&#123;//建树 lazy[node]=0; if(begin==end)&#123;//begin==end表示管理的是结点 scanf("%d",&amp;segTree[node]);//按照顺序输入结点，由于建树类似于树的先根遍历，所以建立的线段树的叶子结点从左到右的值就是输入的顺序 //segTree[node]=a[begin] 用于任意顺序输入,先将输入存入a数组,下标从1开始，begin = end = index return;//输入完成后要return，否则会继续访问左右孩子，可能越界 &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123;//单点更新 if(pos&lt;begin||pos&gt;end) return;//管理的区间不包含pos,直接return if(begin==end)&#123; segTree[node]+=k; return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125; int query(int node,int begin,int end,int left,int right)&#123;//区间查询 if(left&gt;end||right&lt;begin) return 0;//查询结点和区间没有公共点 if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node];//查询区间包含查询结点 pushDown(node,begin,end); int sum=0;//int maxx=-1 sum+=query(lson,begin,mid,left,right);//maxx=max(maxx,query(lson,begin,mid,left,right)) sum+=query(rson,mid+1,end,left,right);//maxx=max(maxx,query(rson,mid+1,end,left,right)) return sum;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123;//区间更新 if(left&gt;end||right&lt;begin) return;//结点和更新区间没有公共点 if(left&lt;=begin&amp;&amp;right&gt;=end)&#123;//更新区间包含结点 segTree[node]+=(end-begin+1)*k; lazy[node]+=k; return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125;``` ### 例题 #### 一、单点更新，区间查询 HDU1166 敌兵布阵 题目链接:&lt;http://acm.split.hdu.edu.cn/showproblem.php?pid=1166&gt; 代码： ```cpp#include&lt;bits/stdc++.h&gt;#define maxn 50005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[maxn*4];int T,N,a,b;char command[10];void pushUp(int node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void build(int node,int begin,int end)&#123; if(begin==end)&#123; scanf("%d",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segTree[node]+=k; return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; int sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;int main()&#123; scanf("%d",&amp;T); int cas=1; while(T--)&#123; scanf("%d",&amp;N); build(1,1,N); printf("Case %d:\n",cas++); while(scanf("%s",command)!=EOF)&#123; if(command[0]=='E') break; scanf("%d%d",&amp;a,&amp;b); if(command[0]=='Q') cout&lt;&lt;query(1,1,N,a,b)&lt;&lt;endl; else if(command[0]=='A') update(1,1,N,a,b); else if(command[0]=='S') update(1,1,N,a,-b); &#125; &#125;&#125;``` HDU 1754 I Hate It 题目链接：&lt;http://acm.split.hdu.edu.cn/showproblem.php?pid=1754&gt; 代码: ```cpp#include&lt;bits/stdc++.h&gt;#define maxn 200005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[4*maxn];int N,M,A,B;char C[3];void pushUp(int node)&#123; segTree[node]=max(segTree[lson],segTree[rson]);&#125;void build(int node,int begin,int end)&#123; if(begin==end)&#123; scanf("%d",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void update(int node,int begin,int end,int pos,int k)&#123; if(pos&lt;begin||pos&gt;end) return; if(begin==end)&#123; segTree[node]=k;//直接修改 return; &#125; update(lson,begin,mid,pos,k); update(rson,mid+1,end,pos,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; int maxx=0; maxx=max(maxx,query(lson,begin,mid,left,right)); maxx=max(maxx,query(rson,mid+1,end,left,right)); return maxx;&#125;int main()&#123; while(scanf("%d%d",&amp;N,&amp;M)!=EOF)&#123; build(1,1,N); while(M--)&#123; scanf("%s%d%d",C,&amp;A,&amp;B); if(C[0]=='Q')&#123; printf("%d\n",query(1,1,N,A,B)); &#125; else&#123; update(1,1,N,A,B); &#125; &#125; &#125;&#125; 二、区间更新，区间查询POJ 3468 A Simple Problem with Integers题目链接:http://poj.org/problem?id=3468代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#define maxn 100005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;typedef long long ll;ll segTree[4*maxn];ll lazy[4*maxn];ll N,Q,A,B,C;char command[3];void pushUp(ll node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void pushDown(ll node,ll begin,ll end)&#123; if(!lazy[node]) return; segTree[lson]+=(mid-begin+1)*lazy[node]; segTree[rson]+=(end-mid)*lazy[node]; lazy[lson]+=lazy[node]; lazy[rson]+=lazy[node]; lazy[node]=0;&#125;void build(ll node,ll begin,ll end)&#123; lazy[node]=0; if(begin==end)&#123; scanf("%lld",&amp;segTree[node]); return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node); &#125;ll query(ll node,ll begin,ll end,ll left,ll right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; pushDown(node,begin,end); ll sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;void update(ll node,ll begin,ll end,ll left,ll right,ll k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segTree[node]+=(end-begin+1)*k; lazy[node]+=k; return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125;int main()&#123; scanf("%lld%lld",&amp;N,&amp;Q); build(1,1,N); while(Q--)&#123; scanf("%s",command); if(command[0]=='Q')&#123; scanf("%lld%lld",&amp;A,&amp;B); printf("%lld\n",query(1,1,N,A,B)); &#125; else&#123; scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;C); update(1,1,N,A,B,C); &#125; &#125;&#125; HDU 1698 Just A Hook题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1698代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include&lt;bits/stdc++.h&gt;#define maxn 100005#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;int segTree[4*maxn];int lazy[4*maxn];int T,N,Q,X,Y,Z;void pushUp(int node)&#123; segTree[node]=segTree[lson]+segTree[rson];&#125;void build(int node,int begin,int end)&#123; lazy[node]=0; if(begin==end)&#123; segTree[node]=1; return; &#125; build(lson,begin,mid); build(rson,mid+1,end); pushUp(node);&#125;void pushDown(int node,int begin,int end)&#123; if(!lazy[node]) return; segTree[lson]=(mid-begin+1)*lazy[node];//+=改成=,直接更新到底部 segTree[rson]=(end-mid)*lazy[node]; lazy[lson]=lazy[node]; lazy[rson]=lazy[node]; lazy[node]=0;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; segTree[node]=(end-begin+1)*k;//+=改成=,直接更新到底部 lazy[node]=k;//+=改成=,因为此时lazy即使没有下传也不叠加 return; &#125; pushDown(node,begin,end); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k); pushUp(node);&#125;int query(int node,int begin,int end,int left,int right)&#123; if(left&gt;end||right&lt;begin) return 0; if(left&lt;=begin&amp;&amp;right&gt;=end) return segTree[node]; pushDown(node,begin,end); int sum=0; sum+=query(lson,begin,mid,left,right); sum+=query(rson,mid+1,end,left,right); return sum;&#125;int main()&#123; scanf("%d",&amp;T); int cas=1; while(T--)&#123; scanf("%d%d",&amp;N,&amp;Q); build(1,1,N); while(Q--)&#123; scanf("%d%d%d",&amp;X,&amp;Y,&amp;Z); update(1,1,N,X,Y,Z); &#125; printf("Case %d: The total value of the hook is %d.\n",cas++,query(1,1,N,1,N)); &#125;&#125;``` ### 三、区间染色问题 ZOJ 1610 Count the Colors 题目链接:&lt;https://vjudge.net/problem/11553/origin&gt; 代码：```cpp#include&lt;bits/stdc++.h&gt;#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)#define maxn 8005using namespace std;int col[maxn*4];//col[node]表示node管辖的区间的颜色 int sum[maxn];//表示某点的颜色 int res[maxn];void pushDown(int node)&#123; col[lson]=col[rson]=col[node]; col[node]=-1;&#125;void update(int node,int begin,int end,int left,int right,int k)&#123; if(left&gt;end||right&lt;begin) return; if(left&lt;=begin&amp;&amp;right&gt;=end)&#123; col[node]=k; return; &#125; if(col[node]!=-1) pushDown(node); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k);&#125;//不用建树,直接在query里存储颜色即可，因为染色不用求区间和或者最值 void query(int node,int begin,int end,int left,int right)&#123; if(begin==end)&#123; sum[begin]=col[node];//存储每个点的颜色 return; &#125; if (col[node] != -1) pushDown(node); query(lson,begin,mid,left,right); query(rson,mid+1,end,left,right);&#125;int main()&#123; int n,x1,x2,c; while(scanf("%d",&amp;n)!=EOF)&#123; memset(col,-1,sizeof(col)); memset(sum,-1,sizeof(sum)); memset(res,0,sizeof(res)); for(int i=0;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;x1,&amp;x2,&amp;c); if(x1==x2) continue;//为了保证R-1&gt;=L update(1,0,maxn-1,x1,x2-1,c);//为防止重叠,更新区间[L,R-1] /*注意begin=0 end=maxn-1 而不是begin=1 end=n 因为只是涂n次,不一定在1-n范围内涂 */ &#125; query(1,0,maxn-1,0,maxn-1); for(int i=0; i&lt;maxn; i++) &#123; while(i!=0&amp;&amp;sum[i]!=-1&amp;&amp;sum[i]==sum[i-1])//涂过同一颜色也加1 i++; res[sum[i]]++; &#125; for(int i=0; i&lt;maxn; i++) if(res[i]) printf("%d %d\n",i,res[i]); printf("\n"); &#125; return 0;&#125; ``` POJ 2528 Mayor's posters 题目链接:&lt;http://poj.org/problem?id=2528&gt; 代码: ```cpp/*解法：离散化，如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的 1 2 3 4 6 7 8 10 — — — — — — — — 1 2 3 4 5 6 7 8离散化 X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。但是只是这样简单的离散化是错误的，如三张海报为：1~10 1~4 6~10离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10第一张海报时：墙的1~4被染为1；第二张海报时：墙的1~2被染为2，3~4仍为1；第三张海报时：墙的3~4被染为3，1~2仍为2。最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3最终，1~2为2，3为1，4~5为3，于是输出正确结果3。*/ #include&lt;cstdio&gt; #include&lt;cstring&gt;#include&lt;algorithm&gt;#define lson (node&lt;&lt;1)#define rson ((node&lt;&lt;1)|1)#define mid ((begin+end)&gt;&gt;1)using namespace std;#define maxn 10005//不用建树,直接在query里记录hash即可，因为染色不用求区间和或者最值，也不用pushUp int m, li[maxn], ri[maxn];int poster[maxn&lt;&lt;3], col[maxn&lt;&lt;4], ans; //col记录当前该位置最上面一层的海报种类,即染色问题的颜色 //poster记录海报位置 bool hash[maxn];//hash用于标记某种种类的海报是否计算过,若已计算过标记为true,不再重复计算 void pushDown(int node) &#123; col[lson] = col[rson] = col[node];//类似lazy标记，向下传递后清空 col[node] = -1;&#125;void update(int node,int begin, int end,int left, int right, int k) &#123; if(left&gt;end||right&lt;begin) return; if (begin &gt;= left &amp;&amp; end &lt;= right) &#123; col[node] = k; return; &#125; if(col[node] != -1) pushDown(node); update(lson,begin,mid,left,right,k); update(rson,mid+1,end,left,right,k);&#125;void query(int node,int begin,int end) &#123; if (begin == end) &#123; if (!hash[col[node]]) &#123; ans++; hash[col[node]] = true; &#125; return; &#125; if (col[node] != -1) pushDown(node); query(lson,begin,mid); query(rson,mid+1,end);&#125;int binarySearch(int ll, int hh, int xx) &#123; int mm; while (ll &lt;= hh) &#123; mm = (ll + hh) &gt;&gt; 1; if (poster[mm] == xx) return mm; else if (poster[mm] &gt; xx) hh = mm - 1; else ll = mm + 1; &#125; return -1;&#125;int main()&#123; int t, n, i; scanf ("%d", &amp;t); while (t--) &#123; memset(col, -1, sizeof (col));//-1表示没有染色 memset (hash, false, sizeof (hash));/*因为本题墙的长度为10000000,直接做会超时,而实际海报数量只有10000,考虑把每张海报左右两端的两段映射到小范围计算，所以考虑离散化,但传统离散化会出错,要如果有两个位置相邻的数字数值不相邻,考虑在中间插入一个比大的数小1的数*/ int cnt = 0; scanf ("%d", &amp;n); for (i = 1; i &lt;= n; i++) &#123; scanf ("%d %d", &amp;li[i], &amp;ri[i]); poster[++cnt] = li[i]; poster[++cnt] = ri[i]; &#125; sort(poster+1, poster+cnt+1); m = 1; for (i = 2; i &lt;= cnt; i++) &#123; if (poster[i] != poster[i-1]) poster[++m] = poster[i];//去重 &#125; for (i = m; i &gt; 1; i--) &#123; if (poster[i] - poster[i-1] &gt; 1) poster[++m] = poster[i] - 1;//在末尾加入要增加的点 &#125; sort(poster+1, poster+m+1);//重新排序 for (i = 1; i &lt;= n; i++) &#123; int l = binarySearch(1, m, li[i]);//在离散化后的poster数组里二分查找每一组的左右端点 int r = binarySearch(1, m, ri[i]); update(1,1,m,l,r,i); &#125; ans = 0; query(1, 1, m); printf("%d\n", ans); &#125; return 0;&#125; 四、矩形面积交/面积并HDU 1542 Atlantis(矩形面积并)题目链接：http://acm.split.hdu.edu.cn/showproblem.php?pid=1542代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include&lt;bits/stdc++.h&gt; #define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)#define maxn 2005using namespace std;int n;double y[maxn];//沿x轴扫描,沿y轴建树,线段树的结点是纵向的线段,最下面一层结点以排序后相邻的y1,y2为边界 struct LINE // 存储线段信息；&#123; double x; // 该线段的x坐标； double y_up,y_down; // 竖向线段的上下端点； int flag;//矩形的左边界为1,右边界为-1 &#125;line[maxn];struct node//线段树的结点,不再是单个点,是一个区间 &#123; double l,r; // 区间的左右边界,即某段扫描线的上下端点 double x; // 记录上一个横坐标位置，用于求面积； int cover; // 记录覆盖的线段数;即同一方向的线段数;由flag累加 bool flag; // 标记只有一个区间的节点,即在线段树最底层的结点,我们将一个个连续的区间离散化成一个结点；&#125;node[maxn&lt;&lt;2];bool cmp(LINE a,LINE b)&#123; return a.x&lt;b.x;&#125;void build(int rt,int l,int r) // 建树；&#123; node[rt].l=y[l]; // 维护区间； node[rt].r=y[r]; node[rt].x=-1; node[rt].flag=false; node[rt].cover=0; if(l+1==r)&#123; // 区间是连续的; node[rt].flag=true; // 标记为结点; return; &#125; build(lson,l,mid); build(rson,mid,r); // 因为将一个个连续区间离散成点，所以此处mid不需要+1；&#125;double Insert_query(int rt,double x,double l,double r,int flag) /*查询+更新x处（l,r）区间面积，l和r代表的是区间查询区间的边界，node[rt].l和node[rt].r代表的是结点边界*/&#123; if(l&gt;=node[rt].r||r&lt;=node[rt].l) return 0; // 该方向结点不包含所要查询的区间； if(node[rt].flag)&#123; // 找到只有一个区间的叶子结点； if(node[rt].cover&gt;0)&#123; double pre=node[rt].x; double ans=(x-pre)*(node[rt].r-node[rt].l); // 计算面积； node[rt].x=x; // 更新定位x位置，便于下次计算面积； node[rt].cover+=flag; // 更新覆盖的线段数； return ans; &#125; else&#123; node[rt].x=x; node[rt].cover+=flag; return 0;//没有产生面积并也要return 0 &#125; &#125; double ans1,ans2; ans1=Insert_query(lson,x,l,r,flag); ans2=Insert_query(rson,x,l,r,flag); return ans1+ans2;&#125;int main()&#123; int Case=0; double x1,x2,y1,y2; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int cnt=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); y[cnt]=y1; line[cnt].x=x1; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=1; // 表示左边线段； y[cnt]=y2; line[cnt].x=x2; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=-1; // 表示右边线段； &#125; sort(y,y+cnt); // 将所有高度由小到大排序，将区间建树表示 sort(line,line+cnt,cmp); // 因为扫描线从左到右扫描，所以按照横坐标从小到大排序后逐一插入线段树 build(1,0,cnt-1); double area=0; for(int i=0;i&lt;cnt;i++)&#123; area+=Insert_query(1,line[i].x,line[i].y_down,line[i].y_up,line[i].flag); &#125; printf("Test case #%d\nTotal explored area: %.2lf\n\n",++Case,area); &#125; return 0;&#125;``` HDU 1255 覆盖的面积(矩形面积交) 题目链接:&lt;http://acm.split.hdu.edu.cn/showproblem.php?pid=1255&gt; 代码: ```cpp#include&lt;bits/stdc++.h&gt;#define lson (rt&lt;&lt;1)#define rson ((rt&lt;&lt;1)|1)#define mid ((l+r)&gt;&gt;1)#define maxn 2005using namespace std;int T,N;double y[maxn];struct LINE&#123; double x; double y_up,y_down; int flag;&#125;line[maxn];struct node&#123; double l,r; double x; int cover; bool flag;&#125;node[maxn&lt;&lt;2];bool cmp(LINE a,LINE b)&#123; return a.x&lt;b.x;&#125;void build(int rt,int l,int r)&#123; node[rt].l=y[l]; node[rt].r=y[r]; node[rt].x=-1; node[rt].flag=false; node[rt].cover=0; if(l+1==r)&#123; node[rt].flag=true; return; &#125; build(lson,l,mid); build(rson,mid,r);&#125;double Insert_query(int rt,double x,double l,double r,int flag)&#123; if(l&gt;=node[rt].r||r&lt;=node[rt].l) return 0; if(node[rt].flag)&#123; if(node[rt].cover&gt;1)&#123; double pre=node[rt].x; double ans=(x-pre)*(node[rt].r-node[rt].l); node[rt].x=x; node[rt].cover+=flag; return ans; &#125; else&#123; node[rt].x=x; node[rt].cover+=flag; return 0; &#125; &#125; double ans1,ans2; ans1=Insert_query(lson,x,l,r,flag); ans2=Insert_query(rson,x,l,r,flag); return ans1+ans2;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; int cnt=0; scanf("%d",&amp;N); while(N--)&#123; double x1,y1,x2,y2; scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2); y[cnt]=y1; line[cnt].x=x1; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=1; y[cnt]=y2; line[cnt].x=x2; line[cnt].y_down=y1; line[cnt].y_up=y2; line[cnt++].flag=-1; &#125; sort(y,y+cnt); sort(line,line+cnt,cmp); build(1,0,cnt-1); double area=0; for(int i=0;i&lt;cnt;i++)&#123; area+=Insert_query(1,line[i].x,line[i].y_down,line[i].y_up,line[i].flag); &#125; printf("%.2lf\n",area); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之抽象类、接口、lambda表达式与内部类]]></title>
    <url>%2F2017%2F10%2F16%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类在继承的层次结构中，每个新子类都使类变得越来越明确具体。如果从一个子类追溯到父类，类就会变得更通用和抽象。类的设计应该确保父类包含它子类的共同特征。如果一个父类设计得非常抽象，以至于它没有任何具体的实例，这样的类称为抽象类，使用abstract关键字修饰。抽象类定义了相公子类的共同行为。 抽象方法如果一个方法非常抽象，只定义了方法，没有提供方法的具体实现，那么我们把它定义为一个抽象方法，它的具体实现由子类提供，即子类覆盖抽象方法提供方法体。抽象方法由abstract关键字修饰，只有方法头，没有花括号和方法体，以分号结尾。比如一个GeometricObject类定义了一个名为getArea的抽象方法，即public abstract double getArea(); 几点说明1.抽象方法应该定义为public，以便子类进行重写。2.抽象类的构造器应该定义为protected，因为抽象类不能通过new直接创建实例，其构造器只被子类调用。创建一个具体子类的实例时，它的父类的构造器被调用以初始化父类中定义的数据域。3.一个包含抽象方法的类必须定义为抽象类，一个不包含抽象方法的类也可以定义为抽象类(如果不想让某类创建实例，可以把它定义为抽象类)4.如果子类继承抽象类时没有覆盖其所有的抽象方法，即子类中仍有抽象方法，子类也应该定义为抽象的5.抽象方法是非静态的6.子类可以覆盖父类的方法并将它定义为abstract,这种情况很少见，但它在当父类方法实现在子类中变得无效时是很有用的，在这种情况下，子类必须定义为abstract7.即使子类的父类是具体的，这个子类也可以是抽象的。例如，Object是具体的，但它的子类GeometricObject是抽象的。8.不能使用new操作符从一个抽象类创建一个实例，但是抽象类可以用作一种数据类型。下面的语句创建一个GeometricObject类型的数组是正确的：GeometricObject[] objects = new GeometricObject[10];然后可以创建一个具体子类的实例并把它的引用赋给数组，如：Objects[0] = new Circle(); 接口接口在很多方面都与抽象类很相似，但它的目的是指明相关或者不相关类的多个对象的共同行为，属性成员都是公共静态常量，成员方法都是公共抽象方法。例如，使用正确的接口，可以指明这些对象是可比较的、可克隆的。为了区分接口和类，Java采用Interface关键字定义接口。在一个java文件内，只能有一个public类或一个public接口，即public类和public接口不能同文件共存。接口没有构造器，没有实例域，也不能使用new操作符创建实例。接口没有构造器的原因有三点：1.构造器用于初始化成员变量，接口没有成员变量，不需要构造器2.类可以实现多个接口，如果多个接口都有构造方法，不好确定构造方法链的调用次序3.作为高度抽象的概念，接口不能实例化对象，也就不需要构造器 像常规类一样，每个接口都被编译为独立的字节码文件，可以作为引用变量的数据类型和类型转换的结果，可以使用instanceof关键字等。类实现接口用implements关键字，一个类可以实现多个接口，用逗号隔开即可。一个接口可以继承多个接口，用extends关键字。在定义接口中的数据域和方法时可以简写，例如：1234public interface T&#123; public static final int K = 1; public abstract void p(); &#125; 可简写成1234public interface T&#123; int K = 1; void p();&#125; 要注意接口中所有的数据域都是public static final，所有的方法都是public abstract，在定义接口中允许省略修饰符，但在子类重写方法时不可缺省public修饰符，否则方法的可见性会缩小为包内可见。 静态方法从Java SE 8开始，允许在接口中增加静态方法，理论上讲是可以的，但这有违于接口作为抽象规范的初衷。 默认方法可以为接口方法提供一个默认实现，用default修饰符标记，这样子类无需重写这个方法也能得到一个接口的默认实现。例如：12345678public interface Collection&#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 这样实现Collection的程序员就不用操心实现isEmpty方法了。默认方法的一个重要用法是“接口演化”。以Collection接口为例，这个接口作为Java的一部分已经很多年了，假设很久以前定义了一个实现Collection接口的类Bag。后来在Collection接口中增加了一个stream方法，假设stream方法不是一个默认方法，那么Bag类将不能编译，因为它没有实现这个新方法。如果不重新编译这个类，而是使用原先包含这个类的JAR文件，这个类仍能正常加载，正常构造实例，但如果在一个Bag实例上调用stream方法，会出现一个AbstractMethodError。但如果把stream方法定义为默认方法就可以解决这个问题，既可以重新编译也可以使用JAR文件加载类并调用stream方法。 解决默认方法的冲突如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生冲突。解决冲突规则如下：1) 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。2) 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法，必须覆盖这个方法来解决冲突，即从中选择一个方法重写。 Comparable接口Comparable接口定义了compareTo方法，用于比较对象。当想使用Arrays类的sort方法对对象数组进行排序时，对象所属的类必须实现了Comparable接口。Comparable接口是一个带泛型的接口，定义为：123public interface Comparable&lt;E&gt;&#123; public int compareTo(E o); &#125; compareTo应该与equals保持一致，即当且仅当o1.equals(o2)为true时，o1.compareTo(o2) == 0成立。以下是compareTo方法的实现： 12345class Employee implements Comparable&lt;Employee&gt;&#123;public int compareTo(Employee other)&#123; return Double.compare(salary,other.salary); &#125;&#125; 在比较浮点数时可以使用Double的静态方法compare,这样就不必担心溢出或精度损失，类似的还有Integer.compare方法等 继承过程中的compareTo，如果由子类决定相等的概念，每个compare方法都应该在开始时检测：if(getClass() != other.getClass()) throw new ClassCastException()：如果父类决定相等的概念，应该在超类中提供一个compareTo方法，并将这个方法声明为final。 Comparator接口 Comparator接口意为”比较器”接口，是一个泛型接口，可用于自定义排序规则和大小比较等。要进行自定义排序，Arrays.sort方法有一个重载版本，需要提供一个数组和一个比较器作为参数，比较器是实现了Comparator接口的类的实例。接口定义为： 1234public interface Comparator&lt;T&gt;&#123; int compare(T first,T second);&#125; 如果要按长度比较字符串，由于String是按字典序比较字符串，肯定不能让String类用两种方法实现compareTo方法 —— 况且String类也不由我们修改。此时可以定义如下实现Comparator的类： 123456789101112class lengthComparator implements Comparator&lt;String&gt;&#123; public int compare(String first,String second)&#123; return first.length() - second.length(); &#125;&#125;``` 因为要调用compare方法，所以具体比较大小和排序时都要创建一个lengthComparator的实例： **大小比较**```javaComparator&lt;String&gt; comp = new LengthComparator();if(comp.compare(words[i],words[j]) &gt; 0) ... 自定义排序 12String[] friends = &#123;"Peter","Paul","Mary"&#125;;Arrays.sort(friends,new LengthComparator()); Cloneable接口 首先，我们考虑为一个包含对象引用的变量建立副本会发生什么，例如： 123Employee original = new Employee("John Public",50000);Employee copy = original;copy.ratseSalary(10); //original的salary也被改变 原变量和副本都会指向同一个对象，这说明，任何一个变量的改变都会影响到另一个变量。如果有一个对象original，希望创建一个对象copy使得其初始状态与original相同，但是之后它们各自回有自己不同的状态，这种情况下就可以使用克隆，例如：123456789Employee copy = original.clone();copy.raiseSalary(10); //original的salary不会被改变``` Object类中的clone方法将原始对象的每个数据域复制给目标对象，如果一个数据域是基本数据类型，复制的就是它的值，如果是引用类型，复制的就是它的引用，这种克隆称为**浅复制**,即original != copy,但original.hireDay == copy.hireDay。这有时是不符合我们要求的，我们不希望在改变某个对象的引用类型的数据域时影响到另一个对象，这时我们需要**深复制**,即如果数据域是引用类型，复制的是对象的内容而不是引用。 无论是**浅复制**还是**深复制**，我们都需要先实现Cloneable接口，否则会产生一个必检异常。Cloneable接口的定义是： ```javapublic interface Cloneable&#123;&#125; 我们发现这个接口是空的，一个带空体的接口称为标记接口。一个标记接口既不包括常量也不包括方法，它用来表示一个类拥有的某些特定的属性，其惟一的作用是允许在类型查询中使用instanceof关键字。但如果一个请求克隆的对象不实现这个接口，会产生CloneNotSupportedException，即使clone的默认(浅拷贝)实现能够满足要求，还是要实现这一接口。在这里，Cloneable接口的出现与接口的正常使用并没有关系。具体来说，它没有指定clone方法，这个方法是从Object类继承的，这个接口只是作为一个标记。 Object类中提供的原始clone方法的方法头是protected native Object clone() throws CloneNotSupportedException,关键字native表明这个方法不是用Java写的，但它是JVM针对自身平台实现的。关键字protected限定方法只能在同一个包内或在其子类中访问。由于这个原因：必须在要实现克隆的子类中覆盖这个方法并把可见性修饰父改为public。下面给出一个浅复制的例子：12345678class Employee implements Cloneable&#123; public Employee clone() throws CloneNotSupportedException &#123; return (Employee) super.clone(); &#125; . . .&#125; 下面给出一个深复制的例子： 12345678910class Employee implements Cloneable&#123; public Employee clone() throws CloneNotSupportedException &#123; . . . Employee cloned = (Employee) super.clone; cloned.hireDay = (Date)hireDay.clone(); return cloned; &#125;&#125; 我们注意到Object类的clone方法的返回值类型是Object，而Employee类的clone方法返回值类型是Employee，这叫做协变返回类型，即子类在重写父类方法时可以返回父类返回值类型的子类型。clone方法声明异常也可以改成捕获异常，如：123456789public Employee clone()&#123; try &#123; Employee cloned = (Employee) super.clone(); . . . &#125; catch(CloneNotSupportedException e)&#123; return null;&#125; &#125; 复制数组的三种方法1.申请一个新数组，遍历原数组逐一复制元素2.使用System类的静态方法arraycopy3.使用数组对象.clone返回一个数组克隆的引用 接口和抽象类区别：1.接口所有的变量必须是public static final;抽象类的变量无限制2.接口没有构造方法，不能用new操作符实例化;抽象类有构造方法，由子类通过构造方法链调用，不能用new操作符实例化3.接口所有方法必须是公共抽象实例方法(Java SE 8开始允许定义静态方法)，抽象类无限制4.一个类只可以继承一个父类，但可以实现多个接口5.所有的类有一个共同的根Object类，接口没有共同的根6.抽象类和子类的关系应该是强的“是一种”关系(strong is-a relationship),而接口和子类的关系是弱的”是一种”关系(weak is-a relationship)。接口比抽象类更灵活，因为实现接口的子类只需要具有统一的行为即可，不需要都属于同一个类型的类。 接口与回调 回调是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下按钮或选择某个菜单项时应该采取什么行动。 内部类 内部类，或者称为嵌套类，是一个定义在另一个类范围中的类。一个内部类可以如常规类一样使用。通常，在一个类只被它的外部类所使用的时候，才将它定义为内部类，内部类机制主要用于设计具有互相协作关系的类集合。比如： 12345678910111213141516//OuterClass.java: inner class demopublic class OuterClass &#123; private int data; /** A method in the outer class */ public void m()&#123; //Do something &#125; // An inner class class InnerClass &#123; /** A method in the inner class */ public void mi()&#123; data++; m(); &#125; &#125; &#125; 为什么要使用内部类，主要原因有三： 1.内部类可以访问包含它的外部类的所有数据域(包括私有数据域)和方法，没有必要将外部类对象的引用传递给内部类的构造方法,内部类有一个指向外部类对象的隐式引用，如果显式写出，外部类的引用是OuterClass.this 2.内部类可以对同一个包中的其他类隐藏起来 3.当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷 内部类具有一下特征： 1) 一个内部类被编译成一个名为OuterClassName$InnerClassName的类。例如，一个定义在Test类中的内部类A被编译成Test$A.class 2) 一个内部类可以使用可见性修饰符(public、private、protected、default)所定义，和应用于一个类中成员的可见性规则一样 3) 一个内部类可以被定义为static，一个static的内部类可以使用外部类的名字访问,一个static内部类不能访问外部类中的非静态成员 4) 内部类对象通常在外部类中创建，但是你也可以从另外一个类中来创建一个内部类的对象。如果内部类是非静态的，你必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类对象：OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 如果内部类是静态的，使用下面语法来创建一个内部类对象:OuterClass.InnerClass innerObject = new OuterClass.InnerClass(); 5) 内部类所有的静态域必须是final,不能有static方法 一个简单的内部类的用途是将相互依赖的类结合到一个主类中，这样做减少了源文件的数量(因为非内部类如果用public修饰必须放在不同的源文件中，而内部类可放在同一源文件中)，这样也使得类文件容易组织，因为它们都将主类名作为前缀。另外一个内部类的实际用途是避免类名冲突。 内部类对于定义处理器类非常有用，一个处理器类被设计为针对一个GUI组件创建一个处理器对象(比如，一个按钮)。处理器类不会被其他应用所共享，所以将它定义在主类里面作为一个内部类使用是恰如其分的。 下面给出一个使用内部类进行简单事件处理的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.HBox;import javafx.stage.Stage;public class HandleEvent extends Application &#123; @Override public void start(Stage primaryStage) throws Exception &#123; HBox pane = new HBox(10); pane.setAlignment(Pos.CENTER); Button btOK = new Button("OK"); OKHandlerClass handler1 = new OKHandlerClass(); btOK.setOnAction(handler1); Button btCancel = new Button("Cancel"); CancelHandlerClass handler2 = new CancelHandlerClass(); btCancel.setOnAction(handler2); pane.getChildren().addAll(btOK,btCancel); Scene scene = new Scene(pane,100,50); primaryStage.setTitle("HandleEvent"); primaryStage.setScene(scene); primaryStage.show(); &#125; class OKHandlerClass implements EventHandler&lt;ActionEvent&gt;&#123; @Override public void handle(ActionEvent e) &#123; System.out.println("OK button clicked"); &#125; &#125; class CancelHandlerClass implements EventHandler&lt;ActionEvent&gt;&#123; @Override public void handle(ActionEvent e) &#123; System.out.println("Cancel button clicked"); &#125; &#125; public static void main(String[] args) &#123; Application.launch(args); &#125;&#125; 局部内部类 可以把内部类定义在一个方法中，称为局部内部类。局部类不能用public或private访问修饰符进行声明。它的作用域被限定在声明这个局部类的块中。局部类有一个优势，即对外部世界完全隐藏起来。即使外部类中的其他代码也不能访问它。除了其所在的方法之外，没有任何方法知道该局部类的存在。 匿名内部类静态内部类lambda表达式从常规内部类——匿名内部类——lambda表达式看演化代理]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之反射]]></title>
    <url>%2F2017%2F10%2F14%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射库提供了一个非常丰富且精心设计的工具集，以便能够动态编写能够操纵Java代码的程序。这项功能被大量应用于JavaBeans中，它是Java组件的体系结构。 1.什么是反射？ 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。 要想理解反射的原理，首先要了解什么是类型信息。Java让我们识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。 2.反射的作用 1.在运行时分析类的能力，即查看类的方法、属性、父类、接口等类的内部信息的机制 2.在运行时分析对象的数据域 3.实现通用的数组操作代码 4.利用Method对象，这个对象很像C++中的函数指针 3.Class类 我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到JVM中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是java.lang.Class&lt;T&gt;泛型类的一个实例，比如Class&lt;MyClass&gt;对象即为一个封装了MyClass类的定义信息的Class&lt;T&gt;实例，从中我们可以得出结论：万物皆对象，任何类型(包括基本类型和引用类型).class都是java.lang.Class&lt;T&gt;的实例，简言之，class对象是Class泛型类的实例，它代表了一个类型。由于java.lang.Class&lt;T&gt;类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。 在下面的讲解中，我们将以People类和Student类为例：1234567891011121314151617181920212223242526272829public class People &#123; private String name; private int age; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void speak() &#123; System.out.println(getName() + " " + getAge()); &#125;&#125; 123456789101112131415161718192021222324public class Student extends People &#123; private int grade; public Student(String name, int age) &#123; super(name, age); &#125; public Student(String name, int age, int grade) &#123; super(name, age); this.grade = grade; &#125; public int getGrade() &#123; return grade; &#125; public void setGrade(int grade) &#123; this.grade = grade; &#125; private void learn(String course) &#123; System.out.println(name + " learn " + course); &#125; &#125; 获取class对象有以下三种: 1) 可以通过类名.class得到相应类的Class对象，如: 1Class&lt;People&gt; peopleClass = People.class; 2) 如果已知类的全限定名称(包含包名)，可以通过Class的forName静态方法得到类的Class对象，如： 12Class&lt;People&gt; peopleClass = Class.forName("cn.habitdiary.People");//假设People类在cn.habitdiary包中 在使用forName时必须要保证传入的字符串是一个类名或接口名，否则会抛出一个ClassNotFoundException,这是一个必检异常，所以我们在使用该方法时必须提供一个异常处理器,例如: 1234567try&#123; String name = "xxx"; Class c1 = Class.forName(name); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; 3) 可以通过类的实例对象.getClass()得到相应类的Class对象，如: 12People people = new People("Steven"， 20);Class&lt;People&gt; peopleClass = people.getClass(); 实例对象.getClass().getName() 可以获取当前对象的类的全限定名称(包含包名) 实例对象.getClass().getSimpleName()可以获取当前对象的类的底层类简称(不含包名) 实例对象.getClass().getCanonicalName()大部分情况和getName()相同，但在表示数组或内部类时有所区别，比如对于String数组，getName返回的是[Ljava.lang.String之类的表现形式，而getCanonicalName返回的就是跟我们声明类似的形式。 但在类加载的时候需要的是getName得到的那样的名字，而在根据类名字创建文件的时候最好使用getCanonicalName() 注意： 1.一个Class对象实际上表现的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class对象 2.Class类是一个泛型类，但有时候我们不能提前确定class对象的类型,就可以用Class&lt;?&gt;来代替，即上面代码中的Class&lt;People&gt; peopleClass可以写成Class&lt;?&gt; peopleClass 3.虚拟机为每个类型管理一个Class对象，可以用 == 运算符实现两个类对象比较的操作 4.newInstance()方法可以返回一个Class对象对应类的新实例(返回值类型是Object)，比如: 12String s = "java.util.Random";Object m = Class.forName(s).newInstance(); 如果希望给构造器提供参数，就不能使用这种写法，而必须使用Constructor类中的newInstance方法。 4.在运行时分析类的能力 下面简要介绍一下反射机制最重要的内容 —— 检查类的结构。Java中为了支持反射机制主要提供了以下的类：java.lang.Classjava.lang.reflect.Fieldjava.lang.reflect.Constructorjava.lang.reflect.Methodjava.lang.reflect.Modifier java.lang.Class类的常用API如下： Field[] getFields() Field[] getDeclaredFields() Method[] getMethods() Method[] getDeclaredMethods() Constructor&lt; ? &gt;[] getConstructors() Constructor&lt; ? &gt;[] getDeclaredConstructors() Class&lt; ? &gt; getSupperClass() Class&lt; ? &gt;[] getInterfaces() 提示：getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员;而getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有、受保护和默认成员，但不包括超类的成员。getSupperClass()返回class对象对应类的超类的class对象，没有显式继承的类的超类是Object。getInterfaces返回class对象对应类的所有接口的class对象 其中java.lang.reflect包中的三个类Field、Constructor和Method分别用于描述类的域、构造器、方法。这三个类的常用API如下： String getName() 返回一个用于描述域名、构造器或方法的字符串 Class&lt; ? &gt; getDeclaringClass() 返回一个用于描述类中定义的域、构造器或方法的Class对象 Class&lt; ? &gt;[] getExceptionTypes() (在Constuctor和Method类中)返回一个用于描述方法抛出异常类型的Class对象数组 int getModifiers() 返回一个描述域、构造器或方法的修饰符的整型数值。使用Modifier的toString静态方法可以分析这个返回值 Class&lt; ? &gt;[] getParameterTypes() (在Constructor和Method类中) 返回一个用于描述参数类型的Class对象数组 Class&lt; ? &gt; getReturnType() (在Method类中) 返回一个用于描述返回类型的Class对象 java.lang.reflect.Modifier类的常用API如下 static String toString(int modifiers)返回修饰符对应的字符串描述 static boolean isAbstract(int modifiers) static boolean isFinal(int modifiers) static boolean isInterface(int modifiers) static boolean isNative(int modifiers) static boolean isPrivate(int modifiers) static boolean isProtected(int modifiers) static boolean isPublic(int modifiers) static boolean isStatic(int modifiers) static boolean isStrict(int modifiers) static boolean isSynchronized(int modifiers) static boolean isVolatile(int modifiers)上述方法检测修饰符是否是某一特定修饰符java.lang.reflect.Modifier类一般和Field、Constructor、Method类的getModifiers()方法配套使用，用于解析该方法返回的整型数值的含义 下面是一个检测类内部结构的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.lang.reflect.*;import java.lang.Class;import java.util.Scanner;public class ReflectionTest &#123; public static void main(String[] args) &#123; String name; if(args.length &gt; 0) name = args[0]; else &#123; Scanner in = new Scanner(System.in); System.out.println("Enter class name (e.g. java.util.Date)"); name = in.next(); &#125; try &#123; Class&lt;?&gt; c1 = Class.forName(name); Class&lt;?&gt; superc1 = c1.getSuperclass(); String modifiers = Modifier.toString(c1.getModifiers()); if (modifiers.length() &gt; 0) System.out.print(modifiers + " " ); System.out.print("class " + name); if(superc1 != null &amp;&amp; superc1 != Object.class) System.out.print(" extends " + superc1.getSimpleName()); System.out.print("\n&#123;\n"); printFields(c1); System.out.println(); printConstructors(c1); System.out.println(); printMethods(c1); System.out.println("&#125;"); &#125; catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class&lt;?&gt; c1) &#123; Constructor&lt;?&gt;[] constructors = c1.getDeclaredConstructors(); for(Constructor&lt;?&gt; c : constructors) &#123; String name = c.getName(); System.out.print(" "); String modifiers = Modifier.toString(c.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(name + "("); Class&lt;?&gt;[] paramTypes = c.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class&lt;?&gt; c1) &#123; Method[] methods = c1.getDeclaredMethods(); for(Method m :methods) &#123; Class&lt;?&gt; retType = m.getReturnType(); String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.print(retType.getSimpleName() + " " + name + "("); Class&lt;?&gt;[] paramTypes = m.getParameterTypes(); for(int j = 0;j &lt; paramTypes.length;j++) &#123; if(j &gt; 0) System.out.print(", "); System.out.print(paramTypes[j].getSimpleName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class&lt;?&gt; c1) &#123; Field[] Fields = c1.getDeclaredFields(); for(Field f : Fields) &#123; Class&lt;?&gt; type = f.getType(); String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if(modifiers.length() &gt; 0) System.out.print(modifiers + " "); System.out.println(type.getSimpleName() + " " + name + ";"); &#125; &#125;&#125; 5.在运行时使用反射分析对象 反射不仅可以查看类的域、构造器、方法等，还可以进一步查看某个对象指定数据域的值。 查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象(例如，通过getDeclaredFields得到的对象)，obj是某个包含f域的类的对象，f.get(obj)将返回一个Object对象，其值为obj域的当前值。比如： 12345Employee harry = new Empolyee("Harry Hacker",35000,10,1,1989);Class&lt;Employee&gt; c1 = harry.getClass();Field f = c1.getDeclaredField("name"); //返回某一个特定域f.setAccessible(true); //由于name是私有域，必须先设置为可访问Object v = f.get(harry); 上述的String可以作为Object返回，但如果某个域是基本数据类型，比如double，可以使用Field类的getDouble方法返回double类型数值，也可以使用get方法，反射机制会将其自动装箱成Double类型对象。f.set(obj,value) 可以把obj对象的f域设置为value 下面是一些相关API在java.lang.reflect.Field中： Object get(Object obj)返回obj对象中用Field对象表示的域值 xxx getXxx(Object obj)返回obj对象的基本类型的域的值 void set(Object obj,Object newValue)用一个新值设置obj对象中Field对象表示的域 在java.lang.Class中： Field getField(String name)返回指定名称的公有域 Field getDeclaredField(String name) 返回指定名称的声明的域 在java.lang.reflect.AccessibleObject中： void setAccessible(boolean flag)为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置 boolean isAccessible()返回反射对象的可访问标志的值 static void setAccessible(AccessibleObject[] array,boolean flag)批量设置AccessibleObject(是Field、Constructor、Method的公共超类)数组的所有元素的可访问标志 6.使用反射编写泛型数组代码 java.lang.reflect包中的Array类允许动态地创建数组。例如，在Arrays类中有copyOf方法，可以扩展已经填满的数组。12Employee[] a = new Employee[100];a = Arrays.copyOf(a,2 * a.length); 我们想要编写一个适用于所有数组类型的copyOf方法，下面是第一次尝试:12345public static Object[] badCopyOf(Object[] a,int newLength)&#123; Object[] newArray = new Object[newLength]; System.arraycopy(a,0,newArray,0,Math.min(a.length,newLength); return newArray;&#125; 上述代码存在一个错误，即使用了new Object[newLength]创建数组，这样会在运行时抛出ClassCastException,将一个Employee[]临时转换成Object[]，再把它转回来是可以的，但从一开始就是Object[]的数组永远不能转换成Employee[]数组。为了解决这个问题，下面提供java.lang.reflect.Array中的API static Object get(Object array,int index)返回对象数组某个位置上的元素 static xxx getXxx(Object array,int index)(xxx是基本数据类型)返回基本类型数组某个位置上的值 static void set(Object array,int index,Object newValue)设置对象数组某个位置上的元素 static void setXxx(Object array,int index,xxx newValue)(xxx是基本数据类型)设置基本类型数组某个位置上的值 static int getLength(Object array)返回数组的长度 static Object newInstance(Class componentType,int length) static Object newInstance(Class componentType,int[] length)返回一个具有给定类型、给定维数的新数组 下面给出正确的代码实现： 1234567891011public static Object goodCopyOf(Object a,int newLength)&#123;&#123; Class c1 = a.getClass();//获取a数组的类对象 if(!c1.isArray()) return null;//确认是一个数组 Class componentType = c1.getComponentType(); //获取数组类型 int length = Array.getLength(a); Object newArray = Array.newInstance(componentType,newLength); System.arraycopy(a,0,newArray,0,Math.min(length,newLength)); return newArray; &#125; 这个CopyOf方法可以扩展任意类型的数组，不仅仅是对象数组使用示例: 12int[] a = &#123;1,2,3,4,5&#125;;a = (int[]) goodCopyOf(a,10); 为了实现上述操作，应该将goodCopyOf的参数声明为Object类型，而不要声明为Object[],因为整数数组类型可以被转换为Object，但不能转换成Object[]类型 7.调用任意方法 通过反射还可以调用任意方法，这是通过Method类的invoke方法实现的，方法签名是:Object invoke(Object obj,Object... args),Object obj表示调用方法的对象，Object…args表示方法的参数列表。如果方法是静态方法，将第一个参数设置为null;如果方法是非静态无参方法，第二个参数列表可以忽略。 例如：String n = (String)m1.invoke(harry);(m1表示Employee类的getName方法)。如果返回值是基本类型，invoke方法会返回其包装器类型,可以利用自动开箱将其还原为基本数据类型。例如:double s = (Double)m2.invoke(harry);(m2表示Employee类的getSalary方法)getMethods方法和getDeclaredMethods会返回一个Method对象列表，如果要得到特定的Method对象，可以调用Class类的getMethod方法，其签名是Method getMethod(String Methodname,Class…parameterTypes)。例如： 12Method m1 = Employee.class.getMethod("getName"); Method m2 = Employee.class.getMethod("raiseSalary",double.class); 下面给出一个调用任意方法打印函数表的程序(以自定义的square和Math.sqrt方法为例)： 12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.*;public class MethodTableTest&#123; public static void main(String[] args) &#123;Method square = MethodTableTest.class.getMethod("square",double.class); Method sqrt = Math.class.getMethod("sqrt",double.class); printTable(1,10,10,square); printTable(1,10,10,sqrt); &#125; public static double square(double x) &#123; return x * x; &#125; public static void printTable(double from,double to,int n,Method f) &#123; System.out.println(f); double dx = (to - from) / (n - 1); for(double x = from;x &lt;= to;x += dx) &#123; try &#123; double y = (Double)f.invoke(null,x); System.out.printf("%10.4f | %10/4f\n",x,y); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; invoke方法如果提供了错误的参数，会抛出一个异常，所以要提供一个异常处理器 建议在有必要的时候才使用invoke方法，有如下原因: 1.invoke方法的参数和返回值必须是Object类型，意味着必须进行多次类型转换，这样会使编译器错过检查代码的机会，等到测试阶段才发现错误，找到并改正会更加困难 2.通过反射调用方法比直接调用方法要明显慢一些 特别重申：建议Java开发者不要使用Method对象的回调功能，使用接口进行回调会使代码的执行速度更快，更易于维护。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之继承和多态]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[父类与子类在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。 继承面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。 继承有如下几个关键点1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们3.不是所有的“是一种”(is-a)关系都该用继承来建模4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承5.Java中类与类的继承是单一继承 super关键字super关键字有两种作用：1.调用父类的构造方法因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。形式是super()或super(arguments)，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条super()有些人认为super与this引用在此处是类似的概念，实际上不太恰当，super不是一个对象的引用，也不能赋给另一个引用变量，他只是一个指示编译器调用超类方法的特殊关键字。 2.调用父类的方法在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用super.方法名来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，super.super.方法名是不合法的。 构造方法链在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码： public class Faculty extends Employee{ public static void main(String[] args){ new Faculty(); } public Faculty(){ System.out.println("(4) Performs Faculty's tasks"); } } class Employee extends Person{ public Employee(){ this("(2) Invoke Employee's overloaded constructor"); System.out.println("(3) Perfoms Employee's tasks"); } public Employee(String s){ System.out.println(s); } } class Person{ public Person() { System.out.println("(1) Performs Person's tasks"); } } 打印结果为:(1) Performs Person’s tasks(2) Invoke Employee’s overloaded constructor(3) Performs Employee’s tasks(4) Performs Faculty’s tasks 我们可以知道：子类的构造方法的第一条语句要么是super语句(包括编译器隐式插入的),要么是this语句，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类 注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。 方法重载与重写重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同) 重写方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。为了避免错误，可以使用重写标注，在要重写的方法前加上@Override，该标注会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。 关于重写的几点注意1.仅当实例方法时刻访问的，它才能被覆盖2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法 方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。 多态Java允许把子类对象的引用赋给父类引用变量，即父类型变量可以引用子类型的对象。从物理层面理解，继承自父类的子类的内存先存储父类数据域再存储子类的新增数据域，所以子类对象既可以看成子类对象本身(看整段内存)也可以看成父类对象(看内存的前一部分)。注意：子类引用赋给父类变量之后，只能访问父类属性和方法或在子类中重写过的父类方法，不能访问子类的特有属性和方法，除非进行向下转型。 动态绑定多态机制的底层实现技术是动态绑定，动态绑定是指JVM在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。 对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。 静态绑定(前期绑定)：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。例如：C 。针对java简单的可以理解为程序编译期的绑定；这里特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。 动态绑定(后期绑定)：在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。 简言之，一个方法可能在沿着继承链的多个类中实现，JVM在运行时动态绑定方法的实现。 理解方法调用假设下面要调用x.f(args)，方法调用的过程为：1） 编译器查看对象的声明类型和方法名，可能存在多个名字为f的方法，比如f(int)和f(String)。编译器会一一列举类中所有名为f的方法和其超类中可访问的名为f的方法，至此编译器已获取所有可能被调用的候选方法。2） 编译器将查看调用方法时提供的参数类型，如果所有f方法中存在一个与提供的参数类型完全匹配的方法，就选择这个方法，这个过程称为重载解析，如果没有完全匹配参数的方法，允许自动向上类型转换进行匹配，仍然没有合适的方法会报告编译错误。至此，编译器已获得需要调用的方法名字和参数类型。3） 如果是private方法、static方法、final方法或者构造器，编译器可以准确知道应该调用那个方法(即静态绑定),因为private方法、构造器不能被继承，更谈不上重写，而static方法和final方法虽然能被继承，但不能被重写。4) 当程序运行，并且采用动态绑定调用方法时，JVM一定调用与x所引用对象的实际类型最合适的类的方法，即在沿着继承链从最特殊的子类开始向更通用的父类查找目标方法，直到找到对该方法的实现就停止，调用该方法。 每次调用方法都要进行搜索，时间开销很大。因此，JVM预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样调用方法时JVM只要提取对象实际类型的方法表，搜索定义该方法签名的类，再调用该方法就可以了。方法表示例(Manager继承自Employee)： Employee:getName() -&gt; Employee.getName()getSalary() -&gt; Employee.getSalary()getHireDay() -&gt; Employee.getHireDay()raiseSalary(double) -&gt; Employee.raiseSalary(double) Manager:getName() -&gt; Employee.getName()//继承的方法getSalary() -&gt; Manager.getSalary()//重写的方法getHireDay() -&gt; Employee.getHireDay()//继承的方法raiseSalary(double) -&gt; Employee.raiseSalary(double)//继承的方法setBonus(double) -&gt; Manager.setBonus(double)//新增的方法 内联优化带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联优化所有的final方法，内联对于提升Java运行效率作用重大，此举能够使性能平均提高50%。如果确定一个类不会被派生或一个方法不会被重写，建议使用final关键字修饰。 对象类型转换和基本数据类型一样，对象可以自动进行向上转型(即多态)，比如Apple类继承自Fruit类，把Apple对象的引用赋给Fruit变量一定是合法的。但如果向下转型(目的是访问子类特有数据域和调用子类特有方法)，要进行强制类型转换，格式为：(子类名)对象名。此时要保证该对象的实际类型确实是要强制转换的子类型，比如fruit是一个引用了Apple对象的Fruit类型的变量，如果向下转型成Banana类是非法的，会抛出一个ClassCastException,而转成Apple类是合法的。我们可以通过instanceof运算符来检测一个对象是否是某个类或接口的实例，其返回值是boolean类型的。注意:1.对象成员访问运算符(.)优先于类型转换运算符。使用圆括号保证在点运算符(.)之前进行转换，例如：((Circle)object).getArea();2.转换基本类型值返回一个新的值，但转换一个对象引用不会创建一个新的对象。 Object类Object类是Java中所有类的祖先(Java的类层次是一个单根结构)，但不用显式写出public class xxx extends Object,在Java中只有基本数据类型不是对象，所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。下面介绍Object类中的几个重要方法及重写规范： 1) equals方法Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同引用，它们一定是相等的。 equals方法的原型是public boolean equals(Object obj),默认实现是: public boolean equals(Object obj){ return (this == obj); } 调用它的语法是object1.equals(object2)，作用和直接使用==判等相同, 但这在大多数情况下没什么意义，我们一般通过判断对象的某些数据域是否相等来判断对象是否相等，此时我们需要重写equals方法。比如类Employee定义了数据域：private String name,private double salary,private LocalDate hireDayequals方法重写如下： public boolean equals(Object obj){ if(this == obj) return true; //快速检测引用是否相等，相等返回ture if(obj == null) return false; //检测引用是否为空，为空返回false if(getClass() != obj.getClass()) return false; //检测是否属于同一个类，不是返回false Empolyee other = (Employee) obj;//向下转型 return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); //逐一比较数据域,有一个不等返回就false，否则返回true 进一步改进：改进一上述的第4步检测，可以改为 return Objects.equals(name,other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay,other.hireDay); 其中Objects.equals方法可以防备name 或 hireDay 可能为null的情况，如果两个参数都为null，Objects(a,b)返回true;如果其中一个为null，返回false;如果两个参数都不为null,调用a.equals(b)。Objects类在java.util包中。 在子类中定义equals方法时，首先调用超类的equals，如果检测失败，对象就不可能相等。如果超类中的域相等，只需要比较子类中新增的数据域就可以。比如Manager类继承自Employee，在父类的基础上增加了private double bonus： public boolean equals(Object obj){ if(!super.equals(obj)) return false; Manager other = (Manager) obj; return bonus == other.bonus; } 改进二上述代码的第3步使用了getClass检测，这适用于子类拥有自己相等概念的情况，比如雇员和经理，只要对应的姓名、薪水和雇佣日期相等，而奖金不相等，就认为是不同的，可以使用getCalss检测。但是如果超类决定相等的概念，就可以使用instanceof进行检测，比如雇员的ID作为相等的概念，就可以用xxx instanceof Employee进行检测，并将Empolyee.equals声明为final。 equals方法要满足下面的特性 自反性: 对于任何非空引用，x.equals(x)应该返回true 对称性：对于任何引用x和y, x.equals(y)的结果应该和y.equals(x)的结果相同 传递性：对于任何引用x、y和z,如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true 一致性: 如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果 对于任何非空引用x,x.equals(null)应该返回false 下面我们给出编写一个完美的equals方法的建议：1) 先快速检测引用是否相等，如果相等两个对象一定相等，不用继续检测2) 检测引用是否为空，如果为空，不必再检测，直接返回不等3) 如果equals语义在每个子类中有所改变(子类决定相等的概念)，用getClass检测:if(getClass() != obj.getClass()) return false;如果所有子类都拥有统一的语义(父类决定相等)，就使用instanceof检测：if(!(obj instanceof ClassName) return false)4) 将obj向下转型为相应类的类型变量5) 逐一比较数据域，注意基本数据类型用 == 检测，引用类型用equals方法检测数组对象用静态的Arrays.equals方法判等 2) hashCode方法散列码(hash code)是由对象导出的一个整型值。散列码是没有规律的，如果x和y是两个不同的对象,x.hashCode()与y.hashCode()基本上不会相同。String类使用下列算法计算散列码： int hash = 0; for(int i = 0;i &lt; length();i++){ hash = 31 * hash + charAt(i); } 由于hashCode方法定义在Object类中，方法原型是public int hashCode(),因此每个对象都有一个默认的散列码，其值为对象的存储地址。内容相同的字符串的散列码相同，因为字符串的散列码是由内容导出的，而内容相同的StringBuilder对象的散列码不同，因为StringBuilder类中没有重写hashCode方法，它的散列码是Object类定义的默认hashCode方法导出的对象存储地址。如果重写了equals方法，就必须重写hashCode方法，以便用户可以将对象插入到散列表中。hashCode方法应该返回一个整型数值(可以是负数),并合理地组合实例域的散列码，以便能让各个不同的对象产生的散列码更均匀。例如，下面是Employee类的hashCode方法 public int hashCode(){ return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode(); 进一步改进 public int hashCode(){ return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay); 从上面的代码我们可以发现，在重写hashCode方法时，我们要充分组合类的实例域，其中引用类型用Objects.hashCode()，基本类型用相应包装类的hashCode()其中Objects.hashCode()是null安全的，如果参数为null，返回值是0,否则返回调用参数调用hashCode的结果。另外，使用静态方法Double.hashCode来避免创建Double对象 还有更简单的做法 public int hashCode(){ return Objects.hash(name,salary,hireDay); } Equals和hashCode的定义必须一致,如果X.equals(y)返回true,那么x.hashCode()就应该等于y.hashCode(),用于组合散列的实例域equals中用于比较的实例域，比如equals比较的是雇员的ID，就需要散列ID 3) toString方法方法原型是public String toString(),用于返回一个描述当前对象的字符串，Object类提供的默认实现是返回一个形式为：类名@对象十六进制内存地址的字符串，我们需要重写toString方法来返回更清晰的描述。数组对象则返回一个类似[I@1a46e30的字符串(前缀[I表明是一个整型数组,@后面是数组对象的十六进制内存地址)，修正方法是调用Arrays.toString方法，如果是多维数组需要调用Arrays.deepToString方法。toString不仅可以显式调用，也会在需要一个描述对象的字符串时隐式调用，比如用System.out.println语句打印一个对象，相当于打印对象的toString方法返回的字符串;又比如通过操作符”+”连接字符串时连接一个对象会调用它的toString方法。当重写toString时，如果返回的字符串涉及到类名,不要硬加入类名，可以通过getClass().getName()获得类名字符串，这样子类如果要调用父类的toString只用super.toString()就可以得到带有父类名的完整字符串描述。 泛型数组列表在许多程序设计语言中，特别是在C++中，必须在编译时就确定整个数组的大小。而在Java中，允许在运行时确定数组大小。比如： int actualSize = . . .; Employee[] staff = new Employee[actualSize]; 但这还是没有完全解决运行时动态更改数组的问题，于是我们引入了一个ArrayList类(在Java.util包中)，它使用起来有点像数组，但在添加或删除元素时具有自动调节数组容量的功能。ArrayList是一个采用类型参数的泛型类,声明方式为ArrayList&lt;E&gt; arrayList = new ArrayList&lt;E&gt;(),从Java SE 7开始，可以省去右边的类型参数，即ArrayList&lt;E&gt; arrayList = new ArrayList&lt;&gt;()在Java SE 5以前的版本没有提供泛型类，只有一个ArrayList类，保存Object类型的元素，等价于ArrayList&lt;Object&gt;,可放入任何类型的对象。其提供的get方法只能返回Object对象，需要进行强制类型转换;且add方法和set方法不检查参数类型，具有一定的危险性。ArrayList管理这对象引用的一个内部数组，如果数组满了，ArrayList会自动创建一个更大的数组，并将所有的对象从较小的数组拷贝到较大的数组中。 ArrayList类的常用API ArrayList&lt;E&gt;() 构造一个初始容量为10的空列表 ArrayList&lt;E&gt;(int initialCapacity)构造一个具有指定初始容量的空列表 boolean add(E e) 将指定的元素添加到此列表的尾部，永远返回true void add(int index, E element) 将指定的元素插入此列表中的指定位置。 int size() 返回此列表中的元素数。 void ensureCapacity(int minCapacity) 如果可以预先确定要插入的元素个数，使用此方法一次性扩容到位，否则通过add方法需要多次拷贝扩容，大大降低效率。 E get(int index) 返回此列表中指定位置上的元素。 E remove(int index) 移除此列表中指定位置上的元素并返回该元素。 boolean remove(Object o) 移除此列表中首次出现的指定元素（如果存在）。 void set(int index, E element) 用指定的元素替代此列表中指定位置上的元素。 boolean isEmpty() 如果此列表中没有元素，则返回 true boolean contains(Object o) 如果此列表中包含指定的元素，则返回 true。 void clear() 移除此列表中的所有元素。 Object clone() 返回此 ArrayList 实例的浅表副本。 trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。 对于数组列表有用的方法1.数组和ArrayList互相转换 数组转ArrayList: String[] array = {"red","green","blue"}; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(array)); ArrayList转数组: String[] array = new String[list.size()]; list.toArray(array); 2.Collections类Collections类中有很多适用于ArrayList的静态方法，比如max和min方法返回列表中的最大和最小元素，sort方法对列表排序，shuffle方法随机打乱列表元素。 ArrayList的元素只能是非基本数据类型的，所以如果要容纳基本类型的元素，我们需使用相应的包装类，且此时ArrayList的使用支持自动装箱和自动开箱。 final关键字总结final关键字在不同语句中有不同的作用：1) 修饰类变量或成员变量 如果是基本数据类型，表示该变量的值不可改变;如果是引用类型，表示该变量不能再指向其它对象，即引用值不可变。final还可以修饰方法的局部变量，即常量2) 修饰方法 表示该方法不能被重写3) 修饰类 表示该类不能被扩展 继承的设计技巧1.将公共操作和域放在超类2.不要使用受保护的域protected机制并不能够带来更好的保护，其原因主要有两点:第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected的域，从而破坏了封装性。第二，同一个包中的所有类都可以访问protected的域，而不管它是否为这个类的子类。不过，protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用，比如Object提供的clone方法就是protected的 3.使用继承实现 “is-a” 关系4.除非所有继承的方法都有意义，否则不要使用继承比如在使用ArrayList类设计一个Stack类时，不应该使用继承，因为栈只能在栈顶操作元素，而ArrayList中的方法可以在任意位置插入、删除和访问任意位置的元素，这显然不合适。此时应该使用组合代替继承。 5.在覆盖方法时，不要改变预期的行为6.使用多态，而非类型信息即尽量面向父类泛化编程，把不同子类的类似行为的方法定义在父类里，并在子类里覆盖该行为 7.不要过多地使用反射反射机制使得人们可以通过在运行时查看域和方法，让人们编写出更具有通用性的程序。这种功能对于编写系统程序极为实用，但不适于编写应用程序。反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之对象与类]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[面向对象程序设计概述 面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。 传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。 对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。 类和对象 类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。 对象：由类构造的实例，一个类可以构造多个实例。 设计类的简单规则 先从设计类的数据域开始，再向类里添加方法。 类之间的关系1.依赖(use-a) 如果A类的方法操纵B类的对象，我们说A类依赖于B类。应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。2.聚合(has-a) 如果A类对象包含B类对象，我们说A类和B类聚合。3.继承(is-a) 如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 对象与对象变量 对象是调用构造方法在堆上分配内存产生的(用new + 构造方法来调用)，而对象变量是在栈上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上产生了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。 存储区域1.创建的实例及成员变量（静、非静态）在堆中2.局部变量在栈中3.类的基本信息和方法定义在方法区 UML类图相关知识见http://www.uml.org.cn/oobject/201211231.asp 构造器 构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。 构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，因为它是用来创建实例的，所以它永远是实例方法，不能被static修饰。 构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。 访问对象的数据和方法 在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。 引用数据域和null值 如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。 默认赋值规则 类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。 基本变量和引用变量的区别 基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。 没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。 静态/非静态变量、常量和静态/非静态方法静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。不要从构造器中传入参数来初始化静态域，最好使用set方法改变静态数据域。非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。非静态方法：又称实例方法，是依赖于具体对象的方法。关系：静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。 工厂方法静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：12345NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.gerPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x));// prints $0.10System.out.println(percentFormatter.format(x));//prints 10% 使用静态工厂方法的原因主要有两个：1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类 可见性修饰符public修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public protected修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问 default缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。 privateprivate成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。 注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。 包包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句package + 包名，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。 类的导入精确导入：导入某个包的特定类,如import java.util.Scanner通配导入：导入某个包的所有类,如import java.util.*当使用多个包中的同名类时，要用包名.类名的格式编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如import static java.lang.System.*导入了System类的静态方法和静态域，就可以不加类名前缀:out.println(&quot;Hello world!&quot;)，out是System类里定义的静态成员，是PrintStream的实例。 数据域封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。实现封装的步骤：1.用private可见性修饰符修饰类成员2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue) 向方法传递对象参数可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。 对象数组和普通数组所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。 不可变对象和类一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。一个类是不可变类要满足以下三个条件：1.所有的数据域都是私有的2.没有修改器方法3.没有一个返回指向可变数据域引用的访问器方法 变量作用域一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如1234public class F&#123; private int j = i + 1; private int i;&#125; 就是错误的，因为j的初始化基于i已经被初始化的前提。 局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。 建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。 this引用this关键字有两大作用：1.表示指向调用对象本身的引用名2.可以在构造方法内部调用同一个类的其他构造方法，此时this(参数列表)语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用this(参数列表)的形式来实现它们。这样做可以简化代码，使类易于维护。 对象构造默认域初始化即依赖编译器对数据域的默认初始化。 显式域初始化在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。 无参数的构造器即将对数据域的初始化置于一个无参的构造器中。 有参数的构造器即给构造器传入参数对数据域进行初始化 初始化块即用花括号包含的一组数据域赋值代码块，一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块。 成员初始化顺序1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行。2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。3.父类的实例成员和实例初始化块，按在代码中出现的顺序依次执行。4.执行父类的构造方法。5.子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。6.执行子类的构造方法。 注意：静态成员只在构造该类的第一个对象时初始化一次，可以看作初始化类。 类设计技巧1.一定要保证数据域私有2.一定要对数据初始化最好不要依赖默认初始化，会影响程序可读性。 3.不要在类中使用过多的基本类型用其他集合了相关基本类型的类代替多个基本类型使用 4.不是所有的域都需要独立的域访问器和域修改器有的数据域定义后不必要修改 5.将职责过多的类进行分解6.类名和方法名要能够体现它们的职责7.优先使用不可变的类更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习之区间dp]]></title>
    <url>%2F2017%2F10%2F11%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[简介区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。 算法结构设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段 For l:=2 to n do // 枚举区间长度for i:=1 to n do // 枚举区间的左端点beginj:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到if j&gt;n then break; // 保证了下标不越界for k:= i to j-1 do // 状态转移，去推出 f[i,j]f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }end; 这个结构必须记好，这是区间动态规划的代码结构。 例题石子合并题目链接:http://acm.nyist.net/JudgeOnline/problem.php?pid=737 题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。那么dp[i][j] = min(dp[i][k] + dp[k+1][j])那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2） 代码1(无优化) 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i)//枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = i; k &lt; j; ++k) &#123; dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; 代码2(平行四边形优化) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 210int dp[N][N],sum[N],s[N][N];int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); s[i][i]=i; sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i) //枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = s[i][j-1]; k &lt;= s[i+1][j]; ++k)//四边形优化 &#123; if(dp[i][j]&gt;dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]) &#123; dp[i][j]=dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]; s[i][j]=k; &#125; &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0;&#125; 括号匹配题目链接：http://poj.org/problem?id=2955 题意:给出一串的只有‘（’ ‘）’ ‘[‘ ‘]’四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。 分析：定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ;2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] ) 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;const int N = 120;int dp[N][N];int main()&#123; string s; while(cin&gt;&gt;s) &#123; if(s=="end") break; memset(dp,0,sizeof(dp)); int n = s.size(); for(int len = 2;len &lt;= n;len++)//枚举区间长度 &#123; for(int i = 0;i &lt;= n - len; i++)//枚举区间左端点 &#123; int j = i + len - 1;//确定区间右端点 if(j &gt; n) break; if(s[i]=='('&amp;&amp;s[j]==')' || s[i]=='['&amp;&amp;s[j]==']') dp[i][j]=dp[i+1][j-1]+2; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);//枚举中间位置,注意j不取等号 &#125; &#125; cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; &#125; return 0;&#125; 如果要求打印路径，即输出匹配后的括号 题目链接: http://poj.org/problem?id=1141 代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 120;int dp[N][N],pos[N][N]; /*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/string s;void show(int i,int j)&#123; if(i&gt;j) return; if(i==j) &#123; if(s[i]=='('||s[i]==')') cout&lt;&lt;"()"; else cout&lt;&lt;"[]"; &#125; else &#123; if(pos[i][j]==-1) &#123; cout&lt;&lt;s[i]; show(i+1,j-1); cout&lt;&lt;s[j]; &#125; else &#123; show(i,pos[i][j]); show(pos[i][j]+1,j); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;s) &#123; memset(dp,0,sizeof(dp)); int len=s.size(); for(int i=1; i&lt;len; i++) &#123; for(int j=0,k=i; k&lt;len; j++,k++) &#123; if(s[j]=='('&amp;&amp;s[k]==')' || s[j]=='['&amp;&amp;s[k]==']') &#123; dp[j][k]=dp[j+1][k-1]+2; pos[j][k]=-1; &#125; for(int f=j; f&lt;k; f++) &#123; if(dp[j][f]+dp[f+1][k]&gt;=dp[j][k]) &#123; dp[j][k]=dp[j][f]+dp[f+1][k]; pos[j][k]=f; &#125; &#125; &#125; &#125; show(0,len-1); cout&lt;&lt;endl; &#125; return 0;&#125; 整数划分题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=746 题意: 给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积 分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数设a[i][j]为区间[i,j]所形成的数所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i]) 代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long dp[25][25];long long a[25][25];char str[25];int main()&#123; int len, t, m; scanf("%d", &amp;t); while (t--) &#123; scanf("%s%d", str, &amp;m); len = strlen(str); m--; memset (a, 0, sizeof(a)); memset (dp, 0, sizeof(dp)); for (int i = 0; i &lt; len; i++) //先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值 &#123; a[i][i] = str[i] - '0'; for (int j = i + 1; j &lt; len; j++) &#123; a[i][j] = a[i][j - 1] * 10 + str[j] - '0'; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; dp[i][0] = a[0][i]; &#125; for (int j = 1; j &lt;= m; j++) &#123; for (int i = j; i &lt; len; i++) &#123; for (int k = 0; k &lt; i; k++) &#123; dp[i][j] = max(dp[i][j], dp[k][j - 1] * a[k + 1][i]); &#125; &#125; &#125; printf("%lld\n", dp[len - 1][m]); &#125; return 0;&#125; Halloween Costumes题目链接：http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422 题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会 分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有 ①：如果在之后的区间内都不再重复利用这件衣服，那么明显 dp[i][j] = dp[i+1][j] + 1; ②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，那么转移方程为 dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j]) 代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[105];int dp[105][105];int main(void)&#123; int t; int cas = 0; scanf("%d",&amp;t); while(t--) &#123; cas ++; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) &#123; for(int j = i;j &lt;= n;j++) &#123; dp[i][j] = j-i+1; &#125; &#125; for(int i = n-1;i &gt;= 1;i--) &#123; for(int j = i+1;j &lt;= n;j++) &#123; dp[i][j] = dp[i+1][j] + 1; for(int k = i+1;k &lt;= j;k++) &#123; if(a[i] == a[k]) &#123; dp[i][j] = min(dp[i][j],dp[i][k-1] + dp[k+1][j]); &#125; &#125; &#125; &#125; printf("Case %d: %d\n",cas,dp[1][n]); &#125; return 0;&#125; Cheapest Palindrome题目链接:http://poj.org/problem?id=3280 题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。 分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况： 1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值； 2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值 3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小 然后dp[i][j]取上面这些情况的最小值 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int dp[2005][2005],add[27],del[27];char s[2005];int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)&gt;0) &#123; scanf("%s",s+1); for(int i=1;i&lt;=n;i++) &#123; char ch[10]; int tmp1,tmp2; scanf("%s%d%d",ch,&amp;tmp1,&amp;tmp2); add[ch[0]-'a'+1]=tmp1; del[ch[0]-'a'+1]=tmp2; &#125; memset(dp,0,sizeof(dp)); for(int i=m-1;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i+1][j]+add[s[i]-'a'+1],dp[i+1][j]+del[s[i]-'a'+1]); int tmp=min(dp[i][j-1]+add[s[j]-'a'+1],dp[i][j-1]+del[s[j]-'a'+1]); dp[i][j]=min(dp[i][j],tmp); if(s[i]==s[j]) dp[i][j]=min(dp[i][j],dp[i+1][j-1]); &#125; &#125; printf("%d\n",dp[1][m]); &#125; return 0;&#125; Treats for the Cows题目链接:http://poj.org/problem?id=3186 题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值 分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来转移方程：dp[i][j]=max(dp[i+1][j]+p[i](n+i-j),dp[i][j-1]+p[j](n+i-j)); 其中n-(j-i)是第几次取 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int p[2010];int dp[2010][2010];int n;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); dp[i][i]= n * p[i]; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=i;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i+1][j]+p[i]*(n+i-j),dp[i][j-1]+p[j]*(n+i-j)); &#125; printf("%d\n",dp[1][n]); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH远程登录实现本地机和服务器的文件传输]]></title>
    <url>%2F2017%2F10%2F07%2FSSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见: 在Ubuntu下通过SSH连接远程服务器 (1)用SSH登录远程ubuntu主机假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu我们在命令行输入以下命令来连接：ssh -l ubuntu 118.89.223.117之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端 (2)从远程Ubuntu主机下载文件/文件夹到本地(scp)语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径 我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件要下载文件到本地,我们要结束SSH连接,切换到本地机,输入eixt或quit即可 我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功 我们进入本地目录验证一下 hello文件的确下载到了本地 (3)从本地向远程ubuntu主机上传文件/文件夹(scp)语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径 假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下 要上传本地文件,我们要结束SSH连接,切换到本地机,输入eixt或quit即可然后输入命令$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/，输入密码后提示文件上传成功 我们通过SSH登录到远程主机验证一下,pwd打印当前所在位置，发现我们处于/home/ubuntu目录下,ls显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下通过SSH连接远程服务器]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。 环境准备装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台 步骤一:打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端$ sudo apt-get install aptitude$ sudo aptitude install openssh-server 步骤二:启动ssh-server$ /etc/init.d/ssh restart 步骤三：确认ssh-server已经正常工作$ netstat -tlptcp6 0 0 *:ssh *:* LISTEN -看到上面一行说明ssh-server已经在运行了 步骤四：在本地机终端通过ssh登录服务器$ ssh -l 远程服务器用户名 服务器ip地址接下来会提示输入密码，然后就能成功登录到服务器上了 参考http://blog.csdn.net/wh_19910525/article/details/7585257]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制修改ubuntu密码]]></title>
    <url>%2F2017%2F10%2F06%2F%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。 查了资料,总结出两种解决方法: 方法一:加上sudo权限 方法二:切换到root用户 mark一下]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习笔记]]></title>
    <url>%2F2017%2F10%2F05%2FMarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。1. 标题标题根据字体大小分级产生层次，有两种写法：写法一：1234一级标题==================二级标题--------------------- 效果如下： 一级标题二级标题写法二：123456# 一级标题## 二级标题 ### 三级标题 #### 四级标题##### 五级标题 ###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题可见#的数量越多标题字号越小，要特别注意#和标题之间要留一个空格! 2. 内联样式内联样式能描述文字的粗细、倾斜程度等2.1 语义标记：代码:123456*这是斜体*_这是斜体_**这是粗体** ***这是加粗斜体*** **_这是加粗斜体_**~~这是删除线~~ 效果如下: 这是斜体这是斜体这是粗体这是加粗斜体这是加粗斜体这是删除线 可见语义标记允许叠加 2.2 语义标签代码:123456&lt;i&gt;这是斜体&lt;/i&gt; &lt;b&gt;这是粗体&lt;/b&gt; &lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt; &lt;em&gt;这是强调&lt;/em&gt; 这是上标 Z&lt;sup&gt;a&lt;/sup&gt; 这是下标 Z&lt;sub&gt;a&lt;/sub&gt; 效果如下： 这是斜体这是粗体这是粗斜体这是强调这是上标 Za这是下标 Za 可见语义标签可以嵌套，特别要注意&lt;em&gt;&lt;/em&gt;标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用&lt;i&gt;&lt;/i&gt;标签替代 3. 引用3.1 单行式 代码: 1&gt; hello world 效果如下: hello world 3.2 多行式 代码: 123&gt; hello world &gt; hello world &gt; hello world 效果如下: hello worldhello worldhello world 3.3 嵌套式 代码: 123&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc 效果如下: aaaaaaaaa bbbbbbbbb cccccccccc 4. 换行与段落缩进换行: 在行末敲两个空格和一个回车段落缩进: 将输入法切换为全角后敲击两次空格即可完成两个字符的缩进5. 行内标记与代码块5.1 行内标记(用前后各一个`标记代码块将变成一行) 代码: 1标记之外`hello world`标记之外 效果如下: 标记之外hello world标记之外 5.2 代码块(用于插入各类型的代码) 方法一 (使用前后各一个```包裹代码生成块,注意```之后换行不需要敲两个空格!!!): 效果如下: 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 方法二 (使用Tab缩进): 代码及效果如下: 我是文字… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 注意要在前文后空一行再进行Tab缩进 方法三 (自定义语法)： 即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮 效果如下： html代码块 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; javascript代码块 12345var num = 0;for(var i = 0; i &lt; 5; i++)&#123; num += i; &#125;console.log(num); 6. 超链接 Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。 6.1 行内式语法说明: []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。 代码: 12这是[XJY&apos;s Blog](http://habitdiary.cn) 这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;) 效果如下:这是XJY’s Blog这是XJY’s Blog 6.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明:参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 代码: 12345我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。[1]:http://www.baidu.com &quot;Baidu&quot;[2]:http://note.youdao.com/ &quot;youdaonote&quot;[3]:http://www.imooc.com/ &quot;IMOOC&quot;[网站]:http://note.youdao.com/ &quot;youdaonote&quot; 效果如下: 我经常去的网站有Baidu、有道云笔记以及IMOOC,有道云笔记是不错的网站。 6.3 自动链接语法说明:Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：代码: 12&lt;http://example.com/&gt;&lt;address@example.com&gt; 效果如下:http://example.com/&#97;&#x64;&#100;&#x72;&#x65;&#115;&#115;&#64;&#x65;&#x78;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#109; 7. 列表7.1 无序列表代码: 123* 吃饭* 睡觉* 打代码 效果如下: 吃饭 睡觉 打代码 7.2 有序列表代码: 1231. 把冰箱门打开2. 把大象关进去3. 把冰箱门带上 效果如下: 把冰箱门打开 把大象关进去 把冰箱门带上 7.3 序表嵌套代码: 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 效果如下: one one-1 two-2 two two-1 two-2 7.4 任务列表代码(方括号里是x表示打勾,空格表示为空): 123- [x] 选项一- [ ] 选项二 - [ ] 选项三 效果如下: 选项一 选项二 选项三 8. 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 8.1 内联式语法说明:![图片Alt](图片地址 “图片Title”)代码: 12爱琴海![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;) 效果如下:爱琴海 8.2 参照式语法说明:在文档要插入图片的地方写![图片Alt][标记]，在文档的最后写上[标记]:图片地址 “Title”代码: 123爱琴海![爱琴海][1][1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot; 效果如下:爱琴海 说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/574157059. 插入视频如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：1&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt; 效果如下: mark一下第一次写博客遇到的神坑: 在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 最后要感谢提供参考的大牛博客: http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13 http://www.jianshu.com/p/b03a8d7b1719]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
