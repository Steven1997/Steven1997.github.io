<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java学习总结之继承和多态]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[父类与子类在Java术语中，如果C1类扩展自另一个类C2，我们称C2为父类，也称超类或基类，称C1为子类，也称次类、扩展类、派生类。父类是更通用的类，子类是扩充父类得到的更特定的类。子类从它的父类中继承可访问的数据域和方法，还可以添加新的数据域和方法。从物理层面来看，为子类对象开辟的内存的前一部分存储从父类继承的成员(可访问)，后面再放置子类新扩展的成员。 继承面向对象的编程允许从已经存在的类中定义新的类，这称为继承。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。继承通过extends关键字实现。 继承有如下几个关键点1.子类并不是父类的一个子集，实际上，一个子类通常比它的父类包含更多的信息和方法2.父类中的私有数据域在该类之外是不可访问的，故不能在子类中直接使用，如果父类中定义了公共访问器或修改器，可以在子类中调用它们3.不是所有的“是一种”(is-a)关系都该用继承来建模4.继承是用来为“是一种”关系(is-a)建模的，不要仅仅为了重用方法这个原因而盲目使用继承5.Java中类与类的继承是单一继承 super关键字super关键字有两种作用：1.调用父类的构造方法因为继承时父类的构造方法不会被继承，而子类的构造方法只能初始化子类新增加的数据域，所以要通过super关键字调用父类的构造方法来初始化从父类继承的数据域。形式是super()或super(arguments)，分别调用了父类的无参构造方法和相应的有参构造方法。super语句要写在子类构造方法的第一条，否则编译器会自动在构造方法开头插入一条super()2.调用父类的方法在继承时往往会进行重写，即覆盖父类的方法。此时如果要调用父类原有的未被覆盖的方法，就可以使用super.方法名来调用父类的方法。如果父类方法没有被覆盖，可以省略super关键字。只能调用一级父类的方法，不可以跨父类，super.super.方法名是不合法的。 构造方法链在任何情况下，构造一个类的实例时，将会调用沿着继承链的所有父类的构造方法。当构造一个子类对象时，子类构造方法会在完成自己的任务之前，首先调用它的父类的构造方法。如果父类继承自其他类，那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。这个过程一直持续到这个继承体系结构的最后一个构造方法被调用为止。这就是构造方法链。比如下面的代码： public class Faculty extends Employee{ public static void main(String[] args){ new Faculty(); } public Faculty(){ System.out.println("(4) Performs Faculty's tasks"); } } class Employee extends Person{ public Employee(){ this("(2) Invoke Employee's overloaded constructor"); System.out.println("(3) Perfoms Employee's tasks"); } public Employee(String s){ System.out.println(s); } } class Person{ public Person() { System.out.println("(1) Performs Person's tasks"); } } 打印结果为:(1) Performs Person’s tasks(2) Invoke Employee’s overloaded constructor(3) Performs Employee’s tasks(4) Performs Faculty’s tasks 我们可以知道：子类的构造方法的第一条语句要么是super语句(包括编译器隐式插入的),要么是this语句，它通过调用同一个类的另一个重载的构造方法，再调用该方法的super语句初始化父类 注意:如果没有显式在子类构造方法中定义super语句，编译器自动插入的super语句匹配的是父类的无参构造方法，如果父类没有无参构造方法，编译器会报错。所以建议为每个类都提供一个无参构造方法，以便于日后对该类进行扩展。 方法重载与重写重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。重载的方法方法名相同，返回值类型可以不同，参数列表必须不同(包括参数个数、类型和次序，有一个不同就算不同) 重写方法重写是指在继承时子类覆盖父类中已有的方法并提供对其的新的实现(修改方法体)。重写的方法和原方法返回值类型、方法名、参数列表均相同，可见性修饰符范围不可缩小(要么相同要么扩大)。为了避免错误，可以使用重写标注，在要重写的方法前加上@Override，该标注会强制编译器检查是否重写了某方法，如果没有重写，编译器会报告一个错误。 关于重写的几点注意1.仅当实例方法时刻访问的，它才能被覆盖2.静态方法可以被继承，但不能被覆盖。如果子类中重新定义了父类的静态方法，父类的静态方法会被隐藏，可以使用父类名.静态方法名调用隐藏的静态方法 方法重写发生在通过继承而相关的不同类中，方法重载可以发生在同一类中，也可以发生在由于继承关系而相关的不同类中。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习总结之对象与类]]></title>
    <url>%2F2017%2F10%2F12%2FJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[面向对象程序设计概述 面向对象程序设计(简称OOP)是当今主流的程序设计范型，它已经取代了传统的“结构化”过程化程序开发技术。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。 传统结构化程序设计主要通过设计一系列的过程(即算法)来解决问题，即算法+数据结构=程序，先要确定如何操作数据，再决定如何组织数据使之便于操作。而面向对象程序设计将数据域(属性)和对数据的操作(方法)绑定在一个对象中，将数据放在第一位，然后再考虑操作数据的算法。 对于规模较小的问题将其分解为过程开发较为理想，而对于规模较大的问题使用OOP比较理想，比如出现错误，在集成在对象的方法中寻找错误比在众多零散过程中查找更容易。 类和对象 类：类是构造对象的模板或蓝图，用于定义对象的数据域和方法。一个java源文件中只能有一个公共类，且类名与文件名相同。编译源文件时每个类都生成一个.class文件。如果A类使用B类，称A类是B类的客户。 对象：由类构造的实例，一个类可以构造多个实例。 设计类的简单规则 先从设计类的数据域开始，再向类里添加方法。 类之间的关系1.依赖(use-a) 如果A类的方法操纵B类的对象，我们说A类依赖于B类。应该尽可能使相互依赖的类减少，否则B类的改变会影响A类，从而可能使A类产生bug。用软件工程的术语来说，即让类之间的耦合度最小。2.聚合(has-a) 如果A类对象包含B类对象，我们说A类和B类聚合。3.继承(is-a) 如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 对象与对象变量 对象是调用构造方法在堆上分配内存产生的(用new + 构造方法来调用)，而对象变量是在栈上的持有对象引用的变量(声明方式为：类名 + 对象名)。一个对象可被多个对象变量引用。比如语句A a = new A()，new A()在堆上产生了对象，a是对象变量，包含对于该对象的引用。该语句完成了三个操作，前半部分声明了一个A类型的对象变量a，后半部分创建了A类对象的实例，等号把对象引用赋给对象遍历变量(如果不赋值给a，new A()是一个匿名对象)。大多数情况下，我们可以简单地说a是一个A类对象，而不用冗长地说a是一个包含对A对象引用的变量。在Java中，数组被看作对象，一个数组变量实际上是一个包含数组引用的变量。 存储区域1.创建的实例及成员变量（静、非静态）在堆中2.局部变量在栈中3.类的基本信息和方法定义在方法区 UML类图相关知识见http://www.uml.org.cn/oobject/201211231.asp 构造器 构造器用于构造对象实例，并对数据域进行相应初始化，物理层面表现为在堆上为对象的非静态成员开辟存储空间。 构造器名应该与类名相同，无返回值，甚至连void也没有，可以被可见性修饰符(如public)修饰，不能被static修饰。 构造方法可以重载，没有参数的构造方法称为无参构造方法或默认构造方法，当类中没有定义构造方法时，编译器会自动插入一个方法体为空的默认构造方法，但一旦定义了有参构造方法，该默认构造方法不会被插入。 访问对象的数据和方法 在面向对象编程中，对象成员可以引用该对象的数据域和方法。在创建一个对象后，它的数据域和方法可以使用点操作符(.)来访问和调用，该操作符也称为对象成员访问操作符。 引用数据域和null值 如果一个引用类型的数据域没有引用任何对象，那么它的值为null,是一个引用类型直接量。访问值为null引用变量的数据域或方法会抛出一个NullPointerException。 默认赋值规则 类中的变量如果没有赋值，会被自动赋予默认值，引用类型默认值为null，byte为(byte)0,short为(short)0,int为0,long为0L,float为0.0f,double为0.0，char为‘\u0000’(空字符,但也占长度),boolean为false。但如果Java没有给方法里的局部变量赋值，会出现编译错误。 基本变量和引用变量的区别 基本变量类型有byte,short,int,long,float,double,char,boolean八种，其他类型变量都是引用变量。基本变量对应内存所存储的值是基本类型值，而引用变量存储的值是一个引用，是对象的存储地址。将一个变量赋给另一个变量，另一个变量就被赋予同样的值。对基本类型来说，就是将一个变量的实际值赋给另一个变量;对引用变量来说，就是将一个变量的引用赋给另一个变量，从而两个变量指向同一个对象。 没有变量引用的对象会成为垃圾，Java运行系统会检测垃圾并自动回收它所占的空间，这个过程称为垃圾回收。如果你认为不再需要某个对象，可以显式地给该对象变量赋null值，让它被JVM自动回收。 静态/非静态变量、常量和静态/非静态方法静态变量：又称类变量，是由一个类的所有实例共享，变量值存储在一个公共内存地址，描述类的对象的公共属性，不依赖于具体对象的变量。用关键字static表示。非静态变量：又称实例变量，是依赖于具体对象的变量，变量值存储在特定对象的内存地址。常量：类的所有对象共享且不可变的量，用static final修饰，final决定了其不可变性，static决定了它不依赖于具体对象，可以不实例化直接通过类名调用。静态方法：无需创建类实例就可以调用的方法，不依赖于具体对象，用关键字static表示,其中main方法也是静态方法。非静态方法：又称实例方法，是依赖于具体对象的方法。关系：静态数据域或方法既可以通过类访问，也可以通过对象访问;非静态数据域或方法只能通过对象访问(但为了便于程序可读性，建议用类名调用静态成员，用对象名调用非静态成员)。静态方法只能访问静态数据域，非静态方法可以访问非静态数据域和静态数据域。 工厂方法静态方法还有另外一种常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。比如NumberFormat使用如下工厂方法生成不同风格的格式化对象：12345NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance(); NumberFormat percentFormatter = NumberFormat.gerPercentInstance(); double x = 0.1; System.out.println(currencyFormatter.format(x));// prints $0.10System.out.println(percentFormatter.format(x));//prints 10% 使用静态工厂方法的原因主要有两个：1.无法命名构造器。构造器名和类名必须相同，但NumberFormat希望得到的不同实例拥有不同名字2.当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFromat类对象，这是NumberFormat的子类 可见性修饰符public修饰的成员可以在任何范围内直接访问，只是一种最宽松的访问控制等级。需要注意的，所谓的直接访问仍需要先创建或获得一个相应类的对象然后才可以使用”对象名.成员“的方式访问其属性或调用其方法，但是出于信息封装和隐藏的需要一般不提倡把成员声明为public的，而构造方法和需要外界直接调用的普通方法则适合声明为public protected修饰的成员可以在其所在类中、同一包中及子类中（无论子类在不在同一个包）被直接访问，但不能在位于不同包中的非子类中被直接访问 default缺省访问修饰符的成员只能在其所在类中或包中直接访问，在不同包中即使是不同包的子类也不能直接访问。 privateprivate成员只能在所在类中被直接访问，是4种访问等级最高的一个，建议为了实现类的封装，实例数据域应该使用private修饰。如果不想让一个类创建实例，可以用private修饰其构造方法。 注意：private和protected只能修饰类成员，public和default可以修饰类和类成员。public的类成员只有位于public类里才能出包访问，如果类是default的，也不能出包访问。 包包可以用来更好地组织、管理类，在不同的包中可以定义同名的类而不会发生冲突，建议将因特网域名的逆序作为包名，比如域名habitdiary.cn，可以定义包名为cn.habitdiary,还可以进一步定义子包名，比如cn.habitdiary.core，当然包和子包的这种嵌套关系只是为了逻辑结构更加严谨，在编译器看来这两个包是互相独立的集合。为了把类放入包中，需要在程序中首先出现语句package + 包名，前面不能有注释或空白。如果定义类时没有指定包，就表示把它放在默认包中，建议最好将类放入包中，不要使用默认包。源文件应该放到与完整包名匹配的子目录下，比如cn.habitdiary.core应该放在子目录cn/habitdiary/core下，编译器会把编译得到的.class文件放在同一目录下。 类的导入精确导入：导入某个包的特定类,如import java.util.Scanner通配导入：导入某个包的所有类,如import java.util.*当使用多个包中的同名类时，要用包名.类名的格式编译器定位类会按照配置的环境变量找到类库，再根据导入路径在相应的包中定位相应的类静态导入：import语句不仅可以导入类，还可以导入静态方法和静态域，只要加入static关键字。比如import static java.lang.System.*导入了System类的静态方法和静态域，就可以不加类名前缀:out.println(&quot;Hello world!&quot;)，out是System类里定义的静态成员，是PrintStream的实例。 数据域封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，避免了对数据域的直接修改，提高了数据的安全性和易维护性。实现封装的关键是绝不能让类中的方法直接访问其他类的实例域，程序仅通过方法和数据进行交互。实现封装的步骤：1.用private可见性修饰符修饰类成员2.设置访问器(get方法)，方法签名习惯为:public returnType getPropertyName()，如果返回值类型是boolean型,习惯下定义为:public boolean isPropertyName()3.设置修改器(set方法)，方法签名习惯为:public void setPropertyName(dataType propertyValue) 向方法传递对象参数可以将对象传递给方法，同传递数组一样，传递对象实际上是传递对象的引用。Java只有一种参数传递方式:值传递。只不过引用类型变量的值是引用，引用上传值的最好描述为传共享。 对象数组和普通数组所有数组变量存储的都是对数组的引用，但是普通数组里存储的就是实际的值，对象数组里存储的则还是对象的引用，而非对象本身，其类似于二维数组有两层的引用关系，对象数组元素的初始值默认为null。 不可变对象和类一旦创建之后内容就不可改变的对象是不可变对象，它的类称为不可变类。一个类是不可变类要满足以下三个条件：1.所有的数据域都是私有的2.没有修改器方法3.没有一个返回指向可变数据域引用的访问器方法 变量作用域一个类的实例变量和静态变量的作用于是整个类，不论在何处声明，所以类的变量和方法可以在类中以任意顺序出现。但是当一个变量初始化要基于另一个变量时不是这样。比如1234public class F&#123; private int j = i + 1; private int i;&#125; 就是错误的，因为j的初始化基于i已经被初始化的前提。 局部变量(包括方法中声明的变量和形参等)的作用域则从声明开始到包含该变量的块结束处。如果一个局部变量和类成员变量有相同的名字，则局部变量优先，同名的成员变量被隐藏。可以通过this引用显示隐藏的成员变量。 建议：在声明类的变量和方法时，最好按照：数据域 —— 构造方法 —— 普通方法的顺序，且最好在数据域和方法之间空一行，提高程序可读性。 this引用this关键字有两大作用：1.表示指向调用对象本身的引用名2.可以在构造方法内部调用同一个类的其他构造方法，此时this(参数列表)语句应该出现在构造方法其他语句之前，如果一个类有多个构造方法，最好尽可能使用this(参数列表)的形式来实现它们。这样做可以简化代码，使类易于维护。 对象构造默认域初始化即依赖编译器对数据域的默认初始化。 显式域初始化在数据域的定义处进行赋值，可以在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，这种方法特别有用。初始值不一定是常量值，可以调用方法返回一个值对域进行初始化。 无参数的构造器即将对数据域的初始化置于一个无参的构造器中。 有参数的构造器即给构造器传入参数对数据域进行初始化 初始化块即用花括号包含的一组数据域赋值代码块，一般在数据域声明处之后，构造器之前。如果在初始化块前加static关键字，并在块内初始化静态数据域，就成了静态初始化块。 成员初始化顺序1.父类静态成员和静态初始化快，按在代码中出现的顺序依次执行。2.子类静态成员和静态初始化块，按在代码中出现的顺序依次执行。3.父类的实例成员和实例初始化块，按在代码中出现的顺序依次执行。4.执行父类的构造方法。5.子类实例成员和实例初始化块，按在代码中出现的顺序依次执行。6.执行子类的构造方法。 注意：静态成员只在构造该类的第一个对象时初始化一次，可以看作初始化类。 类设计技巧1.一定要保证数据域私有2.一定要对数据初始化最好不要依赖默认初始化，会影响程序可读性。 3.不要在类中使用过多的基本类型用其他集合了相关基本类型的类代替多个基本类型使用 4.不是所有的域都需要独立的域访问器和域修改器有的数据域定义后不必要修改 5.将职责过多的类进行分解6.类名和方法名要能够体现它们的职责7.优先使用不可变的类更改对象的问题在于，如果多个线程试图同时更新一个对象，就会发生并发更改，其结果是不可预料的。如果类是不可更改的，就可以安全地在多个线程间共享其对象。修改状态可通过返回状态已修改的新对象来实现，而不是修改对象本身。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划之区间dp]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%8C%BA%E9%97%B4dp%2F</url>
    <content type="text"><![CDATA[简介区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。 算法结构设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段 For l:=2 to n do // 枚举区间长度for i:=1 to n do // 枚举区间的左端点beginj:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到if j&gt;n then break; // 保证了下标不越界for k:= i to j-1 do // 状态转移，去推出 f[i,j]f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }end; 这个结构必须记好，这是区间动态规划的代码结构。 例题石子合并题目链接:http://acm.nyist.net/JudgeOnline/problem.php?pid=737 题意:有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。 分析:要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。定义状态dp[i][j]为从第i个石子到第j个石子的合并最小代价。那么dp[i][j] = min(dp[i][k] + dp[k+1][j])那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。这个问题可以用到平行四边形优化，用一个s[i][j]=k 表示区间 i—j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2） 代码1(无优化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #define N 210 int dp[N][N],sum[N]; int main() &#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i)//枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = i; k &lt; j; ++k) &#123; dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]); &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0; &#125; ``` 代码2(平行四边形优化) ```cpp #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #define N 210 int dp[N][N],sum[N],s[N][N]; int main() &#123; int n; while(~scanf("%d",&amp;n)) &#123; int a[N];sum[0]=0; memset(s,0,sizeof(s)); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); s[i][i]=i; sum[i]=sum[i-1]+a[i];//因为要求解区间和，先维护前缀和 &#125; memset(dp,0,sizeof(dp)); int i,j,l,k; for(l = 2; l &lt;= n; ++l)//枚举区间长度 &#123; for(i = 1; i &lt;= n - l + 1; ++i) //枚举区间左端点 &#123; j = i + l - 1;//根据左端点和区间长度求区间右端点 if(j &gt; n) break; dp[i][j] = 0x3f3f3f3f; for(k = s[i][j-1]; k &lt;= s[i+1][j]; ++k)//四边形优化 &#123; if(dp[i][j]&gt;dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]) &#123; dp[i][j]=dp[i][k] + dp[k + 1][j] + sum[j] - sum[i-1]; s[i][j]=k; &#125; &#125; &#125; &#125; printf("%d\n", dp[1][n]); &#125; return 0; &#125; ``` ### 括号匹配 题目链接：&lt;http://poj.org/problem?id=2955&gt; 题意:给出一串的只有‘（’ ‘）’ '[‘ ']'四种括号组成的串，让你求解需要最少添加括号数让串中的所有括号完全匹配。 分析： 定义dp [ i ] [ j ] 为串中第 i 个到第 j 个括号的最大匹配数目 1.如果第 i 个和第 j 个匹配,则dp [ i ] [ j ] = dp [ i+1 ] [ j-1 ] + 2 ; 2.如果第 i 个和第 j 个不匹配，枚举中间分割点k(i &lt;= k &lt; j)dp[ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k+1 ] [ j ] ) 代码 ```cpp #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;string&gt; using namespace std; const int N = 120; int dp[N][N]; int main() &#123; string s; while(cin&gt;&gt;s) &#123; if(s=="end") break; memset(dp,0,sizeof(dp)); int n = s.size(); for(int len = 2;len &lt;= n;len++)//枚举区间长度 &#123; for(int i = 0;i &lt;= n - len; i++)//枚举区间左端点 &#123; int j = i + len - 1;//确定区间右端点 if(j &gt; n) break; if(s[i]=='('&amp;&amp;s[j]==')' || s[i]=='['&amp;&amp;s[j]==']') dp[i][j]=dp[i+1][j-1]+2; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]);//枚举中间位置,注意j不取等号 &#125; &#125; cout&lt;&lt;dp[0][n-1]&lt;&lt;endl; &#125; return 0; &#125;``` 如果要求打印路径，即输出匹配后的括号 题目链接: &lt;http://poj.org/problem?id=1141&gt; 代码: ```cpp #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; const int N = 120; int dp[N][N],pos[N][N]; /*定义pos【i】【j】表示 i 到 j 从哪儿分开使得匹配添加括号最少，如果i和j匹配我们可以让pos【i】【j】=-1；*/ string s; void show(int i,int j) &#123; if(i&gt;j) return; if(i==j) &#123; if(s[i]=='('||s[i]==')') cout&lt;&lt;"()"; else cout&lt;&lt;"[]"; &#125; else &#123; if(pos[i][j]==-1) &#123; cout&lt;&lt;s[i]; show(i+1,j-1); cout&lt;&lt;s[j]; &#125; else &#123; show(i,pos[i][j]); show(pos[i][j]+1,j); &#125; &#125; &#125; int main() &#123; while(cin&gt;&gt;s) &#123; memset(dp,0,sizeof(dp)); int len=s.size(); for(int i=1; i&lt;len; i++) &#123; for(int j=0,k=i; k&lt;len; j++,k++) &#123; if(s[j]=='('&amp;&amp;s[k]==')' || s[j]=='['&amp;&amp;s[k]==']') &#123; dp[j][k]=dp[j+1][k-1]+2; pos[j][k]=-1; &#125; for(int f=j; f&lt;k; f++) &#123; if(dp[j][f]+dp[f+1][k]&gt;=dp[j][k]) &#123; dp[j][k]=dp[j][f]+dp[f+1][k]; pos[j][k]=f; &#125; &#125; &#125; &#125; show(0,len-1); cout&lt;&lt;endl; &#125; return 0; &#125; 整数划分题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=746 题意: 给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积 分析: 区间dp，设dp[i][j] 表示在区间[0, i]之中，插入j个乘号可以得到的最大数设a[i][j]为区间[i,j]所形成的数所以 dp[i][j] = max(dp[k][j-1] * a[k + 1][i]) 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168 #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; long long dp[25][25]; long long a[25][25]; char str[25]; int main() &#123; int len, t, m; scanf("%d", &amp;t); while (t--) &#123; scanf("%s%d", str, &amp;m); len = strlen(str); m--; memset (a, 0, sizeof(a)); memset (dp, 0, sizeof(dp)); for (int i = 0; i &lt; len; i++) //先对a进行预处理，减少复杂度，a[i][j]表示第i段到第j段的数值 &#123; a[i][i] = str[i] - '0'; for (int j = i + 1; j &lt; len; j++) &#123; a[i][j] = a[i][j - 1] * 10 + str[j] - '0'; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; dp[i][0] = a[0][i]; &#125; for (int j = 1; j &lt;= m; j++) &#123; for (int i = j; i &lt; len; i++) &#123; for (int k = 0; k &lt; i; k++) &#123; dp[i][j] = max(dp[i][j], dp[k][j - 1] * a[k + 1][i]); &#125; &#125; &#125; printf("%lld\n", dp[len - 1][m]); &#125; return 0; &#125;``` ### Halloween Costumes 题目链接：&lt;http://lightoj.com/login_main.php?url=volume_showproblem.php?problem=1422&gt; 题意：给你n天需要穿的衣服的样式，每次可以套着穿衣服，脱掉的衣服就不能再穿了，问至少要带多少条衣服才能参加所有宴会 分析：首先我们使用dp[a][b]来表示区间 a~b 的答案，那么对于第 i 件衣服，我们有①：如果在之后的区间内都不再重复利用这件衣服，那么明显 dp[i][j] = dp[i+1][j] + 1;②：如果在之后的区间 i+1 ~ j 中存在一件衣服 k 是跟 i 一样的，那么我们便可以考虑是不是可以将i那件衣服在k这个地方重复利用，那么转移方程为 dp[i][j] = min(dp[i][j] , dp[i][k-1]+dp[k+1][j]) 代码:```cpp #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n; int a[105]; int dp[105][105]; int main(void) &#123; int t; int cas = 0; scanf("%d",&amp;t); while(t--) &#123; cas ++; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) &#123; for(int j = i;j &lt;= n;j++) &#123; dp[i][j] = j-i+1; &#125; &#125; for(int i = n-1;i &gt;= 1;i--) &#123; for(int j = i+1;j &lt;= n;j++) &#123; dp[i][j] = dp[i+1][j] + 1; for(int k = i+1;k &lt;= j;k++) &#123; if(a[i] == a[k]) &#123; dp[i][j] = min(dp[i][j],dp[i][k-1] + dp[k+1][j]); &#125; &#125; &#125; &#125; printf("Case %d: %d\n",cas,dp[1][n]); &#125; return 0; &#125;``` ### Cheapest Palindrome题目链接:&lt;http://poj.org/problem?id=3280&gt; 题意:给你m个字符，其中有n种字符，每种字符都有两个值，分别是增加一个这样的字符的代价，删除一个这样的字符的代价，让你求将原先给出的那串字符变成回文串的最小代价。 分析:dp[i][j]代表区间i到区间j成为回文串的最小代价，那么对于dp[i][j]有三种情况：1、dp[i+1][j]表示区间i到区间j已经是回文串了的最小代价，那么对于s[i]这个字母，我们有两种操作，删除与添加，对应有两种代价，dp[i+1][j]+add[s[i]],dp[i+1][j]+del[s[i]]，取这两种代价的最小值；2、dp[i][j-1]表示区间i到区间j-1已经是回文串了的最小代价，那么对于s[j]这个字母，同样有两种操作，dp[i][j-1]+add[s[j]],dp[i][j-1]+del[s[j]]，取最小值3、若是s[i]==s[j]，dp[i+1][j-1]表示区间i+1到区间j-1已经是回文串的最小代价，那么对于这种情况，我们考虑dp[i][j]与dp[i+1][j-1]的大小然后dp[i][j]取上面这些情况的最小值 代码 ```cpp #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int dp[2005][2005],add[27],del[27]; char s[2005]; int main() &#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)&gt;0) &#123; scanf("%s",s+1); for(int i=1;i&lt;=n;i++) &#123; char ch[10]; int tmp1,tmp2; scanf("%s%d%d",ch,&amp;tmp1,&amp;tmp2); add[ch[0]-'a'+1]=tmp1; del[ch[0]-'a'+1]=tmp2; &#125; memset(dp,0,sizeof(dp)); for(int i=m-1;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=m;j++) &#123; dp[i][j]=min(dp[i+1][j]+add[s[i]-'a'+1],dp[i+1][j]+del[s[i]-'a'+1]); int tmp=min(dp[i][j-1]+add[s[j]-'a'+1],dp[i][j-1]+del[s[j]-'a'+1]); dp[i][j]=min(dp[i][j],tmp); if(s[i]==s[j]) dp[i][j]=min(dp[i][j],dp[i+1][j-1]); &#125; &#125; printf("%d\n",dp[1][m]); &#125; return 0; &#125; Treats for the Cows题目链接:http://poj.org/problem?id=3186 题意:只能从一个序列的左右两端取数字，且取出的第i个数乘i,求乘积相加的最大值 分析:设dp[i][j]为取到剩余区间为[i,j]的最大值，可能由d[i+1][j]或者d[i][j-1]转移而来转移方程：dp[i][j]=max(dp[i+1][j]+p[i](n+i-j),dp[i][j-1]+p[j](n+i-j)); 其中n-(j-i)是第几次取 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int p[2010];int dp[2010][2010];int n;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); dp[i][i]= n * p[i]; &#125; int ans=0; for(int i=n;i&gt;=1;i--) for(int j=i;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i+1][j]+p[i]*(n+i-j),dp[i][j-1]+p[j]*(n+i-j)); &#125; printf("%d\n",dp[1][n]); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH远程登录实现本地机和服务器的文件传输]]></title>
    <url>%2F2017%2F10%2F07%2FSSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[SSH是一种以安全、加密方式连接远程主机或服务器的方法。SSH服务器接受从有SSH的客户机的连接，允许操作者象在本地一样地登录系统。如果已经搭建了SSH远程登录服务，如何实现本地机和远程服务器的文件交互呢？以下操作基于远程机已经安装了SSH服务器端，如果没有安装，详细步骤见: 在Ubuntu下通过SSH连接远程服务器 (1)用SSH登录远程ubuntu主机假设远程Ubuntu主机安装了SSH服务器端。远程Ubuntu主机的IP为：118.89.223.117,用户名为ubuntu我们在命令行输入以下命令来连接：ssh -l ubuntu 118.89.223.117之后提示输入密码，回车，登录成功，注意此时已经切换到了远程机的终端 (2)从远程Ubuntu主机下载文件/文件夹到本地(scp)语法格式：scp -r 远程主机用户名@远程主机ip:待下载文件的远程主机目录路径 保存下载文件的本地文件路径 我们先在远程机的/home/ubuntu目录下新建一个名为hello的文件要下载文件到本地,我们要结束SSH连接,切换到本地机,输入eixt或quit即可 我们将远程机的hello文件下载到本地的/home/xiejunyu/local目录下，输入密码后提示文件下载成功 我们进入本地目录验证一下 hello文件的确下载到了本地 (3)从本地向远程ubuntu主机上传文件/文件夹(scp)语法格式：scp -r 待上传的本地文件路径 远程主机用户名@远程主机ip:用于保存文件的远程主机目录路径 假设要上传一个在/home/xiejunyu/local目录下的test.txt文件,远程主机用户名为ubuntu,ip为118.89.223.117,保存到远程主机的/home/ubuntu目录下 要上传本地文件,我们要结束SSH连接,切换到本地机,输入eixt或quit即可然后输入命令$ scp -r /home/xiejunyu/local/test.txt ubuntu@118.89.223.117:/home/ubuntu/，输入密码后提示文件上传成功 我们通过SSH登录到远程主机验证一下,pwd打印当前所在位置，发现我们处于/home/ubuntu目录下,ls显示当前目录下的文件，我们发现有test.txt文件,说明本地的test.txt已经上传到了远程机的/home/ubuntu目录下]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下通过SSH连接远程服务器]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%9C%A8Ubuntu%E4%B8%8B%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[登录远程服务器是搭建、维护网站的常用操作。在Windows环境下我们会选择XSHELL等工具进行登录，而在Linux环境下可以通过终端快捷登录。 环境准备装有Ubuntu操作系统的本地机和远程腾讯云服务器各一台 步骤一:打开腾讯云官网，登录云服务器，在服务器上安装SSH服务器端$ sudo apt-get install aptitude$ sudo aptitude install openssh-server 步骤二:启动ssh-server$ /etc/init.d/ssh restart 步骤三：确认ssh-server已经正常工作$ netstat -tlptcp6 0 0 *:ssh *:* LISTEN -看到上面一行说明ssh-server已经在运行了 步骤四：在本地机终端通过ssh登录服务器$ ssh -l 远程服务器用户名 服务器ip地址接下来会提示输入密码，然后就能成功登录到服务器上了 参考http://blog.csdn.net/wh_19910525/article/details/7585257]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强制修改ubuntu密码]]></title>
    <url>%2F2017%2F10%2F06%2F%E5%BC%BA%E5%88%B6%E4%BF%AE%E6%94%B9ubuntu%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天想要修改ubuntu的密码,结果设置了两次密码，一次提示密码长度太短,一次提示强度不够。 查了资料,总结出两种解决方法: 方法一:加上sudo权限 方法二:切换到root用户 mark一下]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习笔记]]></title>
    <url>%2F2017%2F10%2F05%2FMarkdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 花了近两天时间终于搭建好了我的个人博客,因为Hexo是基于Markdown语法写作的博客，之前对Markdown一窍不通，于是赶快找了几篇大牛的博客学习，从中整理出了Hexo博客写作的常用语法。当然Markdown还有很多高级的用法,例如绘制流程图、时序图，插入数学公式等，由于在博客写作中不多用，文中没有提到。1. 标题标题根据字体大小分级产生层次，有两种写法：写法一：1234一级标题==================二级标题--------------------- 效果如下： 一级标题二级标题写法二：123456# 一级标题## 二级标题 ### 三级标题 #### 四级标题##### 五级标题 ###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题可见#的数量越多标题字号越小，要特别注意#和标题之间要留一个空格! 2. 内联样式内联样式能描述文字的粗细、倾斜程度等2.1 语义标记：代码:123456*这是斜体*_这是斜体_**这是粗体** ***这是加粗斜体*** **_这是加粗斜体_**~~这是删除线~~ 效果如下: 这是斜体这是斜体这是粗体这是加粗斜体这是加粗斜体这是删除线 可见语义标记允许叠加 2.2 语义标签代码:123456&lt;i&gt;这是斜体&lt;/i&gt; &lt;b&gt;这是粗体&lt;/b&gt; &lt;i&gt;&lt;b&gt;这是粗斜体&lt;/b&gt;&lt;/i&gt; &lt;em&gt;这是强调&lt;/em&gt; 这是上标 Z&lt;sup&gt;a&lt;/sup&gt; 这是下标 Z&lt;sub&gt;a&lt;/sub&gt; 效果如下： 这是斜体这是粗体这是粗斜体这是强调这是上标 Za这是下标 Za 可见语义标签可以嵌套，特别要注意&lt;em&gt;&lt;/em&gt;标签虽然显示的效果和斜体完全一致,但由于其具有强调语义,建议只在需要强调时使用,如果只是想使用斜体,尽量使用&lt;i&gt;&lt;/i&gt;标签替代 3. 引用3.1 单行式 代码: 1&gt; hello world 效果如下: hello world 3.2 多行式 代码: 123&gt; hello world &gt; hello world &gt; hello world 效果如下: hello worldhello worldhello world 3.3 嵌套式 代码: 123&gt; aaaaaaaaa&gt;&gt; bbbbbbbbb&gt;&gt;&gt; cccccccccc 效果如下: aaaaaaaaa bbbbbbbbb cccccccccc 4. 换行与段落缩进换行: 在行末敲两个空格和一个回车段落缩进: 将输入法切换为全角后敲击两次空格即可完成两个字符的缩进5. 行内标记与代码块5.1 行内标记(用前后各一个`标记代码块将变成一行) 代码: 1标记之外`hello world`标记之外 效果如下: 标记之外hello world标记之外 5.2 代码块(用于插入各类型的代码) 方法一 (使用前后各一个```包裹代码生成块): 效果如下: 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 方法二 (使用Tab缩进): 代码及效果如下: 我是文字… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 注意要在前文后空一行再进行Tab缩进 方法三 (自定义语法)： 即在前一个```后面附加语言名称如html、javascript等,可以产生语法高亮 效果如下： html代码块 12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; javascript代码块 12345var num = 0;for(var i = 0; i &lt; 5; i++)&#123; num += i; &#125;console.log(num); 6. 超链接 Markdown支持两种形式的链接语法: 行内式和参考式两种形式，行内式一般使用较多。 6.1 行内式语法说明: []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)这样的形式。链接地址与链接标题前有一个空格。 代码: 12这是[XJY&apos;s Blog](http://habitdiary.cn) 这是[XJY&apos;s Blog](http://habitdiary.cn &quot;XJY&apos;s Blog&quot;) 效果如下:这是XJY’s Blog这是XJY’s Blog 6.2 参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明:参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 代码: 12345我经常去的网站有[Baidu][1]、[有道云笔记][2]以及[IMOOC][3],[有道云笔记][2]是不错的[网站][]。[1]:http://www.baidu.com &quot;Baidu&quot;[2]:http://note.youdao.com/ &quot;youdaonote&quot;[3]:http://www.imooc.com/ &quot;IMOOC&quot;[网站]:http://note.youdao.com/ &quot;youdaonote&quot; 效果如下: 我经常去的网站有Baidu、有道云笔记以及IMOOC,有道云笔记是不错的网站。 6.3 自动链接语法说明:Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：代码: 12&lt;http://example.com/&gt;&lt;address@example.com&gt; 效果如下:http://example.com/&#97;&#100;&#x64;&#114;&#101;&#x73;&#x73;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d; 7. 列表7.1 无序列表代码: 123* 吃饭* 睡觉* 打代码 效果如下: 吃饭 睡觉 打代码 7.2 有序列表代码: 1231. 把冰箱门打开2. 把大象关进去3. 把冰箱门带上 效果如下: 把冰箱门打开 把大象关进去 把冰箱门带上 7.3 序表嵌套代码: 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 效果如下: one one-1 two-2 two two-1 two-2 7.4 任务列表代码(方括号里是x表示打勾,空格表示为空): 123- [x] 选项一- [ ] 选项二 - [ ] 选项三 效果如下: 选项一 选项二 选项三 8. 插入图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 8.1 内联式语法说明:![图片Alt](图片地址 “图片Title”)代码: 12爱琴海![爱琴海](http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot;) 效果如下:爱琴海 8.2 参照式语法说明:在文档要插入图片的地方写![图片Alt][标记]，在文档的最后写上[标记]:图片地址 “Title”代码: 123爱琴海![爱琴海][1][1]:http://pic.sc.chinaz.com/files/pic/pic9/201603/apic19710.jpg &quot;爱琴海&quot; 效果如下:爱琴海 说明: 如果要在Hexo中插入本地图片,具体方法见博客：http://blog.csdn.net/sugar_rainbow/article/details/574157059. 插入视频如果要插入的视频来源于优酷，爱奇艺，Youtube(播放时需要翻墙)等支持iframe的视频网站，那么你可以尝试在markdown编辑器中插入以下代码：1&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://tv.sohu.com/upload/static/share/share_play.html#90268916_9365222_0_9001_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt; 效果如下: mark一下第一次写博客遇到的神坑: 在转义包裹代码块的三个反引号```时,应该在每一个反引号之前都加反斜杠,刚开始只在开头加了一个，编辑器预览正确，但发布后排版就混乱了，找了好久才发现错误。 最后要感谢提供参考的大牛博客: http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C#title-13 http://www.jianshu.com/p/b03a8d7b1719]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
