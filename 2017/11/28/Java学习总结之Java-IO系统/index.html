<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Java," />





  <link rel="alternate" href="/atom.xml" title="XJY's Blog" type="application/atom+xml" />






<meta name="description" content="概述Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习总结之Java IO系统">
<meta property="og:url" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/index.html">
<meta property="og:site_name" content="XJY&#39;s Blog">
<meta property="og:description" content="概述Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/File1.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/File2.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/File3.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/File4.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/RandomAccessFile.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/result.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/Stream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/Information.jpg">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/JavaIO流类层次图.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/Compare.jpg">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/1.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/2.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/节点流.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/节点流示意图.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/处理流.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/处理流示意图.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/InputStream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/FileOutputStream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/FileReader.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/FileWriter.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/InputStreamReader.jpg">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/OutputStreamWriter.jpg">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/change.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/Buffer.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/BufferedReader1.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/BufferedReader2.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/BufferedWriter.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/test.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/ByteArrayInputStream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/ByteArrayOutputStream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/合并流.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/DataInputStream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/DataOutputStream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/对象序列化.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/对象序列化步骤.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/序列化和反序列化.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/管道流.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/回退流.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/PushbackInputStream.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/1.jpg">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/2.jpg">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/System1.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/System2.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/System3.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/System4.png">
<meta property="og:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/System5.png">
<meta property="og:updated_time" content="2018-02-21T12:18:58.661Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java学习总结之Java IO系统">
<meta name="twitter:description" content="概述Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。">
<meta name="twitter:image" content="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/File1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/"/>





  <title>Java学习总结之Java IO系统 | XJY's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/Steven1997"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/567c3a48d796e2fc06ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XJY's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">你要静候再静候 就算失收始终要守</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bookmark"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-folder-open"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://habitdiary.cn/2017/11/28/Java学习总结之Java-IO系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢均宇">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/fqtbjudvb4y.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XJY's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java学习总结之Java IO系统</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T22:07:13+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。本节讲述最基本的和流与 I/O 相关的功能。  </p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>JAVA中IO操作有相应步骤，以文件操作为例，主要操作流程如下：<br>1.使用File类打开一个文件<br>2.通过字节流或字符流的子类，指定输出的位置<br>3.进行读/写操作<br>4.关闭输入/输出  </p>
<p>那么我们先来介绍一下File类<br>Java文件类在Java.io包中，它以<strong>抽象</strong>的方式代表文件名和目录路径名。该类主要用于获取文件和目录的<strong>属性</strong>，文件和目录的<strong>创建、查找、删除、重命名</strong>等,但<strong>不能</strong>进行文件的<strong>读写操作</strong>。<br>File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。  </p>
<p>通过给定的<strong>父抽象路径名</strong>和<strong>子路径名字符串</strong>创建一个新的File实例。<br><code>File(File parent, String child)</code>  </p>
<p>通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例。<br><code>File(String pathname)</code>  </p>
<p>根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。<br><code>File(String parent, String child)</code>  </p>
<p>通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例。<br><code>File(URI uri)</code>  </p>
<p><strong>注意：</strong><br>1.在各个操作系统中，路径的分隔符是不一样的，例如：Windows中使用反斜杠：”<code>\</code>“，Linux|Unix中使用正斜杠：”<code>/</code>“。在使用反斜杠时要写成”<code>\\</code>“的形式，因为反斜杠要进行转义。如果要让Java保持可移植性，应该使用File类的静态常量File.pathSeparator。<br>2.<strong>构建一个File实例并不会在机器上创建一个文件。</strong>不管文件是否存在，都可以创建任意文件名的File实例。可以调用File实例上的exists()方法来判断这个文件是否存在。通过后续的学习我们会知道，当把一个输出流绑定到一个不存在的File实例上时，会自动在机器上创建该文件，如果文件已经存在，把输出流绑定到该文件上则会覆盖该文件，但这些都不是在创建File实例时进行的。</p>
<p>创建File对象成功后，可以使用以下列表中的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/File1.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File2.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File3.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/File4.png" alt="fail">  </p>
<p>下面给出一个使用File类的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      String dirname = <span class="string">"/java"</span>;</div><div class="line">      File f1 = <span class="keyword">new</span> File(dirname);</div><div class="line">      <span class="keyword">if</span> (f1.isDirectory()) &#123;</div><div class="line">         System.out.println( <span class="string">"Directory of "</span> + dirname);</div><div class="line">         String s[] = f1.list();</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">            File f = <span class="keyword">new</span> File(dirname + <span class="string">"/"</span> + s[i]);</div><div class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</div><div class="line">               System.out.println(s[i] + <span class="string">" is a directory"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               System.out.println(s[i] + <span class="string">" is a file"</span>);</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         System.out.println(dirname + <span class="string">" is not a directory"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>小贴士：</strong>lastModified()方法返回的是从时间戳(1970年1月1日0时0分0秒)到当前的毫秒数，返回值类型是long，可以用Date类对它进行包装使其更易读。</p>
<h3 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h3><p><strong>创建目录：</strong><br>File类中有两个方法可以用来创建文件夹：</p>
<ul>
<li>mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li>
<li>mkdirs()方法创建一个文件夹和它的所有父文件夹。<br>下面的例子创建 “/tmp/user/java/bin”文件夹：  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDir</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    String dirname = <span class="string">"/tmp/user/java/bin"</span>;</div><div class="line">    File d = <span class="keyword">new</span> File(dirname);</div><div class="line">    <span class="comment">// 现在创建目录</span></div><div class="line">    d.mkdirs();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>mkdirs是递归创建文件夹，允许在创建某文件夹时其父文件夹不存在,从而一同创建;mkdir必须满足路径上的父文件夹全都存在</strong><br><strong>注意：</strong> Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。<br><strong>读取目录：</strong><br>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。<br>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。<br>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。<br>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    String dirname = <span class="string">"/tmp"</span>;</div><div class="line">    File f1 = <span class="keyword">new</span> File(dirname);</div><div class="line">    <span class="keyword">if</span> (f1.isDirectory()) &#123;</div><div class="line">      System.out.println( <span class="string">"目录 "</span> + dirname);</div><div class="line">      String s[] = f1.list();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.length; i++) &#123;</div><div class="line">        File f = <span class="keyword">new</span> File(dirname + <span class="string">"/"</span> + s[i]);</div><div class="line">        <span class="keyword">if</span> (f.isDirectory()) &#123;</div><div class="line">          System.out.println(s[i] + <span class="string">" 是一个目录"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          System.out.println(s[i] + <span class="string">" 是一个文件"</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      System.out.println(dirname + <span class="string">" 不是一个目录"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>删除目录或文件：</strong><br>删除文件可以使用 java.io.File.delete() 方法。<br>以下代码会删除目录/tmp/java/，即便目录不为空。<br>测试目录结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/tmp/java/</div><div class="line">|-- <span class="number">1</span>.log</div><div class="line">|-- test</div></pre></td></tr></table></figure></p>
<p>deleteFolder是一个递归函数，类似于DFS思想<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteFileDemo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      <span class="comment">// 这里修改为自己的测试目录</span></div><div class="line">    File folder = <span class="keyword">new</span> File(<span class="string">"/tmp/java/"</span>);</div><div class="line">    deleteFolder(folder);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//删除文件及目录</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(File folder)</span> </span>&#123;</div><div class="line">    File[] files = folder.listFiles();</div><div class="line">        <span class="keyword">if</span>(files!=<span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">for</span>(File f: files) &#123;</div><div class="line">                <span class="keyword">if</span>(f.isDirectory()) &#123;</div><div class="line">                    deleteFolder(f);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    f.delete();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        folder.delete();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>RandomAccessFile不同于File，它提供了对文件内容的访问，可以<strong>读写文件且支持随机访问文件的任意位置</strong>。<br>RandomAccessFile读写用到文件指针，它的初始位置为0,可以用getFilePointer()方法获取文件指针的位置。下面是RandomAccessFile常用的方法。  </p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/RandomAccessFile.png" alt="fail"><br>public int read(int x) throws IOException 方法只读取一个字节，也就是x的低八位。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.RandomAccessFile ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo01</span></span>&#123;</div><div class="line">	<span class="comment">// 所有的异常直接抛出，程序中不再进行处理</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;	<span class="comment">// 指定要操作的文件</span></div><div class="line">		RandomAccessFile rdf = <span class="keyword">null</span> ;		<span class="comment">// 声明RandomAccessFile类的对象</span></div><div class="line">		rdf = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"rw"</span>) ;<span class="comment">// 读写模式，如果文件不存在，会自动创建</span></div><div class="line">		String name = <span class="keyword">null</span> ;</div><div class="line">		<span class="keyword">int</span> age = <span class="number">0</span> ;</div><div class="line">		name = <span class="string">"zhangsan"</span> ;			<span class="comment">// 字符串长度为8</span></div><div class="line">		age = <span class="number">30</span> ;					<span class="comment">// 数字的长度为4</span></div><div class="line">		rdf.writeBytes(name) ;		<span class="comment">// 将姓名写入文件之中</span></div><div class="line">		rdf.writeInt(age) ;			<span class="comment">// 将年龄写入文件之中</span></div><div class="line">		name = <span class="string">"lisi    "</span> ;			<span class="comment">// 字符串长度为8</span></div><div class="line">		age = <span class="number">31</span> ;					<span class="comment">// 数字的长度为4</span></div><div class="line">		rdf.writeBytes(name) ;		<span class="comment">// 将姓名写入文件之中</span></div><div class="line">		rdf.writeInt(age) ;			<span class="comment">// 将年龄写入文件之中</span></div><div class="line">		name = <span class="string">"wangwu  "</span> ;			<span class="comment">// 字符串长度为8</span></div><div class="line">		age = <span class="number">32</span> ;					<span class="comment">// 数字的长度为4</span></div><div class="line">		rdf.writeBytes(name) ;		<span class="comment">// 将姓名写入文件之中</span></div><div class="line">		rdf.writeInt(age) ;			<span class="comment">// 将年龄写入文件之中</span></div><div class="line">		rdf.close() ;				<span class="comment">// 关闭</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>写完之后，开始读取数据。写的时候可以将一个字符串写入，读的时候需要一个个的以字节的形式读取出来。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.RandomAccessFile ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccessFileDemo02</span></span>&#123;</div><div class="line">	<span class="comment">// 所有的异常直接抛出，程序中不再进行处理</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;	<span class="comment">// 指定要操作的文件</span></div><div class="line">		RandomAccessFile rdf = <span class="keyword">null</span> ;		<span class="comment">// 声明RandomAccessFile类的对象</span></div><div class="line">		rdf = <span class="keyword">new</span> RandomAccessFile(f,<span class="string">"r"</span>) ;<span class="comment">// 以只读的方式打开文件</span></div><div class="line">		String name = <span class="keyword">null</span> ;</div><div class="line">		<span class="keyword">int</span> age = <span class="number">0</span> ;</div><div class="line">		<span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>] ;	<span class="comment">// 开辟byte数组</span></div><div class="line">		<span class="comment">// 读取第二个人的信息，意味着要空出第一个人的信息</span></div><div class="line">		rdf.skipBytes(<span class="number">12</span>) ;		<span class="comment">// 跳过第一个人的信息</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">			b[i] = rdf.readByte() ;	<span class="comment">// 读取一个字节</span></div><div class="line">		&#125;</div><div class="line">		name = <span class="keyword">new</span> String(b) ;	<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">		age = rdf.readInt() ;	<span class="comment">// 读取数字</span></div><div class="line">		System.out.println(<span class="string">"第二个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line">		<span class="comment">// 读取第一个人的信息</span></div><div class="line">		rdf.seek(<span class="number">0</span>) ;	<span class="comment">// 指针回到文件的开头</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">			b[i] = rdf.readByte() ;	<span class="comment">// 读取一个字节</span></div><div class="line">		&#125;</div><div class="line">		name = <span class="keyword">new</span> String(b) ;	<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">		age = rdf.readInt() ;	<span class="comment">// 读取数字</span></div><div class="line">		System.out.println(<span class="string">"第一个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line">		rdf.skipBytes(<span class="number">12</span>) ;	<span class="comment">// 跳过第二个人的信息</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;</div><div class="line">			b[i] = rdf.readByte() ;	<span class="comment">// 读取一个字节</span></div><div class="line">		&#125;</div><div class="line">		name = <span class="keyword">new</span> String(b) ;	<span class="comment">// 将读取出来的byte数组变为字符串</span></div><div class="line">		age = rdf.readInt() ;	<span class="comment">// 读取数字</span></div><div class="line">		System.out.println(<span class="string">"第三个人的信息 --&gt; 姓名："</span> + name + <span class="string">"；年龄："</span> + age) ;</div><div class="line">		rdf.close() ;				<span class="comment">// 关闭</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>结果如下：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/result.png" alt="fail"> </p>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>在Java程序中所有的数据都是以<strong>流</strong>的方式进行<strong>传输或保存</strong>的，程序需要数据的时候要使用<strong>输入流</strong>读取数据，而当程序需要将一些数据保存起来的时候，就要使用<strong>输出流</strong>完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是<strong>字节文件</strong>。流涉及的领域很广：标准输入输出，文件的操作，网络上的数据流，字符串流，对象流，zip文件流等等。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Stream.png" alt="fail"><br>流具有<strong>方向性</strong>，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。<br>可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Information.jpg" alt="fail"><br>先上一个<strong>Java IO流类层次图</strong>，如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/JavaIO流类层次图.png" alt="fail" title="Java IO流类层次图"><br>是不是被吓到了？没关系，我们将通过一个个例子来学习这些功能。  </p>
<h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><h4 id="1-按操作数据类型分：字符流和字节流"><a href="#1-按操作数据类型分：字符流和字节流" class="headerlink" title="1.按操作数据类型分：字符流和字节流"></a>1.按操作数据类型分：字符流和字节流</h4><p><strong>字符流：</strong>Java中的字符流处理的最基本的单元是<strong>2字节的Unicode码元(char)</strong>，它通常用来处理文本数据，如字符、字符数组或字符串等。所谓Unicode码元，也就是一个Unicode代码单元，范围是0x0000~0xFFFF。在以上范围内的每个数字都与一个字符相对应，Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。然而与存储在内存中不同，存储在磁盘上的数据通常有着各种各样的编码方式。使用不同的编码方式，相同的字符会有不同的二进制表示。实际上字符流是这样工作的：  </p>
<ul>
<li>输出字符流：把要写入文件的字符序列(实际上是Unicode码元序列)转为指定编码方式下的字节序列，然后再写入到文件中。</li>
<li>输入字符流：把要读取的字节序列按指定编码方式解码为相应字符序列(实际上是Unicode码元序列从)从而可以存在内存中。 </li>
</ul>
<p>也就是说，所有的文件在<strong>硬盘</strong>或在<strong>传输</strong>时都是以<strong>字节</strong>的方式进行的，包括图片等都是<strong>按字节的方式存储</strong>的，而字符是只有在<strong>内存</strong>中才会形成。 </p>
<p><strong>字节流：</strong>Java中的字节流处理的最基本单位为<strong>单个字节(byte)</strong>，它通常用来处理二进制数据,如果要得到字节对应的字符需要强制类型转换。  </p>
<p><strong>两者比较：</strong><br>1.字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，所以它对多国语言支持性较好，如果要操作中文数据等，用字符流。<br>2.字符流只用来处理文本数据，字节流还可以用来处理媒体数据，如视频、音频、图片等。<br>3.字符流的两个<strong>抽象基类</strong>为Reader和Writer，字节流的两个<strong>抽象基类</strong>为InputStream和OutputStream。它们的具体子类名以基类名为后缀进行扩展。<br>4.字节流在操作的时候不会用到缓冲区(内存)，是直接对文件本身操作的，而字符流在操作的时候使用缓冲区。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/Compare.jpg" alt="fail"></p>
<p>以向一个文件输出”Hello world!”为例，我们分别使用字节流和字符流进行输出，且在使用完之后都不关闭流。</p>
<p>使用字节流不关闭执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOPractice</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="comment">// 第1步：使用File类找到一个文件    </span></div><div class="line">		     File f = <span class="keyword">new</span> File(<span class="string">"/home/xiejunyu/"</span>+</div><div class="line">             <span class="string">"桌面/text.txt"</span>);   </div><div class="line">		<span class="comment">// 第2步：通过子类实例化父类对象     </span></div><div class="line">	         OutputStream out = <span class="keyword">new</span> FileOutputStream(f); </div><div class="line">		<span class="comment">// 通过对象多态性进行实例化    </span></div><div class="line">		<span class="comment">// 第3步：进行写操作    </span></div><div class="line">		     String str = <span class="string">"Hello World!"</span>;      </div><div class="line">		<span class="comment">// 准备一个字符串    </span></div><div class="line">		     <span class="keyword">byte</span> b[] = str.getBytes();          </div><div class="line">		<span class="comment">// 字符串转byte数组    </span></div><div class="line">		     out.write(b);                      </div><div class="line">		<span class="comment">// 将内容输出    </span></div><div class="line">		 <span class="comment">// 第4步：关闭输出流    </span></div><div class="line">		    <span class="comment">// out.close();                  </span></div><div class="line">		<span class="comment">// 此时没有关闭    </span></div><div class="line">		        &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/1.png" alt="fail"><br>此时没有关闭字节流操作，但是文件中也依然存在了输出的内容，证明字节流是直接操作文件本身的。  </p>
<p>使用字符流不关闭执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.FileWriter;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.Writer;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOPractice</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		 <span class="comment">// 第1步：使用File类找到一个文件    </span></div><div class="line">        File f = <span class="keyword">new</span> File(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">        <span class="comment">// 第2步：通过子类实例化父类对象            </span></div><div class="line">        Writer  out = <span class="keyword">new</span> FileWriter(f);            </div><div class="line">        <span class="comment">// 第3步：进行写操作    </span></div><div class="line">        String str = <span class="string">"Hello World!"</span>;      </div><div class="line">        <span class="comment">// 准备一个字符串    </span></div><div class="line">        out.write(str);                    </div><div class="line">        <span class="comment">// 将内容输出    </span></div><div class="line">        <span class="comment">// 第4步：关闭输出流    </span></div><div class="line">        <span class="comment">// out.close();</span></div><div class="line">        <span class="comment">// 此时没有关闭    </span></div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/2.png" alt="fail"></p>
<p>程序运行后会发现文件中没有任何内容，这是因为字符流操作时使用了缓冲区，而在关闭字符流时会强制性地将缓冲区中的内容进行输出，但是如果程序没有关闭字符流，缓冲区中的内容是无法输出的，所以得出结论：<strong>字符流使用了缓冲区，而字节流没有使用缓冲区。</strong>如果想让缓冲区中的内容输出，要么关闭流强制刷新缓冲区，要么调用flush方法冲刷缓冲区。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源(如文件或数据库)，则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。<br>在字符流的操作中，所有的字符都是在内存中形成的，在输出前会将所有的内容暂时保存在内存之中，所以使用了缓冲区暂存数据。  </p>
<p><strong>建议：</strong><br>1.虽然不关闭字节流不影响数据的输出，且后续JVM会自动回收这部分内存，但还是建议在使用完任何流对象之后关闭流。<br>2.使用流对象都要声明或抛出IOException<br>3.在创建一个文件时，如果目录下有同名文件将被覆盖<br>4.在写文件时，如果文件不存在，会在创建输出流对象并绑定文件时自动创建文件，不必使用File的exists方法提前检测<br>4.在读取文件时，必须使用File的exists方法提前检测来保证该文件已存在，否则抛出FileNotFoundException</p>
<h4 id="2-按流向分：输入流和输出流"><a href="#2-按流向分：输入流和输出流" class="headerlink" title="2.按流向分：输入流和输出流"></a>2.按流向分：输入流和输出流</h4><p>输入流：程序从输入流读取数据源。数据源包括外界(键盘、文件、网络等)，即是将数据源读入到程序的通信通道。输入流主要包括两个抽象基类：InputStream(字节输入流)和Reader(字符输入流)及其扩展的具体子类。<br>输出流：程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道。输出流主要包括两个抽象基类：OutputStream(字节输出流)和Writer(字符输出流)及其扩展的具体子类。 </p>
<h4 id="3-按功能分：节点流和处理流"><a href="#3-按功能分：节点流和处理流" class="headerlink" title="3.按功能分：节点流和处理流"></a>3.按功能分：节点流和处理流</h4><p>按照流是否<strong>直接</strong>与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两类。<br>节点流：程序用于直接操作目标设备所对应的类叫节点流。(低级流)<br>处理流：程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据，这个间接流类就是处理流。处理流可以看成是对已存在的流进行连接和封装的流。(高级流)  </p>
<p><strong>注意：在使用到处理流对流进行连接和封装时，读写完毕要关闭所有出现的流，包括节点流和处理流。</strong>  </p>
<h5 id="1-节点流"><a href="#1-节点流" class="headerlink" title="(1) 节点流"></a>(1) 节点流</h5><p><img src="/2017/11/28/Java学习总结之Java-IO系统/节点流.png" alt="fail">  </p>
<ul>
<li>File 文件流。对文件进行读、写操作：FileReader、FileWriter、FileInputStream、FileOutputStream。  </li>
<li>Memory 流。<br>向内存数组读写数据: CharArrayReader与 CharArrayWriter、ByteArrayInputStream与ByteArrayOutputStream。<br>向内存字符串读写数据：StringReader、StringWriter、StringBufferInputStream。  </li>
<li>Pipe管道流：实现管道的输入和输出(进程间通信)： PipedReader与PipedWriter、PipedInputStream与PipedOutputStream。    </li>
</ul>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/节点流示意图.png" alt="fail">  </p>
<h5 id="1-处理流"><a href="#1-处理流" class="headerlink" title="(1) 处理流"></a>(1) 处理流</h5><p><img src="/2017/11/28/Java学习总结之Java-IO系统/处理流.png" alt="fail">  </p>
<ul>
<li>Buffering缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：BufferedReader与BufferedWriter、BufferedInputStream与BufferedOutputStream。   </li>
<li>Filtering 滤流：在数据进行读或写时进行过滤：FilterReader与FilterWriter、FilterInputStream与FilterOutputStream。  </li>
<li>Converting between Bytes and Characters 转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换(Stream到Reader)：InputStreamReader、OutputStreamWriter。   </li>
<li>Object Serialization 对象流 ：ObjectInputStream、ObjectOutputStream。   </li>
<li>DataConversion数据流：按基本数据类型读、写(处理的数据是Java的基本类型)：DataInputStream、DataOutputStream 。 </li>
<li>Counting计数流：在读入数据时对行记数 ：LineNumberReader、LineNumberInputStream。 </li>
<li>Peeking Ahead预读流： 通过缓存机制，进行预读 ：PushbackReader、PushbackInputStream。   </li>
<li>Printing打印流： 包含方便的打印方法 ：PrintWriter、PrintStream。  </li>
</ul>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/处理流示意图.png" alt="fail">  </p>
<h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>在Java中，从控制台输入有三种方法：  </p>
<h4 id="1-使用标准输入流对象System-in"><a href="#1-使用标准输入流对象System-in" class="headerlink" title="1.使用标准输入流对象System.in"></a>1.使用标准输入流对象System.in</h4><p>System.in是System中内置的InputStream类对象，它的read方法一次只读入<strong>一个字节</strong>数据，返回0 ~ 255的一个byte值,一般用来读取一个字符，需要强制类型转换为char类型，而我们通常要取得一个字符串或一组数字，故这种方法不常用。下面给出这种方法的一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharTest</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		 <span class="keyword">try</span>&#123;   </div><div class="line">		 System.out.print(<span class="string">"Enter a Char:"</span>);   </div><div class="line">		 <span class="keyword">char</span> i = (<span class="keyword">char</span>)System.in.read();   </div><div class="line">		 System.out.println(<span class="string">"Yout Enter Char is:"</span> + i);  		  &#125;   </div><div class="line">		 <span class="keyword">catch</span>(IOException e)&#123;   </div><div class="line">		    e.printStackTrace();   </div><div class="line">		 &#125;   </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>使用这种方法必须提供try-catch块或者在main方法首部声明IOException异常，因为System.in是一个流对象</strong>  </p>
<h4 id="2-使用Scanner类"><a href="#2-使用Scanner类" class="headerlink" title="2.使用Scanner类"></a>2.使用Scanner类</h4><p>Scanner类功能十分强大，可以读入字符串、整数、浮点数、布尔类型值等等。下面是例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);   </div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Name:"</span>);   </div><div class="line">    String name = sc.nextLine();  <span class="comment">//读取字符串型输入   </span></div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Age:"</span>);   </div><div class="line">    <span class="keyword">int</span> age = sc.nextInt();    <span class="comment">//读取整型输入   </span></div><div class="line">    System.out.println(<span class="string">"ScannerTest, Please Enter Salary:"</span>);   </div><div class="line">    <span class="keyword">float</span> salary = sc.nextFloat(); <span class="comment">//读取float型输入   </span></div><div class="line">    System.out.println(<span class="string">"Your Information is as below:"</span>);   </div><div class="line">    System.out.println(<span class="string">"Name:"</span> + name +<span class="string">"\n"</span> + <span class="string">"Age:"</span>+age </div><div class="line">    + <span class="string">"\n"</span>+<span class="string">"Salary:"</span>+salary);   </div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong><br>1.用nextXXX()读入XXX类型的数据，XXX可以是除了char外的所有基本数据类型，还可以是BigInteger或BigDecimal，其中凡是整型类型的数据还可以指定radix(进制)，可以用next()和nextLine()读取一个字符串或一行字符<br>2.next()和nextLine()的区别：<br>next()</p>
<ul>
<li>一定要读取到有效字符后才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串，除非用useDelimeter方法修改分隔符。  </li>
</ul>
<p>nextLine()</p>
<ul>
<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>可以获得空白。</li>
</ul>
<p>3.可以用循环配合hasNextXXX方法判断输入是否继续<br>4.Scanner类没有直接提供读取一个字符的方法，如果要读取一个字符，有三种方法，一是<strong>读入一个字符串后取字符串的第一个字符</strong>，二是使用<strong>System.in的read方法</strong>，三是使用<strong>字符流</strong>读入</p>
<p>更多Scanner的用法之前已经在<a href="http://habitdiary.cn/2017/10/10/Java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8BJava%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/">Java学习总结之Java基本程序设计结构</a>中总结过了，不再赘述。</p>
<h4 id="3-使用BufferedReader对象"><a href="#3-使用BufferedReader对象" class="headerlink" title="3.使用BufferedReader对象"></a>3.使用BufferedReader对象</h4><p>可以把 System.in 包装在一个 BufferedReader 对象中来创建一个<strong>字符流</strong>。<br>下面是创建 BufferedReader 的基本语法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </div><div class="line">                      InputStreamReader(System.in));</div></pre></td></tr></table></figure></p>
<p>其中，System.in是一个InputStream对象(字节流)，使用InputStreamReader作为桥梁，将字节流转换为字符流，然后再使用BufferedReader进行进一步包装。<br>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符(读入一个用0~65535之间的整数表示的字符，需要强制类型转换为char类型，如果已到达流末尾，则返回 -1)，或者用 readLine() 方法读取一个字符串。下面是例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"><span class="comment">//必须要处理java.io.IOException异常</span></div><div class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader</div><div class="line">  (System.in ));</div><div class="line">  <span class="comment">//java.io.InputStreamReader继承了Reader类</span></div><div class="line">  String read = <span class="keyword">null</span>;</div><div class="line">  System.out.print(<span class="string">"输入数据："</span>);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">   read = br.readLine();</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">   e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">  System.out.println(<span class="string">"输入数据："</span>+read);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRRead</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line">    <span class="comment">// 使用 System.in 创建 BufferedReader </span></div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </div><div class="line">                       InputStreamReader(System.in));</div><div class="line">    System.out.println(<span class="string">"输入字符, 按下 'q' 键退出。"</span>);</div><div class="line">    <span class="comment">// 读取字符</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       c = (<span class="keyword">char</span>) br.read();</div><div class="line">       System.out.println(c);</div><div class="line">    &#125; <span class="keyword">while</span>(c != <span class="string">'q'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的程序读取和显示字符行直到你输入了单词”end”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 BufferedReader 在控制台读取字符</span></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRReadLines</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="comment">// 使用 System.in 创建 BufferedReader </span></div><div class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></div><div class="line">                            InputStreamReader(System.in));</div><div class="line">    String str;</div><div class="line">    System.out.println(<span class="string">"Enter lines of text."</span>);</div><div class="line">    System.out.println(<span class="string">"Enter 'end' to quit."</span>);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       str = br.readLine();</div><div class="line">       System.out.println(str);</div><div class="line">    &#125; <span class="keyword">while</span>(!str.equals(<span class="string">"end"</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>在ACM等算法竞赛中，我们常常也会使用Java，在输入数据时有以下几点注意：</strong><br>1.hasXXX等价于C++中读到文件末尾(EOF)<br>2.使用BufferedReader输入会比Scanner输入快十倍左右!</p>
<h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><p>控制台的输出由 print() 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类的一个对象。<br>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。<br>PrintStream 定义 write() 的最简单格式如下所示：<br><code>void write(int byteval)</code>该方法将 byteval 的低八位字节写到流中,即System.out的write方法一次只能写一个字节(类比System.in的read方法一次只能读取一个字节)。<br>下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="comment">// 演示 System.out.write().</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDemo</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> b; </div><div class="line">      b = <span class="string">'A'</span>;<span class="comment">//向上类型转换</span></div><div class="line">      System.out.write(b);</div><div class="line">      System.out.write(<span class="string">'\n'</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：write() 方法不经常使用，因为 print() 和 println() 方法用起来更为方便。</strong></p>
<h3 id="字节流-OutputStream、InputStream"><a href="#字节流-OutputStream、InputStream" class="headerlink" title="字节流(OutputStream、InputStream)"></a>字节流(OutputStream、InputStream)</h3><p>字节流主要是操作byte类型的数据，以byte数组为准，主要操作类是OutputStream、InputStream。<br>由于文件读写最为常见，我们先讨论两个重要的字节流 FileInputStream(文件输入流) 和 FileOutputStream(文件输出流)，分别是抽象类InputStream和OutputStream的具体子类：</p>
<p><strong>FileInputStream</strong><br>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。<br>有多种构造方法可用来创建对象。<br>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/java/hello"</span>);</div></pre></td></tr></table></figure></p>
<p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">InputStream in = <span class="keyword">new</span> FileInputStream(f);</div></pre></td></tr></table></figure></p>
<p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/InputStream.png" alt="fail" title="InputStream"><br>下面是一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	InputStream f  = <span class="keyword">new</span> FileInputStream</div><div class="line">	(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>((c =  f.read()) != -<span class="number">1</span>) </div><div class="line">    <span class="comment">//这里也可以先用available方法得到可读的字节数</span></div><div class="line">	System.out.println((<span class="keyword">char</span>)c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们需要创建一个byte[]来保存读取的字节时，如果数组太小，无法完整读入数据，如果太大又会造成内存浪费。<strong>可以使用File类的length方法得到文件的数据字节数，从而有效确定byte数组的大小。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// 创建一个FileInputStream对象</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">			<span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</div><div class="line">			fis.read(b,<span class="number">0</span>,<span class="number">5</span>); </div><div class="line">            <span class="comment">/*把字节从文件读入b数组，从b数组的0位置开始存放，</span></div><div class="line"><span class="comment">            读取5个字节*/</span></div><div class="line">			System.out.println(<span class="keyword">new</span> String(b));</div><div class="line">			fis.close();</div><div class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意:</strong> 每调用一次read方法,当前读取在文件中的位置就会向后移动一个字节或者移动byte[]的长度(read的两个重载方法)，已经到文件末尾会返回-1，可以通过read方法返回-1判断是否读到文件末尾，也可以使用available方法返回下一次可以不受阻塞读取的字节数来读取。<strong>FileInputStream不支持mark和reset方法进行重复读取。BufferedInputStream支持此操作。</strong>  </p>
<p><strong>FileOutputStream</strong><br>该类用来创建一个文件并向文件中写数据。<br><strong>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</strong><br>有两个构造方法可以用来创建 FileOutputStream 对象。<br>使用字符串类型的文件名来创建一个输出流对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/java/hello"</span>)</div></pre></td></tr></table></figure></p>
<p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</div></pre></td></tr></table></figure></p>
<p>之前的所有操作中，如果重新执行程序，则肯定会覆盖文件中的已有内容，那么此时就可以通过FileOutputStream向文件中追加内容，FileOutputStream的另外一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file,<span class="keyword">boolean</span> append)</span></span></div></pre></td></tr></table></figure></p>
<p>在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。程序代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/java/hello"</span>);</div><div class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f,<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileOutputStream.png" alt="fail" title="FileOutputStream"><br>当有一个字符串时，可以用getBytes方法转为byte数组用于字节流的输出。  </p>
<p>下面是一个演示 InputStream 和 OutputStream 用法的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      <span class="keyword">byte</span> bWrite[] = <span class="string">"ABC"</span>.getBytes();</div><div class="line">      OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x &lt; bWrite.length ; x++)&#123;</div><div class="line">      os.write(bWrite[x] ); <span class="comment">// writes the bytes</span></div><div class="line">    &#125;</div><div class="line">    os.close();</div><div class="line"> </div><div class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"/home/xiejunyu/桌面/test.txt"</span>);</div><div class="line">    <span class="keyword">int</span> size = is.available();</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; size; i++)&#123;</div><div class="line">      System.out.print((<span class="keyword">char</span>)is.read() + <span class="string">"  "</span>);</div><div class="line">    &#125;</div><div class="line">      is.close();</div><div class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">      System.out.print(<span class="string">"Exception"</span>);</div><div class="line">    &#125;  </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的程序首先创建文件test.txt，并把给定的数字以二进制形式写进该文件，同时输出到控制台上。<br>以上代码由于是二进制写入，可能存在乱码，你可以使用以下代码实例来解决乱码问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileStreamTest2</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    </div><div class="line">    File f = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</div><div class="line">    FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(f);</div><div class="line">    <span class="comment">// 构建FileOutputStream对象,文件不存在会自动新建;如果存在会覆盖原文件</span></div><div class="line">    </div><div class="line">    OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fop, <span class="string">"UTF-8"</span>);</div><div class="line">    <span class="comment">// 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"中文输入"</span>);</div><div class="line">    <span class="comment">// 写入到缓冲区</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"\r\n"</span>);</div><div class="line">    <span class="comment">//换行</span></div><div class="line">    </div><div class="line">    writer.append(<span class="string">"English"</span>);</div><div class="line">    <span class="comment">// 刷新缓冲区,写入到文件,如果下面已经没有写入的内容了,直接close也会写入</span></div><div class="line">    </div><div class="line">    writer.close();</div><div class="line">    <span class="comment">//关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉</span></div><div class="line">    </div><div class="line">    fop.close();</div><div class="line">    <span class="comment">// 关闭输出流,释放系统资源</span></div><div class="line"> </div><div class="line">    FileInputStream fip = <span class="keyword">new</span> FileInputStream(f);</div><div class="line">    <span class="comment">// 构建FileInputStream对象</span></div><div class="line">    </div><div class="line">    InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fip, <span class="string">"UTF-8"</span>);</div><div class="line">    <span class="comment">// 构建InputStreamReader对象,编码与写入相同</span></div><div class="line"> </div><div class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">    <span class="keyword">while</span> (reader.ready()) &#123;</div><div class="line">      sb.append((<span class="keyword">char</span>) reader.read());</div><div class="line">      <span class="comment">// 转成char加到StringBuffer对象中</span></div><div class="line">    &#125;</div><div class="line">    System.out.println(sb.toString());</div><div class="line">    reader.close();</div><div class="line">    <span class="comment">// 关闭读取流</span></div><div class="line">    </div><div class="line">    fip.close();</div><div class="line">    <span class="comment">// 关闭输入流,释放系统资源</span></div><div class="line"> </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上例子证明：在对多国语言的支持上，字符流表现更优，此时应使用字符流而不是字节流。  </p>
<p>还可以用InputStream和OutputStream配合进行文件的复制，即读取原件数据，写入副本文件。<br>复制有两种实现方式：<br>实现一：将源文件中的内容全部读取进来，之后一次性的写入到目标文件<br>实现二：边读边写  </p>
<p>在实际开发中建议使用边读边写的方式，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// 文件拷贝</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			FileInputStream fis=<span class="keyword">new</span> FileInputStream(<span class="string">"happy.gif"</span>);</div><div class="line">			FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="string">"happycopy.gif"</span>);</div><div class="line">			<span class="keyword">int</span> n=<span class="number">0</span>;</div><div class="line">			<span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">			<span class="keyword">while</span>((n=fis.read(b))!=-<span class="number">1</span>)&#123; </div><div class="line">            <span class="comment">/*循环读取，每次1024个字节，最后一次可能不满1024。</span></div><div class="line"><span class="comment">            后面的字节覆盖前面的字节，不必担心数组溢出。*/</span></div><div class="line">				fos.write(b,<span class="number">0</span>,n); <span class="comment">//n是实际读取到的字节数，如果写fos.write(b)，会造成最后一次数组未满的情况也写1024个字节，从而造成副本比原件略大</span></div><div class="line">			&#125;</div><div class="line">			fis.close();</div><div class="line">			fos.close();</div><div class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>实际上边读边写也分为三种方式：<br>1.批量拷贝(循环读取，每次读入一个byte数组)<br>2.缓冲拷贝(使用缓冲流)<br>3.批量+缓冲拷贝(循环批量读取到字节数组中，然后使用缓冲输出流写入到文件)  </p>
<p><strong>第三种方式是最快的。</strong>  </p>
<p><strong>注意：</strong>InputStream的int read()方法读取一个字节，并用这个字节填充整型的低八位并返回，OutputStream的void write(int x)写入x的低八位，如果要写入一个int，需要移位并写4次。读写基本数据类型建议使用DataInputStream和DataOutputStream。</p>
<h3 id="字符流-Writer、Reader"><a href="#字符流-Writer、Reader" class="headerlink" title="字符流(Writer、Reader)"></a>字符流(Writer、Reader)</h3><p>Java提供了两个操作字符的字符流基类，分别是Writer和Reader。先来了解两个用于读写文件的字符流FileReader(字符输入流)和FileWriter(字符输出流)：  </p>
<p><strong>FileReader</strong><br>FileReader类从InputStreamReader类继承而来。该类按字符读取流中数据。可以通过以下几种构造方法创建需要的对象。<br>在给定从中读取数据的 File 的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(File file)</div></pre></td></tr></table></figure></p>
<p>在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(FileDescriptor fd)</div></pre></td></tr></table></figure></p>
<p>在给定从中读取数据的文件名的情况下创建一个新 FileReader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileReader(String fileName)</div></pre></td></tr></table></figure></p>
<p>创建FIleReader对象成功后，可以参照以下列表里的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileReader.png" alt="fail" title="FileReader">  </p>
<p><strong>FileWriter</strong><br>FileWriter 类从 OutputStreamWriter 类继承而来。该类按字符向流中写入数据。可以通过以下几种构造方法创建需要的对象。<br>在给出 File 对象的情况下构造一个 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(File file)</div></pre></td></tr></table></figure></p>
<p>在给出 File 对象的情况下构造一个 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(File file, <span class="keyword">boolean</span> append)</div></pre></td></tr></table></figure></p>
<p>构造与某个文件描述符相关联的 FileWriter 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(FileDescriptor fd)</div></pre></td></tr></table></figure></p>
<p>在给出文件名的情况下构造 FileWriter 对象，它具有指示是否挂起写入数据的 boolean 值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FileWriter(String fileName, <span class="keyword">boolean</span> append)</div></pre></td></tr></table></figure></p>
<p>创建FileWriter对象成功后，可以参照以下列表里的方法操作文件。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/FileWriter.png" alt="fail" title="FileWriter"><br><strong>字符流的操作比字节流操作方便一点，就是可以直接输出字符串。不在用再像之前那样进行字节转换操作了。使用字符流默认情况下依然是覆盖已有的文件，如果想追加的话，则直接在FileWriter上增加一个可追加的标记即可。</strong></p>
<p>下面的例子演示了FileReader和FileWriter的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRead</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">      File file = <span class="keyword">new</span> File(<span class="string">"Hello1.txt"</span>);</div><div class="line">      <span class="comment">// 创建文件</span></div><div class="line">      file.createNewFile();</div><div class="line">      <span class="comment">// creates a FileWriter Object</span></div><div class="line">      FileWriter writer = <span class="keyword">new</span> FileWriter(file); </div><div class="line">      <span class="comment">// 向文件写入内容</span></div><div class="line">      writer.write(<span class="string">"This\n is\n an\n example\n"</span>); </div><div class="line">      writer.flush();</div><div class="line">      writer.close();</div><div class="line">      <span class="comment">//创建 FileReader 对象</span></div><div class="line">      FileReader fr = <span class="keyword">new</span> FileReader(file); </div><div class="line">      <span class="keyword">char</span> [] a = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">50</span>];</div><div class="line">      fr.read(a); <span class="comment">// 从数组中读取内容</span></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">char</span> c : a)</div><div class="line">          System.out.print(c); <span class="comment">// 一个个打印字符</span></div><div class="line">      fr.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="字节-字符转换流-OutputStreamWriter、InputStreamReader"><a href="#字节-字符转换流-OutputStreamWriter、InputStreamReader" class="headerlink" title="字节-字符转换流(OutputStreamWriter、InputStreamReader)"></a>字节-字符转换流(OutputStreamWriter、InputStreamReader)</h3><p>在整个IO包中，实际上就是分为字节流和字符流，但是除了这两个流之外，还存在了一组字节流-字符流的转换类。  </p>
<p><strong>InputStreamReader</strong><br>InputStreamReader是<strong>字节流</strong>通向<strong>字符流</strong>的桥梁，它使用指定的charset读取字节并将其解码为字符。它拥有一个InputStream类型的变量，并继承了Reader，使用了对象的适配器模式，如图所示：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/InputStreamReader.jpg" alt="fail"><br>根据InputStream的实例创建InputStreamReader的方法有4种：<br>1.根据默认字符集创建<br>InputStreamReader(InputStream in)<br>2.使用给定字符集创建<br>InputStreamReader(InputStream in, Charset cs)<br>3.使用给定字符集解码器创建<br>InputStreamReader(InputStream in, CharsetDecoder dec)<br>4.使用指定字符集名字符串创建<br>InputStreamReader(InputStream in, String charsetName)</p>
<p>后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。<br><strong>注意：</strong>在对文件进行读写操作时，默认使用的是项目的编码，如果要读写其他编码方式的文件，要在构造输入输出流时指定对应的编码。这一般通过字节-字符转换流完成。   </p>
<p>每次调用InputStreamReader中的一个read()方法都会导致从底层输入流读取一个或多个字节。要启用从字节到字符的有效转换，可以提前从底层流读取更多的字节，使其超过满足当前读取操作所需的字节。共有3个可用的read()方法：  </p>
<p>int read(); //读取单个字符<br>int read(char[] cbuf, int offset, int length);<br>//将字符读入数组中的某一部分<br>boolean ready(); //判断此流是否已经准备好用于读取 </p>
<p>使用字符流的形式读取字节流的文件，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo01</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + </div><div class="line">        <span class="string">"test.txt"</span>) ;	</div><div class="line">		Reader reader = <span class="keyword">new</span> InputStreamReader</div><div class="line">        (<span class="keyword">new</span> FileInputStream(f)) ;	</div><div class="line">        <span class="comment">// 将字节流变为字符流</span></div><div class="line">		<span class="keyword">char</span> c[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>] ;</div><div class="line">		<span class="keyword">int</span> len = reader.read(c) ;	<span class="comment">// 读取</span></div><div class="line">		reader.close() ;	<span class="comment">// 关闭</span></div><div class="line">		System.out.println(<span class="keyword">new</span> String(c,<span class="number">0</span>,len)) ;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>OutputStreamWriter</strong><br>OutputStreamWriter是<strong>字符流</strong>通向<strong>字节流</strong>的桥梁，可使用指定的charset将要写入流中的字符编码成字节。因此，它拥有一个OutputStream类型的变量，并继承了Writer，使用对象的适配器模式,如图所示：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/OutputStreamWriter.jpg" alt="fail" title="OutputStreamWriter"><br>根据OutputStream的实例创建OutputStreamWriter的方法有4种：  </p>
<p>1.根据默认字符集创建<br>OutputStreamReader(OutputStream out)  </p>
<p>2.使用给定字符集创建<br>OutputStreamReader(OutputStream out, Charset cs)       </p>
<p>3.使用给定字符集解码器创建<br>OutputStreamReader(OutputStream out, CharsetDecoder dec)  </p>
<p>4.使用指定字符集名字符串创建<br>OutputStreamReader(OutputStream out, Stroutg charsetName)        </p>
<p>后面的3个构造函数都制定了一个字符集，最后一个是最简单的，可以直接指定字符集的名称来创建，例如UTF-8等。  </p>
<p>每次调用write()方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给write()方法的字符没有缓冲。共有3个可用的write()方法：<br>void write(char[] cbuf, int off, int len); //写入字符数组的某一部分<br>void write(int c); //写入单个字符<br>void write(String str, int off, int len); //写入字符串的某一部分 </p>
<p>例如：将字节的文件输出流，以字符的形式输出。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo01</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;	</div><div class="line">		File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</div><div class="line">		Writer out = <span class="keyword">new</span> OutputStreamWriter</div><div class="line">        (<span class="keyword">new</span> FileOutputStream(f)) ;	<span class="comment">// 字节流变为字符流</span></div><div class="line">	    out.write(<span class="string">"hello world!!"</span>) ;	</div><div class="line">           <span class="comment">// 使用字符流输出</span></div><div class="line">		out.close() ;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>特别说明：</strong>OutputStreamWriter是字符流到字节流的桥梁，这不表示OutputStreamWriter接收一个字符流并将其转换为字节流，恰恰相反，其接收的OutputStream是一个字节流，而它本身是一个字符流。<strong>那为什么说它是字符流到字节流的桥梁呢？</strong><br>我们以文件操作为例，之前已经提到，在内存中数据是以字符形式存在的，而在文件中数据是以字节形式保存的。所以在<strong>内存</strong>中的<strong>字符数据</strong>需要通过OutputStreamWriter变为<strong>字节流</strong>才能保存在文件之中，读取的时候需要将读入的<strong>字节流</strong>通过InputStreamReader变为<strong>字符流</strong>。<br>但OutputStreamWriter和InputStreamReader都是字符流，也就是说，OutputStreamWriter以字符输出流形式操作了字节的输出流，但实际上还是以字节的形式输出。而InputStreamReader，虽然以字符输入流的形式操作，但实际上还是使用的字节流输入，也就是说，传输或者是从文件中读取数据的时候，文件中真正保存的数据永远是字节。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/change.png" alt="fail">  </p>
<p>输入流和输出流要指定相同的字符集才能避免乱码！</p>
<p><strong>FileWriter和FileReader的说明</strong><br>从JDK文档中可以知道FileOutputStream是OutputStream的直接子类，FileInputStream也是InputStream的直接子类，但是在字符流文件的两个操作类却有一些特殊，FileWriter并不直接是Writer的子类，而是转换流OutputStreamWriter的子类，而FileReader也不直接是Reader的子类，而是转换流InputStreamReader的子类，那么从这两个类的继承关系就可以清楚的发现，不管是是使用字节流还是字符流实际上最终都是以字节形式操作输出流的。</p>
<h3 id="缓冲流-BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream"><a href="#缓冲流-BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream" class="headerlink" title="缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)"></a>缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)</h3><p>缓冲流是一系列处理流(包装流)，目的是为了提高I/O效率，它们为I/O提供了内存缓冲区，这是一种常见的性能优化，增加缓冲区的两个目的：<br>(1)允许Java的I/O一次不只操作一个字符，这样提高了整个系统的性能<br>(2)由于有缓冲区，使得在流上执行skip、mark和reset方法都成为可能。<br>如果没有缓冲区，每次调用 read() 或 write()方法都会对文件进行读或写字节，在文件和内存之间发生字节和字符的转换，这是极其低效的。  </p>
<p><strong>BufferedReader</strong><br>BufferedReader是一个包装类，是为了提高读效率提供的，其可以接收一个Reader,然后用readLine()逐行读入字符流，直到遇到换行符为止（相当于反复调用Reader类对象的read()方法读入多个字符）。<br><strong>因此，建议用 BufferedReader 包装所有其 read() 操作可能开销很高的 Reader（如 FileReader 和 InputStreamReader),如：</strong>   </p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/Buffer.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedReader1.png" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedReader2.png" alt="fail"> </p>
<p> markSupported 判断该输入流能支持 mark 和 reset 方法。mark 用于标记当前位置，readlimit 制定可以重新读取的最大字节数，如果标记后读取的字节数不超过 readlimit 可以用 reset 回到标志位置重复读取。</p>
<p><strong>BufferedWriter</strong><br>同理建议用BfferedWriter包装所有其write()操作可能开销很高的Writer(如FileWriter和OutputStreamWriter)<br><img src="/2017/11/28/Java学习总结之Java-IO系统/BufferedWriter.png" alt="fail" title="BufferedWriter">    </p>
<p><strong>BufferedInputStream</strong><br>BufferedInputStream用于包装其他较为缓慢的InputStream<br>构造方法摘要  </p>
<ul>
<li>BufferedInputStream(InputStream in)<br>创建一个使用默认大小输入缓冲区的缓冲字节输入流</li>
<li>BufferedInputStream(InputStream in, int size)<br>创建一个使用指定大小输入缓冲区的缓冲字节输入流  </li>
</ul>
<p>方法摘要  </p>
<ul>
<li>public int read();<br>从该输入流中读取一个字节</li>
<li>public int read(byte[] b,int off,int len);<br>从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。  </li>
</ul>
<p><strong>BufferedOutputStream</strong><br>BufferedOutputStream用于包装其他较为缓慢的OutputStream<br>构造方法摘要  </p>
<ul>
<li>BufferedOutputStream(OutputStream out);<br>创建一个使用默认大小输入缓冲区的缓冲字节输出流</li>
<li>BufferedOutputStream(OutputStream out,int size);<br>创建一个使用默认大小输入缓冲区的缓冲字节输出流  </li>
</ul>
<p>方法摘要  </p>
<ul>
<li>public void write(int b);<br>向输出流中输出一个字节  </li>
<li>public void write(byte[] b,int off,int len);<br>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。  </li>
<li>public void flush();<br>刷新此缓冲的输出流。这迫使所有缓冲的输出字节被写出到底层输出流中。  </li>
</ul>
<p><strong>其他</strong><br>（1）缓冲输入流BufferedInputSTream除了支持read和skip方法意外，还支持其父类的mark和reset方法;<br>（2）BufferedReader提供了一种新的ReadLine方法用于读取一行字符串（以\r或\n分隔）;<br>（3）BufferedWriter提供了一种新的newLine方法用于写入一个行分隔符;<br>（4）<strong>对于输出的缓冲流，BufferedWriter和BufferedOutputStream，写出的数据会先在缓冲区(由缓冲流提供的一个字节数组，是不可见的)中缓存，直到缓冲区满了会自动写数据到输出流，如果缓冲区未满，可以使用flush方法将会使缓冲区的数据强制写出。关闭输出流也会造成缓冲区中残留的数据被写出。注意BufferedReader和BufferedInputStream没有flush方法，因为flush只用于输出到文件时。</strong>  </p>
<h3 id="打印流-PrintStream、PrintWriter"><a href="#打印流-PrintStream、PrintWriter" class="headerlink" title="打印流(PrintStream、PrintWriter)"></a>打印流(PrintStream、PrintWriter)</h3><p>在整个IO包中，打印流是<strong>输出信息最方便</strong>的类，主要包含字节打印流(PrintStream)和字符打印流(PrintWriter)。打印流提供了非常方便的打印功能，可以打印任何的数据类型，例如：小数、整数、字符串等等。<br>相较OutputStream在输出时的各种麻烦(比如要将String转为byte[]才能输出)打印流中可以方便地进行输出。  </p>
<p><strong>PrintStream</strong><br>1、public PrintStream(File file) throws FileNotFoundException<br>//构造方法 通过一个File对象实例化PrintStream类  </p>
<p>2、public PrintStream(OutputStream out)<br>//构造方法 接收OutputStream对象，实例化PrintStream类  </p>
<p>3、public PrintStream printf(Locale l, String format, Object …arg)<br>//普通方法 根据指定的Locale进行格式化输出</p>
<p>4、public PrintStream printf(String format,Object … arg)<br>//普通方法 根据本地环境进行格式化输出</p>
<p>5、public void print(boolean b)<br>//普通方法 此方法被重载很多次，输出任意数据</p>
<p>6、public void println(boolean b)<br>//普通方法 此方法被重载很多次，输出任意数据后换行  </p>
<p><strong>打印流的好处：</strong>在PrintStream中定义的构造方法中可以清楚的发现有一个构造方法可以直接接收OutputStream类的实例，这是因为与OutputStream相比起来，PrintStream可以更加方便的输出数据，这就好比将OutputStream重新包装了一下，使之输出更加方便。  </p>
<p><strong>PrintWriter</strong><br><strong>构造方法</strong>  </p>
<p>//使用指定文件创建不具有自动行刷新的新 PrintWriter<br>public PrintWriter(File file);</p>
<p>//创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter<br>public PrintWriter(File file,String csn);</p>
<p>//根据现有的 OutputStream 创建不带自动行刷新的新PrintWriter<br>public PrintWriter(OutputStream out);</p>
<p>//通过现有的 OutputStream 创建新的 PrintWriter(具有自动行刷新)<br>public PrintWriter(OutputStream out,boolean autoFlush);</p>
<p>//创建具有指定文件名称且不带自动行刷新的新PrintWriter<br>public PrintWriter(String fileName);</p>
<p>//创建具有指定文件名称和字符集且不带自动行刷新的PrintWriter<br>public PrintWriter(String fileName,String csn);</p>
<p>//创建新 PrintWriter(具有自动行刷新)<br>public PrintWriter(Writer out,boolean autoFlush)   </p>
<p><strong>常用方法</strong><br>//打印boolean值<br>public void print(boolean b)<br>//打印 boolean 值，然后终止该行<br>public void println(boolean x)</p>
<p>//打印字符<br>public void print(char c)<br>//打印字符，然后终止该行<br>public void println(char x)</p>
<p>//打印字符数组<br>public void print(char[] s)<br>//打印字符数组，然后终止该行<br>public void println(char[] x)</p>
<p>//打印 double 精度浮点数<br>public void print(double d)<br>//打印 double 精度浮点数,然后终止该行<br>public void println(double x)</p>
<p>//打印一个浮点数<br>public void print(float f)<br>//打印浮点数，然后终止该行<br>public void println(float x)  </p>
<p>//打印整数<br>public void print(int i)<br>//打印整数，然后终止该行<br>public void println(int x)</p>
<p>//打印 long 整数<br>public void print(long l)<br>//打印 long 整数，然后终止该行<br>public void println(long x)</p>
<p>//打印对象<br>public void print(Object obj)<br>//打印 Object，然后终止该行<br>public void println(Object x)  </p>
<p>//打印字符串。如果参数为 null，则打印字符串 “null”<br>public void print(String s)<br>//打印 String，然后终止该行<br>public void println(String x)</p>
<p>//通过写入行分隔符字符串终止当前行<br>public void println()</p>
<p>//使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区<br>public PrintWriter format(Locale l,String format,Object… args)  </p>
<p>//使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。如果启用自动刷新，则调用此方法将刷新输出缓冲区<br>public PrintWriter format(String format,Object… args)  </p>
<p>//将指定字符添加到此 writer<br>public PrintWriter append(char c)<br>//将指定的字符序列添加到此 writer<br>public PrintWriter append(CharSequence csq)<br>//将指定字符序列的子序列添加到此 writer<br>public PrintWriter append(CharSequence csq,int start,int end)</p>
<p>//写入字符数组<br>public void write(char[] buf)<br>//写入字符数组的某一部分<br>public void write(char[] buf,int off,int len)<br>//写入单个字符<br>public void write(int c)<br>//写入字符串<br>public void write(String s)<br>//写入字符串的某一部分<br>public void write(String s,int off,int len)</p>
<p><strong>提示：</strong>由于BufferedWriter没有PrintWriter使用灵活，所以在实际的操作中，我们往往会使用<strong>PrinterWriter/BufferedReader</strong>这种组合。  </p>
<h3 id="内存操作流"><a href="#内存操作流" class="headerlink" title="内存操作流"></a>内存操作流</h3><p>之前的程序中，输出输入都是在内存和文件之间进行的，当然，输入输出也可以不访问文件，只在内存中进行。也就是把数据的输入源和输出目的地从文件改成了byte数组、char数组或字符串。  </p>
<h4 id="字节数组流-ByteArrayInputStream、ByteArrayOutputStream"><a href="#字节数组流-ByteArrayInputStream、ByteArrayOutputStream" class="headerlink" title="字节数组流(ByteArrayInputStream、ByteArrayOutputStream)"></a>字节数组流(ByteArrayInputStream、ByteArrayOutputStream)</h4><p>ByteArrayInputStream的主要功能是完成将byte数组的内容写入到内存之中，而ByteArrayOutputStream的主要功能是将内存中的数据输出到byte数组。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/test.png" alt="fail">  </p>
<p><strong>ByteArrayInputStream</strong><br>字节数组输入流从内存中的一个字节数组读取字节到内存，这个字节数组就是数据的输入源。创建字节数组输入流对象有以下几种方式。<br>接收字节数组作为参数创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayInputStream bArray = </div><div class="line"><span class="keyword">new</span> ByteArrayInputStream(<span class="keyword">byte</span> [] b);</div></pre></td></tr></table></figure></p>
<p>另一种创建方式是接收一个字节数组，和两个整型变量 off、len，off表示第一个读取的字节，len表示读取字节的长度,<strong>即将字节数组中从off开始的len个字节读入该输入流</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ByteArrayInputStream bArray = <span class="keyword">new</span></div><div class="line">ByteArrayInputStream(<span class="keyword">byte</span> []b,<span class="keyword">int</span> off,<span class="keyword">int</span> len)</div></pre></td></tr></table></figure></p>
<p>成功创建字节数组输入流对象后，可以参见以下列表中的方法，对流进行读操作或其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/ByteArrayInputStream.png" alt="fail" title="ByteArrayInputStream">  </p>
<p><strong>ByteArrayOutputStream</strong><br>字节数组输出流在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存在该字节数组缓冲区中，可以用toByteArray()得到该字节数组，也可以用toString()得到缓冲区内容转换得到的字符串。创建字节数组输出流对象有以下几种方式。<br>下面的构造方法创建一个32字节（默认大小）的缓冲区。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream();</div></pre></td></tr></table></figure></p>
<p>另一个构造方法创建一个大小为n字节的缓冲区。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream(<span class="keyword">int</span> n)</div></pre></td></tr></table></figure></p>
<p>成功创建字节数组输出流对象后，可以参见以下列表中的方法，对流进行写操作或其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/ByteArrayOutputStream.png" alt="fail" title="ByteArrayOutputStream"><br>下面的例子演示了ByteArrayInputStream 和 ByteArrayOutputStream的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayDemo01</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		String str = <span class="string">"HELLOWORLD"</span> ;		<span class="comment">// 定义一个字符串，全部由大写字母组成</span></div><div class="line">		ByteArrayInputStream bis = <span class="keyword">null</span> ;	<span class="comment">// 内存输入流</span></div><div class="line">		ByteArrayOutputStream bos = <span class="keyword">null</span> ;	<span class="comment">// 内存输出流</span></div><div class="line">		bis = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()) ;	<span class="comment">// 向内存中输入内容</span></div><div class="line">		bos = <span class="keyword">new</span> ByteArrayOutputStream() ;	<span class="comment">// 准备从内存ByteArrayInputStream中读取内容</span></div><div class="line">		<span class="keyword">int</span> temp = <span class="number">0</span> ;</div><div class="line">		<span class="keyword">while</span>((temp=bis.read())!=-<span class="number">1</span>)&#123;</div><div class="line">			<span class="keyword">char</span> c = (<span class="keyword">char</span>) temp ;	<span class="comment">// 读取的数字变为字符</span></div><div class="line">			bos.write(Character.toLowerCase(c)) ;	<span class="comment">// 将字符变为小写</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 所有的数据就全部都在ByteArrayOutputStream中</span></div><div class="line">		String newStr = bos.toString() ;	<span class="comment">// 取出内容</span></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			bis.close() ;</div><div class="line">			bos.close() ;</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;</div><div class="line">		System.out.println(newStr) ;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="字符数据流-CharArrayReader、CharArrayWriter"><a href="#字符数据流-CharArrayReader、CharArrayWriter" class="headerlink" title="字符数据流(CharArrayReader、CharArrayWriter)"></a>字符数据流(CharArrayReader、CharArrayWriter)</h4><p>CharArrayReader、CharArrayWriter和ByteArrayInputStream、ByteArrayOutputStream类似，只不过后者是字节数组输入流，而前者是字符数组输入流。<br><strong>CharArrayReader</strong><br>构造方法摘要  </p>
<ul>
<li>CharArrayReader(char buf[]);<br>使用传入的buf构造CharArrayReader </li>
<li>CharArrayReader(char buf[], int offset, int length);<br>使用传入的buf的一部分构造CharArrayReader    </li>
</ul>
<p>方法摘要  </p>
<ul>
<li>void close(); 关闭此流  </li>
<li>void mark(int readAheadLimit); 标记当前流读取的位置  </li>
<li>void markSupport(); 检测此流是否支持标记  </li>
<li>int read(); 读取一个字符、并以整数形式返回  </li>
<li>int read(char[] b, int off, int len); 将buf中len个字符读取到下标从off开始的b中、返回读取的字符个数  </li>
<li>boolean ready(); 查看CharArrayReader是否可读。  </li>
<li>void reset(); 将此流开始位置重置到最后一次调用mark是流的读取位置  </li>
<li>long skip(long n); 丢弃buf中n个字符、返回实际丢弃的字符个数  </li>
</ul>
<p><strong>CharArrayWriter</strong><br>构造方法摘要    </p>
<ul>
<li>public CharArrayWriter()<br>使用默认的buf大小创建CharArrayWriter。   </li>
<li>public CharArrayWriter(int initialSize)<br>使用指定的buf大小创建CharArrayWriter。  </li>
</ul>
<p>方法摘要  </p>
<ul>
<li>CharArrayWriter append(CharSequence csq)<br>将一串有序字符序列写入buf中  </li>
<li>CharArrayWriter append(CharSequence csq, int start, int end)<br>将一串有序字符序列的一部分写入buf中  </li>
<li>CharArrayWriter append(char c) 将一个字符写入buf中</li>
<li>void close() 关闭此流（没有效果，因为不访问文件）</li>
<li>void flush() flush此流（没有效果，因为不访问文件）</li>
<li>void reset() 清空buf、重头开始</li>
<li>int size() 查看当前buf中字符总数</li>
<li>char[] toCharArray() 将buf中内容转换成char[]</li>
<li>String toString() 将buf中字符转换成String返回</li>
<li>void write(int c) 写入一个字符。</li>
<li>void write(char c[], int off, int len)<br>将一个char[]的一部分写入buf中、若buf满、扩容。</li>
<li>void write(String str, int off, int len)<br>将一个字符串写入buf中、满自动扩容</li>
<li>void writeTo(Writer out)<br>将buf中现有的字节写入到另一个输出字符流out中</li>
</ul>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">       String str = <span class="string">"Hello world!"</span>;</div><div class="line"></div><div class="line">       <span class="comment">// 构建字符输入流</span></div><div class="line">       CharArrayReader reader = <span class="keyword">new</span> CharArrayReader(str.toCharArray());</div><div class="line"></div><div class="line">       <span class="comment">// 从字符输入流读取字符</span></div><div class="line">       <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">       <span class="keyword">int</span> len = reader.read(chars);</div><div class="line">       System.out.println(<span class="keyword">new</span> String(chars, <span class="number">0</span>, len));</div><div class="line">   &#125;</div><div class="line">   	<span class="comment">//构建字符输出流</span></div><div class="line">   CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter(<span class="number">1024</span> * <span class="number">1024</span>);</div><div class="line"></div><div class="line">       <span class="comment">// 将字符串写入到CharArrayWriter</span></div><div class="line">       String msg = <span class="string">"hello world！！！22121"</span>;</div><div class="line">       writer.write(msg.toCharArray());</div><div class="line"></div><div class="line">       System.out.println(writer.toString());</div><div class="line"></div><div class="line">       writer.close();</div></pre></td></tr></table></figure></p>
<h4 id="字符串流-StringReader、StringWriter"><a href="#字符串流-StringReader、StringWriter" class="headerlink" title="字符串流(StringReader、StringWriter)"></a>字符串流(StringReader、StringWriter)</h4><p>字符串流和字符数据流基本一样，只是把char[]数组换成了String，在此不赘述。  </p>
<h3 id="合并流-SequenceInputStream、SequenceOutputStream"><a href="#合并流-SequenceInputStream、SequenceOutputStream" class="headerlink" title="合并流(SequenceInputStream、SequenceOutputStream)"></a>合并流(SequenceInputStream、SequenceOutputStream)</h3><p><strong>SequenceInputStream</strong><br>有些情况下，当我们需要从多个输入流中向程序读入数据。此时，可以使用合并流，将多个输入流合并成一个SequenceInputStream流对象。<br>SequenceInputStream会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。 合并流的作用是将多个源合并合一个源。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/合并流.png" alt="fail">  </p>
<p>构造方法<br>public SequenceInputStream(InputStream s1,InputStream s2)<br>使用两个输入流对象实例化本类对象。  </p>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.SequenceInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.FileInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceDemo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;	</div><div class="line">    <span class="comment">// 所有异常抛出</span></div><div class="line">		InputStream is1 = <span class="keyword">null</span> ;		<span class="comment">// 输入流1</span></div><div class="line">		InputStream is2 = <span class="keyword">null</span> ;		<span class="comment">// 输入流1</span></div><div class="line">		OutputStream os = <span class="keyword">null</span> ;		<span class="comment">// 输出流</span></div><div class="line">		SequenceInputStream sis = <span class="keyword">null</span> ;	<span class="comment">// 合并流</span></div><div class="line">		is1 = <span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"a.txt"</span>);</div><div class="line">		is2 = <span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"b.txt"</span>);</div><div class="line">		os = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span> + File.separator + <span class="string">"ab.txt"</span>);</div><div class="line">		sis = <span class="keyword">new</span> SequenceInputStream(is1,is2) ;</div><div class="line">        <span class="comment">// 实例化合并流</span></div><div class="line">		<span class="keyword">int</span> temp = <span class="number">0</span> ;	<span class="comment">// 接收内容</span></div><div class="line">		<span class="keyword">while</span>((temp=sis.read())!=-<span class="number">1</span>)&#123;	<span class="comment">// 循环输出</span></div><div class="line">			os.write(temp) ;	<span class="comment">// 保存内容</span></div><div class="line">		&#125;</div><div class="line">		sis.close() ;	<span class="comment">// 关闭合并流</span></div><div class="line">		is1.close() ;	<span class="comment">// 关闭输入流1`</span></div><div class="line">		is2.close() ;	<span class="comment">// 关闭输入流2</span></div><div class="line">		os.close() ;	<span class="comment">// 关闭输出流</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>SequenceOutputStream</strong><br>同SequenceInputStream,区别在于合并的是两个OutputStream，在此不赘述。</p>
<h3 id="数据操作流-DataInputStream、DataOutputStream"><a href="#数据操作流-DataInputStream、DataOutputStream" class="headerlink" title="数据操作流(DataInputStream、DataOutputStream)"></a>数据操作流(DataInputStream、DataOutputStream)</h3><p><strong>DataInputStream</strong><br>数据输入流允许应用程序以与机器无关方式从底层输入流中读取<strong>Java 8种基本数据类型</strong>，方法命名为readXxx。<br>下面的构造方法用来创建数据输入流对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(InputStream in);</div></pre></td></tr></table></figure></p>
<p>另一种创建方式是接收一个字节数组，和两个整形变量 off、len，off表示第一个读取的字节，len表示读取字节的长度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">byte</span>[] a,<span class="keyword">int</span> off,<span class="keyword">int</span> len);</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/DataInputStream.png" alt="fail" title="DataInputStream"><br><strong>DataOutputStream</strong><br>数据输出流允许应用程序以与机器无关方式将<strong>Java 8种基本数据类型</strong>写到底层输出流,方法命名为writeXxx。<br>下面的构造方法用来创建数据输出流对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(OutputStream  out);</div></pre></td></tr></table></figure></p>
<p>创建对象成功后，可以参照以下列表给出的方法，对流进行写操作或者其他操作。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/DataOutputStream.png" alt="fail" title="DataOutputStream"><br>下面的例子演示了DataInputStream和DataOutputStream的使用，该例从文本文件test.txt中读取5行，并转换成大写字母，最后保存在另一个文件test1.txt中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"></div><div class="line">      DataInputStream d = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span></div><div class="line">                               FileInputStream(<span class="string">"test.txt"</span>));</div><div class="line"></div><div class="line">      DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span></div><div class="line">                               FileOutputStream(<span class="string">"test1.txt"</span>));</div><div class="line"></div><div class="line">      String count;</div><div class="line">      <span class="keyword">while</span>((count = d.readLine()) != <span class="keyword">null</span>)&#123;</div><div class="line">          String u = count.toUpperCase();</div><div class="line">          System.out.println(u);</div><div class="line">          out.writeBytes(u + <span class="string">"  ,"</span>);</div><div class="line">      &#125;</div><div class="line">      d.close();</div><div class="line">      out.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对象流-ObjectInputStream、ObjectOutputStream"><a href="#对象流-ObjectInputStream、ObjectOutputStream" class="headerlink" title="对象流(ObjectInputStream、ObjectOutputStream)"></a>对象流(ObjectInputStream、ObjectOutputStream)</h3><h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>对象序列化，就是把一个对象变为二进制的数据流的一种方法，通过对象序列化可以方便的实现对象的传输或存储。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/对象序列化.png" alt="fail" title="对象序列化">    </p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/对象序列化步骤.png" alt="fail" title="对象序列化"><br><strong>注意：</strong>Serializable接口和Cloneable接口一样是一个标记接口，即没有任何方法的接口。但只有一个类实现了Serializable接口，它才能被序列化为二进制流进行传输，否则会抛出NotSerializableException异常。一个类如果实现了Serializable接口，其子类也都可以序列化。  </p>
<p>定义一个可被序列化的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String name ;	 </div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age ;		</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;	</div><div class="line">		<span class="keyword">this</span>.name = name ;</div><div class="line">		<span class="keyword">this</span>.age = age ;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"；年龄："</span> + <span class="keyword">this</span>.age ;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>以后此类的对象就可以被序列化了。变为二进制byte流。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/序列化和反序列化.png" alt="fail" title="序列化和反序列化">   </p>
<h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p>在对象进行序列化或反序列化操作的时候，要考虑JDK版本的问题，如果序列化的JDK版本和反序列化的JDK版本不统一则就有可能造成异常。所以在序列化操作中引入了一个serialVersionUID的常量，可以通过此常量来验证版本的一致性，在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现版本不一致的异常。</p>
<p>在上述的Person类中添加<code>private static final long serialVersionUID = 1L;</code>即可</p>
<h4 id="对象的序列化和反序列化"><a href="#对象的序列化和反序列化" class="headerlink" title="对象的序列化和反序列化"></a>对象的序列化和反序列化</h4><p>要想完成对象的输入或输出，还必须依靠对象输出流（ObjectOutputStream）和对象输入流（ObjectInputStream）,<br><strong>使用对象输出流输出序列化对象的过程，即把Java对象转换为字节序列的过程</strong>，也称为<strong>序列化</strong>，而<strong>使用对象输入流读入的过程，即把字节序列恢复为Java对象的过程</strong>，也称为<strong>反序列化</strong>。  </p>
<h4 id="ObjectOutputStream-序列化"><a href="#ObjectOutputStream-序列化" class="headerlink" title="ObjectOutputStream(序列化)"></a>ObjectOutputStream(序列化)</h4><p>常用构造方法：<br>public ObjectOutputStream(OutputStream out)  //接收一个字节输出流对象  </p>
<p>常用方法：<br>public final void writeObject(Object obj) //把一个对象写入输出流 </p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo01</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        File f = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"test.txt"</span>) ; <span class="comment">// 定义保存路径  </span></div><div class="line">        ObjectOutputStream oos = <span class="keyword">null</span> ; <span class="comment">// 声明对象输出流  </span></div><div class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f) ;    <span class="comment">// 文件输出流  </span></div><div class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(out) ;  </div><div class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">30</span>)) ;  <span class="comment">// 保存对象  </span></div><div class="line">        oos.close() ;   <span class="comment">// 关闭  </span></div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>对象序列化的真正内容：由于堆中只保存对象的非静态属性，方法和静态属性保存在静态区。所以序列化的实际是对象的非静态属性。  </p>
<h4 id="ObjectInputStream-反序列化"><a href="#ObjectInputStream-反序列化" class="headerlink" title="ObjectInputStream(反序列化)"></a>ObjectInputStream(反序列化)</h4><p>常用构造方法：<br>public ObjectInputStream(InputStream in)  //接收一个字节输入流对象<br>常用方法：<br>public final Object readObject()  //把输入流读出对象</p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo01</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		File f = <span class="keyword">new</span> File(<span class="string">"D:"</span> + File.separator + <span class="string">"test.txt"</span>) ;	</div><div class="line">		ObjectInputStream ois = <span class="keyword">null</span> ;</div><div class="line">		InputStream in = <span class="keyword">new</span> FileOutputStream(f);</div><div class="line">		ois = <span class="keyword">new</span> ObjectInStream(in) ;</div><div class="line">		Person person = (Person)ois.readObject();</div><div class="line">		oos.close() ;	</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h4><p>当使用Serializable接口实现序列化操作时，如果一个对象中的某个属性不希望被JVM默认序列化的话，则可以使用transient关键字进行声明。如果用transient声明一个实例变量，当对象存储时，它的值不需要维持，而会保持默认值。换句话来说就是，用transient关键字标记的成员变量不参与JVM的默认序列化过程。  </p>
<p>更多序列化知识见：<br><a href="https://www.jianshu.com/p/0221518ad38f" target="_blank" rel="external">Java序列化心得（一）：序列化设计和默认序列化格式的问题</a><br><a href="https://www.jianshu.com/p/352fa61e0512" target="_blank" rel="external">Java序列化心得（二）：自定义序列化</a><br><a href="http://blog.csdn.net/u013087513/article/details/52174690" target="_blank" rel="external">Java IO操作——对象序列化（Serializable接口、ObjectOutputStream、以及与Externalizable接口的用法和区别）</a></p>
<p>拓展：ArrayList源码中对序列化的实现就是默认序列化和自定义序列化混合，只对底层数组的有效元素进行序列化，多余空间不必序列化，从而提高了性能。  </p>
<p>在对子类进行反序列化的操作时，没有实现Serializable接口的父类的构造方法会被自顶向下调用。</p>
<h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>在日常的使用中经常会使用到像WinRAR或WinZIP这样的压缩文件，通过这些软件可以把一个很大的文件进行压缩以方便传输。<br>在JAVA中 为了减少传输时的数据量也提供了专门的压缩流，可以将文件或文件夹压缩成ZIP、JAR、GZIP等文件的格式。<br>具体见大牛博客：<br><a href="http://blog.csdn.net/u013087513/article/details/52151227" target="_blank" rel="external">http://blog.csdn.net/u013087513/article/details/52151227</a>  </p>
<h3 id="管道流-PipedOutputStream、PipedInputStream"><a href="#管道流-PipedOutputStream、PipedInputStream" class="headerlink" title="管道流(PipedOutputStream、PipedInputStream)"></a>管道流(PipedOutputStream、PipedInputStream)</h3><p>管道流的作用是可以进行两个线程间的通讯，分为管道输出流(PipedOutputStream)、管道输入流(PipedInputStream)如果要想进行管道输出，则必须把输出流连在输入流之上，在PipedOutputStream中有一个方法用于连接管道：<br><strong>public void connect(PipedInputStream snk) throws IOException</strong>  </p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/管道流.png" alt="fail">  </p>
<p>例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.* ;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;			<span class="comment">// 线程类</span></div><div class="line">	<span class="keyword">private</span> PipedOutputStream pos = <span class="keyword">null</span> ;	<span class="comment">// 管道输出流</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.pos = <span class="keyword">new</span> PipedOutputStream() ;	<span class="comment">// 实例化输出流</span></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">		String str = <span class="string">"Hello World!!!"</span> ;	<span class="comment">// 要输出的内容</span></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			<span class="keyword">this</span>.pos.write(str.getBytes()) ;</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			<span class="keyword">this</span>.pos.close() ;</div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getPos</span><span class="params">()</span></span>&#123;	<span class="comment">// 得到此线程的管道输出流</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.pos ;	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> PipedInputStream pis = <span class="keyword">null</span> ;	<span class="comment">// 管道输入流</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Receive</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.pis = <span class="keyword">new</span> PipedInputStream() ;	<span class="comment">// 实例化输入流</span></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>] ;	<span class="comment">// 接收内容</span></div><div class="line">		<span class="keyword">int</span> len = <span class="number">0</span> ;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			len = <span class="keyword">this</span>.pis.read(b) ;	<span class="comment">// 读取内容</span></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			<span class="keyword">this</span>.pis.close() ;	<span class="comment">// 关闭</span></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"接收的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getPis</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.pis ;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedDemo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		Send s = <span class="keyword">new</span> Send() ;</div><div class="line">		Receive r = <span class="keyword">new</span> Receive() ;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			s.getPos().connect(r.getPis()) ;	<span class="comment">// 连接管道</span></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">new</span> Thread(s).start() ;	<span class="comment">// 启动线程</span></div><div class="line">		<span class="keyword">new</span> Thread(r).start() ;	<span class="comment">// 启动线程</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="回退流-PushbackInputStream和PushbackReader"><a href="#回退流-PushbackInputStream和PushbackReader" class="headerlink" title="回退流(PushbackInputStream和PushbackReader)"></a>回退流(PushbackInputStream和PushbackReader)</h3><p>在Java IO中所有的数据都是采用顺序的读取方式，即对于一个输入流来讲都是采用从头到尾的顺序读取的，如果在输入流中某个不需要的内容被读取进来，则只能通过程序将这些不需要的内容处理掉，为了解决这样的处理问题，在Java中提供了一种回退输入流(PushbackInputStream、PushbackReader),可以把读取进来的某些数据重新回退到输入流的缓冲区之中。</p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/回退流.png" alt="fail" title="回退流的工作原理">  </p>
<p>回退流分为字节回退流和字符回退流，我们以字节回退流PushbackInputStream为例。  </p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/PushbackInputStream.png" alt="fail">   </p>
<p>对于回退操作来说，提供了三个unread()的操作方法，这三个操作方法与InputStream类中的read()方法是一一对应的。</p>
<p> 例子如下，内存中使用ByteArrayInputStream，把内容设置到内存之中：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PushbackInputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushInputStreamDemo</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;	<span class="comment">// 所有异常抛出</span></div><div class="line">		String str = <span class="string">"www.baidu.com"</span> ;		<span class="comment">// 定义字符串</span></div><div class="line">		PushbackInputStream push = <span class="keyword">null</span> ;		<span class="comment">// 定义回退流对象</span></div><div class="line">		ByteArrayInputStream bai = <span class="keyword">null</span> ;		<span class="comment">// 定义内存输入流</span></div><div class="line">		bai = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes()) ;	<span class="comment">// 实例化内存输入流</span></div><div class="line">		push = <span class="keyword">new</span> PushbackInputStream(bai) ;	<span class="comment">// 从内存中读取数据</span></div><div class="line">		System.out.print(<span class="string">"读取之后的数据为："</span>) ;</div><div class="line">		<span class="keyword">int</span> temp = <span class="number">0</span> ; </div><div class="line">		<span class="keyword">while</span>((temp=push.read())!=-<span class="number">1</span>)&#123;	<span class="comment">// 读取内容</span></div><div class="line">			<span class="keyword">if</span>(temp==<span class="string">'.'</span>)&#123;	<span class="comment">// 判断是否读取到了“.”</span></div><div class="line">				push.unread(temp) ;	<span class="comment">// 放回到缓冲区之中</span></div><div class="line">				temp = push.read() ;	<span class="comment">// 再读一遍</span></div><div class="line">				System.out.print(<span class="string">"（退回"</span>+(<span class="keyword">char</span>)temp+<span class="string">"）"</span>) ;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				System.out.print((<span class="keyword">char</span>)temp) ;	<span class="comment">// 输出内容</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="选择合适的IO流"><a href="#选择合适的IO流" class="headerlink" title="选择合适的IO流"></a>选择合适的IO流</h3><p>1.首先，明确IO流中有两个主要的体系，即  InputStream、OutputStream和Reader、Writer。其次，明确数据的来源和数据将要到达的目的地。  </p>
<p>2.明确将要操作的数据是否是纯文本数据。如果数据源是纯文本数据选Reader;数据源不是纯文本数据选择InputStream。如果数据目的地是纯文本数据就选择Writer;如果不是则选择OutputStream。  </p>
<p>3.明确具体的设备。即数据源是从哪个设备来的：是硬盘就加File;是键盘用System.in(是一个InputStream对象);是内存用数组;是网络用Socket流。同样目的是哪个设备：是硬盘就加File;是键盘用System.out(是一个PrintStream对象);是内存用数组;是网络用Socket流。    </p>
<p>4.明确是否还需要其他额外功能呢，例如：<br>①是否需要较高的效率，即是否需要使用缓冲区，是就加上Buffered;<br>②是否需要转换，是就使用转换流，InputStreamReader 和OutputStreamWriter。  </p>
<p>例子：<br><img src="/2017/11/28/Java学习总结之Java-IO系统/1.jpg" alt="fail"><br><img src="/2017/11/28/Java学习总结之Java-IO系统/2.jpg" alt="fail">   </p>
<h3 id="System类对IO的支持-out、err、in"><a href="#System类对IO的支持-out、err、in" class="headerlink" title="System类对IO的支持(out、err、in)"></a>System类对IO的支持(out、err、in)</h3><p>System类的常量<br>System表示系统类，实际上在Java中也对IO给予了一定的支持<br>1、public static final PrintStream out<br>//常量  对应系统标准输出，一般是显示器<br>2、public static final PrintStream err<br>//常量 错误信息输出<br>3、public static final InputStream in<br>//常量 对应标准输出，一般是键盘</p>
<p>使用static final关键字声明的变量是全局常量，只要是常量，则所有的单词字母必须全部大写，按照现在的标准：<br>System.OUT —&gt; System.out  </p>
<h4 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h4><p>使用System.out输出的时候就是将输出的位置定义在了显示器之中。FileOutputStream是定位在文件里，而System.out是定位在屏幕上输出。PrintStream就是OutputStream的子类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.OutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.IOException ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo01</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		OutputStream out = System.out ;<span class="comment">// 此时的输出流是向屏幕上输出</span></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			out.write(<span class="string">"hello world!!!"</span>.getBytes()) ;	<span class="comment">// 向屏幕上输出</span></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;	<span class="comment">// 打印异常</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			out.close() ;	<span class="comment">// 关闭输出流</span></div><div class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">			e.printStackTrace() ;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/System1.png" alt="fail">   </p>
<h4 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h4><p>System.err 表示的是错误的标准输出，如果程序中出现了错误的话，则直接使用System.err进行输出即可。程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo02</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		String str = <span class="string">"hello"</span> ;		<span class="comment">// 声明一个非数字的字符串</span></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			System.out.println(Integer.parseInt(str)) ;	<span class="comment">// 转型</span></div><div class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">			System.err.println(e) ;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/System2.png" alt="fail"><br>使用System.out输出错误如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo03</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		String str = <span class="string">"hello"</span> ;		<span class="comment">// 声明一个非数字的字符串</span></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			System.out.println(Integer.parseInt(str)) ;	<span class="comment">// 转型</span></div><div class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">			System.out.println(e) ;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/System3.png" alt="fail">  </p>
<p><strong>System.out 和System.err 的区别：</strong>System.out和System.err都是PrintStream的实例化对象，而且通过代码可以发现，两者都可以输出错误信息，但是一般来讲System.out是将信息显示给用户看，是正常的信息显示，而System.err的正好相反是不希望用户看到的，会直接在后台打印，是专门显示错误的。<br>一般来讲，如果要输出错误信息的时候最好不要使用System.out而是直接使用System.err 这一点只能从其概念上划分。<br><img src="/2017/11/28/Java学习总结之Java-IO系统/System4.png" alt="fail">  </p>
<h4 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h4><p>System.in实际上是一个键盘的输入流，其本身是InputStream类型的对象。那么，此时就可以利用此方式完成从键盘读取数据的功能。<br>InputStream对应的是输入流，输入流的话肯定是从指定位置读取的，之前使用的是FileInputStream，是从文件中读取的。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo04</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;	<span class="comment">// 所有异常抛出</span></div><div class="line">		InputStream input = System.in ;	<span class="comment">// 从键盘接收数据</span></div><div class="line">		<span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>] ;	<span class="comment">// 开辟空间，接收数据</span></div><div class="line">		System.out.print(<span class="string">"请输入内容："</span>) ;	<span class="comment">// 提示信息</span></div><div class="line">		<span class="keyword">int</span> len = input.read(b) ;	<span class="comment">// 接收数据</span></div><div class="line">		System.out.println(<span class="string">"输入的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">		input.close() ;	<span class="comment">// 关闭输入流</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是以上的操作存在如下问题：<br>问题一：指定了输入数据的长度，如果现在输入的数据超过了长度范围，只能输入部分的数据。<br>问题二：如果byte数组是奇数的话，则还可能出现中文乱码的情况，因为一个字符是两个字节。  </p>
<p>可以通过标志位的方式避免指定byte数组大小来解决。实例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo05</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;	<span class="comment">// 所有异常抛出</span></div><div class="line">		InputStream input = System.in ;	<span class="comment">// 从键盘接收数据</span></div><div class="line">		StringBuffer buf = <span class="keyword">new</span> StringBuffer() ;	<span class="comment">// 使用StringBuffer接收数据</span></div><div class="line">		System.out.print(<span class="string">"请输入内容："</span>) ;	<span class="comment">// 提示信息</span></div><div class="line">		<span class="keyword">int</span> temp = <span class="number">0</span> ;		<span class="comment">// 接收内容</span></div><div class="line">		<span class="keyword">while</span>((temp=input.read())!=-<span class="number">1</span>)&#123;</div><div class="line">			<span class="keyword">char</span> c = (<span class="keyword">char</span>) temp ;	<span class="comment">// 将数据变为字符</span></div><div class="line">			<span class="keyword">if</span>(c==<span class="string">'\n'</span>)&#123;	<span class="comment">// 退出循环，输入回车表示输入完成</span></div><div class="line">				<span class="keyword">break</span> ;</div><div class="line">			&#125;</div><div class="line">			buf.append(c) ;	<span class="comment">// 保存内容</span></div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"输入的内容为："</span> + buf) ;</div><div class="line">		input.close() ;	<span class="comment">// 关闭输入流</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但这种方法读取中文还是会乱码，这是因为每读取一个字节就将其转为字符，字母和数字都是占1个字节 可以正常显示。但是如果是中文的话，就相当于每读取到一个字节就是半个字符就进行转化，所以导致乱码的错误。<br>最好的输入方式是将全部输入的数据暂时存放在一块内存之上，之后一次性的从内存中读取数据，这样所有数据就整体只读了一次，则不会造成乱码，而且也不会受到长度的限制。  </p>
<p><img src="/2017/11/28/Java学习总结之Java-IO系统/System5.png" alt="fail">  </p>
<p>上述功能可以通过BufferedReader实现。  </p>
<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>从之前的操作中知道System.out、System.err、System.in三个常量的作用，但是通过System类也可以改变System.in的输入流来源，以及System.out和System.err两个输出流的输出位置。<br>1、public static void setOut(PrintStream out)<br>//普通方法 重定向标准输出流<br>2、public static void setErr(PrintStream err)<br>//普通方法 重定向标准错误输出流<br>3、public static void setIn(InputStream in)<br>//普通方法 重定向标准输入流</p>
<h4 id="为System-out输出重定向"><a href="#为System-out输出重定向" class="headerlink" title="为System.out输出重定向"></a>为System.out输出重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo06</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		System.setOut(</div><div class="line">			<span class="keyword">new</span> PrintStream(</div><div class="line">				<span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span> + </div><div class="line">					File.separator + <span class="string">"red.txt"</span>))) ;	<span class="comment">// System.out输出重定向</span></div><div class="line">		System.out.print(<span class="string">"hello"</span>) ;	<span class="comment">// 输出时，不再向屏幕上输出</span></div><div class="line">		System.out.println(<span class="string">",world"</span>) ;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>System.out是希望用户看得到信息，一旦有错误，最好保存起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo07</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">		String str = <span class="string">"hello"</span> ;		<span class="comment">// 声明一个非数字的字符串</span></div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			System.out.println(Integer.parseInt(str)) ;	<span class="comment">// 转型</span></div><div class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">			<span class="keyword">try</span>&#123;</div><div class="line">				System.setOut(</div><div class="line">					<span class="keyword">new</span> PrintStream(</div><div class="line">						<span class="keyword">new</span> FileOutputStream(<span class="string">"d:"</span></div><div class="line">							+ File.separator + <span class="string">"err.log"</span>))) ;	<span class="comment">// 输出重定向</span></div><div class="line">			&#125;<span class="keyword">catch</span>(Exception e1)&#123;</div><div class="line">			</div><div class="line">			&#125;</div><div class="line">			System.out.println(e) ;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>通过此操作就可以完成错误的重定向，保存错误日志。</strong>  </p>
<h4 id="为System-err重定向"><a href="#为System-err重定向" class="headerlink" title="为System.err重定向"></a>为System.err重定向</h4><p>利用System.err向屏幕上输出信息，此时，为了方便起见，使用内存操作流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream ;</div><div class="line"><span class="keyword">import</span> java.io.PrintStream ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo08</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;	<span class="comment">// 所有异常抛出</span></div><div class="line">		ByteArrayOutputStream bos = <span class="keyword">null</span> ;		<span class="comment">// 声明内存输出流</span></div><div class="line">		bos = <span class="keyword">new</span> ByteArrayOutputStream() ;		<span class="comment">// 实例化</span></div><div class="line">		System.setErr(<span class="keyword">new</span> PrintStream(bos)) ;	<span class="comment">// 输出重定向</span></div><div class="line">		System.err.print(<span class="string">"hello"</span>) ;	<span class="comment">// 错误输出，不再向屏幕上输出</span></div><div class="line">		System.err.println(<span class="string">"world"</span>) ;			<span class="comment">// 向内存中输出</span></div><div class="line">		System.out.println(bos) ;	<span class="comment">// 输出内存中的数据</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一般不建议去修改System.err的输出位置，因为这样的信息都不太希望用户可以看见。  </p>
<h4 id="为System-in重定向"><a href="#为System-in重定向" class="headerlink" title="为System.in重定向"></a>为System.in重定向</h4><p>默认情况下System.in是指键盘输入，也可以通过setIn()方法，将其输入流的位置改变，例如，现在从文件中读取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream ;</div><div class="line"><span class="keyword">import</span> java.io.InputStream ;</div><div class="line"><span class="keyword">import</span> java.io.File ;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo09</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;	<span class="comment">// 所有异常抛出</span></div><div class="line">		System.setIn(<span class="keyword">new</span> FileInputStream(<span class="string">"d:"</span></div><div class="line">			+ File.separator + <span class="string">"demo.txt"</span>)) ;	<span class="comment">// 设置输入重定向</span></div><div class="line">		InputStream input = System.in ;	<span class="comment">// 从文件中接收数据</span></div><div class="line">		<span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]	;<span class="comment">// 开辟空间，接收数据</span></div><div class="line">		<span class="keyword">int</span> len = input.read(b) ;	<span class="comment">//接收</span></div><div class="line">		System.out.println(<span class="string">"输入的内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,len)) ;</div><div class="line">		input.close() ;	<span class="comment">// 关闭输入流</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三个常量的使用：  </p>
<ul>
<li>System.out是希望用户可以看见的信息。用IDE(Eclipse)的话错误信息使用黑颜色显示的。  </li>
<li>System.err 是不希望用户可以看见的信息。则在IDE中将以红色的文字显示错误信息。  </li>
<li>System.in 对应键盘输入。  </li>
<li>以上三个常量的输入、输出都可以重定向，但是一般建议只修改setOut的重定向。  </li>
<li>System.in读取的时候会出现中文乱码的问题，则可以通过BufferedReader完成读取功能。</li>
</ul>

      
    </div>
    
    
    

    

    

    
   <div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
</div> 
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/19/使用telnet发送HTTP请求报文/" rel="next" title="使用telnet发送HTTP请求报文">
                <i class="fa fa-chevron-left"></i> 使用telnet发送HTTP请求报文
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/01/使用jsoup简易爬取POJ题面/" rel="prev" title="使用jsoup简易爬取POJ题面">
                使用jsoup简易爬取POJ题面 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="uyan_frame"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/fqtbjudvb4y.jpg"
                alt="谢均宇" />
            
              <p class="site-author-name" itemprop="name">谢均宇</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Steven1997" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:573668878@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://m.collegefun.cn/" title="CaptainShen's Station" target="_blank">CaptainShen's Station</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://77sera.cn/" title="Sera's Blog" target="_blank">Sera's Blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File"><span class="nav-number">2.</span> <span class="nav-text">File</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的目录"><span class="nav-number">3.</span> <span class="nav-text">Java中的目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile"><span class="nav-number">4.</span> <span class="nav-text">RandomAccessFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流"><span class="nav-number">5.</span> <span class="nav-text">流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO流分类"><span class="nav-number">6.</span> <span class="nav-text">IO流分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-按操作数据类型分：字符流和字节流"><span class="nav-number">6.1.</span> <span class="nav-text">1.按操作数据类型分：字符流和字节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-按流向分：输入流和输出流"><span class="nav-number">6.2.</span> <span class="nav-text">2.按流向分：输入流和输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-按功能分：节点流和处理流"><span class="nav-number">6.3.</span> <span class="nav-text">3.按功能分：节点流和处理流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-节点流"><span class="nav-number">6.3.1.</span> <span class="nav-text">(1) 节点流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-处理流"><span class="nav-number">6.3.2.</span> <span class="nav-text">(1) 处理流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取控制台输入"><span class="nav-number">7.</span> <span class="nav-text">读取控制台输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-使用标准输入流对象System-in"><span class="nav-number">7.1.</span> <span class="nav-text">1.使用标准输入流对象System.in</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-使用Scanner类"><span class="nav-number">7.2.</span> <span class="nav-text">2.使用Scanner类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-使用BufferedReader对象"><span class="nav-number">7.3.</span> <span class="nav-text">3.使用BufferedReader对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制台输出"><span class="nav-number">8.</span> <span class="nav-text">控制台输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流-OutputStream、InputStream"><span class="nav-number">9.</span> <span class="nav-text">字节流(OutputStream、InputStream)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符流-Writer、Reader"><span class="nav-number">10.</span> <span class="nav-text">字符流(Writer、Reader)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节-字符转换流-OutputStreamWriter、InputStreamReader"><span class="nav-number">11.</span> <span class="nav-text">字节-字符转换流(OutputStreamWriter、InputStreamReader)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲流-BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream"><span class="nav-number">12.</span> <span class="nav-text">缓冲流(BufferedReader和BufferedWriter、BufferedInputStream和BufferedOutputStream)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打印流-PrintStream、PrintWriter"><span class="nav-number">13.</span> <span class="nav-text">打印流(PrintStream、PrintWriter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存操作流"><span class="nav-number">14.</span> <span class="nav-text">内存操作流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字节数组流-ByteArrayInputStream、ByteArrayOutputStream"><span class="nav-number">14.1.</span> <span class="nav-text">字节数组流(ByteArrayInputStream、ByteArrayOutputStream)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符数据流-CharArrayReader、CharArrayWriter"><span class="nav-number">14.2.</span> <span class="nav-text">字符数据流(CharArrayReader、CharArrayWriter)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串流-StringReader、StringWriter"><span class="nav-number">14.3.</span> <span class="nav-text">字符串流(StringReader、StringWriter)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并流-SequenceInputStream、SequenceOutputStream"><span class="nav-number">15.</span> <span class="nav-text">合并流(SequenceInputStream、SequenceOutputStream)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据操作流-DataInputStream、DataOutputStream"><span class="nav-number">16.</span> <span class="nav-text">数据操作流(DataInputStream、DataOutputStream)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象流-ObjectInputStream、ObjectOutputStream"><span class="nav-number">17.</span> <span class="nav-text">对象流(ObjectInputStream、ObjectOutputStream)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象序列化"><span class="nav-number">17.1.</span> <span class="nav-text">对象序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#serialVersionUID"><span class="nav-number">17.2.</span> <span class="nav-text">serialVersionUID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的序列化和反序列化"><span class="nav-number">17.3.</span> <span class="nav-text">对象的序列化和反序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectOutputStream-序列化"><span class="nav-number">17.4.</span> <span class="nav-text">ObjectOutputStream(序列化)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectInputStream-反序列化"><span class="nav-number">17.5.</span> <span class="nav-text">ObjectInputStream(反序列化)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#transient关键字"><span class="nav-number">17.6.</span> <span class="nav-text">transient关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#压缩流"><span class="nav-number">18.</span> <span class="nav-text">压缩流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道流-PipedOutputStream、PipedInputStream"><span class="nav-number">19.</span> <span class="nav-text">管道流(PipedOutputStream、PipedInputStream)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回退流-PushbackInputStream和PushbackReader"><span class="nav-number">20.</span> <span class="nav-text">回退流(PushbackInputStream和PushbackReader)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择合适的IO流"><span class="nav-number">21.</span> <span class="nav-text">选择合适的IO流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System类对IO的支持-out、err、in"><span class="nav-number">22.</span> <span class="nav-text">System类对IO的支持(out、err、in)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#System-out"><span class="nav-number">22.1.</span> <span class="nav-text">System.out</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System-err"><span class="nav-number">22.2.</span> <span class="nav-text">System.err</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System-in"><span class="nav-number">22.3.</span> <span class="nav-text">System.in</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入输出重定向"><span class="nav-number">23.</span> <span class="nav-text">输入输出重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为System-out输出重定向"><span class="nav-number">23.1.</span> <span class="nav-text">为System.out输出重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为System-err重定向"><span class="nav-number">23.2.</span> <span class="nav-text">为System.err重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为System-in重定向"><span class="nav-number">23.3.</span> <span class="nav-text">为System.in重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">23.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>

        </section>
      <!--/noindex-->
      

      

    </div>
 <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=191528&auto=1&height=66"></iframe>
</div>
   
 </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谢均宇</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>





  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  
    

    
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2145941"></script>
      <!-- UY END -->
    
  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

  
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

</body>
</html>
